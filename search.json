[{"title":"Собеседование в 2ГИС","path":"/sobesedovanie-v-2-gis/","content":"\n## Автоматизация\n\n1. Опыт использования инструментов автоматизации:\n- [CI/CD](/ci-cd/)\n- [Docker и контейнеризация](/docker/)\n- виртуальные машины\n- языки программирования\n- [фреймворки](/frejmvorki-avtomatizaczii-testirovaniya/)  \n[Сравнение Junit и TestNG](/j-unit-vs-test-ng/)\n\n2. Применяемые подходы к автоматизации и процессы для автоматизации\n- [подходы](/podhody-k-avtomatizaczii-testirovaniya/)\n- процессы\n\n3. Сетевой стек и архитектура веб-приложений\n- сетевой стек\n- архитектура веб-приложений","category":"interview","description":"Темы для обсуждения на собеседовании на позицию QA Automation Engineer"},{"title":"CI/CD","path":"/ci-cd/","content":"\n**CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка)** — это технология автоматизации тестирования и доставки новых модулей разрабатываемого проекта заинтересованным сторонам (разработчикам, аналитикам, инженерам качества, конечным пользователям и др.).\n\n## Принципы CI/CD\nКонцепция непрерывной интеграции и развертывания относится к agile-методологиям разработки программного обеспечения. Ее основная цель — уделение достаточного внимания бизнес-требованиям, безопасности и качеству кода конечного продукта. В рамках подхода решаются следующие задачи:\n\n- автоматизация последовательной сборки, упаковки и тестирования программных продуктов;\n- автоматизация развертывания приложения в различных окружениях;\n- минимизация ошибок и уязвимостей программного продукта.\n\nРазработка по методике CI/CD соответствует таким основным принципам:\n- **Распределение ответственности.** Задачи и этапы разработки разделяются между членами команды или ее подгруппами (при работе над большим проектом). Рабочий процесс организуется с учетом бизнес-логистики, внедрения сквозных функций, проведения тестов, безопасности хранения данных и т.д.\n- **Сокращение рисков.** Каждый разработчик или подгруппа разработчиков должны стремиться минимизировать уязвимости и ошибки на всех этапах разработки. Для этого постоянно контролируется бизнес-логистика, проводится пользовательское тестирование продукта, оптимизируется хранение, обработка данных и т.д.\n- **Оптимизация обратной связи.** Успех проекта зависит от того, как работают друг с другом разработчики, клиенты и пользователи. Это влияет на скорость внесения в приложение корректировок и обновлений. Если сборку и тестирование можно автоматизировать, то во многих других операциях требуется участие человека. Чтобы взаимодействие происходило конструктивнее, уменьшается количество посредников между заказчиком, исполнителями и пользователями.\nСоздание рабочей среды. Для удобства совместной работы у разработчиков должно быть общее рабочее пространство. Помимо основной ветки процесса в нем должна быть побочная – в ней удобнее проводить тестирование, вносить корректировки, отслеживать отказоустойчивость и т.д.\n\nСI/CD представляет собой современную аналогию конвейерного производства. Их объединяют четкое распределение труда, непрерывный, потоковый характер рабочего процесса, параллельное выполнение сразу нескольких задач (например, кодинга и тестирования). Сегодня эта концепция является доминирующей в DevOps.\n\n## Этапы CI/CD\n**Написание кода.** Каждый разработчик создает код отведенного ему модуля и тестирует его в ручном режиме. Затем разработанный и проверенный программный блок интегрируется в основной ветке с текущей версией продукта. Как только все модули будут опубликованы в главной ветке, команда переходит к следующему этапу.\n\n**Сборка.** Заранее подобранная система контроля версий запускает автоматизированную сборку и тестирование всего продукта. Триггеры могут быть настроены автоматически или вручную. Автоматическая сборка выполняется с помощью Jenkins или другого сервера непрерывной интеграции.\n\n**Ручное тестирование.** Как только CI-сервер закончит автоматизированную сборку продукта, он передается тестировщикам на проверку. Они используют различные методики тестирования для выявления и устранения ошибок и уязвимостей программы.\n\n**Релиз.** После исправления ошибок вычищенный и отлаженный код переходит на этап релиза для клиентов. Его проверяет заказчик, возможно, с привлечением своих специалистов или ограниченной группы пользователей. По результатам проверки код отправляется на доработку или согласуется.\n\n**Развертывание.** Текущая версия программы размещается на продакшн-серверах разработчика. Заказчик может работать с программой, исследовать ее функции, искать уязвимости.\n\n**Поддержка и отслеживание.** После развертывания приложение становится доступным конечным пользователям. Параллельно этому разработчики выполняют его поддержку и одновременно мониторят реакцию пользователей, анализируют их опыт взаимодействия с программой.\n\n**Планирование.** На основании данных, полученных при изучении пользовательского опыта, разработчик подготавливает план доработок, включающий новые функции, исправление ошибок и т.д. После этого он вносит все корректировки в продукт — и цикл разработки начинается снова.\n\nТаким образом, рабочий процесс по методологии CI/CD включает как последовательные, так и параллельные этапы. Именно для распараллеливания в рабочем пространстве создается побочная ветка — в ней проще вести работу, не вмешиваясь в основной код до тех пор, пока программируемый модуль не будет готов к интеграции. Условно рабочий процесс по методологии CI/CD можно представить в виде следующей схемы:\n\n## Общий принцип CI/CD-разработки\n\n### Преимущества CI/CD\n**Сокращение сроков разработки.** Методология уменьшает время доработок до нескольких дней, в сложных проектах — недель. Это позволяет разработчикам быстрее тестировать и опробовать нововведения, а затем внедрять их в продукт раньше конкурентов.\nОтбор перспективных вариантов. Быстрое тестирование и большое количество итераций позволяют разработчику вовремя отсеивать бесперспективные варианты кода на начальных этапах. Это также способствует экономичному расходованию времени и ресурсов без их распыления на тупиковые направления.\n\n**Качество тестирования.** Сочетание ручной и автоматизированной проверки позволяет выявлять ошибки на ранних этапах разработки. Это снижает вероятность их накопления на этапе релиза, что еще больше сокращает время работы над проектом.\n\n## Недостатки CI/CD\n**Высокие требования к опыту.** Рабочий процесс в любой компании можно перевести на методологию CI/CD. Однако это требует от разработчиков как знания самой концепции на практическом уровне, так и умения быстро реорганизовать процессы в самой организации. Иными словами, CI/CD имеет достаточно большой порог вхождения в сравнении со многими традиционными методологиями.\n\n**Сложность постоянного взаимодействия.** Непрерывная интеграция и доставка программного продукта требуют от разработчиков высокой скоординированности действий. На практике это означает, что должно быть отдельное лицо, которое занимается организацией рабочего процесса и налаживанием взаимодействия между членами команды.\n\n## Инструменты для CI/CD\nТак как непрерывная интеграция и развертывание подразумевает автоматизацию многих процессов в ходе разработки, для этого созданы различные программные инструменты и сервисы:\n\n**GitLab.** Эта платформа позволяет управлять хранилищами проекта, документировать результаты тестирования и доработок, анализировать и дополнять функциональность проекта, выявлять и устранять ошибки.\n\n**Docker.** СD-система, позволяющая контейнеризировать проект, то есть упаковать его со всем окружением и зависимостями.\n\n**Travis-CI.** Сервер, который можно подключать к виртуальным репозиториям GitHub с минимальными настройками. Благодаря использованию облачных технологий его не нужно отдельно устанавливать.\n\n**Jenkins.** Один из самый популярных DevOps-инструментов, совместимый со всевозможными плагинами для адаптации под различные проекты и задачи.\n\n**PHP Censor.** CI-сервер, автоматизирующий сборку PHP-проектов. Может работать с репозиториями GitLab, Mercurial и другими, с библиотеками для тестирования Atoum, PHP Spec, Behat.\n\nВозможность оперативно вносить изменения, постоянно тестировать и дорабатывать продукт, взаимодействовать не только друг с другом, но и с клиентом — вот что делает концепцию CI/CD популярной среди разработчиков. Сегодня ее понимание и практическое освоение являются важной рекомендацией при разработке как крупных, так и небольших проектов.\n\nhttps://www.youtube.com/watch?v=7S1ndRRht6M\n\n## Вопросы\n\n### Какие стадии должны быть в любом пайплайне?\n\n- build\n- test - unit, integration tests\n- lint - metrics chacks: coverage, code analysis\n- deploy\n- system tests: api tests, ui tests\n\n### Что такое Continuous Integration и Continuous Deployment? В чем разница между Continuous Deployment и Continuous Delivery?\nContinuous Integration (CI) - непрерывная интеграция, это практика разработки программного обеспечения, при которой члены команды часто интегрируют свою работу. Интеграция это слияние новой версии кода со стабильной и проверка, что при этом ничего не сломалось. \n\nРазница между Continuous Delivery и Continuous Deployment очень маленькая. Представим два пайплайна для одного и того же приложения. В каждом есть шаги:\n\nSource Control - внесение изменений в систему контроля версий ПО\nBuild - сборка приложения и прогон unit тестов\nStaging - деплой на тестовое окружение, прогон интеграционных, нагрузочных и других тестов\nProduction - деплой на окружение с пользователями\nКаждый пайплайн запускается автоматически по триггеру из системы контроля версий. В случае Continuous Deployment каждый следующий шаг, будет выполнен автоматически если предыдущий был успешный, включая деплой на Production.\n\nЕсли же у вас Continuous Delivery, то шаги будут выполняться автоматически только в безопасной среде, а перед деплоем на Production пайплайн остановится и будет ждать ручного подтверждения. Механизм, как это будет реализовано может быть разным. От самого простого, когда ответственный человек должен зайти в пайплайн и нажать кнопку Next, до интерактивного бота с кнопками в корпоративном мессенджере.\n\nЗачем нужен ручной апрув перед деплоем на Production, ведь это тормозит пайплайн т.е. доставку фич и исправлений багов? Вопрос резонный, но ответ такой же. Не все проекты одинаковые, есть такие в которых решение о деплое на Production должно быть принято человеком ответственно и осознанно. Когда бизнес сложный, с большим количеством факторов и нельзя переложить выбор “деплоить или нет” на пару алгоритмических критериев, тогда и применяется Continuous Delivery, а не Continuous Deployment.\n\n\n52. Опишите основные этапы CI/CD.\n момент, когда триггерится сборка, например, когда разработчик сделал коммит в свою ветку, запускается процесс, который выполняется специально написанными скриптами и утилитами. Этот процесс состоит из нескольких обязательных шагов. Простой пример для PR:\n\nПри открытии каждого Pull Request, Git-сервер отправляет уведомление CI-серверу;\nCI-сервер клонирует репозиторий, проверяет исходную ветку (например bugfix/wrong-sorting), и сливает код с кодом master-ветке;\nТогда запускается билд-скрипт (сценарий сборки). Например ./gradlew build;\nЕсли эта команда возвращает код ответа “0”, то билд успешно выполнен. (Другой ответ означает ошибку);\nCI-сервер направляет уведомление об успешном билде на Git-сервере;\nЕсли билд был успешен, то Pull Request разрешается слить с существующим кодом. (Если не успешен, то, соответственно, не разрешается).\nОшибка в любом из шагов приводит к полному падению всей сборки. Ну и, само собой разумеется, шаги расположены в таком порядке, чтобы сужать воронку потенциальных проблем. Если Quality Gate предыдущего этапа не пройдет, то на проверку следующего уже можно не тратить ресурсы.\n\nПример Quality Gates, которые встроены в pipeline отсюда:\n\nСборка сервиса:\nПроверка наличия конфигурации корректного формата;\nПроверка стандартов оформления кода;\nПроверка на необходимое покрытие Unit-тестами;\nГенерации и публикации контрактов (контроль обратной совместимости).\nЗапуск Beta-тестов;\nОбязательный code-review;\nСканирование на уязвимости.\nПример сферического пайплайна в вакууме отсюда:\n\nCode scanning: код проверяется на соответствие общему гайдлайну (linters), уязвимости (code security) и качество (code quality);\nUnit tests;\nBuild: этап для сборки artifacts/packages/images и т.д. Здесь уже можно задуматься о том, каким будет стратегия версионирования всего приложения. Во времена контейнеризации, в первую очередь интересуют образы для контейнеров и способы их версионирования;\nScan package: пакет/образ собрали. Теперь нужно просканировать его на уязвимости. Современные registry уже содержат инструментарий для этого;\nDeploy: стадия для развертывания приложения в различных окружениях;\nIntegration testing: приложение задеплоили. Оно где-то живет в отдельном контуре. Наступает этап интеграционного тестирования. Тестирование может быть как ручным, так и автоматизированным;\nPerformance testing (load/stress testing): данный вид тестирования имеет смысл проводить на stage/pre-production окружениях. С тем условием, что ресурсные мощности на нем такие же, как в production;\nCode Review / Approved: одним из важнейших этапов являются Merge Request. Именно в них могут производиться отдельные действия в pipeline перед слиянием, а также назначаться группы лиц, требующих одобрения перед слиянием.\n\n\n53. Опишите пример процесса CI (и/или CD), который начинается с момента, когда разработчик запушил изменения/PR в Git?\n\n54. Расскажите о разновидностях тестов, которые мы можем использовать в CI пайплайне.\n\n55. Какие инструменты CI вы использовали? Есть ли опыт работы с Jenkinsfile?\n\n56. Какие виды тестов вы знаете и зачем они нужны?\n\n72. Как автоматическое тестирование интегрируется в CI?\n\n73. Как настроить Job или Pipeline на знакомом вам CI-инструменте?\n\n74. Какие инструменты для генерации репорта после выполнения автоматических тестов вы знаете?\n\n75. Какую информацию должен содержать отчет о выполнении автоматических тестов?","category":"testops","description":"CI/CD"},{"title":"Подходы к автоматизации тестирования","path":"/podhody-k-avtomatizaczii-testirovaniya/","content":"\n## Виды подходов\nВ автоматизированном тестировании выделяют следующие подходы:\n\n1. TDD (англ. Test Driven Development);\n2. BDD (англ. Behaviour Driven Development);\n3. KDT (англ. Keyword Driven Testing);\n4. DDT (англ. Data-driven testing).\n\n## Data-Driven Testing\nЭто тестирование, управляемое данными. При таком подходе тестовые данные хранятся отдельно от тест-кейсов, допустим, в файле либо в базе данных. Такое разделение логически упрощает тесты.\n\nData-Driven Testing используется в тех проектах, где нужно выполнить тестирование отдельных приложений в нескольких средах с большими наборами данных и стабильными test cases.\n\nОбычно при DDT выполняются следующие операции:\n- извлечение части тестовых данных из хранилища;\n- ввод данных в форму приложения;\n- проверка результатов;\n- продолжение тестирования со следующим набором входных данных.\n\nЧтобы проверка приложения была успешна, потребуются разные комбинации данных. \n\n## Keyword Driven Testing\nРечь идёт о тестах, управляемых ключевыми словами. Данный подход предполагает использование ключевых слов, описывающих набор действий, нужных для выполнения конкретного шага тестового сценария. \n\nПри таком подходе в первую очередь определяется набор ключевых слов, а только после этого ассоциируется функция либо действие, связанное с данным ключевым словом. Например, каждые шаги теста, такие как щелчок мышью, нажатие клавиши, открытие либо закрытие браузера описываются определёнными ключевыми словами («открыть» — openbrowser, «нажать» — click и т. п.).\n\nПри KDT-подходе вы можете создавать простые функциональные тесты на самых ранних этапах разработки и тестировать приложение по частям. \n\nЭтапы разработки KDT-тестов:\n\n1. Определяем ключевые слова.\n2. Реализуем ключевые слова как исполняемые файлы.\n3. Создаём тест-кейсы.\n4. Создаём скрипты.\n5. Выполняем автоматизированные сценарии.\n\nПлюсы подхода:\n\n1. функциональные тестировщики могут планировать автоматизацию тестирования до того, как приложение будет готово;\n2. тесты можно разработать без знаний программирования;\n3. подход не зависит от выбранного языка программирования. \n\n## Test Driven Development\nПодход разработки через тестирование (TDD) предполагает организацию автоматического тестирования посредством написания модульных, функциональных и интеграционных тестов, определяющих требования к коду перед написанием кода.\nТо есть в первую очередь пишется тест, проверяющий корректность работы ещё ненаписанного кода. Тест, само собой, не проходит. Далее программист пишет код, где выполняются действия, необходимые для прохождения теста. Когда тест будет успешно пройден, возможна доработка имеющегося кода.\n\nРазработка через тестирование — это больше, чем просто проверка корректности, так как она оказывает влияние и на дизайн программы. Если вы изначально сфокусированы на тестах, вам проще представить, какая именно функциональность нужна пользователю. В результате разработчик продумает детали интерфейса до его реализации. Это, в свою очередь, сократит время на разработку и отладку.\n\nКроме того, разработка через TDD сосредотачивается на тестировании отдельно взятых модулей, при этом используются заглушки (mock-объекты) для представления внешнего мира.\n\n## Behavior Driven Development\nПодход BDD — это разработка, основанная на поведении. По сути, BDD является разновидностью (расширением) TDD с той лишь разницей, что BDD-подход ориентирован на поведение сущности, которую вы тестируете (в TDD основной фокус идёт непосредственно на сам код). Суть BDD заключается в описании системы архитектуры приложения в терминах, понятных неспециалисту. Это даёт возможность ускорить процесс получения обратной связи, убрав традиционные барьеры. То есть описание пользовательских сценариев происходит на естественном языке — грубо говоря, на языке бизнеса.\n\n#### Источник информации:\n1. [Подходы к автоматизации тестирования веб-приложений](https://otus.ru/nest/post/1083/)","category":"interview","description":"Подходы к автоматизации тестирования"},{"title":"Фреймворки автоматизации тестирования","path":"/frejmvorki-avtomatizaczii-testirovaniya/","content":"\nВ каждой команде разработки и поставки ПО группа QA отвечает за разработку, внедрение и выполнение тестов. Для каждого типа тестирования должен быть определён тестовый сценарий, принципы, правила и инструменты для проведения. Фреймворк тестирования — это набор этих руководств, инструментов и практик, который помогает инженерам-тестировщикам эффективно выполнять тестовые сценарии.\n\nСуществуют разные фреймворки для разных целей тестирования. Вот некоторые из самых популярных типов фреймворков для автоматизированного тестирования:\n\n## Модульный\nПриложение разделено на отдельные модули, и каждый модуль тестируется в изолированном состоянии;\n\n## Линейный\nСоставление и исполнение тестовых скриптов. Тестировщики пишут тестовые сценарии последовательно, выполняя их затем для каждого отдельного тест-кейса;\n\n## Библиотечная архитектура\nСоздан на основе модульного фреймворка тестирования, с той лишь разницей, что содержит функции для многократного использования;\n\n## Управляемое данными тестирование\nТестовые скрипты выполняются и верифицируются на основе данных, которые хранятся в центральном хранилище данных или базе данных (SQL, ODBC-ресурсы, csv или xls файлы);\n\n## Тестирование по ключевым словам\nВ данном фреймворке не обязательно иметь навыки программирования, поскольку ключевые слова, используемые при создании тестов, отделены от технического кода. \nТестировщику достаточно иметь представление о всём наборе действий, реализованных во фреймворке;\n\n## Гибридный\nКомбинация из различных фреймворков.\n\nГлавная цель всех команд разработчиков программного обеспечения — обеспечить быструю поставку качественного и надежного программного продукта. Чтобы обеспечить быстрый и эффективный процесс поставки, необходимо непрерывное тестирование. Автоматизация — ключ к тому, чтобы разрабатываемое ПО могло быстро пройти через все стадии конвейера разработки и предоставить клиентам свои функции. Однако, это не означает, что команды должны вкладывать всё свое время и ресурсы в автоматизацию тестирования. Команды должны понимать, что можно и нужно автоматизировать, а что не стóит. Правильный выбор охвата тестов на ранних этапах разработки имеет большое значение.","category":"interview","description":"Фреймворки автоматизации тестирования"},{"path":"/title/","content":"https://logrocon.ru/news/automation_testing"},{"path":"/title/","content":"https://www.youtube.com/watch?v=Ys2CB4C2NWA"},{"title":"Понимание клиент-серверной архитектуры","path":"/ponimanie-klient-servernoj-arhitektury/","content":"\nВ клиент серверной архитектуре есть три звена:\n- клиент\n- сервер\n- база данных\n\nКогда мы вводим данные в программу клиент, клиент передает данные на сервер, а сервер перенаправляет его в БД. Клиент может быть web приложением или desktop приложением.\n\nПосле того как запрос был обработан в БД, поисковый результат возвращается обратно на сервер, а сервер передает его на клиент. Клиент отрисовывает информацию пользователю.\n\n## Клиент\nНужен для пользователя, он отрисовывает байты кода. Отвечает за то чтобы отобразить пользователю нужную информацию и позволить сформировать запрос в удобном интерфейсе, иногда еще провести базовые проверки введенных данных.\n\n## Сервер\nНа сервере находится основная логика приложения. \n\n### Почему всю логику нельзя хранить на клиенте?\nМожно. Но клиентов у нас может быть много. К нашему приложению могут обращаться с разных компьютеров. И чтобы все работало быстро и не тормозило нужен мощный клиентский компьютер. Поэтому проще заплатить за мощный сервер, который будет эту логику обрабатывать и остальные клиентские машины могут быть слабее. Также если вся логика будет на клиенте то получается что на каждом клиенте будет храниться код который обрабатывает логику а это дублирование кода. И если мы что то исправляем то нам надо вносить изменения на сотни компьютеров. А это дорого, долго и неудобно.\n\n## База данных\nХранилище данных. Его иногда может и не быть. \n\nЕсли приложение простое, то данные могут харниться на сервере. Такая архитектура называется двузвенная. Но в таком случае если сервер упадет или перезагрузится, то информация потеряется. Поэтому лучше когда она храниться отдельно. \n\nЭто может быть не база данных, сервер может записывать информацию в файлы. Но тогда программисту нужно будет самому фактически делать самописную базу данных. Опять же для простых приложений можно и так. Но для серьезного продукта лучше иметь отдельную базу данных. \n\nБаза данных специально ориентирована на хранение информации для того чтобы можно было быстро и легко по этой информации искать и она обеспечивает сохранность данных. Даже если компьютер выключится все равно наши данные сохранятся. Также повышается надежность приложения, тк в базе могут храниться персональные данные: ФИО, ИНН, Адрес, Телефон и т.д. и не все должны иметь к ним доступ. \n\n**Недостаток клиент серверной архитектуры**\n\nЕсли одно звено упало то не работает все приложение.\n\nЧтобы такого не случалось делают кластер серверов. Это значит что работает не один сервер а несколько. Также перед ними добавляют балансировщик, который решает кому отправлять запрос. Когда приходит запрос балансировщик смотрит какой из серверов менее загружен и передает туда запрос. Такое бывает когда приложение высоконагруженное и один сервер с ним просто не справляется. Таким образом в кластере может быть не 2 сервера, а 10, 15 и т.д.\n\nТочно также можно балансировать базу данных, может быть несколько копий баз данных на разных машинах и балансировщик отправляет запрос то к одной бвзе то ко второй.\n\nТакая схема называется **горящий резерв**. Если нам нужно обновить приложение мы отключаем один сервер временно переложив всю нагрузку на оставшийся обновляем один сервер снова его запускаем, гасим второй и обновляем пока нагрузка идет на оставшиеся сервера и т.д. Работа приложения совсем не останавливается. \n\nИ есть схема **холодный резерв**, когда второй сервер является резервной копией на всякий случай и все запросы идут на один сервер, но если с ним что то случилось и он упал тогда балансировщик перенаправляет всю нагрузку на второй сервер. \n\nТакие схемы помогают нам устранить проблему упало одно звено все отдыхают.\n\nСервер дороже, у дисков для серверного приложения особые требования по надежности и есть поддержка специфичных функций. \n","category":"api","description":"Понимание клиент-серверной архитектуры"},{"title":"Взаимодействие сервера, клиента и БД","path":"/vzaimodejstvie-servera-klienta-i-bd/","content":"\n**Интернет** - это много компьютеров подключенных друг к другу через сеть.\n\nУ каждого компьютера в интернете есть свой адрес - **ip адрес**, такой адрес есть у вашего компьютера телфона у сервера гугл и даже ваших часов.\n\nВсе сообщения от одного компьютера к другому посылаются на ip адрес получателя и каким то образом находят его.\n\nКогда мы пишем адрес google.com, компьютер должен узнать ip адрес сервера гугл, для этого есть механизм **DNS** - его цель для определенного доменного имени вернуть его ip-адрес. Но для этого ваш компьютер должен знать ip-адрес dns сервера. Когда вы включаете модем или телефон подключается к сети 4G ваш провайдер говорит адрес своего DNS сервера.Такие DNS сервера есть у многих компаний: у Google, Cloudflare и других.\n\nПосле того как браузер узнал ip-адрес сервера он устанавливает с ним **TCP соединение**. После установления соединения браузер отсылает по этому адресу запрос. Запрос представляет собой отсылку небольшого текста от браузера к серверу. Выглядит этот текст примерно так:\n\n```\nGET / HTTP/2\nHost: google.com\nUser-Agent: Mozilla/5.0\nAccept: */*\n```\n\nЭто **HTTP запрос**. Протокол HTTP - это основной способ общения браузера с сервером. \nПо этому протоколу могут слать запросы не только браузеры, но и напрмиер мобильные приложения, одно серверное приложение может общаться с другим по такому протоколу. \n\nСтрочки в начале текста запроса называются **Headers(Заголовки)**. Каждая строчка это отдельный заголовок. Есть еще тело запроса. Например, если вы отправляете форму, то данные из этой формы будут передаваться в теле запроса. \n\nВ первой строчке обычно идет тип запроса, URL, тип протокола.\n\nОсновные виды запросов:\n- GET\n- POST\n- PUT\n- DELETE\n- OPTIONS\n\nКогда вы открываете веб страницу в браузере то он шлет GET запрос, а если отправляете форму, то POST запрос.\n\nДруги типы могут быть нужны чтобы взаимодействовать по протоколу REST API. \nКогда приложениям нужно общаться с друг с другом то это общение согласились проводить по определенным правилам. Программистам, которые пишут фронт и бек приложения нужно договорится в каком формате они будут отправлять данные. \n\n## Coockie\n\nЭто кусочки информации которые сервер отдает браузеру, браузер их сохраняет и потом при каждом запросе отправляет их вместе с запросом. Это нужно для того что иногда серверу нужно знать что запрос пришел от определенного браузера/определенного человека. Например если вы залогинились на сайте сервер отдает браузеру куки в котором записан id вашего пользователя и потом при каждом запросе от браузера эти куки используются для того чтобы сервер знал что это именно вы. \n\nHttp это не единственный протокол, есть еще и другие, например, WebSoket протокол - используется для того чтобы организовать двустороннее взаимодействие между сервером и браузером, т.е. сообщения могут ходить как от сервера к браузеру, так и от браузера к серверу. \n\n## Сервер\nСервер - это один или несколько компьютеров которые подключены к интернету. Физически такие компьютеры обычно расположены в специальных зданиях которые называют дата центры. На сервере обычно работает специальное приложение которое так и называется веб сервер. Самые популярные сервера: Nginx, Microsoft IIS, Apache. Веб сервер обычно решает что делать с запросом, если это статический контент например картинка то веб сервер сам может получить ее с диска и отдать браузеру. А если это запрос к странице то веб сервер передает этот запрос дальше к специальной программе. И эта программа называется серверное приложение. \n\nСерверное приложение получает запрос, после этого оно идет в базу данных чтобы получить оттуда данные, сформировать их в каком то формате и вернуть, например в виде html-страницы. Есть и другие форматы данных. Либо выдает ошибку. После этого веб сервер получает этот ответ от серверного приложения и отдает его в браузер. После этого он может закрыть соединение либо оставить его открытым. \n\nКак правило веб приложения пишут так чтобы в них не хранилось ничего, никакое состояние, чтобы состояние хранились в базе данных. Это сделано в основном для того чтобы приложение можно было масштабировать, запускать копию приложения на нескольких компьютерах(серверах) одновременно. А это нужно для производительности, потому что у вас может быть тысячи или миллионы запросов в минуту. \n\n## Реляционные базы данных\n\nСамые популярные: Postgres, MySQL/MariaDB, MS SQL, Oracle.\n\nДанные хранятся в виде таблиц и получить их от туда можно с помощью SQL запросов. Состочние приложения должно храниться в базе данных. Например если пользователь ищет гостиницу в сочи то список таких гостиниц должен храниться в базе данных. И у базы данных есть важное свойство - она быстрая, если мы хотим получить список гостиниц куда пускают с животными то база данных вернет такой список за считанные милисекунды. У базы данных для этого есть специальный механизм - индексы (Index) и у каждой гостиницы может быть поле с признаком пускают ли туда с животными или нет. И индекс это такая структура которая позволяет быстро найти все записи где в этом поле стоит определенное значение. Также базы данных умеют объединять данные из нескольких таблиц, группировать данные по каком то полю или вычислять значение по нескольким полям. \n\nЕсли много пользователей пытаются получить доступ к одной и той же странице то нет смысла каждый раз генерировать ее с помощью приложения снова и снова. В этом случае поможет кеширование. \n\n## Кеширование\nКеш - промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. \n\nКеширование может быть на разном уровне, можно полностью закешировать страницу и тогда приложение вообще не будет вызываться, а страница будет браться постоянно из кеша. Многие популярные веб серверы так умеют. Например для Nginx достаточно указать директорию куда складывать кеш и все заработает само. Еще можно кешировать часть страницы тогда вы сами решаете когда пишите приложение что именно вы будуте кешировать. Кеш обычно держат в памяти либо использует какое -нибудь специальное хранилище типа redis. А базы данных сами умеют кешировать запросы к ним. Например Postgress пытается держать все индексы в памяти чтобы как можно более быстрее к ним можно было обращаться. И даже сам Центральный процессор кеширует ту память с которой он в данный момент работает. \n\nВ заголовках которые возвращает сервер есть заголовок Content-type который говорит в каком формате возвращаются данные. чаще всего  данные возвращаются в следующих форматах: HTML, JSON, Yaml, XML, текст без форматирования. \n\nПосле того как все данные от сервера переданы, TCP соединение может быть закрыто или оставаться открытым. И управляет этим процессом специальный заголовок: Connection: Keep-Alive. Если TCP соединение остается открытым то браузер может послать через него еще один запрос к серверу. Например чтобы получить картинки или файлы скриптов. \n\nФорматы данных\n\n- текстовые форматы:\n    - HTML - используется для описания содержимого веб страниц\n    - JSON, Yaml, XML - форматы с помощью которых можно описывать любые данные\n\nДля того чтобы отобразить веб страницу браузеру нужно распарсить текст и понять из каких частей состоит страница, будут ли там заголовки картинки какой то текст. Может быть туда включены javascript скрипты или css стили. После этого браузер пытается составить DOM дерево. Все что показано на странице организовано в памяти в виде структуры которая называется дерево. Есть корневой элемент - `<html>` у него 2 наследника `<head>` и `<body>` и так далее до текста картинок заголовков и тд.\n\nИногда в процессе построения такого дерева на встречается ссылка на внешний ресурс, например, на картинку и обычно браузер может запросить этот внешний ресурс и сразу же продолжить построение дерева не дожидаясь ответа. Но иногда все же приходится дожидаться загрузки внешнего ресурса, например javascript файла, чтобы продолжить построение дерева и это замедляет открытие страницы. И как только DOM дерево будет построено в памяти браузер рисует то что получилось на экране. Этот процесс назфвается рендерингом. Браузер берет css стили и накладывает на DOM дерево после этого пытается понять где на экране должен находиться каждый из блоков и после этого ричсует это в окошке браузера. После того как страница отрисовалась браузер начинает делать 2 вещи: слушать события например не нажали ли вы на какую то кнопку или ссылку на экране и выполнять javascript код который он загрузил вместе со страницей и тут вступает в работу фронтенд приложение. \n\nФронтенд приложение - это javascript код который работает в браузере он умеет слушать события которые происходят на странице и реагировать на них. У этого кода есть доступ к API браузера. API браузера - это набор функций которые может вызывать программа на javascript'e. \n\nПримеры Browser API:\n- DOM API - с его помощью можно менять содержимое веб страницы\n- Vibration API - позволяет телефону вибрировать когда вы захотите\n- WebGL - позволяет программировать 3хмерную графику в браузере\n\nНо не все браузеры могут поддерживать конкретный API. \n\nРабота мобильных приложений похоже на работу браузера, они могут отправлять запросы на сервер и получать на них ответы и они могут использовать теже форматы данных что и браузерное приложение, html формат обычно не использует потому что нет смысла генерировать веб страницу когда можно показать нативные контролы. \n","category":"api","description":"Взаимодействие сервера, клиента и БД"},{"title":"REST и SOAP","path":"/rest-i-soap/","content":"\n## API\nAPI - это контракт, который предоставляет программа: какие операции можно выполнять.\n\nAPI включает:\n- операции которые можно проводить\n- данные которые подаются на вход\n- данные которые предоставляются на выходе\n\nAPI - набор функций. \n\nAPI  входа, API отчетности, API платежек и тд\nили одно общее API.\n\nНа каждое API есть контракт который говорит какие функции можно выполнять.\n\nДля SOAP таким контрактом является wsdl, для REST - wadl.\n\nОписание функций которые мы можем использовать. Одни и теже функции можно использовать в разных API.\n\nВызвать API можно напрямую или косвенно.\n\nНапрямую:\n- система вызывает функции внутри себя;\n- одна система вызывает метод другой системы;\n- в автотестах;\n\nКосвенно:\n- пользователь работает с GUI;\n\nТестирование (через) API\n\nКогда одна система общается с другой по протоколу(HTTP, GMS) передачи данных - это называется remote API(общение по сети).\nЕсть еще shared memory API - это когда программа общается в одной виртуальной памяти\n\nSOAP\nПередает сообщение в xml формате. \nWSDL - это список всех методов которые нам доступны через SOAP.\n\n## REST и SOAP\n\nREST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.\n\nREST означает REpresentational State Transfer (Википедия: «передача состояния представления»). Это популярный архитектурный подход для создания API в современном мире.\n\nПример реализации RESTful: JSON через HTTP;  \nПример реализации SOAP: XML поверх SOAP через HTTP;\n\nНа верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.\n\nСпецифика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML, включающий:\n- Envelope (конверт) – корневой элемент, который определяет сообщение и пространство имен, использованное в документе,\n- Header (заголовок) – содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации,\n- Body (тело) – содержит сообщение, которым обмениваются приложения,\n- Fault – необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений. И запрос, и ответ должны соответствовать структуре SOAP.\n\nСпецифика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP - методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.\n\n### Формат обмена сообщениями\n\nВ SOAP вы используете формат SOAP XML для запросов и ответов.\nВ REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.\n\n### Определения услуг\n\nSOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.\nREST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.\n\n### Транспорт\n\nSOAP не накладывает никаких ограничений на тип транспортного протокола. Вы можете использовать либо Web протокол HTTP, либо MQ.\n\nREST подразумевает наилучшее использование транспортного протокола HTTP\n\nПростота реализации\n\nRESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.\n\nREST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.\nОднако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.","category":"api","description":"REST и SOAP"},{"title":"Response codes","path":"/response-codes/","content":"\nКод ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:\n\n1. Информационные 100 - 199\n2. Успешные 200 - 299\n3. Перенаправления 300 - 399\n4. Клиентские ошибки 400 - 499\n5. Серверные ошибки 500 - 599\n\n<table>\n <thead>\n  <tr>\n   <th scope=\"col\">Код ответа</th>\n   <th scope=\"col\">Название</th>\n   <th scope=\"col\">Описание</th>\n   <th scope=\"col\">Версия HTTP</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th colspan=\"4\"><em>Информационные</em></th>\n  </tr>\n  <tr>\n   <td id=\"100\">100</td>\n   <td>Continue</td>\n   <td>\"Продолжить\". Этот промежуточный ответ указывает, что запрос успешно принят и клиент может продолжать присылать запросы либо проигнорировать этот ответ, если запрос был завершён.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"101\">101</td>\n   <td>Switching Protocol</td>\n   <td>\"Переключение протокола\". Этот код присылается в ответ на запрос клиента, содержащий заголовок <code>Upgrade:</code>, и указывает, что сервер переключился на протокол, который был указан в заголовке. Эта возможность позволяет перейти на несовместимую версию протокола и обычно не используется.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td>102</td>\n   <td>Processing</td>\n   <td>\"В обработке\". Этот код указывает, что сервер получил запрос и обрабатывает его, но обработка ещё не завершена.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td>103</td>\n   <td>Early Hints</td>\n   <td>\"Ранние подсказки\". В ответе сообщаются ресурсы, которые могут быть загружены заранее, пока сервер будет подготавливать основной ответ. <a href=\"https://datatracker.ietf.org/doc/rfc8297\">RFC 8297 (Experimental)</a>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Успешные</em></th>\n  </tr>\n  <tr>\n   <td id=\"200\">200</td>\n   <td>\n    <p>OK</p>\n   </td>\n   <td>\"Успешно\". Запрос успешно обработан. Что значит \"успешно\", зависит от метода HTTP, который был запрошен:\n    <ul>\n     <li>GET: \"ПОЛУЧИТЬ\". Запрошенный ресурс был найден и передан в теле ответа.</li>\n     <li>HEAD: \"ЗАГОЛОВОК\". Заголовки переданы в ответе.</li>\n     <li>POST: \"ПОСЫЛКА\". Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.</li>\n     <li>TRACE: \"ОТСЛЕЖИВАТЬ\". Тело ответа содержит тело запроса полученного сервером.</li>\n    </ul>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"201\">201</td>\n   <td>Created</td>\n   <td>\"Создано\". Запрос успешно выполнен и в результате был создан ресурс. Этот код обычно присылается в ответ на запрос PUT \"ПОМЕСТИТЬ\".</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"202\">202</td>\n   <td>Accepted</td>\n   <td>\"Принято\". Запрос принят, но ещё не обработан. Не поддерживаемо, т.е., нет способа с помощью HTTP отправить асинхронный ответ позже, который будет показывать итог обработки запроса. Это предназначено для случаев, когда запрос обрабатывается другим процессом или сервером, либо для пакетной обработки.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"203\">203</td>\n   <td>Non-Authoritative Information</td>\n   <td>\"Информация не авторитетна\". Этот код ответа означает, что информация, которая возвращена, была предоставлена не от исходного сервера, а из какого-нибудь другого источника. Во всех остальных ситуациях более предпочтителен код ответа 200 OK.</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"204\">204</td>\n   <td>No Content</td>\n   <td>\"Нет содержимого\". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"205\">205</td>\n   <td>Reset Content</td>\n   <td>\"Сбросить содержимое\". Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"206\">206</td>\n   <td>Partial Content</td>\n   <td>\"Частичное содержимое\". <span id=\"result_box\" lang=\"ru\"><span class=\"hps\">Этот код ответа</span> <span class=\"hps\">используется, когда клиент присылает </span><span class=\"hps\">заголовок</span> <span class=\"hps\">диапазона</span><span>, чтобы</span> выполнить <span class=\"hps\">загрузку отдельно,</span> <span class=\"hps\">в</span> <span class=\"hps\">несколько потоков</span></span>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Сообщения о перенаправлениях</em></th>\n  </tr>\n  <tr>\n   <td id=\"300\">300</td>\n   <td>Multiple Choice</td>\n   <td>\n    <p><span id=\"result_box\" lang=\"ru\"><span>\"</span></span><span class=\"short_text\" id=\"result_box\" lang=\"ru\"><span class=\"alt-edited\">Множественный выбор</span></span>\"<span lang=\"ru\"><span>. </span></span>Этот код ответа присылается, когда з<span lang=\"ru\"><span>апрос</span> <span>имеет более чем</span> <span>один из возможных</span> <span>ответов</span><span>.</span> И <span>User-agent </span><span>или</span> <span>пользователь должен</span> <span>выбрать один из ответов</span><span>. </span></span>Не существует стандартизированного способа выбора одного из полученных ответов.</p>\n   </td>\n   <td>HTTP/1.0 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"301\">301</td>\n   <td>Moved Permanently</td>\n   <td>\n    <p>\"Перемещён на постоянной основе\". Этот код ответа значит, что <span id=\"result_box\" lang=\"ru\"><span>URI </span><span>запрашиваемого</span> <span>ресурса</span> <span>был изменён</span><span>.</span> <span>Возможно,</span> <span>новый</span> <span>URI </span></span><span lang=\"ru\"><span>будет </span></span>предоставлен <span lang=\"ru\"><span>в ответе.</span></span></p>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"302\">302</td>\n   <td>Found</td>\n   <td>\n    <p>\"Найдено\". Этот код ответа значит, что запрошенный ресурс <em>временно изменён</em>. <span id=\"result_box\" lang=\"ru\"><span>Новые</span> <span>изменения в</span> <span>URI</span> <span>могут быть</span></span> доступны в <span id=\"result_box\" lang=\"ru\"><span>будущем</span></span>. <span id=\"result_box\" lang=\"ru\"><span>Таким образом,</span> этот<span> </span><span>URI,</span> <span>должен</span> <span>быть использован</span> <span>клиентом</span> <span>в</span> <span>будущих запросах</span><span>.</span></span></p>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"303\">303</td>\n   <td>See Other</td>\n   <td>\"Просмотр других ресурсов\". Этот код ответа присылается, чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"304\">304</td>\n   <td>Not Modified</td>\n   <td>\"Не модифицировано\". Используется для кеширования. Это код ответа значит, что запрошенный ресурс не был изменён. Таким образом, клиент может продолжать использовать кешированную версию ответа.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"305\">305</td>\n   <td>Use Proxy</td>\n   <td>\"Использовать прокси\". Это означает, что запрошенный ресурс должен быть доступен через прокси. Этот код ответа в основном не поддерживается из соображений безопасности.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"306\">306</td>\n   <td>Switch Proxy</td>\n   <td>Больше не использовать. Изначально подразумевалось, что \" последующие запросы должны использовать указанный прокси.\"</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"307\">307</td>\n   <td>Temporary Redirect</td>\n   <td>\"Временное перенаправление\". Сервер отправил этот ответ, чтобы клиент получил запрошенный ресурс на другой URL-адрес с тем же методом, который использовал предыдущий запрос. Данный код имеет ту же семантику, что код ответа <code>302 Found</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если в первом запросе использовался <code>POST</code>, то во втором запросе также должен использоваться <code>POST</code>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"308\">308</td>\n   <td>Permanent Redirect</td>\n   <td>\n    <p>\"Перенаправление на постоянной основе\". Это означает, что ресурс теперь постоянно находится в другом URI, указанном в заголовке <code>Location:</code> HTTP Response. Данный код ответа имеет ту же семантику, что и код ответа <code>301 Moved Permanently</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если <code>POST</code> использовался в первом запросе, <code>POST</code> должен использоваться и во втором запросе.<br><br>Примечание: Это экспериментальный код ответа, Спецификация которого в настоящее время находится в черновом виде.</p>\n\n   </td>\n   <td><a class=\"external\" href=\"http://greenbytes.de/tech/webdav/draft-reschke-http-status-308-07.html\">draft-reschke-http-status-308</a></td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Клиентские</em></th>\n  </tr>\n  <tr>\n   <td id=\"400\">400</td>\n   <td>Bad Request</td>\n   <td>\"Плохой запрос\". Этот ответ означает, что сервер не понимает запрос из-за неверного синтаксиса. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"401\">401</td>\n   <td>Unauthorized</td>\n   <td>\"Неавторизованно\". Для получения запрашиваемого ответа нужна аутентификация. Статус похож на статус 403, но,в этом случае, аутентификация возможна. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"402\">402</td>\n   <td>Payment Required</td>\n   <td>\"Необходима оплата\". Этот код ответа зарезервирован для будущего использования. Первоначальная цель для создания этого когда была в использовании его для цифровых платёжных систем(на данный момент не используется).</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"403\">403</td>\n   <td>Forbidden</td>\n   <td>\"Запрещено\". У клиента нет прав доступа к содержимому, поэтому сервер отказывается дать надлежащий ответ. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"404\">404</td>\n   <td>Not Found</td>\n   <td>\"Не найден\". Сервер не может найти запрашиваемый ресурс. Код этого ответа, наверно, самый известный из-за частоты его появления в вебе. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"405\">405</td>\n   <td>Method Not Allowed</td>\n   <td>\"Метод не разрешён\". Сервер знает о запрашиваемом методе, но он был деактивирован и не может быть использован. Два обязательных метода,  <code>GET</code> и <code>HEAD</code>,  никогда не должны быть деактивированы и не должны возвращать этот код ошибки.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"406\">406</td>\n   <td>Not Acceptable</td>\n   <td>\n    <p>Этот ответ отсылается, когда веб сервер после выполнения <a href=\"/en/HTTP/Content_negotiation#Server-driven_negotiation\" title=\"https://developer.mozilla.org/en/HTTP/Content_negotiation#Server-driven_negotiation\">server-driven content negotiation</a>, не нашёл контента, отвечающего критериям, полученным из user agent.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"407\">407</td>\n   <td>Proxy Authentication Required</td>\n   <td>Этот код ответа аналогичен коду 401, только аутентификация требуется для прокси сервера.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"408\">408</td>\n   <td>Request Timeout</td>\n   <td>Ответ с таким кодом может прийти, даже без предшествующего запроса. Он означает, что сервер хотел бы отключить это неиспользуемое соединение. Этот метод используется все чаще с тех пор, как некоторые браузеры, вроде Chrome и IE9, стали использовать <a class=\"external\" href=\"http://www.belshe.com/2011/02/10/the-era-of-browser-preconnect/\">HTTP механизмы предварительного соединения</a> для ускорения сёрфинга  (смотрите bug(634278) , будущей реализации этого механизма в Firefox). Также учитывайте, что некоторые серверы прерывают соединения не отправляя подобных сообщений.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"409\">409</td>\n   <td>Conflict</td>\n   <td>\n    <p>Этот ответ отсылается, когда запрос конфликтует с текущим состоянием сервера.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"410\">410</td>\n   <td>Gone</td>\n   <td>\n    <p>Этот ответ отсылается, когда запрашиваемый контент удалён с сервера.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"411\">411</td>\n   <td>Length Required</td>\n   <td>\n    <p>Запрос отклонён, потому что сервер требует указание заголовка <code>Content-Length</code>, но он не указан.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"412\">412</td>\n   <td>Precondition Failed</td>\n   <td>Клиент указал в своих заголовках условия, которые сервер не может выполнить</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"413\">413</td>\n   <td>Request Entity Too Large</td>\n   <td>\n    <p>Размер запроса превышает лимит, объявленный сервером. Сервер может закрыть соединение, вернув заголовок <code>Retry-After</code></p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"414\">414</td>\n   <td>Request-URI Too Long</td>\n   <td>URI запрашиваемый клиентом слишком длинный для того, чтобы сервер смог его обработать</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"415\">415</td>\n   <td>Unsupported Media Type</td>\n   <td>Медиа формат запрашиваемых данных не поддерживается сервером, поэтому запрос отклонён</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"416\">416</td>\n   <td>Requested Range Not Satisfiable</td>\n   <td>Диапазон указанный заголовком запроса <code>Range</code> не может быть выполнен; возможно, он выходит за пределы переданного URI</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"417\">417</td>\n   <td>Expectation Failed</td>\n   <td>Этот код ответа означает, что ожидание, полученное из заголовка запроса <code>Expect</code>, не может быть выполнено сервером.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Серверные</em></th>\n  </tr>\n  <tr>\n   <td id=\"500\">500</td>\n   <td>Internal Server Error</td>\n   <td>\"Внутренняя ошибка сервера\". Сервер столкнулся с ситуацией, которую он не знает как обработать. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"501\">501</td>\n   <td>Not Implemented</td>\n   <td>\"Не выполнено\". Метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые сервера должны поддерживать (и, соответственно, не должны возвращать этот код) -  <code>GET</code> и <code>HEAD</code>.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"502\">502</td>\n   <td>Bad Gateway</td>\n   <td>\"Плохой шлюз\". Эта ошибка означает что сервер, во время работы в качестве шлюза для получения ответа, нужного для обработки запроса, получил недействительный (недопустимый) ответ. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"503\">503</td>\n   <td>Service Unavailable</td>\n   <td>\"Сервис недоступен\". Сервер не готов обрабатывать запрос. Зачастую причинами являются отключение сервера или то, что он перегружен. Обратите внимание, что вместе с этим ответом удобная для пользователей(user-friendly) страница должна отправлять объяснение проблемы.  Этот ответ должен использоваться для временных условий и <code>Retry-After:</code> HTTP-заголовок должен, если возможно, содержать  предполагаемое время до восстановления сервиса. Веб-мастер также должен позаботиться о заголовках, связанных с кешем, которые отправляются вместе с этим ответом, так как эти ответы, связанные с временными условиями, обычно не должны кешироваться. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"504\">504</td>\n   <td>Gateway Timeout</td>\n   <td>Этот ответ об ошибке предоставляется, когда сервер действует как шлюз и не может получить ответ вовремя.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"505\">505</td>\n   <td>HTTP Version Not Supported</td>\n   <td>\"HTTP-версия не поддерживается\". HTTP-версия, используемая в запросе, не поддерживается сервером.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n </tbody>\n</table>","category":"api","description":"Response codes"},{"title":"Аутентификация и авторизация","path":"/autentifikacziya-i-avtorizacziya/","content":"## Идентификация\nИдентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.\n\n## Аутентификация\nАутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.\n\n## Авторизация\nАвторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.\n\n## Пример\nСкажем, пользователь хочет войти в свой аккаунт Google. Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов. Вот что при этом происходит:\n\nДля начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.\n\nПосле этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это аутентификация.\n\nСкорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это двухфакторная аутентификация.\n\nПосле этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — это авторизация.\n","category":"api","description":"Аутентификация и авторизация"},{"title":"Ресурсы. API","path":"/resursy-api/","content":"\n\n## API testing\n\nhttps://www.youtube.com/watch?v=kAZYAs8Mta4\n\nhttps://www.youtube.com/watch?v=vRl2oO7hCFY\n\nhttps://www.youtube.com/watch?v=FRkelR5H3ho\n\nhttps://www.youtube.com/watch?v=vaEHDkDcPTo\n\nhttps://www.youtube.com/watch?v=woB6yiX-Ll8\n\nhttps://www.youtube.com/watch?v=9VnBVmo1Muc\n\nhttps://www.youtube.com/watch?v=syapweRMiOQ\n\nhttps://www.youtube.com/watch?v=gc4jlXfjNow\n\nhttps://www.youtube.com/watch?v=VTVx5Rx6rsY\n\n## Rest Assured\n\nhttps://www.youtube.com/watch?v=c3V7N0MCm6g\n\nhttps://www.youtube.com/watch?v=x0-uXN2JnFQ","category":"api","description":"Ресурсы. API"},{"title":"Чек лист проверок API","path":"/chek-list-proverok-api/","content":"\n## Чек-лист API тестов\n- Корректность структуры данных\n- POST запросы\n  - Заполнены все поля валидными данными\n  - Заполнены только обязательные поля\n  - Заполнены не все обязательные поля\n  - Не заполнено ни одно поле\n  - Валидация данных в полях (корректные и некорректные данные)\n  - Пустой JSON\n  - Дата создания объекта\n- GET запросы\n  - Пустой список (если возможно)\n  - Заполненный список\n  - Пагинация в списке (limit, offset)\n  - Получение списка с ограничением на количество записей\n  - Получение списка начиная с указанного номера\n  - В случае передачи параметров с некорректным значением возвращается 400 с описанием ошибки в теле ответа\n  - При отрицательном offset список пользователей возвращается начиная с первой позиции\n  - При несуществующем offset возвращается пустой список пользователей\n  - Сортировка списка\n  - Запрос данных по валидному ID, проверка возвращения корректных данных\n  - Запрос данных по несуществующему ID, но в валидном формате\n  - Запрос данных по невалидному ID\n- PUT запросы\n  - Обновление с корректными данными\n  - Обновление по несуществующему ID\n  - Обновление по невалидному ID\n  - Валидация полей (корректные и некорректные данные)\n  - Частичное обновление (в JSON присутствуют не все поля)\n- DELETE запросы\n  - Удаление существующего объекта\n  - Удаление уже удаленного объекта\n  - Удаление по несуществующему ID\n  - Удаление по невалидному ID\n  - Удаление и повторное добавление такой же сущности (если есть уникальные поля)\n- Проверка статусов ответов\n- Проверка всех возможных ошибок\n- Остальные специфичные проверки в случае сложной логики","category":"api","description":"Чек лист проверок API"},{"title":"Assertions","path":"/assertions/","content":"\nВместо сложения слов лучше использовать supplier\n\n()-> \"gfdg\"+ test + \"expected \";","category":"automation","description":"Assertions"},{"title":"Code Style","path":"/code-style/","content":"\nqwerty","category":"automation","description":"Code Style"},{"title":"Курс по автоматизации тестирования Java","path":"/kurs-po-avtomatizaczii-testirovaniya-java/","content":"\n## Вводное занятие. Сразу к практике!\n\n❌ [Вводное занятие. 13-ый поток](https://qa.guru/pl/teach/control/lesson/view?id=242247981&editMode=0)\n\n❌ [Selenium 4. Новые возможности](https://qa.guru/pl/teach/control/lesson/view?id=234815403&editMode=0)\n\n## Профессионально работаем с IntelliJ IDEA Юрий Артамонов\n\n1. Основы\n2. Git and Github\n3. Docker\n4. Базы данных\n5. HTTP Client\n6. Selenium\n7. BDD Support\n\n✅ https://www.youtube.com/watch?v=5qrn-Z5Put4\n\n✅ https://www.youtube.com/watch?v=zp0qC6JT0rE\n\n## 2. Git. Github. Погружаемся. Дмитрий Тучс\n\n1. Еще раз повторим основы Git & Github.\n2. Основы ветвления, pull requests.\n\n✅ [Дополнительное занятие. Станислав Васенков. «GitHub. Readme»](https://www.youtube.com/watch?v=ERYv-g2l0QE)\n\n❌ [Принимаем пулреквесты](https://www.youtube.com/watch?v=X0X1N39ciUw)\n\n## 3. Погружаемся в инструментарий и библиотеки. Станислав Васенков.\n\n1. Теория: Gradle, JUnit5, Selenide.\n2. Практика. Работаем с тренажером demoqa.com\n3. Рассмотрим подробнее возможности Selenide и CSS/Xpath-селекторы\n\n## 4. Основы Java. Дмитрий Тучс.\n\n1. Src - main\n2. Класс с точки зрения файлов\n3. Класс с точки зрения Java\n4. Class fields - переменные (в чем разница)\n5. Примитивные типы данных\n6. Литералы\n7. Операторы\n8. Управляющие конструкции\n9. Метод, как описание поведения\n10. Создание обьектов и вызов методов\n\n✅ [QA.GURU 13-ый поток. Дмитрий Тучс. «Основы Java»](https://www.youtube.com/watch?v=JyLdYQPNOi8)\n\n✅ [Основы Java #2. Продолжение](https://qa.guru/pl/teach/control/lesson/view?id=231894553&editMode=0)\n\n✅ [QA.GURU 11-ый поток. Дополнительное занятие. Дмитрий Тучс. «Java. Продолжение»](https://www.youtube.com/watch?v=IFqwHW5PtSM)\n\n✅ [Дополнительное занятие. Дмитрий Тучс. ООП на примере Java](https://qa.guru/pl/teach/control/lesson/view?id=222958479&editMode=0)\n\n✅ [QA.GURU 8-ой поток. Дополнительное занятие. Дмитрий Тучс. «Основы Java. Продолжение»](https://www.youtube.com/watch?v=Arb5Zt1ydgI)\n\n✅ [Основы Java #3. Продолжение](https://qa.guru/pl/teach/control/lesson/view?id=231894597&editMode=0)\n\n✅ [QA.GURU 11-ый поток. Дополнительное занятие. Дмитрий Тучс. «Основы Java. Продолжение»](https://www.youtube.com/watch?v=sCRgsgREWKU)\n\n✅ [QA.GURU 11-ый поток. Дмитрий Тучс. Дополнительное занятие «Основы Java. Продолжение. Часть II»](https://www.youtube.com/watch?v=icT5QaOC_Yg)\n\n## 5. Продолжаем разрабатывать автотесты. PageObjects. Станислав Васенков.\n\n1. Добавляем в код PageObjects\n2. Изучаем подходы - степовой, сценарный, dsl\n3. Добавляем PageComponents\n\n❌ [Станислав Васенков — Как Testid-strategy победила PageObject и BDD/Cucumber монстров](https://www.youtube.com/watch?v=w5EgCZgj5yE)\n\n## 6. Продолжаем разрабатывать автотесты. Генерация тестовых данных. Станислав Васенков.\n\n1. Генерим рандомные значения используя встроенные библиотеки\n2. Используем JavaFaker\n\n## 7. JUnit 5. Дмитрий Тучс\n\n1. Аннотация @Test\n2. Что из себя представляют аннотации в Java\n3. Пишем свою простейшую реализацию JUnit\n4. @Disabled , @DisplayName\n5. тест кейс - что такое и из чего состоит\n6. Параметризованные тесты - концепция\n- Sources (дата-провайдеры)\n- Нэйминг\n\n❌ [junit5/junit4/assertions: кто как готовит свои тесты, кто на чем обжегся и какие вещи никогда не стал бы использовать](https://www.youtube.com/watch?v=w1ey2zjf3-s)\n\n❌ [Дмитрий Тучс — JUnit 5 Parallel test execution. Теория и практика](https://youtu.be/ZIkIUCyJBGU)\n\n❌ [QA.GURU 10-ый поток. Дополнительное занятие. Дмитрий Тучс. «JUnit 5. Продолжение»](https://www.youtube.com/watch?v=3pOjh6O7-cg)\n\n## 8. Selenide #1. Алексей Виноградов\n\n1. Лайвкодинг - тесты для GitHub\n2. DOM для начинающих\n3. Основные функции библиотеки Selenide (справочник-шпаргалка)\n\n❌ [Обзор новинок Selenide и Q&A](https://qa.guru/pl/teach/control/lesson/view?id=222958530&editMode=0)\n\n## 10. Allure Reports. Артём Ерошенко\n\n1. Практика. Подключение Allure Reports и настройка отчетности о прохождении автотестов.\n2. Практика. Построение более информативной отчетности c вложениями:\n- Прикладываем скриншоты, файлы, логи и другие вложения в отчет.\n3. Теория. Обзор возможностей Allure Reports.\n\n## 9. Работаем с файлами. Дмитрий Тучс\n\n1. Как скачать и прочитать файл\n2. Проверяем контент в .txt, .pdf, .xls/.xlsx, .doc/.docx, .zip\n\n## 11. Jenkins. Создаем первую задачу. Станислав Васенков.\n1. Практика. Создаем задачу (Job), связываем с репозиторием в Github, запускаем тесты удаленно.\n2. Теория. Основы Jenkins.\n3. Теория. Основы CI/CD.\n4. Работа в парах: создаем друг другу джобы и запускаем чужой код\n\n## 12. Управляем параметрами в коде и в Jenkins. Станислав Васенков.\n1. Передаем параметры в код из командной строки\n2. Прячем приватные данные с библиотекой owner\n3. Передаем параметры из jenkins\n\n## 13. Телеграм-бот. Отправляем уведомления о результатах прохождении автотестов. Станислав Васенков.\n1. Практика. Пишем телеграмм-бота.\n2. Практика. Постобработка сборки. Настраиваем отправку уведомлений в Jenkins.\n3. Теория. Обзор возможностей Telegram API.\n\n## 14. Учимся быстро разрабатывать готовые проекты для тестовых заданий. Станислав Васенков.\n\nНабиваем руку небольшими проектами.\n\n1. Находим интересную нам вакансию (hh.ru / linkedin / @qa_jobs)\n2. Делаем небольшой проект:\n- разрабатываем 5-10 простых автотестов на сайт из вакансии,\n    - создаем задачу в jenkins,\n- прячем секретные данные с owner (более развернуто будет в следующем занятии)\n- настраиваем Allure-отчет, добавляем вложения:\n    - снимки экрана,\n    - логи браузера,\n    - видеозапись теста,\n- настраиваем нотификация в telegram / slack.\n\nПо мере прохождения курса добавим сюда:\n- автотесты на API\n- тест-план Allure TestOps - с ручными и автоматизированными тестами\n- интеграцию с Jira\n3. Отправляем наш проект hr c сопроводительным письмом\n\n\n## 15. Selenoid. Роман Орлов\n1. Практика. Добавляем контейнеризацию к задаче в Jenkins.\n2. Теория. Основы Docker. Selenoid\n\n❌ [Дополнительное занятие. Selenoid. Роман Орлов (на GO)](https://qa.guru/pl/teach/control/lesson/view?id=225328797&editMode=0)\n\n## 16. Библиотека Owner. Артём Ерошенко\n\n1. Правильно организуем хранение свойств (properties) в проекте с библиотекой Owner\n2. Прячем секретные данные в Jenkins\n\n## 17. Selenide #2. Алексей Виноградов\n\n1. Практика:\n- Написание автотестов на Selenide.\n- Тестирование виджетов.\n2. Теория:\n- Закрепление знаний полученных на практике\n- Java\n- JUnit5\n\n## 18. REST API. Пишем автотесты с Rest-assured. Станислав Васенков.\n\n1. Практика. Пишем тесты на REST API при помощи библиотеки Rest-assured\n2. Теория. Основы HTTP-протокола, типы запросов, коды ответов.\n\n❌ [Алексей Кузнецов. «Retrofit2»](https://qa.guru/pl/teach/control/lesson/view?id=229174108&editMode=0)\n\n## REST API. Декомпозируем UI-тесты. Подключаем отчетность\n\n1. Превращаем UI-взаимодействия в Api-запросы.\nБольше возможностей REST-assured\n2. Подключаем Allure-listener\n3. Добавляем шаблоны для более красивого отчета\n\n## 19. REST API. Продолжаем изучать. Станислав Васенков.\n\n1. Практика. Декомпозируем UI-автотест в несколько API-автотестов.\nБольше возможностей REST-assured\n2. Изучаем вспомогательные инструменты:\n- Postman,\n- Charles/Fiddler,\n- chrome dev tools (вкладка Network)\n3. Теория. Больше про REST API.\n4. Теория. Обзор SOAP API\n\n## 20. REST API/ Groovy. Алексей Кузнецов\n\n- Groovy для ассертов и основы языка\n- Немного магии java\n- Спецификации\n- Шаблоны для Allure\n\n## Дополнительное занятие. REST API. Дмитрий Тучс\n\n- Swagger\n- API с другой стороны (backend на spring boot)\n- Интеграция backend со Swagger\n- Контроллеры, возвращающие списки объектов\n- Практика\n\n## Дополнительное занятие. SOAP API. Дмитрий Тучс\n\n1. Основы протокола\n2. Soap UI\n\n## 21. Мобильная автоматизация #1. Разрабатываем автотесты с Browserstack\n\n1. Практика. Учимся пользоваться инспектором в Browserstack, разрабатываем первые автотесты на iOS / Android с Selenide\n2. Практика. Browserstack-API. Забираем логи, видео.\n3. Теория. Основы тестирования мобильных приложений.\n\n## 22. Мобильная автоматизация #2. Разрабатываем автотесты с эмулятором Android-устройства и на своем телефоне\n\n1. Настраиваем рабочее место:\n- Appium\n- Android Studio\n- Настраиваем переменные среды\n2. Эмулируем Android устройство\n3. Подключаем свой телефон\n4. Практика. Разрабатываем автотесты с Appium.\n5. Теория. Основы Appium.\n\n[BONUS] Запускаем тесты на школьном Selenoid - Android\n\n## 23. Allure TestOps #1. Артем Ерошенко\n1. Знакомство с системой.\n2. Заведение тест-кейсов.\n3. Создание первого тест-плана.\n\n## 24. Allure TestOps #2. Артем Ерошенко\n1. Интеграции с Jenkins и Jira\n2. Объединение ручных тестов и автотестов в единый тест-план\n3. Метрики, графики, углубленное изучение платформы\n4. Администрирование\n5. Обзор решений и внедренных проектов\n\n## 25. Дипломный проект\n\nНабиваем руку небольшими проектами.\n\n1. Находим интересную нам вакансию (hh.ru / linkedin / @qa_jobs)\n2. Делаем небольшой проект - разрабатываем 5-10 простых автотестов на сайт из вакансии, добавляем джобу в дженкинсе с аллюр-отчетом\nДобавляем сюда Selenoid, Allure TestOps, Jira, Telegram notifications\n3. Отправляем наш проект hr c сопроводительным письмом\n\n❌ [Проверка дипломных проектов 7-го потока](https://qa.guru/pl/teach/control/lesson/view?id=223930680&editMode=0)\n\n❌ [Проверка дипломных проектов 8-го потока](https://www.youtube.com/watch?v=wI8dVgOQzJ8)\n\n## 26. Переезд на собственную инфраструктуру с ресурсов школы. Егор Иванов (выпускник первого потока)\n\nНастроим тестовый стенд локально. Точно также стенд настраивается на любом VPS, например в DigitalOcean.com\n\n1. Рассмотрим базовые команды Linux, которые понадобятся\n2. Доступ к удаленному серверу через ssh Ubuntu  \n  2.1 Доступ к Ubuntu через ssh при помощи публичного RSA ключа\n3. На виртуальной машине установим:  \n  3.1 Java  \n  3.2 Docker  \n  3.3 Docker-compose\n4. Создаем конфиг для docker-compose\n5. Поднимаем Selenoid + Selenoid UI  \n  5.1 Проверяем, как это работает\n6. Поднимаем Jenkins  \n  6.1 Первичные настройки Jenkins.  \n  6.2 Проверка работоспособности.\n  \nЗадание не обязательное. Доступ к инфраструктуре школы останется после окончания обучения (в разумных пределах, конечно).\n\n❌ [Дополнительное занятие. SQL + работа с базой из Java. Дмитрий Тучс.](https://qa.guru/pl/teach/control/lesson/view?id=222958523&editMode=0)\n\n❌ [Дополнительное занятие. Дмитрий Тучс. Тестируем gRPC](https://qa.guru/pl/teach/control/lesson/view?id=222958538&editMode=0)\n\n❌ [Делаем ревью библиотеки allure-notifications. Дмитрий Тучс. Алексей Кузнецов](https://qa.guru/pl/teach/control/lesson/view?id=242453199&editMode=0)\n\n❌ [Делаем ревью автотестов для Allure TestOps. Дмитрий Тучс. Александр Киреев](https://qa.guru/pl/teach/control/lesson/view?id=243490573&editMode=0)\n\n❌ [Дорабатываем сервис генерации проектов start.autotests.cloud. Станислав Васенков](https://qa.guru/pl/teach/control/lesson/view?id=244143788&editMode=0)\n\n❌ [QA.GURU. Станислав Васенков. «Расширенное занятие по уведомлениям о статусе ваших автотестов.»](https://www.youtube.com/watch?v=ybbGlgCusOQ)\n\n\n\n","category":"automation","description":"Курс по автоматизации тестирования Java"},{"title":"Проблемы и решения","path":"/problemy-i-resheniya/","content":"\n## Ошибка Timeout waiting to lock... во время сборки Gradle проекта \nВ терминале нужно выполнить команду \n```\nfind ~/.gradle -type f -name \"*.lock\" -delete\n``` \n\n## ITK\nSelenide вернет проинициализированный объкт после того как откроет страницу по указанному url.\n\n```java\nHuman h = Selenide.open(\"\", Human.class);\n```\n\n## Папка test не подсвечивается как модуль\nНужно пометить папку src-test-java как Test Source и пересобрать проект в gradle\n","category":"automation","description":"Проблемы и решения"},{"title":"Ресурсы для написания проекта по автоматизации 1","path":"/resursy-dlya-napisaniya-proekta-po-avtomatizaczii-1/","content":"\n## Kubernetes, Docker, Selenoid\n\n[Ресурсы. Kubernetes, Docker, Selenoid](/resursy-kubernetes-docker-selenoid/)\n\n## Selenium 4\n\n[Ресурсы. Selenium 4](/resursy-selenium-4/)\n\n## API\n\n[Ресурсы. API](/resursy-api/)\n\n## UI\n\n[Ресурсы. UI](/resursy-ui/)\n\n## CI\n\n[Ресурсы. CI](/resursy-ci/)\n\n## Тест дизайн\n\n[Ресурсы. Тест дизайн](/resursy-test-dizajn/)\n\n## Паттерны проектирования\n\nhttps://www.youtube.com/watch?v=EnooA2kEhY0\n\nhttps://www.youtube.com/watch?v=-JI9tcWr8E4\n\nhttps://www.youtube.com/watch?v=oVx1Z04Ajq0\n\nhttps://www.youtube.com/watch?v=pln38fIbYqA\n\n## Статический анализ\n\nhttps://youtube.com/watch?v=O0-vAiqGrVk\n\nhttps://www.youtube.com/watch?v=E87YkXhdxAA\n\n## Тестовое покрытие\n\nhttps://www.youtube.com/watch?v=vl79g-0zzP0\n\nhttps://www.youtube.com/watch?v=lMD82Pj3Llk\n\nhttps://www.youtube.com/watch?v=rtwjMceVRaw\n\n## kotlin в автоматизации\n\nhttps://www.youtube.com/watch?v=fkboozZ2CWA\n\nhttps://www.youtube.com/watch?v=2For6QVZqsg\n\n## Appium\n\nhttps://www.youtube.com/watch?v=2ECGcMejda0\n\nhttps://www.youtube.com/watch?v=qYu0CrXqPps\n\n## Карьера в IT\n\nhttps://www.youtube.com/watch?v=Euh4ohO9Ong\n\nhttps://www.youtube.com/watch?v=1wvYjuq9508\n\nhttps://www.youtube.com/watch?v=cNxX4cyrviA\n\n## Code Review\n\nhttps://www.youtube.com/watch?v=RFUMO7XTAQY\n\nhttps://www.youtube.com/watch?v=edNscDtiYGE\n\n## Тестовые данные \n\nhttps://www.youtube.com/watch?v=E21AxgHX2B0\n\n## Разное\n\nhttps://www.youtube.com/watch?v=99q5KnqycmY\n\nhttps://www.youtube.com/watch?v=x-tNXvvz_KA\n\nhttps://www.youtube.com/watch?v=AoJb6QLeIMI\n\nhttps://www.youtube.com/watch?v=hYSQq4XqWIw\n\nhttps://www.youtube.com/watch?v=roLrGhpQeq4\n\nhttps://www.youtube.com/watch?v=13KmFOo8Qag\n\nhttps://www.youtube.com/watch?v=hQqjXjwWH_4","category":"automation","description":"Ресурсы для написания проекта по автоматизации"},{"title":"Ресурсы. UI","path":"/resursy-ui/","content":"\n## Разработка фреймворка\n\n✅ [Слои тестового фрамеворка: Что? Где? Когда? Антон Шапин. COMAQA Piter 2017](https://youtu.be/8Qm9TJtclYw)\n\n❌ [Секция QA: Полезные практики создания автоматических тестов с использованием Cucumber-JVM](https://youtu.be/tX3V90K8VIU)\n\n✅ [Практика создания модульного тестового проекта (Денис Кудряшов, Leroy Merlin)](https://youtu.be/eIOyQ4Axktk)\n\n✅ [Десять причин моей ненависти - Андрей Солнцев. QA Fest 2019](https://youtu.be/pln38fIbYqA)\n\n❌ [Mocks and network tricks in UI automation - Дмитрий Прокопук. QA Fest 2019](https://youtu.be/rYl3HV_43qg)\n\n❌ [Не изобретайте велосипед! Грамотные функциональные тесты с WebDriver и Thucydides -Николай Алименков](https://youtu.be/mlS5n6ykAgg)\n\n❌ [Sergey Pirogov - Test Cases as a Code](https://youtu.be/dAJ9CIioTIA)\n\n✅ [Что делать, если у вас слишком много автотестов (Сергей Потанин, Wrike, Воронеж)](https://youtu.be/N2eOA4t_xaM)\n\n❌ [Артем Ерошенко — Воркшоп. Fullstack QA: Разбираемся в зоопарке тестов. Часть 1](https://youtu.be/wMm2mxVv1h0)\n\n❌ [Артем Ерошенко — Воркшоп. Fullstack QA: Разбираемся в зоопарке тестов. Часть 2](https://youtu.be/lRSevfOCqwM)\n\n✅ [Сергей Разуваев — Проблемы и решения при тестировании тяжелого энтерпрайза](https://youtu.be/q7G3825dueQ)\n\n❌ [Андрей Солнцев — Воркшоп: Как начать свой проект автоматизации с нуля. Продолжение (часть 1)](https://youtu.be/h254Tccxgq4)\n\n❌ [Андрей Солнцев — Воркшоп: Как начать свой проект автоматизации с нуля. Продолжение (часть 2)](https://youtu.be/WETyt87o_R4)\n\n✅ [Дмитрий Тучс — JUnit 5 Parallel test execution. Теория и практика](https://youtu.be/ZIkIUCyJBGU)\n\n❌ [#11 Артем и Сева. Моки(Mocks) и стабы(Stubs).](https://youtu.be/VbVcGpS8HV4)\n\n❌ [Николай Алименков Автоматизация тестирования Web UI](https://youtu.be/cUoSTBkeFy4)\n\n❌ [А вы знаете что тестируют ваши тесты? (Николай Алименков, SQADays-11)](https://youtu.be/irldaKe-PwU)\n\n❌ [Андрей Солнцев, Антон Кекс — Воркшоп: Парное программирование. Часть 1](https://youtu.be/8K1apzz8Ml4)\n\n❌ [Андрей Солнцев, Антон Кекс — Воркшоп: Парное программирование. Часть 2](https://youtu.be/Itm_KUGo8Ro)\n\n❌ [Владимир Ситников — assertTrue, как много в этом слове...](https://youtu.be/1XoQv5oeAm8)\n\n[Артем Ерошенко — TestOps: DevOps для тестировщиков](https://youtu.be/Iam2NlTukFQ)\n\n[Артем Ерошенко — Нужно сделать рефакторинг проекта? Есть IDEA!](https://youtu.be/Y6oryeeFZYc)\n\n[Артем Ерошенко — Простота, доверие, контроль — три кита автоматизации веб-тестирования](https://youtu.be/gwXpYB6ZayE)\n## Ускорение тестов\n\nhttps://www.youtube.com/watch?v=GZXq6oovGcw\n\nhttps://www.youtube.com/watch?v=yyzGP2CyMRM\n\n### Flaky tests\n\n- 2017\n\n❌ [2017.11.29 Андрей Солнцев - Flaky tests](https://youtu.be/y5TqMKdzmlk) //27.12\n\n- 2018\n\n❌ [Flaky tests are a pain (Andrei Solntsev, Estonia) [RU]](https://youtu.be/zOiSo1hYjF8) // 31.03\n\n❌ [Андрей Солнцев — Flaky tests](https://youtu.be/jLG3RXECQU8) // 2.04\n\n\n- 2019\n\n❌ [Flaky tests 2.0 - (Andrey Solntsev, Estonia)](https://youtu.be/ibx8nVvt-Js) //18.04\n\n❌ [2019.04.30 Андрей Солнцев — Flaky tests. Часть 2](https://youtu.be/elQ2LGGU2bg) // 6.05\n\n- 2020\n\n❌ [Flaky tests: The method. (Andrei Solntsev, Estonia) [RU]](https://youtu.be/6MfMtky-0q4) //15.03\n\n❌ [2020.08.31 Андрей Солнцев - Flaky tests: Метод](https://youtu.be/SSglWLW40Ac) //1.11\n\n\n- 2021\n\n❌ [Андрей Солнцев — Flaky tests. Порядок имеет значение](https://youtu.be/fFe3reCoeBQ) // 9.02\n\n❌ [Андрей Солнцев — Flaky tests. Метод](https://youtu.be/LDjDtR6kd2c) // 9.09\n\n\n## BDD\n\nhttps://www.youtube.com/watch?v=5FM88buqCYU\n\nhttps://www.youtube.com/watch?v=OYj-kWmLcns\n\n## Page Object\n\nhttps://www.youtube.com/watch?v=3aA5roxhlrQ\n\nhttps://www.youtube.com/watch?v=bMwthP9JMmM\n\nhttps://www.youtube.com/watch?v=jT1mIQmdVuo\n\n## интеграционные тесты\n\nhttps://www.youtube.com/watch?v=S4PblsCWANA\n\n## Xpath\n\nhttps://www.youtube.com/watch?v=nuWWl1jE3Vg\n\nhttps://www.youtube.com/watch?v=QcrLCYB_ckc\n\nhttps://www.youtube.com/c/SoftwareTestingMaterialWebsite/videos\n\n\n## test data \n\nhttps://www.youtube.com/watch?v=E21AxgHX2B0\n\nhttps://www.youtube.com/watch?v=dMRlZQMuKNc\n\nhttps://www.youtube.com/watch?v=STsuxvFQTI8\n\n## отчеты\n\nhttps://www.youtube.com/watch?v=4UjOXFnwDOo\n\nhttps://www.youtube.com/watch?v=tcH9-wrkVrk\n\nhttps://www.youtube.com/watch?v=C72RC7hz6Cw\n\nhttps://www.youtube.com/watch?v=rONnA66Ud1A\n\n## интеграция с TMS\n\nhttps://www.youtube.com/watch?v=P-vureOnDWY\n\nhttps://www.youtube.com/watch?v=epXQp6Sq2Oc\n\nhttps://www.youtube.com/watch?v=xjyacUQ3598\n\nhttps://www.youtube.com/watch?v=s5pendRUgKM\n\nhttps://www.youtube.com/watch?v=p4WU6cMMsls\n\nhttps://youtu.be/ipWx2sIcIeI\n\n## Разное\n\nhttps://www.youtube.com/watch?v=zpB3u0vFJnk\n\nhttps://www.youtube.com/watch?v=kYm-lHutUBI\n\nhttps://www.youtube.com/watch?v=aElDbHjJrV0\n\nhttps://www.youtube.com/watch?v=wIOX_I69zYg\n\nhttps://youtu.be/YnEfNzJauvM\n\nhttps://youtu.be/BEPGrEWZVUE\n\nhttps://www.youtube.com/watch?v=oSIqXLxzR0s\n\n","category":"automation","description":"Ресурсы. UI"},{"title":"Алгоритмы (курс Тинькофф)","path":"/algoritmy-kurs-tinkoff/","content":"\n## Асимптотический анализ\nИспользуется для оценки алгоритмов. Оценивается не то сколько алгоритм работает на конкретных данных, а то сколько алгоритм работает в зависимости от размера входа (объема данных). \n\nT(n) - сколько времени работает алгоритм на входе какого-то размера n.\n\n### В чем измерить сколько работает программа?\nНужно посчитать количество действий которые выполняет программа, колисество read/write операций. \n\n### RAM(Random Access Memory) - модель \nИмеет следующие правила:\n- К любой ячейке памяти можно за O(1) обратиться(read) и за O(1) записать что-то(write).\n\nБазовыми операциями, которыми можно вычислять скорость - это опреации read, write.\n\n$O(n)$ - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **ниже**, чем график функции, которая ее определяет - оценка сверху. (условно худшая скорость)\n\n$\\Omega(n)$ - оценка снизу - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **выше**, чем график функции, которая ее определяет - оценка снизу.\n\n$\\Theta(n)$ - если одновременно выполняются условия  $O(n)$ и $\\Omega(n)$\n\n\n\n\n\nhttps://www.youtube.com/watch?v=1cXq7F3ijxM&list=PLjCCarnDJNssC82zhyeg8BxfhPG3b8iZ2\n","category":"java","description":"курс от  тинькофф"},{"title":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\"","path":"/konspekt-knigi-a-bhargava-grokaem-algoritmy/","content":"\n## Что такое алгоритм?\n\nНабор инструкций для выполнения некоторой задачи.\n\n## $О$-большое\n\nСпециальная нотация которая описывает скорость выполнения алгоритма, а именно показывает с какой скоростью растет время выполнения алгоритма при увеличении входных данных.  \n\n$О$-большое не сообщает скорость в секундах а позволяет сравнить количество операций.  \n$О$-большое определяет время выполнения в худшем случае.\n\n#### Разновидности:\n- $O(1)$ - постоянное время\n- $O(log(n))$ - логарифмическое время. Пример: _бинарный поиск_\n- $O(n)$ - линейное время. Пример: _простой поиск_\n- $O(n * log(n))$ - Пример: _эффективные алгоритмы_\n- $O(n^2)$ - Пример: _медленные алгоритмы сортировки (сортировка выбором)_\n- $O(n!)$ - Пример: _очень медленные алгоритмы (задача о коммивояжере)_\n\n## Линейный поиск\n\nПроходим по массиву и при нахождении первого элемента с искомым значением возвращаем его индекс. \n\n\n```java\nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = lineSearch(arr, 12);\nSystem.out.println(index);\nSystem.out.println(arr[index]);\n```\n\n```java\nstatic int lineSearch(int[] arr, int key) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == key) {\n            return i;\n        }\n    }\n    \n    // return -1\n    throw new RuntimeException(\"Key '\" + key + \"' is not found!\");\n}\n```\n\n**Сложность алгоритма** - $O(n)$.  \nСкорость каждой итерации $O(1)$.  \nВ худшем случай $n$ итераций.  \n\n## Бинарный поиск\n\n- работает когда список отсортирован\n\nАналогично поиску слова в словаре.\n\n#### Реализация через цикл:\n\n```java\nstatic int binarySearch(int[] arr, int key) {\n    int low = 0;\n    int high = arr.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (key < arr[mid]) {\n            high = mid - 1;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n#### Реализация через рекурсию:\n\n```java \nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = binarySearch(arr, 12, 0, arr.length - 1);\n```\n\n```java\nstatic int binarySearch(int[] arr, int key, int low, int high) {\n    int mid = low + (high - low) / 2;\n    if (high < low) {\n        return -1;\n    }\n    if (arr[mid] == key) {\n        return mid;\n    } else if (key < arr[mid]) {\n        return binarySearch(arr, key, low, mid - 1);\n\n    } else {\n        return binarySearch(arr, key, mid + 1, high);\n    }\n}\n```\n\n**Сложность алгоритма** - $O({log_{2}(n)})$.  \n\n${log_{2}(n)} = k$   \n$k$ - в какую степень надо возвести 2, чтобы получить n   \n\n$n={2^k}$\n\n- если число n - не степень двойки, то выбирается такое наименьшее k, что $2^k > n$.\n\n- $O({log_{2}(n)})$ лучше чем O(n).\n\n## Сортировка выбором\n\n```java\npublic static void main(String args[]) throws Exception {\n    int[] arr = {64, 42, 73, 41, 32, 53, 16, 24, 57, 42, 74, 55, 36};\n    System.out.println(Arrays.toString(selectionSort(arr)));\n}\n```\n\n```java\nstatic int[] selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        int ind = smallest(arr, i);\n        int temp = arr[i];\n        arr[i] = arr[ind];\n        arr[ind] = temp;\n    }\n    return arr;\n}\n\nstatic int smallest(int[] arr, int start) {\n    int index = start;\n    int smallest = arr[start];\n    for (int i = start; i < arr.length; i++) {\n        if (arr[i] < smallest) {\n            smallest = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n```\n\n**Сложность алгоритма** - $O(n^2)$.  \n\n\n## Рекурсия\n\n- Каждая рекурсивная функция состоит из двух частей:\n    - рекурсивного случая - функция вызывает сама себя\n    - базового случая - функция себя не вызывает, чтобы предотвратить зацикливание\n\n```java\n static int factorial(int n) {\n    if (n == 1) {\n        return n;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\n\n## Стратегия \"Разделяй и властвуй\"\n\nДанная стратегия состоит из двух шагов:\n\n1. Определяется базовый случай - простейший случай из всех возможных.\n2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.\n\nСтратегия \"Разделяй и властвуй\" - это не алгоритм, это подход к решению задачи.\n\n#### Пример:\nИмеется массив `{2, 4, 6}`. Нужно просуммировать все числа и вернуть сумму. \n\n\n```java\nstatic int sum(int[] arr) {\n    if (arr.length == 0) {\n        return 0;\n    } else if (arr.length == 1) {\n        return arr[0];\n    } else {\n        int[] newArr = Arrays.copyOfRange(arr, 1, arr.length);\n        return arr[0] + sum(newArr);\n    }\n}\n```\n\n> Если в рекурсивной функции используется массив, то базовым случаем чаще всего оказывается либо пустой массив, либо массив из одного элемента.\n\n\n## Быстрая сортировка\n\n- Работает быстрее сортировки выбором.\n- Основана на стратегии \"Разделяй и властвуй\"\n\n\nБазовый случай: массивы с одним элементом или пустой массив  \n\n#### Шаги рекурсивного случая:  \n1. Выбрать опорный элемент.\n2. Разделить массив на два подмассива:\n    - элементы, **меньшие** опрного \n    - элементы, **большие** опорного\n\n\n```java\npublic static void quickSort(int[] arr, int from, int to) {\n    if (from < to) {\n\n        int divideIndex = partition(arr, from, to);\n\n        quickSort(arr, from, divideIndex - 1);\n\n        quickSort(arr, divideIndex, to);\n    }\n}\n\nprivate static int partition(int[] arr, int from, int to) {\n    int rightIndex = to;\n    int leftIndex = from;\n\n    int pivot = arr[from + (to - from) / 2];\n    while (leftIndex <= rightIndex) {\n\n        while (arr[leftIndex] < pivot) {\n            leftIndex++;\n        }\n\n        while (arr[rightIndex] > pivot) {\n            rightIndex--;\n        }\n\n        if (leftIndex <= rightIndex) {\n            swap(arr, rightIndex, leftIndex);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return leftIndex;\n}\n\nprivate static void swap(int[] array, int index1, int index2) {\n    int tmp  = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n```\n\n## Хеш-таблицы\n\n**Хеш-функция** представляет собой функцию которая получает строку[^Под \"строкой\" понимаются любые данные - последовательность байтов.] и возвращает число.\nХеш функция должна соответствовать требованиям:\n- Она должна быть последовательной. Всегда возвращать одинаковое число на одну и ту же строку.\n- Разным словам должны соотвествовать разные числа.\n\nМассив который хранит элементы при помощи хеш-функций называется **хеш-таблицей**. Их также называют \"ассоциативным массивом\", \"словарем\", \"отображением\", \"хеш картой\" или просто \"хеш\".\nХеш таблицы упрощают моделировние отношений между объектами.\n\n```java\nHashMap<String, Double> book = new HashMap();\nbook.put(\"apple\", 0.67);\nbook.put(\"milk\", 1.49);\nbook.put(\"avocado\", 1.49);\nSystem.out.println(book.get(\"avocado\"));\n```\n\nХеши подходят для решения следующих задач:\n- моделирование отношений между объектами;\n- устранение дубликатов;\n- кеширование/запоминание данных вместо выполнения работы на сервере.\n\n## Коллизии\n\nСитуация когда несколько элементов по хешу попадают в одну и туже ячейку[^Двум ключам назначается один элемент массива].\n\n#### Одна из стратегий обработки коллизий:\n> Если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.\nНо если все элементы попадают в одну ячейку и содержатся в одном связанном списке то работа с данными замедляется.\n\nОтсюда следует:\n- _Выбор хеш-функции действительно важен._ В идеале хеш функция должна распределять ключи равномерно по всему хешу.\n- Если связанные списки становятся слишком длинными, то работа с хеш-таблицей сильно замедлится. \nНо они не станут длинными _при использовании хорошей хеш-функции_!\n\nДля предотвращения коллизий необходимы:\n- низкий коэфициент заполнения;\n- хорошая хеш-функция;\n\n## Поиск в ширину\n\nАлгоритм для решения задачи поиска кратчайшего пути называется **_поиском в ширину_**.\n\n## Граф\n\nГраф моделирует набор связей. Каждый граф строится из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называют _соседями_.\n\n![Иллюстрация графа](/images/graph_illustration.png)\n\nАлгоритм поиска в ширину может ответить на 2 вопроса:\n\n1. существует ли путь от узла А к узлу В?\n2. как выглядит кратчайший путь от узла А к узлу В?\n\n> Связи первого уровня добавляются в список поиска раньше связей второго уровня и т.д.  \n\n> Проверять связи необходимо в порядке их добавления. Для операций такого рода есть специальная структура данных, называемая **_очередью_**.\n\n## Очередь\n\nДля этой структуры данных доступно только две операции:\n- постановка в очередь;\n- извлечение из очереди;\n\nЭлементы добавленные в очередь первыми, первыми же будут из нее извлечены.\n\n> <u>Очередь</u> относится к категории структур данных FIFO: _First In, First Out_ (\"первым вошел, первым вышел\").\n\n> А <u>стек</u> принадлежит к категории LIFO: _Last In, First Out_ (\"последним вошел, первым вышел\").\n\n## Реализация графа\n\nГраф можно реализовать с помощью хеш-таблицы. В хеш таблице ключ связан со значением, а в нашем случае узел должен быть связан с соседями.\n\n```java\nHashMap<String, String[]> book = new HashMap();\nString[] siblings = {\"alice\", \"bob\", \"claire\"};\nbook.put(\"you\", siblings);\n```\n\nРазличают _направленный_ и _ненаправленный_ граф.  \n**_Направленный граф (ориентированный, орграф)_** - это граф в котором отношения действуют только в одну сторону.  \n**_Ненаправленный граф (неориентированный, неорграф)_** - направления отношений нет и каждый из узлов является соседом друг к другу.\n\n![Виды графов](/images/graph_types.png)\n\nАлгоритм графа:\n1. Создать очередь\n2. Извлечь из очереди первый элемент\n3. Выполнить поисковую проверку \n4. Если элемент соотвествует поиску закончить проверку, если нет то добавить всех соседей данного элемента в очередь\n5. Повторить шаги пока не закончится очередь либо элемент удолетворяющий поиску не будет найден.\n\n> Однако, если элемент встречается в двух и более списках, то он будет проверяться дважды, либо может войти в цикл.  \nЧтобы избежать такого поведения необходимо добавить список, в который помещаются уже проверенные элементы.\n\n\n```java\npublic static void main(String[] args) {\n    HashMap<String, String[]> all = new HashMap();\n    String[] siblings = {\"alice\", \"bob\", \"claire\"};\n    String[] claireSiblings = {\"jack\", \"steve\", \"bob\"};\n    String[] bobSiblings = {\"claire\", \"damon\"};\n    all.put(\"you\", siblings);\n    all.put(\"claire\", claireSiblings);\n    all.put(\"bob\", bobSiblings);\n\n    ArrayDeque<String> searchDeque = new ArrayDeque();\n    searchDeque.addAll(Arrays.asList(all.get(\"you\")));\n    if (!searchMangoSeller(all, searchDeque)) {\n        throw new RuntimeException(\"Mango seller is not found!\");\n    }\n}\n\nstatic boolean searchMangoSeller(HashMap<String, String[]> all,\n                                    ArrayDeque<String> searchDeque) {\n    ArrayList<String> searched = new ArrayList();\n    while (!searchDeque.isEmpty()) {\n        String person = searchDeque.pop();\n        if (!searched.contains(person)) {\n            if (isSeller(person)) {\n                System.out.println(person + \" is a mango seller!\");\n                return true;\n            } else {\n                String[] siblings = all.get(person);\n                if (siblings != null) {\n                    searchDeque.addAll(Arrays.asList(siblings));\n                }\n                searched.add(person);\n            }\n        }\n    }\n    return false;\n}\n\nstatic boolean isSeller(String person) {\n    return person.charAt(person.length() - 1) == 'n';\n}\n```\n\n#### Время выполнения: \nЕсли поиск выполнен по всей сети то значит вы прошли по каждому ребру $O(количество\\:ребер)$.  \nТакже в программе должна храниться очередь поиска. Добавление каждого человека потребует $O(количество\\:людей)$.\nВ итоге поиск в ширину займет $O(количество\\:людей + количество\\:ребер)$, что обычно записывается как $O(V+E)$, _V - кол-во вершин, E - кол-во ребер_.\n\n## Алгоритм Дейкстры\n\nАлгоритм поиска в ширину находит путь, состоящий из меньшего количества сегментов. Но если нужно найти наименьший путь с учетом определеных характеристик, то эту задачу решает **Алгоритм Дейкстры**.\n\nАлгоритм Дейкстры состоит из следующих шагов:\n\n1. Каждому ребру нужно назначить свой вес, в зависимости от иследуемой характеристики.\n2. Найти узел с наименьшей стоимостью.\n3. Проверить существует ли более дешевый путь к соседям этого узла и если существует, обновить их стоимости.\n4. Повторять, пока это не будет сделано для всех узлов графа.\n5. Вычислить итоговый путь.\n\nГраф с весами называется **_взвешенным графом_**. Граф без весов называется **_невзвешенным графом_**.\n\nДля вычисления кратчайшего пути в <u>невзвешенном графе</u> используется _поиск в ширину_. Кратчайшие пути во <u>взвешенном графе</u> вычисляются по _алгоритму Дейкстры_.\n\nВ графах также могут присутствовать **_циклы_**. Это означает, что вы можете начать с некоторого узла перемещаться по графу, а потом снова оказаться в том же узле. \n\n> В ненаправленном графе, каждый из двух узлов ведет к другому узлу, а это _цикл_!  \n> Поэтому, алгоритм Дейкстры работает только с _направленными ациклическими графами, DAG (Directed Acyclic Graph)_.\n\n### Работа с отрицательным весом\n\nВ том случае если проходя по определенному ребру мы не тратим вес а наоборот получаем дополнительный бонус к нужной характеристике, то такому ребру назначется _отрицательный вес_. \n\nОднако Алгоритм Дейкстры не может использоваться при наличии ребер имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_.\n","category":"java","description":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\""},{"title":"Подготовка к собеседованию на QA Automation Engineer","path":"/podgotovka-k-sobesedovaniyu-na-qa-automation-engineer/","content":"\n## 1. Теория тестирования\n01. [Тестирование, Quality control, Quality assurance](/testirovanie-quality-control-quality-assurance/)\n02. [Понятие качества, международные стандарты качества](/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/)\n03. [Жизненный цикл дефекта](/zhiznennyj-czikl-defekta/)\n04. [Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)](/zhiznennyj-czikl-razrabotki-po-sdlc-software-development-life-cycle/)\n05. [Модели разработки ПО](/modeli-razrabotki-po/)\n06. [Методологии разработки ПО: Scrum, Kanban, RUP, DSDM, RAD, XP](/metodologii-razrabotki-po-scrum-kanban-rup-dsdm-msf-xp)\n07. [Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)](zhiznennyj-czikl-testirovaniya-prilozhenij-stlc-software-testing-life-cycle/)\n08. [Принципы тестирования, Agile принципы тестирования](/princzipy-testirovaniya-agile-princzipy-testirovaniya/)\n09. [Практики и подходы тестирования](/praktiki-i-podhody-testirovaniya/\")\n10. [Виды тестирования](/vidy-testirovaniya/)\n11. [Уровни тестирования](/urovni-testirovaniya/)\n12. [Техники тест-дизайна](/tehniki-test-dizajna/)\n13. [Тестовая документация](/testovaya-dokumentacziya/)\n  - [Тестовая политика и стратегия](/testovaya-politika-i-strategiya/) \n  - Международные стандарты тестовой документации\n  - [Master Test Plan и тестовые планы для каждого уровня](/master-test-plan-i-testovye-plany-dlya-kazhdogo-urovnya/)\n  - [Понятие Test Case и Test Suite](/ponyatie-test-case-i-test-suite/)\n  - [Понятие Test Basis, Test Condition и Test Procedure](/ponyatie-test-basis-test-condition-i-test-procedure/)\n  - [Checl-list, как представитель Experience-Based](/checl-list-kak-predstavitel-experience-based/)\n  - [Bug Report](/bug-report/)\n  - [Summary Report](/summary-report/)\n  - [Requirements Tracebility Matrix](/requirements-tracebility-matrix/)\n  - [Test Data Tables](/test-data-tables/)\n  - [Test Scenario](/test-scenario/)\n  - [External Test Reports](/external-test-reports/)\n  - [Критерии приемки](/kriterii-priemki)\n  - [Метрики тестирования](/metriki-testirovaniya/)\n  - [Требования](/trebovaniya/)\n  - [Тестовый оракул](/testovyj-orakul/)\n\n\n## 2. Тестирование WEB приложений\n- 01. Понимание DOM модели\n- 02. Какие веб-элементы бывают\n- 03. Веб-формы и веб-сервера\n- 04. UI(UX) и Pixel Perfect\n- 05. Тестирование верстки, JS ошибок\n- 06. Тестирование мобильной верстки\n- 07. Тестирование функций безопасности SSL\n- 08. Работа с Dev Tool\n- 09. Подходы к тестированию веб приложений\n- 10. Тестирование кросбраузерности, масштабируемости\n- 11. Тестирование кодировок\n- 12. Тестирование локализации, интернационализации\n- 13. Конфигурационное тестирование\n- 14. Работа с Cookie\n\n## 3. Тестирование API\n- [Понимание клиент-серверной архитектуры](/ponimanie-klient-servernoj-arhitektury/)\n- [Взаимодействие сервера, клиента и БД](/vzaimodejstvie-servera-klienta-i-bd/)\n- [REST и SOAP](/rest-i-soap/)\n- JSON vs XML vs WSDL\n- [Response codes](/response-codes/)\n- HTTP/HTTPS структура и методы\n- [Аутентификация и авторизация](/autentifikacziya-i-avtorizacziya/)\n- Mock servers\n- Написание тестов, assertions, запуск коллекций\n- Уровни переменных и работа с ними\n- Токены, pre-request scripts, debugging API\n- Monitoring and reports\n- Работа со Swagger\n- Описение Rest запросов (Open API)\n- Что такое Open API\n- Типы авторизации (basic auth, oAuth, jwt что-то типо того)\n- GET vs POST, POST vs PUT + идемпотентность\n- http 1.1 vs http 2\n- CSRF token\n\n## 4. Тестирование Mobile\n- Особенности тестирования мобильных приложений\n- Требования AppStore и PlayMarket к релизу\n- Классификация мобильных устройств и расширений\n- Виды мобильных устройств\n- Уровни тестирования mobile\n- Виды тестирования mobile\n- Симуляторы и эмуляторы\n- составление юзабио=лити тестов\n- Тестирование утечки памяти\n- Тестирование энергопотребления\n- Тестирование прерываний и человеческого фактора\n- Эвристики и мнемоники\n- Типичные баги\n- Тестирование игр на мобильных устройствах\n\n## 5. Нагрузочное тестирование\n- Load testing vs Perfomance vs Volume vs Stress\n- Метрики нагрузочного тестирования\n- Инструменты нагрузочного тестирования\n- Администрирование с настройкой мониторинга\n- Работа со скриптами, парсерами и заглушками\n- Основные методики и отчеты\n- Понятие настройки генератора нагрузки\n\n## 6. Системы контроля версий\n- Что такое система контроля версий, цель и виды\n- Основные команды GIT\n- Работа с тегами\n- Просмотр коммитов\n- Ветвление в GIT и работа с ветками\n- Установка GIT на сервер\n\n## 7. Основы HTML & CSS\n- Что такое HTML\n- Что такое CSS\n- Структура веб страницы\n- Основные элементы (html, head, title, meta, style, body, link)\n- Атрибуты\n- Работа с таблицами, тегами\n- Применение стилей и CSS-правил\n\n## 8. SQL и NoSQL базы данных\n- Что такое базы данных и их классификация\n- Формы нормализации баз данных\n- Понятие СУБД\n- 12 правил Кодда\n- Базовые запросы с использованием LIKE, BETWEEN, ORDER BY, ALIASES, IN, TOP/LIMIT, DISTINCT\n- Понятие NULL\n- CREATE, DROP, DELETE, UPDATE, INSERT, ALTER\n- Объединение таблиц(вложенные запросыб джойны и т.д.)\n- Работа с агрегатными функциями GROUP BY, HAVING\n- Представления, хранимые процедуры, триггеры и функции\n- Работа с индексами\n- Constraints\n- Понятие и виды NoSWL баз данных\n\n## 9. Компьютерные сети\n- Классификация и топология сетей\n- [Модель OSI vs стек протоколов TCP/IP](/model-osi-vs-stek-protokolov-tcp-ip/)\n- Основные стандарты\n- Протоколы по уровням и их особенности\n- HTTP, FTP, POP3, SMTP, UDP, TCP, ARP, IPv4 vs IPv6, PPP, ICMP\n- Ethernet, WI-FI, IP, MAC, Маска подсети, VLAN\n- DHCP и DNS\n- Типы данных(сегменты, датаграммы, пакеты, биты, кадры)\n- Сетевое оборудование\n\n## 10. Основы тест менеджмента\n- Метрики тестирования\n- Понятие ROI. Формула, расчеты, примеры\n- Модели улучшения тестовго процесса (TMMi, CTP, STEP, TPI NEXT и другие) Особенности их применения\n- Виды моделей Risk-Based testing. Решение практических кейсов.\n- Основы управления QA командой. Основные показатели\n- Оценка трудозатрат на тестирование\n- Оценка качества продукта\n- TEST MANAGEMENT TOOLS\n\n## 11. Основы автоматизированного тестирования\n- Понятие автоматизированного тестирования. Когда стоит применять, а когда нет\n- Базовые основы программирования(типы данных, классы, методы, конструкторы, интерфесы, принципы ООП)\n- Xpath, CSS-селекторы, локаторы\n- Работа с Selenium WebDriver\n- Написаниеи запуск примитивных автотестов, работа с отчетами об их прохождении\n- Понятие BDD, Gherkin\n- Работа со средой разработки + GIT\n\n## 12. Основы тестирования безопасности\n- Основы тестирования безопасности\n- OWASP TOP-10\n- классификация видов уязвимостей\n- Понятие XSS, INJECTIONS, Authorization Bypass\n- Опыт работы с 2-3 инструментами (OWASP ZAP, Nmap, Metasploit, SQLmap, BeFF и др)\n- Суметь протестировать сайт на наличие SQL-инъекций\n- Базовое представление о Kali Linux\n\n## 13. Виртуализация\n- Понятие и настройка виртуализации\n- Паравиртуализация\n- Работа с VIRTUAL BOX\n- Работа с VMWare\n- Установка и работа с различными ОС\n- Команды Linux. Работа в терминале Mac OS\n- Суметь поднять виртуальную машину и подключиться к ней\n\n## 14. Основы работы со снифферами\n- Понятие и виды снифферов\n- Опыт работы с Fiddler\n- Опыт работы с Charles\n- Опыт работы с Wireshark\n- Суметь перехватить пакет и проанализировать трафик\n\n## 15. Инструменты для тестирования\n- Postman, SOAP UI, CURL, Katalon Studio\n- Jmeter, Grafana, Apigee, Browserstacks, Genymotion\n- PowerShell, Redmine, Jira, HP ALM, IBM Rational Quality Manager, MSTeam Foundation Server, TestRail, TestLink\n- Notepad++, PSPad, Snagit, ScreenHunter, Snipping tool, Monosnap, Sitechco, FakeFiller, PICT, Mackaroo, Lipsum\n- DiffChecker, Intellij IDEA, Eclipse и т.д.\n\n","category":"interview","description":"Подготовка к собеседованию на QA Automation Engineer"},{"title":"Подготовка к собеседованию на QA Automation Engineer 2","path":"/podgotovka-k-sobesedovaniyu-na-qa-automation-engineer-2/","content":"\nhttps://itvdn.com/ru/blog/article/250-questions-qa?utm_sourse=tg_post_/250_questions_qa\n\nhttps://www.youtube.com/channel/UC6hNNlCXv1ZgdGpziNf83RA/videos\n\nhttps://www.youtube.com/watch?v=za6VI5uplIk\n\nhttps://www.youtube.com/watch?v=PIxa53N_uIM\n\nhttps://www.youtube.com/watch?v=LR7aDc_G5Xo\n\nhttps://www.youtube.com/watch?v=KlE3BOltGdw\n\nhttps://www.youtube.com/watch?v=GI2D3MAZBe0\n\nhttps://www.youtube.com/watch?v=PBjYqFNfLhw\n\nhttps://www.youtube.com/watch?v=u5BU2CxgBIo\n\nhttps://www.youtube.com/watch?v=PMJYLi_ePiQ\n\nhttps://www.youtube.com/watch?v=l3vC73Hgl-w\n\nhttps://www.youtube.com/watch?v=Fj1DdwSiY34\n\nhttps://www.youtube.com/watch?v=QnUFyAiL0N0&t=673s\n\nhttps://www.youtube.com/watch?v=KFgYa6GkAjM\n\nhttps://www.youtube.com/watch?v=dMdHRYfjzx0&t=1s\n\nhttps://www.youtube.com/watch?v=6bq28qjTHQk\n\nhttps://www.youtube.com/watch?v=vmOK5r4bjRU\n\nhttps://www.youtube.com/watch?v=WOo3YZHIDYE&t=2s\n\nhttps://www.youtube.com/watch?v=q75avN98ibg\n\nhttps://www.youtube.com/watch?v=XhKDpflWKls&t=2101s\n\nhttps://www.youtube.com/watch?v=4D40jGV8Jb8\n\nhttps://www.youtube.com/watch?v=4ESHltu1YBI\n\n\n\n## QA\n\n## Теоретическая база по Computer Science \nпонимание работы целевой платформы, общие принципы построения приложений, версионность, SDLC и прочее\n\nhttps://www.youtube.com/playlist?list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1\n\n## Теоретическая база по тестированию\nтест-дизайн, практики и подходы тестирования, артефакты тестирования и принципы и подходы к построению и проведению тестирования.\n\n## Теоретическая база по автоматизации\nкакие инструменты есть, как автоматизируются те или иные сценарии, что стоит автоматизировать, а что нет и с какой стороны ко всему этому подходить. Пресловутый page object и html\\page elements.\n\n## Теоретическая база по программированию\nООП, структуры данных, способность решать минимальные типовые задачи, знание Java\\Python.\n\n\n\n\n### Основы тест-дизайна\n\n- как бы вы составили тест-кейсы для какого-то функционала или целой программы\n\n### Понимание работы клиент-серверных приложений\n\n- как работает Web\n- протокол HTTP\n- связка HTML / CSS / JavaScript\n- смысл кросс-браузерного тестирования\n\nкак настроить Selenium или Selenoid, как подбирать CSS или XPath-локаторы для элементов, какие браузеры выбрать для тестов.\nДля автоматизации API необходимо знать про методы HTTP-запросов (GET, POST, PUT, DELETE и т.д.) и их отличия, коды ответа сервера и их основные форматы (JSON, XML).\n\nНа практической части могут дать проверить работу какого-нибудь приложения, попросить составить список тест-кейсов и рассказать про особенности тестирования подобных продуктов.\n\n\n## Java\n\n- вопросы по ООП - что такое класс и экземпляр класса, что такое инкапсуляция, полиморфизм и наследование, какие бывают модификаторы доступа (в Java) и прочее.\n\nЕще на собеседовании могут поспрашивать немного про паттерны программирования. Тут хорошо знать про Singleton, Factory, PageObject, PageFactory, Builder и так далее. Можно еще почитать про принципы разработки SOLID, KISS, DRY, SRP.\n\n## TestOps\n\nс какой CI-системой вы чаще всего работали. На мой взгляд, самыми популярными являются Jenkins, Gitlab CI, TeamCity и Bamboo.\n\nПомимо этого спросят про опыт работы с bash: команды cd, ls, ps, mv, cp и так далее. Просто, чтобы убедиться, что вы не растеряетесь, зайдя на какой-нибудь сервер на основе linux по ssh.\n\nЕще могут быть вопросы по Docker - что такое образ, как запустить контейнер, как сделать маунт директории хост-машины, как собрать docker compose файл, как распространять образы между коллегами (docker registry)... Примерно так.\n\nСкорее всего попросят решить какую-нибудь задачку на SQL-запрос. Он тоже довольно популярен и с ним приходится работать, например, при тестировании серверной части: баз данных, сервисов или API.\n\nНапоследок могут спросить про системы контроля версий. Сейчас, на мой взгляд, самая популярная - это Git. Кандидата могут спросить про то, что такое ветки и коммиты, попросить решить какую-нибудь простую задачу. Например, рассказать о способе решения конфликтов мержа.","category":"interview","description":"Подготовка к собеседованию на QA Automation Engineer"},{"title":"Теоретическая база по тестированию. Список вопросов","path":"/teoreticheskaya-baza-po-testirovaniyu-spisok-voprosov/","content":"\n## Тестирование, Quality control, Quality assurance\n\n### 1. Что такое тестирование программного обеспечения?\nВ соответствии со стандартом ANSI/IEEE 1059 — процесс анализа элемента программного обеспечения для обнаружения различий между существующими и необходимыми условиями (т. Е. Дефектов) и оценки функций элемента программного обеспечения. Щелкните здесь для получения более подробной информации.\n\n### 2. В чем разница между SDET, инженером-тестировщиком и разработчиком\n**SDET против инженера-тестировщика против разработчика**\n\n| Инженер-испытатель |\tSDET |\tРазработчик |\n| ------------------ | ----- | ------------ |\n| Инженер по тестированию думает только о том, прошел или не прошел тестовый пример, и о том, как сломать программное обеспечение |SDET знает функциональные цели системы, а также цели качества|Разработчик думает, как разработать систему и заставить функциональность работать|\n| Инженер-тестировщик работает только для жизненного цикла теста, такого как проектирование тестовых примеров и выполнение|SDET участвует в проектировании, разработке и тестировании|Разработчик ограничен частью кодирования и выпуском для группы тестирования |\n| Знания в области программирования не требуются |\tДинамические наборы навыков, такие как знание качества и тестирования, а также хорошее знание кода|\tТребуются только знания кодирования|\n|Инженеры-испытатели знают, где присутствует повторяющаяся работа или простой ввод данных, но не ожидают, что они минимизируют повторяющиеся задачи\t|SDET понимает потребности автоматизации, они могут кодировать и предоставлять решение для команды, где повторяющаяся работа убивает время. Они могут разработать структуру, которая может помочь команде тестирования сократить повторяющийся цикл тестирования или простую задачу ввода данных.\t|Разработчики не занимаются такими задачами|\n| Ожидается, что инженеры-испытатели не дойдут до уровня кода и настроят производительность\t| Хорошо осведомленные о настройке производительности и угрозах безопасности, они могут предлагать и обращаться к коду и предлагать, где приложение работает с низкой производительностью, плюс они могут оптимизировать код|\tОжидается, что разработчики будут кодировать только те функции, которые ожидаются от клиента|\n\n### 3. Что такое гарантия качества и контроль качества?\n_Обеспечение качества:_ Обеспечение качества включает в себя деятельность, ориентированную на процесс. Это обеспечивает предотвращение дефектов в процессе создания Программных приложений. Таким образом, дефекты не возникают при разработке программного приложения.\n\n_Контроль качества:_ Контроль качества включает в себя деятельность, ориентированную на продукт. Он запускает программу или код для выявления дефектов в программном приложении.\n\n## Понятие качества, международные стандарты качества ???\n\n## Жизненный цикл дефекта\n\n### 1. Как определяешь, что это баг? Вообще, когда считается, что это баг? Правда ли, что некоторые баги на порядок важнее остальных? Как репортишь баги?\n\n###  2. Что такое проверка при тестировании программного обеспечения?\nВерификация — это процесс, чтобы убедиться, правильно ли мы создаем продукт, то есть проверить требования, которые у нас есть, и проверить, разрабатываем ли мы продукт соответствующим образом или нет. Здесь задействованы следующие виды деятельности: инспекции, обзоры, обходы. Щелкните здесь, чтобы узнать подробнее.\n\n###  3. Что такое валидация при тестировании программного обеспечения?\nВалидация — это процесс, независимо от того, создаем ли мы правильный продукт, т.е. для проверки правильности разработанного нами продукта. Мероприятия, связанные с этим, — это тестирование программного приложения. Нажмите здесь, чтобы узнать больше.\n\n### 4. Что такое проверка?\nИнспекция — это формальная встреча, проводимая обученным модератором, но никак не автором. Проверяемый документ готовится и тщательно проверяется рецензентами перед встречей. На контрольном совещании обнаруженные дефекты регистрируются и передаются автору для принятия соответствующих мер. После проверки используется официальный процесс последующих действий для обеспечения своевременных и корректирующих действий.\n\n### 5. Кто все участвует в инспекционной встрече?\nАвтор, Модератор, Рецензент (и), Писец/Регистратор и Менеджер.\n\n### 6. Что такое дефект?\nРазница между фактическими и ожидаемыми результатами называется дефектом. Если разработчик обнаруживает проблему и исправляет ее самостоятельно на этапе разработки, это называется дефектом. Щелкните здесь, чтобы узнать подробнее.\n\n### 7. Что такое ошибка?\nЕсли тестировщики обнаруживают несоответствие в приложении/системе на этапе тестирования, они называют это ошибкой. \nМы не можем скомпилировать или запустить программу из-за ошибки кода в программе. Если разработчик не может успешно скомпилировать или запустить программу, он называет это ошибкой. Щелкните здесь для получения более подробной информации.\n\n### 8. Что такое неудача?\nПосле того, как продукт развернут и клиенты обнаруживают какие-либо проблемы, они называют продукт неисправным. После выпуска, если конечный пользователь обнаруживает проблему, эта конкретная проблема называется ошибкой. Щелкните здесь, чтобы узнать подробнее.\n\n### 9. Что такое серьезность ошибки?\nСерьезность ошибки/дефекта можно определить как влияние ошибки на бизнес клиента. Это может быть критическое, серьезное или незначительное. Проще говоря, насколько сильно повлияет на систему тот или иной дефект. Щелкните здесь, чтобы узнать подробнее.\n\n### 10. Что такое приоритет ошибок?\nПриоритет дефекта можно определить по тому, как скоро дефект должен быть исправлен. Он дает порядок, в котором дефект должен быть устранен. Разработчики решают, какой дефект им следует устранить дальше, в зависимости от приоритета. Он может быть высоким, средним или низким. В большинстве случаев статус приоритета устанавливается в зависимости от требований клиента. Щелкните здесь, чтобы узнать подробнее.\n\n### 11. Приведите несколько примеров серьезности ошибки и приоритета ошибки?\nВысокий приоритет &amp; Высокая степень серьезности: Кнопка «Отправить» не работает на странице входа, и клиенты не могут войти в приложение\n\nНизкий приоритет &amp; Высокая степень серьезности: сбой в работе некоторых функций, которые будут реализованы после нескольких выпусков\n\nHigh Priority &amp; Низкая степень серьезности: орфографическая ошибка в названии компании на главной странице\n\nНизкий приоритет &amp; Низкая серьезность: страница часто задаваемых вопросов загружается\n\n### 12. Что такое критическая ошибка?\nКритическая ошибка — это ошибка, которая означает, что большая часть функциональности или основной компонент системы полностью нарушена, и нет никакого обходного пути для дальнейшего продвижения.\n\nНапример, из-за ошибки в одном модуле мы не можем протестировать другие модули, потому что ошибка блокировщика заблокировала другие модули. Ошибки, влияющие на бизнес клиентов, считаются критическими.\n\nПример:\n1. Кнопка «Войти» не работает в приложении Gmail, и пользователям Gmail заблокирован вход в свои учетные записи.\n2. Сообщение об ошибке появляется, когда клиент нажимает кнопку перевода денег на веб-сайте банка.\n\n### 13. Что такое жизненный цикл ошибки?\nЖизненный цикл ошибки также известен как жизненный цикл дефекта . В процессе разработки программного обеспечения ошибка имеет жизненный цикл. Ошибка должна пройти жизненный цикл, чтобы быть закрытой. Жизненный цикл ошибки варьируется в зависимости от используемых инструментов (QC, JIRA и т. Д.) И процесса, выполняемого в организации. Щелкните здесь, чтобы узнать подробнее.\n\n### 14. Каковы различные стадии жизненного цикла дефекта?\n\nРазличные этапы жизненного цикла ошибки:\n- Новая\n- Назначенная\n- Открытая\n- Тестовая\n- Перемещено в QA/Готово к тестированию\n\n- Подтверждено\n- Исправлено\n- Закрыто\n- Повторно протестировано\n- Открыть повторно\n- Дубликат\n- Отложено\n- Отклонено\n- Не может быть исправлено\n- Невоспроизводимо\n- Требуется дополнительная информация\n\n### 15. Что такое утечка ошибок?\nОшибка, которая фактически упущена командой тестирования во время тестирования, и сборка была выпущена в производство. Если теперь эта ошибка (которая была пропущена группой тестирования) была обнаружена конечным пользователем или заказчиком, мы называем это утечкой ошибки.\n\n### 16. Что такое выпуск ошибок?\nВыпуск программного обеспечения в производственную среду с известными ошибками, мы называем это выпуском ошибок. Эти известные ошибки следует включить в примечание к выпуску.\n\n### 17. Что такое возраст дефекта?\nВозраст дефекта можно определить как временной интервал между датой обнаружения дефекта и датой закрытия дефекта.\n\nВозраст дефекта = Дата закрытия дефекта — Дата обнаружения дефекта\n\nПредположим, тестировщик обнаружил ошибку и сообщил о ней 1 января 2016 г., а 5 января 2016 г. она была успешно исправлена. Таким образом, возраст дефекта составляет 5 дней.\n\n### 18. Что такое ошибка при заполнении?\nЗаполнение ошибок — это процесс добавления известных ошибок в программу, предназначенного для определения скорости обнаружения ошибок. Это помогает в процессе оценки навыков тестировщика в поиске ошибок, а также в оценке возможностей приложения (насколько хорошо приложение работает при наличии ошибок).\n\n### 19. Что такое угадывание ошибок?\nУгадывание ошибок также является методом разработки тестовых примеров, аналогичным поиску ошибок. При угадывании ошибок тестировщики проектируют тестовые примеры, угадывая возможные ошибки, которые могут возникнуть в программном приложении. Намерение состоит в том, чтобы немедленно обнаруживать ошибки.\n\n### 20. Что такое дефект Showstopper?\nДефект showstopper — это дефект, который не позволяет пользователю двигаться дальше в приложении. Это почти похоже на сбой.\n\nПредположим, что кнопка входа не работает. Несмотря на то, что у вас есть действующее имя пользователя и действующий пароль, вы не можете двигаться дальше, потому что кнопка входа в систему не работает.\n\n## Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)\n\n### 1. Что такое SDLC?\nЖизненный цикл разработки программного обеспечения (SDLC) направлен на создание высококачественной системы, которая соответствует ожиданиям клиентов или превосходит их, эффективно и действенно работает в текущей и планируемой инфраструктуре информационных технологий, недорого в обслуживании и рентабельна для улучшения.\n\n### 2. Какие существуют различные доступные модели SDLC?\n- Waterfall\n- Spiral\n- V Model\n- Прототип\n- Agile\n\n### 3. Можете ли вы провести тестирование системы на любом этапе SDLC?\nМы можем проводить тестирование системы только тогда, когда все блоки находятся на своих местах и ​​работают должным образом. Это можно сделать только до пользовательского приемочного тестирования (UAT).\n\n## Модели разработки ПО\n\n### 1. По каким общепринятым сейчас процессам работала твоя бывшая команда? Мог ли бы ты описать своими словами, как можно было улучшить эти процессы?\n\n## Методологии разработки ПО: Scrum, Kanban, RUP, DSDM, RAD, XP\n\n## Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)\n\n### 1. Перечислить результаты тестирования?\nСтратегия тестирования\nПлан тестирования\nОтчет об оценке усилий\nСценарии тестирования\nТестовые наборы/скрипты\nТестовые данные\nМатрица отслеживания требований (RTM)\nОтчет о дефектах/отчет об ошибке\nОтчет о выполнении теста\nГрафики и показатели\nСводный отчет теста\nОтчет об инциденте тестирования\n< li> Отчет о завершении тестирования\n\nПримечание к выпуску\nРуководство по установке/настройке\nРуководство пользователя\nОтчет о состоянии теста\nЕженедельный отчет о состоянии (от менеджера проекта к клиенту)\n\n### 2. Каковы задачи действий по завершению тестирования в тестировании программного обеспечения?\nДействия по завершению тестирования делятся на четыре основные группы.\n\nПроверка завершения теста: чтобы убедиться, что все тесты должны быть либо запущены, либо намеренно пропущены, а все известные дефекты должны быть либо исправлены, отложены для будущих выпусков, либо приняты как постоянное ограничение.\n\nПередача тестовых артефактов: тесты и тестирование среды должны быть переданы лицам, ответственным за техническое обслуживание. Известные дефекты, принятые или отложенные, должны быть задокументированы и доведены до сведения тех, кто будет использовать и поддерживать использование системы.\n\nИзвлеченные уроки: анализ извлеченных уроков для определения изменений, необходимых для будущих выпусков и проектов. На ретроспективных встречах устанавливаются планы, обеспечивающие хорошее\nметоды могут повторяться, а плохие практики не повторяться\n\nАрхивирование результатов, журналов, отчетов и других документов и рабочих продуктов в CMS (системе управления конфигурациями).\n\n### 3. Что такое закрытие теста?\nЗавершение тестирования — это примечание, подготовленное до того, как группа тестирования официально завершит процесс тестирования. Эта записка содержит общее количество тестовых случаев, всего кол-во выполненных тестовых случаев, всего кол-во обнаруженных дефектов, всего исправленных дефектов, всего ошибок не исправлено, всего нет отклоненных ошибок и т. д.\n\n### 4. Какова процедура ручного тестирования?\nРучное тестирование имеет решающее значение для более тщательного тестирования программных приложений. Процедура ручного тестирования состоит из следующего.\n1. Планирование и контроль\n2. Анализ и дизайн\n3. Реализация и исполнение\n4. Оценка и отчетность\n5. Действия по закрытию теста\n\n### 5. Что такое STLC (жизненный цикл тестирования программного обеспечения)?\nSTLC (жизненный цикл тестирования программного обеспечения) определяет, какие действия по тестированию следует выполнять и когда выполнять эти действия по тестированию. Несмотря на то, что тестирование в разных организациях различается, существует жизненный цикл тестирования. Щелкните здесь, чтобы узнать подробнее.\n\n### 6. Каковы этапы жизненного цикла тестирования программного обеспечения?\nНиже приведены этапы STLC.\n\n- Анализ требований\n- Планирование тестирования\n- Дизайн теста\n- Настройка тестовой среды\n- Выполнение теста\n- Завершение теста\n\n### 7. Когда прекратить тестирование? (Или) Как вы решаете, достаточно ли вы прошли тестирование?\nВ проектах реального времени существует множество факторов, которые определяют, когда следует прекратить тестирование.\n\n- Покрытие требований достигает определенной точки\n- Сроки тестирования или крайние сроки выпуска\n- Когда весь бюджет тестирования исчерпан.\n\n- Достигнув определенного процента успешных тестовых случаев.\n- Риск в проекте ниже допустимого предела.\n- Все исправлены ошибки с высоким приоритетом, блокировщики\n- При соблюдении критериев приемлемости\n- По окончании периода альфа- и бета-тестирования\n- Зависит от решения руководства\n\n### 8. Когда ты понимаешь, что настало время прекратить тестирование?\n\n### 9. Как анализируешь риски? Как это отображается на твоих тестах?\n\n### 10. Как ты оцениваешь, эффективен ли твой личный подход к тестированию? Как его меняешь, если видишь, что не очень эффективен?\n\n## Принципы тестирования, Agile принципы тестирования\n\n### 1. Каковы принципы тестирования программного обеспечения?\nТестирование показывает наличие дефектов.\nИсчерпывающее тестирование невозможно.\nРаннее тестирование\nКластеризация дефектов\nПарадокс пестицидов\nТестирование зависит от контекста\nОтсутствие ошибки в ошибке\nНажмите здесь подробнее.\n\n### 2. Что такое исчерпывающее тестирование?\nТестирование всех функций с использованием всех допустимых и недопустимых входных данных и предварительных условий известно как исчерпывающее тестирование.\n\n### 3. Что такое раннее тестирование?\nИсправление дефектов, обнаруженных на ранних этапах SDLC, обходится дешевле. Таким образом, проведение раннего тестирования снижает затраты на исправление дефектов.\n\n### 4. Что такое кластеризация дефектов?\nКластеризация дефектов при тестировании программного обеспечения означает, что небольшой модуль или функциональность содержит большинство ошибок или имеет наибольшее количество сбоев в работе.\n\n### 5. Что такое «парадокс пестицидов»?\nПарадокс пестицидов в тестировании программного обеспечения — это процесс повторения одних и тех же тестовых примеров снова и снова, в конце концов, одни и те же тестовые примеры больше не будут обнаруживать новые ошибки. Итак, чтобы преодолеть этот парадокс пестицидов, необходимо регулярно просматривать тестовые примеры и добавлять или обновлять их, чтобы найти больше дефектов.\n\n### 6. Что такое каскадирование дефектов при тестировании программного обеспечения?\nКаскадирование дефектов при тестировании программного обеспечения означает запуск других дефектов в приложении. Когда дефект не идентифицируется или остается незамеченным во время тестирования, он вызывает другие дефекты. Это приводит к множественным дефектам на более поздних этапах и приводит к увеличению количества дефектов в приложении.\n\nНапример, если есть дефект в системе бухгалтерского учета, связанный с отрицательным налогообложением, то отрицательный налоговый дефект влияет на бухгалтерскую книгу, которая, в свою очередь, влияет на другие отчеты, такие как баланс, прибыль и убытки; Убыток и т. Д.\n\n## Практики и подходы тестирования ???\n\n### 1. Что такое подход Big Bang?\nОбъединение всех модулей один раз и проверка функциональности после завершения тестирования отдельных модулей.\n\nСверху вниз и снизу вверх используются фиктивные модули, известные как заглушки и драйверы. Эти заглушки и драйверы используются для замены отсутствующих компонентов для имитации обмена данными между модулями.\n\n### 2. Что такое подход сверху вниз?\nТестирование происходит сверху вниз. Сначала тестируются модули высокого уровня, затем модули низкого уровня и, наконец, интеграция модулей низкого уровня на высокий уровень, чтобы гарантировать, что система работает должным образом. Заглушки используются как временный модуль, если модуль не готов к интеграционному тестированию.\n\n### 3. Что такое восходящий подход?\nЭто аналог подхода «сверху вниз». Тестирование происходит снизу вверх. Сначала тестируются модули самого низкого уровня, затем модули высокого уровня и, наконец, интеграция модулей высокого уровня на низкий уровень, чтобы гарантировать, что система работает должным образом. Драйверы используются как временный модуль для интеграционного тестирования.\n\n## Виды тестирования\n\n### 1. Что такое статическое тестирование?\n\nСтатическое тестирование включает в себя проверку документов для выявления дефектов на ранних этапах SDLC. При статическом тестировании мы проводим обзоры кода, пошаговые руководства, экспертные обзоры и статический анализ исходного кода с помощью таких инструментов, как StyleCop, ESLint и т. Д.\n\n### 2. Что такое функциональное тестирование?\nПроще говоря, на самом деле система выполняет функциональное тестирование. Чтобы убедиться, что каждая функция программного приложения ведет себя, как указано в документе с требованиями. Тестирование всех функций путем предоставления соответствующих входных данных, чтобы проверить, соответствует ли фактический выход ожидаемому или нет. Он подпадает под действие «черного ящика», и тестировщикам не нужно беспокоиться об исходном коде приложения.\n\n### 3. Что такое нефункциональное тестирование?\nПроще говоря, насколько хорошо работает система, — это нефункциональное тестирование. Нефункциональное тестирование относится к различным аспектам программного обеспечения, таким как производительность, нагрузка, стресс, масштабируемость, безопасность, совместимость и т. Д. Основное внимание уделяется улучшению взаимодействия с пользователем в зависимости от того, насколько быстро система реагирует на запрос.\n\n### 4. В чем разница между функциональным и нефункциональным тестированием?\n\n|Функциональное тестирование |\tНефункциональное тестирование |\n|----------------------------|--------------------------------|\n|На самом деле система выполняет функциональное тестирование|\tНасколько хорошо работает система, — это нефункциональное тестирование|\n|- Чтобы убедиться, что ваш продукт соответствует потребностям клиентов и бизнеса требований и не содержит серьезных ошибок\t<br>- Чтобы продукт соответствовал ожиданиям клиентов<br> - Чтобы проверить точность программного обеспечения в соответствии с ожидаемым результатом|\tЧтобы проверить поведение программного обеспечения при различных условиях загрузки|\n|Выполняется перед нефункциональным тестированием\t|Выполняется после функционального тестирования|\n\nПример функционального тестового примера — проверка функциональности входа\t\nПример нефункционального тестового примера — проверить, загружается ли домашняя страница менее чем за 2 секунды\n\nТипы тестирования:\n• Модульное тестирование\n• Дым тестирование\n• Принятие пользователями\n• Интеграционное тестирование\n• Регрессионное тестирование\n• Локализация\n• Глобализация\n• Совместимость\t\n\nТипы тестирования:\n• Тестирование производительности\n• Объемное тестирование\n• Масштабируемость\n• Тестирование удобства использования\n• Нагрузочное тестирование\n• Стресс-тестирование\n• Соответствие Тестирование\n• Тестирование переносимости\n• Тестирование аварийного восстановления\n\n### 5. Что такое приемочное тестирование?\nЭто также известно как предварительное тестирование. Это делается конечными пользователями вместе с тестировщиками для проверки функциональности приложения. После успешного приемочного тестирования. Официальное тестирование, проводимое для определения того, разработано ли приложение в соответствии с требованиями. Это позволяет клиенту принять или отклонить заявку. Типы приемочного тестирования: Alpha, Beta и amp; Гамма.\n\n### 6. На каком основании составляется приемочный план?\nПлан приемочных испытаний готовится с использованием следующих входных данных.\n\nДокумент с требованиями: В документе с требованиями указывается, что именно необходимо, а что не нужно в существующем проекте с точки зрения заказчика. .\nИнформация от клиента: Информация от клиента будет в формате официальных электронных писем, неформальных переговоров, обсуждений и т. д.\nПлан проекта: документ с планом проекта, подготовленный менеджером проекта.\nВсе три вышеупомянутых ввода служат хорошими исходными данными для подготовки плана приемочных испытаний.\n\n### 7. Что такое альфа-тестирование?\nАльфа-тестирование проводится штатными разработчиками (которые разработали программное обеспечение) и тестировщиками, прежде чем мы отправим программное обеспечение клиентам. Иногда альфа-тестирование выполняется заказчиком или аутсорсинговой командой в присутствии разработчиков или тестировщиков. Это часть пользовательского приемочного тестирования. Это делается для поиска ошибок до того, как клиенты начнут использовать программное обеспечение.\n\n### 8. Что такое бета-тестирование?\nБета-тестирование проводится ограниченным числом конечных пользователей перед доставкой. Это делается после альфа-тестирования. Обычно это делается на месте клиента. Узнайте больше о бета-тестировании здесь.\n\n### 9. Что такое гамма-тестирование?\nГамма-тестирование выполняется, когда программное обеспечение готово к выпуску с указанными требованиями. Делается на месте у клиента. Это делается напрямую, пропуская все действия по внутреннему тестированию.\n\n### 10. Что такое Smoke Testing?\nSmoke Testing проводится для того, чтобы убедиться, что сборка, полученная нами от команды разработчиков, тестируется или нет. Это также называется проверкой «День 0». Это делается на «уровне сборки». Это помогает не тратить время тестирования на простое тестирование всего приложения, когда ключевые функции не работают или ключевые ошибки еще не исправлены.\n\n### 11. Что такое проверка на вменяемость?\nТестирование работоспособности выполняется на этапе выпуска, чтобы проверить основные функции приложения, не углубляясь в него. Его также называют подмножеством регрессионного тестирования. Это делается на «уровне выпуска». Иногда из-за ограничений по времени выпуска невозможно провести тщательное регрессионное тестирование сборки, тестирование работоспособности выполняет эту часть, проверяя основные функции.\n\n### 12. В чем разница между проверкой на вменяемость и проверкой на дым? Sanity test vs Smoke test\nSmoke Testing проверяет все приложение от начала до конца\n\n|Smoke Test|\tSanity Testing |\n|---|---|\n|Smoke Test проводится, чтобы убедиться, что сборка, которую мы получили от команды разработчиков, тестируется или нет\t|Sanity Test выполняется на этапе выпуска для проверки основных функций приложение без углубления|\n|Дымовое тестирование выполняется как разработчиками, так и тестировщиками|\tТестирование на работоспособность выполняется только тестировщиками\nSanity Testing проверяет только определенный компонент всего приложения|\n|Дымовое тестирование, сборка может быть стабильной или нестабильной|\tПроверка работоспособности, сборка относительно стабильна|\n|Это выполняется на начальных сборках.|\tЭто делается в стабильных сборках.|\n|Это часть базового тестирования .\t|Это часть регрессионного тестирования.|\n|Обычно это делается каждый раз при выпуске новой сборки.\t|Это планируется, когда нет времени на углубленное тестирование.|\n\n### 13. Что такое повторное тестирование?\nЧтобы гарантировать, что дефекты, которые были обнаружены и опубликованы в предыдущей сборке, были исправлены или нет в текущей сборке. Скажем, вышла сборка 1.0. Команда тестирования обнаружила некоторые дефекты (идентификатор дефекта 1.0.1, 1.0.2) и разместила их. Была выпущена сборка 1.1, в настоящее время проводится повторное тестирование дефектов 1.0.1 и 1.0.2 в этой сборке.\n\n### 14. Что такое регрессионное тестирование?\nПовторное тестирование уже протестированной программы после модификации для обнаружения любых дефектов, появившихся или обнаруженных в результате изменений в тестируемом программном обеспечении или в другом связанном или несвязанные программные компоненты.\n\nОбычно мы проводим регрессионное тестирование в следующих случаях:\n\n- В приложение добавляются новые функции.\n- Изменение требований (в организациях мы называем это CR)\n- Исправление дефектов\n- Исправление проблем с производительностью\n- Изменение среды (например, обновление БД из MySQL в Oracle)\n\n### 15. Что вы подразумеваете под регрессионным и подтверждающим тестированием?\nРегрессионное тестирование: Команда тестирования повторно выполняет тесты для измененного приложения, чтобы убедиться, что измененный код нарушает что-либо, что работало ранее.\n\nПодтверждающее тестирование: обычно тестеры сообщают об ошибке при тестировании терпит неудачу. Команда разработчиков выпускает новую версию программного обеспечения после исправления дефекта. Теперь группа тестирования проведет повторное тестирование, чтобы убедиться, что обнаруженная ошибка действительно исправлена.\n\n### 16. Что такое тестирование графического интерфейса пользователя?\nТестирование графического интерфейса пользователя предназначено для тестирования интерфейса между приложением и конечным пользователем.\n\n### 17. Что такое тестирование восстановления?\nТестирование восстановления выполняется для того, чтобы определить, насколько быстро система может восстановиться после сбоя системы или отказа оборудования. Это относится к типу нефункционального тестирования.\n\n### 18. Что такое тестирование глобализации?\nГлобализация — это процесс разработки программного приложения, которое может быть адаптировано к различным языкам и регионам без каких-либо изменений.\n\n### 19. Что такое интернационализационное тестирование (тестирование I18N)?\nОбратитесь к тестированию глобализации.\n\n### 20. Что такое тестирование локализации (тестирование L10N)?\nЛокализация — это процесс адаптации программного обеспечения глобализации для определенного региона или языка путем добавления локальных компонентов.\n\n### 21. Что такое тестирование установки?\nОно предназначено для проверки того, успешно ли установлено приложение и работает ли оно должным образом после установки.\n\n### 22. Что такое формальное тестирование?\nЭто процесс, при котором тестировщики тестируют приложение, имея заранее спланированные процедуры и надлежащую документацию.\n\n### 23. Что такое тестирование на основе рисков?\nОпределите модули или функции, которые с наибольшей вероятностью вызывают сбои, и затем протестируйте эти функции.\n\n### 24. Что такое тестирование совместимости?\nОно предназначено для развертывания и проверки того, работает ли приложение должным образом в другой комбинации компонентов среды.\n\n### 25. Что такое исследовательское тестирование?\nОбычно этот процесс выполняется экспертами в предметной области. Они проводят тестирование, просто исследуя функциональные возможности приложения, не зная требований. Ознакомьтесь с нашим подробным руководством по исследовательскому тестированию, а также не пропустите эти популярные инструменты исследовательского тестирования.\n\n### 26. Что такое тестирование на обезьянах?\nУмышленно выполнить ненормальное действие с приложением, чтобы проверить его стабильность. Ознакомьтесь с нашим подробным руководством по тестированию на обезьянах.\n\n### 27. Что такое юзабилити-тестирование?\nЧтобы проверить, является ли приложение удобным для пользователя или нет и удобно ли им пользовался конечный пользователь. Основное внимание в этом тестировании уделяется проверке того, может ли конечный пользователь легко понять приложение и работать с ним. Приложение должно быть самоисследовательным и не должно требовать обучения для работы с ним. Изучите это руководство, чтобы узнать, как проводить тестирование удобства использования.\n\n### 28. Что такое тестирование безопасности?\nТестирование безопасности — это процесс, позволяющий определить, защищает ли система данные и поддерживает ли она функциональность, как задумано.\n\n### 29. Что такое испытание на впитывание?\nЗапуск системы при высокой нагрузке в течение длительного периода времени для выявления проблем с производительностью называется испытанием на выдержку.\n\n### 30. Что такое испытания на выносливость?\nТестирование на выносливость — это нефункциональный вид тестирования. Он также известен как испытание на впитывание. Обратитесь к тестированию на замачивание.\n\n### 31. Что такое тестирование производительности?\nЭтот тип тестирования определяет или проверяет характеристики скорости, масштабируемости и/или стабильности тестируемой системы или приложения. Производительность связана с достижением времени отклика, пропускной способности и уровней использования ресурсов, которые соответствуют целям производительности для проекта или продукта.\n\n### 32. Что такое нагрузочное тестирование?\nОно предназначено для проверки того, что система/приложение может обрабатывать ожидаемое количество транзакций, и для проверки поведения системы/приложения как при нормальной, так и при пиковой нагрузке.\n\n### 33. Что такое объемное тестирование?\nОно предназначено для проверки того, что система/приложение может обрабатывать большой объем данных\n\n### 34. Что такое стресс-тестирование?\nОн предназначен для проверки поведения системы, когда нагрузка превышает расчетную.\n\n### 35. Что такое тестирование масштабируемости?\nТестирование масштабируемости — это тип нефункционального тестирования. Он должен определить, как тестируемое приложение масштабируется с увеличением рабочей нагрузки.\n\n### 36. Что такое тестирование параллелизма?\nТестирование параллелизма означает одновременный доступ к приложению нескольких пользователей для обеспечения стабильности системы. В основном это используется для выявления проблем с взаимоблокировкой.\n\n### 37. Что такое Fuzz-тестирование?\nFuzz-тестирование используется для выявления ошибок кодирования и лазеек безопасности в приложении. Путем ввода огромного количества случайных данных в систему в попытке вызвать сбой, чтобы определить, не работает ли что-нибудь в приложении.\n\n### 38. Что такое специальное тестирование?\nСпециальное тестирование совершенно противоположно формальному тестированию. Это неформальный вид тестирования. При специальном тестировании тестировщики тестируют приложение случайным образом, не следуя каким-либо документам и методам разработки тестов. Это тестирование в первую очередь выполняется, если уровень знаний тестировщиков в тестируемом приложении очень высок. Тестировщики произвольно тестируют приложение без каких-либо тестовых примеров или каких-либо документов бизнес-требований.\n\n### 39. Что такое тестирование интерфейса?\nТестирование интерфейса проводится для оценки того, передают ли данные два предполагаемых модуля и правильно ли взаимодействуют друг с другом.\n\n### 40. Что такое тестирование надежности?\nВыполнять тестирование приложения непрерывно в течение длительного периода времени, чтобы проверить его стабильность\n\n### 41. Что такое периодическое тестирование?\nБакет-тестирование — это метод сравнения двух версий приложения друг с другом, чтобы определить, какая из них работает лучше.\n\n### 42. Что такое A/B-тестирование?\nОбратитесь к Bucket Testing.\n\n### 43. Что такое сплит-тестирование?\nРекомендуемое сегментное тестирование.\n\n### 44. Что такое тестирование API?\nТестирование API — это тип тестирования программного обеспечения, который включает в себя тестирование API напрямую, а также как часть интеграционного тестирования, чтобы проверить, соответствует ли API ожиданиям с точки зрения функциональности, надежности, производительности и безопасности приложения. В тестировании API основное внимание будет уделяться уровню бизнес-логики в архитектуре программного обеспечения. Тестирование API может выполняться в любой программной системе, содержащей несколько API. Тестирование API не будет концентрироваться на внешнем виде приложения. Тестирование API полностью отличается от тестирования GUI.\n\n### 45. Что такое случайное тестирование?\nСлучайное тестирование — это разновидность метода тестирования программного обеспечения с использованием черного ящика, при котором приложение тестирует, генерируя случайные данные.\n\n## Уровни тестирования\n\n### 1. Каковы уровни тестирования?\nВ тестировании программного обеспечения существует четыре уровня тестирования.\n\n- Модульное тестирование или тестирование на уровне компонентов\n- Интеграционное тестирование\n- Тестирование системы\n- Приемочные испытания\n\n### 2. Что такое модульное тестирование?\nМодульное тестирование также называется модульным тестированием или тестированием компонентов. Это делается для проверки правильности работы отдельного модуля или модуля исходного кода. Это делают разработчики в среде разработчика. Подробнее о модульном тестировании.\n\n### 3. Что такое интеграционное тестирование?\nИнтеграционное тестирование — это процесс тестирования интерфейса между двумя программными модулями. Интеграционное тестирование проводится тремя способами. Подход Большого Взрыва, подход сверху вниз, подход снизу вверх. Подробнее об интеграционном тестировании.\n\n### 4. Что такое системное тестирование?\nТестирование полностью интегрированного приложения для оценки соответствия системы указанным требованиям называется тестированием системы или сквозным тестированием. Проверка завершенной системы, чтобы убедиться, что приложение работает должным образом или нет.\n\n### 5. В чем разница между тестированием интеграции и тестированием системы?\nТестирование интеграции и тестирование системы\n\nТЕСТИРОВАНИЕ ИНТЕГРАЦИИ\tТЕСТИРОВАНИЕ СИСТЕМЫ\nЭто тестирование низкого уровня\tЭто тестирование высокого уровня\nЗа ним следует тестирование системы\tЗа ним следует приемочное тестирование\nВыполняется после модульного тестирования\tВыполняется после интеграции тестирование\nРазличные типы интеграционного тестирования:\n• Интеграционное тестирование сверху-снизу\n• Тестирование интеграции снизу вверх\n• Тестирование интеграции большого взрыва\n• Тестирование интеграции сэндвич\tРазличные типы тестирования системы:\n• Регрессионное тестирование\n• Тестирование работоспособности\n• Тестирование удобства использования\n• Повторное тестирование\n• Нагрузочное тестирование\n• Тестирование производительности\n• Техническое тестирование\n\nТестировщики выполняют функциональное тестирование для проверки взаимодействия двух модулей\tТестеры выполняют как функциональные, так и не- функциональное тестирование для оценки функциональности, удобства использования, тестирования производительности и т. д.\nВыполняется для проверки того, взаимодействуют ли два разных модуля эффективно друг с другом или нет\tВыполняется для проверки того, работает ли продукт в соответствии с ожиданиями пользователя и требуемыми спецификациями\nЭто может быть выполнено как тестировщиками, так и разработчиками\tВыполняется тестировщики\nТестирование происходит на интерфейсе двух отдельных модулей\tТестирование проводится для всего программного приложения\n\n### 6. Что такое сквозное тестирование?\nПроще говоря, сквозное тестирование — это процесс тестирования программного обеспечения от начала до конца. Ознакомьтесь с этим руководством по сквозному тестированию для получения дополнительной информации. Также см. Руководство по тестированию системы.\n\n## Техники тест-дизайна\n\n### 1. Что такое анализ граничных значений?\nАнализ граничных значений (BVA) основан на проверке граничных значений допустимых и недопустимых разделов. Поведение на краю каждого эквивалентного раздела с большей вероятностью будет неправильным, чем поведение внутри раздела, поэтому границы — это область, в которой тестирование может привести к дефектам. Каждый раздел имеет свои максимальные и минимальные значения, и эти максимальные и минимальные значения являются граничными значениями раздела. Граничное значение для допустимого раздела является допустимым граничным значением. Точно так же граничное значение для недопустимого раздела является недопустимым граничным значением. Щелкните здесь, чтобы узнать подробнее.\n\n### 2. Что такое разделение классов эквивалентности?\nРазделение эквивалентности также известно как разделение классов эквивалентности. При эквивалентном разбиении входные данные для программного обеспечения или системы делятся на группы, которые, как ожидается, будут демонстрировать аналогичное поведение, поэтому они, вероятно, будут предлагаться одинаково. Следовательно, выбор одного входа из каждой группы для разработки тестовых случаев. Щелкните здесь, чтобы узнать подробнее.\n\n### 3. Что такое тестирование таблицы решений?\nТаблица решений — это таблица причинно-следственных связей. Этот метод тестирования подходит для функций, которые имеют логические отношения между входами (логика if-else). В технике таблицы решений мы имеем дело с комбинациями входных данных. Чтобы идентифицировать тестовые случаи с таблицей решений, мы рассматриваем условия и действия. Мы принимаем условия как входы, а действия как выходы. Щелкните здесь, чтобы узнать подробнее.\n\n### 4. Что такое переход состояния?\nИспользуя тестирование перехода между состояниями, мы выбираем тестовые примеры из приложения, в котором нам нужно протестировать различные переходы системы. Мы можем применить это, когда приложение дает разные выходные данные для одного и того же входа, в зависимости от того, что произошло в более раннем состоянии. Щелкните здесь, чтобы узнать подробнее.\n\n121. Что такое критерии входа?\nПредварительные условия, которые должны быть выполнены перед началом процесса тестирования. Щелкните здесь, чтобы узнать подробнее.\n\n### 5. Что такое критерии выхода?\nУсловия, которые должны быть выполнены перед тестированием, должны быть завершены. Щелкните здесь, чтобы узнать подробнее.\n\n### 6. Что такое RTM?\nМатрица прослеживаемости требований (RTM) используется для отслеживания требований к тестам, которые необходимы для проверки выполнения требований. Мы должны убедиться, что для каждого требования есть хотя бы 1 тестовый пример. Матрица прослеживаемости требований AKA Матрица прослеживаемости или матрица перекрестных ссылок. Щелкните здесь, чтобы узнать подробнее.\n\n## Тестовая документация\n\n### 1. Каковы лучшие практики написания тестовых примеров?\nНапишите тестовые примеры с точки зрения конечных пользователей.\nНапишите шаги теста в простой форме, чтобы каждый мог следовать их легко\nСделать тестовые примеры многоразовыми\nУстановить приоритет\nПредоставить описание тестового примера, тестовые данные, ожидаемый результат, предварительное условие, постусловие.\nНапишите недопустимые тестовые примеры вместе с допустимыми тестами.\nСоблюдайте правила именования.\nРегулярно просматривайте тестовые примеры и при необходимости обновляйте их.\n\n### 2. Что такое тестовые данные?\nТестовые данные — это данные, которые используются тестировщиками для запуска тестовых случаев. Во время выполнения тестовых случаев тестировщикам необходимо ввести некоторые входные данные. Для этого тестировщики подготавливают тестовые данные. Его можно подготовить вручную, а также с помощью инструментов.\n\nНапример, чтобы протестировать базовую функциональность входа в систему с полями идентификатора пользователя и пароля. Нам нужно ввести некоторые данные в поля идентификатора пользователя и пароля. Итак, нам нужно собрать некоторые тестовые данные.\n\n### 3. Что такое тестовое покрытие?\nТестовое покрытие помогает измерить объем тестирования, выполняемого набором тестов.\nТестовое покрытие может выполняться как для функциональных, так и для нефункциональных действий. Он помогает тестировщикам создавать тесты, охватывающие отсутствующие области.\n\n### 4. Что такое покрытие кода?\nПокрытие кода отличается от покрытия тестом. Покрытие кода — это практика модульного тестирования, которая должна затрагивать все области кода хотя бы один раз. Обычно это делают разработчики или юнит-тестеры.\n\n### 5. Каковы наиболее распространенные компоненты отчета о дефектах?\nНаиболее распространенные компоненты формата отчета о дефектах включают следующее\n\n- Имя проекта\n- Имя модуля\n- Идентификатор дефекта\n- Дефект обнаружен\n- Дефект обнаружен\n- Приоритетом\n- Серьезность\n- Дефект устранен\n- Дефект устранен\n\n### 6. Какие тестовые примеры записываются первыми — белые ящики или черный ящик?\nПростой ответ — сначала записываются тестовые примеры черного ящика.\n\nДавайте посмотрим, почему тест черного ящика кейсы пишутся первыми по сравнению с тестовыми случаями белого ящика.\nНеобходимыми условиями для начала написания тестовых случаев для «черного ящика» являются документы с требованиями или проектные документы. Эти документы будут доступны до начала проекта.\nНеобходимыми условиями для начала написания тестовых примеров белого ящика является внутренняя архитектура приложения. Внутренняя архитектура приложения будет доступна в более поздней части проекта, т. Е. При проектировании.\n\n### 7. Какова концепция инструментальных средств в тестировании программного обеспечения?\nWorkbench — это практика документирования того, как должно выполняться конкретное действие. Это часто называют фазами, шагами и задачами.\n\nВ каждой рабочей среде будет пять задач, таких как ввод, выполнение, проверка, вывод и доработка.\n\n### 8. Что такое тестовые метрики?\nМетрики тестирования программного обеспечения предназначены для мониторинга и управления процессом и продуктом. Это помогает без отклонений продвигать проект к намеченным целям. Метрики отвечают на разные вопросы. Важно решить, на какие вопросы вы хотите получить ответы. Щелкните здесь, чтобы узнать подробнее.\n\n### 9. Когда выполняешь тесты, из каких этапов они состоят?\n\n### 10. Приходилось ли писать план тестирования? Опиши этапы в нем. \n\n### 11. Какие инструменты применял для выполнения? Какие для анализа результатов? \n\n### 12. Как приоретизируешь тесты? Что влияет на твои решения?\n\n## Практические вопросы\n\n1. [Как бы вы составили тест-кейсы для какого-то определенного функционала, как раз на таком вопросе и оцениваются ваши знания об техниках тест-дизайна и тестирования.](/testovaya-dokumentacziya/)\n\n2. Проанализировать особенности тестирования определенного программного обеспечения\n\n3. Тестирование калькулятора\n\nИ, собственно, дефекты, которые должны были найти соискатели.\n\n  1. Лишняя буква \"l\" в слове \"Wellcome\".\n  2. Недостающая буква \"r\" в слове \"corect\" внутри окна подтверждения.\n  Здесь мы смотрим на знание английского языка и умение кандидата работать с очепятками визуально. Первый дефект, к слову, находили, буквально, единицы.\n\n  3. Отсутствие кнопок \"0\", \"С\", \"+/-\" и других управляющих элементов функционала.\n  4. Неправильное расположение цифровых кнопок(Расположены инвертированно, относительно стандартной раскладке для калькулятора). \n  5. Отсутствие символа \".\"\n\n  Эти дефекты должны были дать понимание того, откуда кандидат черпает требования к качеству продукта в случае, если прямых требований нету. Есть официальные стандарты, есть индустриальные стандарты, есть продукты конкурентов, и глядя на это, можно было дать кучу правок и замечаний или, хотя бы, задать определенное кол-во вопросов по целесообразности данного инженерного решения. \n  С дефектом под номером 5 связан отдельный вопрос: \"Каким образом возможно видеть подобную цепочку действий, если точка в функционале отсутствует?\". Задавался он для того, чтобы понять, на каком уровне люди взаимодействуют с продуктом и исследуют ли они его достаточно, чтобы делать выводы. А ответ был очень простым - точку очень легко можно ввести с клавиатуры. \n\n  6. Неподходящее обозначение кнопки для умножения(mul). \n  По правде говоря, здесь этот дефект был своеобразной пасхалкой, так как утилита для мок-апов не умела по-человечески отрисовывать звёздочку, по этому было принято решение заменить ее на сокращение от multiplication и заодно проверить умение ребят мыслить аналитически. \n\n  7. Проблемы с расположением элементов. \n\n  Это очень обширная область, где каждый из соискателей мог дать волю своему внутреннему Джонни Айву и указать элементы, расположение которых не совсем удовлетворяет чувству прекрасного, обязательно присущему и нужному для тестировщика.\n\n  8. Неочевидные решения по функционалу элементов.\n\n  Опять-таки, в отсутствие прямых требований, включаем здравый смысл и принимаем решение, нужно ли нам окно подтверждения, нужен ли нам функционал выбора калькулятора в таком виде, в котором он представлен здесь, и так далее. \n\n  9. Инвертированное положение кнопок Yes и No в окне подтверждения. \n\n  Дефект этот задавался для того, чтобы понять, знаком ли человек с гайдлайнами для устоявшихся структурных единиц. Практика показала, что большинство замечавших просто привыкли к другому расположению, но не задавались вопросом, чем это продиктовано. \n\n  Наиболее запомнившиеся мне кандидаты были готовы завести от 10 до 18(рекорд) баг-репортов. \n  Некоторые обращали внимание на картинку, подозрительно напоминающую непрогрузившееся изображение и пустой URL(побочный эффект стандартного окна браузера в утилите для создания мок-апов). \n\n## Другие вопросы\n\n### 1. Что такое управление конфигурацией?\nУправление конфигурацией (CM) — это процесс системного проектирования для поддержания системных ресурсов, компьютерных систем, серверов, программного обеспечения и производительности продукта в согласованном состоянии. Это помогает записывать все изменения, внесенные в систему, и гарантирует, что система работает должным образом, даже если изменения вносятся с течением времени.\n\n### 2. Назовите несколько популярных инструментов управления конфигурацией?\nНекоторые из популярных инструментов управления конфигурацией — это Ansible, Chef, Puppet, Terraform, Saltstack и т. Д.\n\n### 3. Что такое запрос на изменение?\nЗапрос на изменение (MR) при разработке программного обеспечения используется клиентами для изменения существующей функциональности программного обеспечения.\n\n### 4. Что такое отчет об улучшении?\nОтчет об улучшении (ER) при разработке программного обеспечения используется клиентами для добавления новой функции в программное обеспечение.\n\n### 5. Что, если в программном обеспечении так много ошибок, что его вообще невозможно протестировать?\nЕсли в программном обеспечении так много ошибок, первое, что нам нужно сделать, это сообщить об ошибках и классифицировать их в зависимости от степени серьезности. Если ошибки являются критическими, это серьезно влияет на графики и указывает на более глубокие проблемы в процессе разработки программного обеспечения. Поэтому вам необходимо сообщить менеджеру об ошибках с соответствующей документацией в качестве доказательства.\n\n### 6. Что такое Test Harness?\nTest Harness — это набор программного обеспечения и тестовых данных, сконфигурированных для тестирования программного модуля путем его запуска в различных условиях, что включает мониторинг выходных данных с ожидаемыми выходными данными. .\n\nОн содержит механизм выполнения тестов &amp; Репозиторий тестовых скриптов\n\n### 7. Что такое Walk Through?\nПошаговое руководство — это неформальная встреча, которую проводят для изучения, понимания и поиска дефектов. Автор ведет встречу и разъясняет вопросы, поднятые коллегами на встрече.\n\n### 8. В чем разница между автономным приложением, клиент-серверным приложением и веб-приложением?\n\n**Автономное приложение:**  \nАвтономные приложения следуют одному — ярусная архитектура. Уровень представления, бизнеса и базы данных находятся в одной системе для одного пользователя.\n\n**Клиент-серверное приложение:**  \nКлиент-серверные приложения имеют двухуровневую архитектуру. Уровень представления и бизнеса находится в клиентской системе, а уровень базы данных — на другом сервере. Он работает в основном в интрасети.\n\n**Веб-приложение:**  \nВеб-серверные приложения следуют трехуровневой или многоуровневой архитектуре. Уровень представления находится в клиентской системе, уровень бизнеса — на сервере приложений, а уровень базы данных — на сервере базы данных. Работает как в интранете, так и в Интернете.\n\n### 9. Что такое HotFix?\nИсправление — это сборка, направленная на решение серьезной проблемы, обнаруженной в производственной среде.\n\nИногда сборка, выполняемая в производственной среде, имела критические ошибки, и ее производил откат. Теперь команда разработчиков отложила всю свою работу и сосредоточилась на немедленном исправлении этих ошибок и выпустила новую сборку, чтобы исправить это в производственной среде. Эта сборка называется исправлением.\n\nИсправления и исправления — это два разных типа обновлений программного обеспечения. Исправления доступны для всех, а исправления — нет.\n\nИсправления также известны как технические обновления с быстрым исправлением (обновления QFE)\n\n### 10. Что за исправление?\nИсправление — это сборка, направленная на устранение ошибки, обнаруженной тестировщиками в цикле тестирования.\n\n### 11. Что такое вознаграждение за обнаружение ошибок?\nПрограмма вознаграждения за обнаружение ошибок позволяет организации предлагать вознаграждение человеку, который обнаруживает ошибки в их программном обеспечении и сообщает о них.\n\nBug Bounty — это концепция, которая существует с момента создания Интернета. Компании начали понимать, насколько дорого для них нанимать экспертов по тестированию на проникновение каждый раз, когда они хотят найти уязвимости на своем веб-сайте или в приложении. Так недавно программы по поощрению ошибок стали широко распространенными.\n\nПервой компанией, которая подхватила эту концепцию, была Google. Он запустил свою «Программу вознаграждения за уязвимости» в 2010 году и с тех пор выплатил более 4 миллионов долларов.\n\n### 12. Каковы различные стратегии развертывания для конечных пользователей?\nПри развертывании любого проекта тестирования программного обеспечения необходимо следовать четырем стратегиям:\n\n- Пилотный\n- Постепенное внедрение\n- Поэтапное внедрение\n- Параллельная реализация\n\n### 13. Расскажи о своих недавних задачах. Расскажи, какие видел интересные баги.\n\n**Интересные баги:**\n\n- В самом начале работы Amazon покупатель мог заказать отрицательное количество книг. При этом на его банковскую карту зачислялась соответствующая сумма.\n- На заре становления интернет-магазинов в одном из них можно было вписать в графе «Количество товара» значение 0,1, что давало покупателю скидку в 90% (стоимость товара умножалась на те самые 0,1). \n- В другом для хранения аутентификационных данных использовался файл cookie, в котором можно было сменить ID и совершать покупки от чужого лица.\n- В 1991 году программист столкнулся с вирусом Sunday, который модифицирует исполняемый файл и в последний день недели запускается, чтобы уничтожить данные на диске. По какой-то причине этого не произошло, и программист решил разобраться — написал тестовый EXE-файл, скормил его вирусу и посмотрел, что будет. Оказалось, что авторы вируса при его разработке сделали так, что он должен запускаться в день номер 7, а нумерация дней идёт от 0 до 6, так что переменная никогда не принимала нужного значения.\n- «Проблема 2000 года». Разработчики ПО в XX веке часто использовали для обозначения года в датах две последние цифры вместо привычных четырёх. Например, 7 апреля 1994 года представлялось как «07.04.94».\n1 января 2000 по всему миру начали происходить локальные конфликты и сбои в системах. В некоторых городах даже начало пропадать электричество, отопление, часть вычислительных центров просто зависала. Всё это произошло из-за сокращения формата года. После 1999 года наступил 2000, но для машин этот год воспринимался как 1900 (у некоторых даже как 19100). Такая ошибка послужила причиной зависаний во многих системах.\n\n\n### 14. Приходилось ли автоматизировать тесты? Как это было? Расскажи об инструментах автоматизации.\n\n### 15. Какой любимый инструмент автоматизации? Объясни почему. Если его применять не получится, что другое выберешь, и почему?\n\n### 16. Как определяешь, какие тесты достойны автоматизации? Какие тесты не будешь автоматизировать? Почему?\n\n### 17. Вот тебе простой тестовый сценарий. Расскажи, как (и чем) будешь его выполнять.\n\n\n## Дополнительные материалы\n\n### Самоучитель\n\n- https://www.guru99.com/software-testing.html\n- https://github.com/VladislavEremeev/QA_bible\n- [Курс по тестированию ULearn](https://ulearn.me/Course/testing/Testirovanie_UI_e68eca26-6a60-45d8-bc8f-92943aff03a7)\n- [Курс по тестированию Stepik](https://stepik.org/course/16478/syllabus)\n- [Библиотека тестировщика](https://www.software-testing.ru/library/testing)\n\nhttps://www.youtube.com/playlist?list=PLrCZzMib1e9pDKLsabJYuODdVJrHYc4Jd\n\n### Вопросы на логику\n\nhttps://qa-academy.by/qaacademy/news/logicheskie-zadachi-na-sobesedovanii-testirovshhika/\n\n### Вопросы с собеседований\n\n[100 самых популярных вопросов и ответов на собеседовании по тестированию программного обеспечения - atesting.ru](https://atesting.ru/100-samyh-popyliarnyh-voprosov-i-otvetov-na-sobesedovanii-po-testirovaniu-programmnogo-obespecheniia/)\n\n[Вопросы и ответы для собеседования(тестирование ПО) Часть 1](https://medium.com/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-4fc596806d55)\n\n[Вопросы и ответы для собеседования(тестирование ПО) Часть 2](https://medium.com/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-ec8e224e3f98)\n\n[Вопросы и ответы для собеседования(тестирование ПО) Часть 3](https://medium.com/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-3-6194de0a8bd2)\n\n[Top 40 QA (Quality Assurance) Interview Questions & Answers (2022)](https://www.guru99.com/qa-interview-questions-answers.html)\n\n[101+ вопросов по автоматизации и тестированию вручную](http://getbug.ru/101-voprosov-po-avtomatizatsii-i-testirovaniyu-vruchnuyu/)\n\n[Собеседование тестировщиков: вопросы на собеседовании qa](https://automated-testing.info/t/sobesedovanie-testirovshhikov-voprosy-na-sobesedovanii-qa/10078)\n\n[Каких ответов я жду на собеседовании по тестированию](https://habr.com/ru/post/254209/)\n\n[Собеседование Junior Test Engineer](https://fulcrum.software/ua/interview-jun-test-engineer/)\n\n\n### Про систему управления тестированием Qase\n\n[Официальный сайт](https://qase.io/pricing)\n\n[Туда, не зная куда: каким мы увидели Qase](https://habr.com/ru/company/indriver/blog/666192/)\n\n### Testing Challenge\n\nhttps://qakrotov.com/\n\n[Разбор с примерами и ответами](https://qatalks.ru/testing-challenge-answers)\n\nhttps://www.youtube.com/watch?v=vpj5YDuH7ls\n\n### Разное\n\n[Тренажер по ISTQB](https://istqb-training.ru/Training)\n\n[Тесты по разным областям связанным с тестированием](https://www.guru99.com/tests.html)\n\n[Чек-лист тестирования требований](https://habr.com/ru/post/543340/)\n\n[Web Application Testing Checklist: Example Test Cases for Website](https://www.guru99.com/complete-web-application-testing-checklist.html#2)\n\n[Список книг по тестированию](https://radar4site.ru/blog/16-knigi-po-testirovaniyu.html)\n\nhttps://rocket-science.pro/#program\n\nhttps://www.softwaretestinghelp.com/basic-skills-that-every-tester-fresher-should-have/\n\n### YouTube уроки\n\nhttps://www.youtube.com/watch?v=l5cAeQ3BhjI\n\nhttps://www.youtube.com/watch?v=y6vZu6HKrDg\n\nhttps://www.youtube.com/watch?v=s9fH9yS9K8c\n\nhttps://www.youtube.com/watch?v=MmbVEwYnWTs&list=PLZqgWWF4O-zg03RGSZ2GpHLE3BmO8bjKo\n\n## Нагрузочное тестирование\n\n- Load testing vs Perfomance testing vs Volume vs Atress\n- Метрики нагрузочного тестирования\n- Инструменты нагрузочного тестирования\n- Администрирование с настройкой мониторинга\n- Работа со скриптами, прасерами и заглушками\n- Основные методики и отчеты\n- Понятие настройки генератора нагрузки\n\n\n**todo:**\n\n- Lee Copland!\n- Основы ISTQB","category":"interview","description":"Теоретическая база по тестированию. Список вопросов"},{"title":"Теоретическая база по автоматизации","path":"/teoreticheskaya-baza-po-avtomatizaczii/","content":"\nhttps://devsday.ru/blog/details/763\n\ntodo \nизучить https://drill4j.github.io/\n\nhttps://ru.education-wiki.com/8998094-automation-testing-interview-questions\n\nhttps://www.toolsqa.com/\nhttps://coderlessons.com/tutorials/kachestvo-programmnogo-obespecheniia/uchebnik-selenium/uchebnik-selenium\n\nhttps://jsehelper.blogspot.com/2016/01/junit.html\n\nhttps://coderlessons.com/tutorials/kachestvo-programmnogo-obespecheniia/ruchnoe-testirovanie/interviu-po-avtomatizatsii-testirovaniia-q-a\n\nhttps://aqa-topics.herokuapp.com/\n\nhttps://sites.google.com/view/aqa-interview\n\nhttps://www.youtube.com/watch?v=fBTQ3v0i9ic\n\nhttps://www.youtube.com/watch?v=d7aq0aXYEss\n\nhttps://www.youtube.com/watch?v=lWhvKId7IYY\n\nhttps://www.youtube.com/watch?v=gm3lcdcNvMs\n\nhttps://www.youtube.com/watch?v=9kaHs4wCKFc\n\nhttps://www.youtube.com/watch?v=uSVI6Hzu2JM\n\nhttps://atesting.ru/kak-obiasnit-intervuery-stryktyry-avtomatizacii-testirovaniia/\n\nhttp://getbug.ru/101-voprosov-po-avtomatizatsii-i-testirovaniyu-vruchnuyu/\n\n## Test NG\n\nhttps://ru.lambdageeks.com/testng-interview-questions-and-answers/\nhttps://xwizard-test.blogspot.com/2017/02/qa-interview-qa-automation-python-linux.html\n\nhttps://habr.com/ru/company/sbermarket/blog/665260/\n\nhttps://www.conventionalcommits.org/ru/v1.0.0/\n\nhttps://telegra.ph/Ne-avtomatizirujte-test-cases-02-21\n\nЯ больше по java.\nНаписать прогу FizzBuzz.\nФункцию для нахождения факториала.\nРеализация любого алгоритма сортировки.\nSelenium: Explicit/Implicit wait, что лучше, когда какой лучше применять, что это вообще такое.\nВиды селекторов , какие быстрее. и т.д.\nJava: В основном вопросы как по учебнику. Бывает иногда что то необычное - как изменяется размер hashmap, как ведет себя ArrayList при добавлении или удалении элементов.\nStream, lambda, default method, опять же довольно стандартно.\nSQL: Joins, Unions, Delete/Truncate, Having, ну может попросят какой то простенький запрос набросать\n\n\nРаспарсить строку - вытащить все инты, раскидать их по двум массивам - в одном четные по возрастанию, в другом нечетные по убыванию\n\nВиды тестирования, разница между Load и Perfomance testing.\nУровни тестирования.\nКак будешь тестировать апп, когда требований нет , аппликейшен готов, и есть неделя до релиза.\nКак поведешь себя в ситуации нескольких проектов одновременно.\nКак будешь разрабатывать automation framework, который можно применять более чем в одном проекте.\nТехники тестирования и их применение.\n\n\nCI tools - Jenkins - тут зависит от вашего опыта. Я больше по созданию джоб и навинчиванию плагинов на уже существующий каркас.\nМетодологии разработки.\nSoftware development life cycle, аналогично для тестирования.\nSeverity/Priority\n\nУмеешь ли писать framework с нуля.\nxpath: contains, text, or/and.\nКак написать общий xtype для элементов разного типа, но с одним class.\nАналогичный вопрос для CSS selectors.\n\nКак смержить два массива - алгоритм и реализация.\nКак из 4-х чисел получить максимальное время в 24-ом формате.\nАлгоритм, как такое тестировать будешь.\nJunit и TestNg - различия, что лучше и почему.\nData providers.\n\n\nava:\n\nТеория:\n\n1)Принципы ООП\n2)Объяснить своими словами каждый принцип.\n3)Модификаторы доступа. Какие знаете? Зачем используются?\n4)Переопределение, перегрузка - что это ? Цели применения?\n5)Наследование и композиция - что это ? Цели применения?\n6)Зачем нужен интерфейс, абстрактный класс, enum?\n7)Паттерны программирования: Singleton (Одиночка), Abstract factory (Абстрактная фабрика), Decorator(Декоратор).\n\nАвтоматизация:\n\n1)Что такое Selenium?\nЗачем нужен webdriver?\nЗачем нужен selenium-server?\n\n2)Что такое Junit? TestNG? Как запускаете тесты?\n3)Maven. Зачем используется?\n4)Jenkins, TeamCity что это? Какой и как использовали?\n5)Использовали ли Selenide, Allure. Что это за библиотеки и зачем используются?\n6)Паттерн PageObject. Объяснить в теории его смысл.\n\n\nОтносительно недавно, вновь прошел через данную полосу препятствий.\nСобеседовался на QA Automation Lead/Senior и SDET.\nПрактически, никто не задавал вопросов по теории тестирования. В основном, фокус на стратегии, и как внедрять процесс автоматизации. Разве, что классический вопрос про, как тестировать, когда время поджимает.\n\nПро классику, типо, что такое селениум, пейджобджект, кукумбер не буду писать.\n\nСобственно вопросы( идут как попало):\n1. Java - все по классике. Но теперь добавились вопросы по stream/optional, анонимные классы, функциональные интерфейсы, лямбда, предикаты.\n2. Задачки : сортировку никто не отменял. Пузырек, quick sort, merge, selection. И их математическая сложность.\nКак написать простенький rest request с какому то урлу и как расспарсить ответ.\nКак реализовать интерфейс итератор. Развернуть строку, как проверить на палиндром, факториал, фиббоначи. Как найти цикл в связном списке.\nКак удалить дубликаты из списка, как проверить что дубликаты удалены.\nРасспросить строку в зависимости от условий.\n\nКак схлопывать массивы.. Например:\nInput: [2,5],[7,8],[4,5]\nOutput: [2,5],[7,8]\n\nМогут попросить реализовать класс с какой то логикой.\n\nЯ заметил, что лично меня стали спрашивать с уклоном в программирование. На последнем собеседовании было много алгоритмов и вопросов по ним.\n\nПару раз попадал на system design interview.\nОдин раз просили задизайнить твиттер, а потом нетфликс. Это дико круто и интересно.. Но без практики это вообще труба.\nТут просто гугл в помощь и миллион вопросов к тем, кто ставит перед вами эту задачу. Вы должны спрашивать, и использовать ответы на ваши вопросы в построении ответов.\n\n3. Jenkins/teamcity - что это, с чем едят, зачем нужно, как использовать.\nЧто есть CI/CD зачем надо, в чем плюсы.\n4. Docker - что это. Зачем?\nВ чем отличие от VM Docker file vs container vs image. Что такое Docker layer.\nКак двум контейнерам увидеть друг друга.\nЧто такое service. Что такое commit.\n5. SOLID -что это, как расшифровывается.\n6. Уделите внимания структурам данных : hash table, list, set, tree, queue.\n7. Git: cherry pick, merge, rebase.\n\nhttp://infobase.athn.ru/program/2017/11/junior-automation-qa-voprosyi-na-sobesedovanii/\n\nhttps://ru.bitdegree.org/rukovodstvo/selenium/\n\nhttps://habr.com/ru/company/otus/blog/350368/\n\nhttps://www.youtube.com/watch?v=C8Z-N0y6Sqo&list=PLMrFx1ncacK7qZFZB9oePwIi_oFPqHHKM&index=6\n\nhttps://www.youtube.com/watch?v=C8Z-N0y6Sqo&list=PLMrFx1ncacK7qZFZB9oePwIi_oFPqHHKM&index=6\n\nhttps://www.youtube.com/watch?v=ZWI7Khx6UpE&t=367s\n\n\nПо Selenium я бы также советовал подготовиться. Примеры вопросов есть тут и тут.\n\nТакже могут спросить про CSS/XPath-локаторы. Я разобрался в них достаточно глубоко, так как понимал, что на такой должности буду пользоваться этой информацией и навыками довольно часто.\n\nнастройка Selenium/Selenoid, какие браузеры использовать, как правильно подбирать CSS локаторы","category":"interview","description":"Теоретическая база по автоматизации"},{"title":"Теоретическая база по программированию","path":"/teoreticheskaya-baza-po-programmirovaniyu/","content":"\n\nТут уже посерьезнее и нужно будет готовить вопросы о типах данных, переменных, циклах, массивах, ООП, исключениях, коллекциях, строках, паттернах проектирования (Singleton/PageObject/PageFactory/Builder и прочее). Ознакомиться с примерными вопросами, в данном случае — Java, можно тут.\n\nС практической точки зрения на самом собеседовании могут попросить написать алгоритм сортировки либо что-то связанное с объектами.\n\nНе всем кандидатам подобного собеседования нравиться, когда их просят написать тестовый код, аргументируя это тем, что в действительности это вовсе не нужно для работы.\n\nКонечно, в этом есть доля правды, но делается это все для того, чтобы узнать с какими фреймворками кандидат может работать, а с какими, банально, не знаком.\n\nЧаще всего, если человек действительно умеет и любит писать код, он запросто справится с тестовым заданием. Особенно если у него имеется опыт работы на специфических задачах (использование циклов, ветвей, работа с массивами и хеш-картами).\n\nОбязательно будет пару вопросов касательно ООП — понятие класса и экземпляра класса, термин инкапсуляции, разновидности модификаторов доступа и другое.\n\nДополнительно могут начать интересоваться вашими познаниями в паттернах программирования. Здесь нужно ориентироваться в PageFactory, Factory, Builder и PageObject. Можно заранее подучить принципы разработки SRP, KISS, SOLID и DRY.\n\n## Java\n\nключевые изменения в java начиная с 9ой версии\n\nСамоучитель\nhttps://metanit.com/java/tutorial/\nhttp://proglang.su/java\nhttps://howtodoinjava.com/java/\n\n## паттерны проектирования\n\n- https://refactoring.guru/ru/design-patterns/catalog\n\nhttps://atesting.ru/top-40-voprosov-i-otvetov-na-sobesedovanii-po-java-v-2021-gody/\n\n\n## GIT\nhttps://atesting.ru/60-voprosov-dlia-sobesedovanii-po-git-kotorye-vam-nyjno-podgotovit-v-2021-gody/\n\nhttps://www.hackerrank.com/\n\nhttps://www.codewars.com/\n\n\nhttps://leetcode.com/  \nhttps://www.codewars.com/","category":"interview","description":"Теоретическая база по программированию"},{"title":"Теоретическая база по TestOps","path":"/teoreticheskaya-baza-po-test-ops/","content":"\n\nВ этом блоке могут поинтересоваться знаниями работы с CI-системой, а именно с чем вы предпочитаете работать. Могут спросить касательно опыта работы с bash: знаете ли вы команды mv, cd, ps, ls.\n\nМогут спрашивать о Docker — понятие образа, как правильно запускать контейнер, как выполнить установку директории host-машины и прочее.\n\nВ конце, вероятнее всего, спросят касательно знаний о системах контроля версий — от принципов работы git до вариантов решения конфликтов при Merge Request.\n\nhttps://habr.com/ru/company/maxilect/blog/548876/\n\n## Системы контроля версий\n- Что такое система контроля версий, цель и виды\n- Основные команды GIT\n- Есть удаленный репозиторий по ссылке http://1.2.6.192/test.git. Какие шаги нужно выполнить для того, чтобы подтянуть этот репозиторий локально? \nТут всё просто. Проверяем умение человека работать с системами контроля версий. Как ни странно, этот вопрос тоже оказался неподъемным для большинства кандидатов. \nКакого ответа я жду: \n1. Проверить, установлен ли git локально(мы же тестировщики, помните?)\n2. Проверить, есть ли у нас права на доступ к этому репозиторию.\n3. Сделать git init/checkout/pull ИЛИ git clone для репозитория, если предыдущие два шага не выявили проблем. \n- Работа с тегами\n- Просмотр коммитов\n- Ветвление в Git и работа с ветками\n- Установка GIT на сервер\n\n\nКак работает Интернет\nhttps://developer.mozilla.org/ru/docs/Learn/Common_questions/How_does_the_Internet_work\nhttps://developer.mozilla.org/ru/docs/Learn/Common_questions/Pages_sites_servers_and_search_engines\nhttps://developer.mozilla.org/ru/docs/Learn/Common_questions/What_is_a_domain_name\nЭта статья о том, что такое Интернет, и как он работает.\n\nНеобходимые знания:\tОтсутствуют, но мы будем признательны, если вы сначала прочтёте Материал о там как начать разрабатывать свой сайт\nЦель:\t\nВы изучите основы технической инфраструктуры Веба и поймёте разницу между Вебом и интернетом. \n\nРезюме\nИнтернет является основой сети (the Web), технической инфраструктурой, благодаря которой и существует Всемирная Паутина. По своей сути, интернет - очень большая сеть компьютеров, которые могут взаимодействовать друг с другом.\n\nИстория интернета не до конца ясна. Проект по созданию интернета был начат в 60-х годах как исследовательский проект при поддержке министерства обороны США, но уже в 80-е годы вырос в сеть, которую поддерживали и развивали множество университетов и частных компаний. Технологии, лежащие в основе интернета, также продолжали развиваться со временем, но основной принцип работы не сильно изменился: Интернет - это способ подключить компьютеры в единую сеть и убедиться, что даже при серьёзных сбоях, они всё равно найдут способ связаться друг с другом.\n\nАктивное изучение\nКак работает интернет за 5 минут: 5-минутный видеоролик поможет вам понять базовые принципы работы интернета (автор Aaron Titus).\nПогружаемся глубже\nПростая сеть\nКогда нужно связать между собой два компьютера, вы должны связать их в сеть либо проводным (обычно с помощью Ethernet кабеля), либо беспроводным способом (например, с помощью WiFi или Bluetooth). Современные компьютеры поддерживают любой из этих способов связи.\n\nПримечание: До конца этой статьи мы будем говорить только о физическом (проводном) способе подключения, но беспроводные сети работают аналогичным образом.\n\nTwo computers linked together\n\nТаким способом вы можете подключить более двух компьютеров, но с каждым новым это становится все сложнее. Если хочется подключить, скажем, 10 компьютеров, вам понадобится 45 кабелей и 9 сетевых плат в каждом компьютере!\n\nTen computers all together\n\nЧтобы решить эту проблему, каждый компьютер в сети подключается к специальному маленькому компьютеру. Этот компьютер называют маршрутизатором. Маршрутизатор исполняет только одну роль: как сигнальщик на железной дороге он следит за тем, чтобы пакет, отправленный одним компьютером — источником — достиг пункта назначения. Чтобы отправить сообщение компьютеру B, компьютер A сначала должен отправить его маршрутизатору, который перенаправит его компьютеру B и проконтролирует, чтобы данные не попали компьютеру C.\n\nС добавлением маршрутизатора наша сеть здорово упрощается: чтобы соединить 10 компьютеров нам требуется только 10 кабелей (каждый кабель соединяет маршрутизатор с одним из компьютеров).\n\nTen computers with a router\n\nСеть сетей\nПока все нормально. Но что нам делать, если нужно объединить в сеть сотни, тысячи или миллиарды компьютеров? Конечно, один маршрутизатор не справится с этой задачей, но если вы внимательно читали, то помните, что маршрутизатор — это обычный компьютер, и ничто не мешает нам соединить друг с другом 2 маршрутизатора. Давайте сделаем это.\n\nTwo routers linked together\n\nПодключая компьютеры к маршрутизатору, а затем — маршрутизатор к другому маршрутизатору, мы можем увеличивать нашу сеть до сколь угодно больших размеров.\n\nRouters linked to routers\n\nТакая сеть уже очень похожа на то, что мы называем интернетом, но мы что-то упустили. Наша сеть построена для решения только наших задач. Но кроме неё есть и другие сети: наши друзья, соседи — кто угодно может создать свою сеть. Как же нам их объединить? Мы не можем протянуть кабели между нашим домом и всеми остальными сетями в мире. Чтобы решить эту проблему, мы можем воспользоваться уже существующими кабельными сетями. Ведь у нас дома уже есть кабели, например, электрические или телефонные. Телефонный провод уже соединяет ваш дом со всем остальным миром, так что он идеально подходит для решения нашей задачи. Чтобы подключить нашу сеть к глобальной сети с помощью телефонного провода, нам понадобится специальное оборудование, которое называется модем. Модем перекодирует информацию, поступающую из нашей сети в формат, который можно передавать через телефонную сеть, и наоборот, декодируют информацию из телефонной сети в формат, который распознают наши компьютеры.\n\nA router linked to a modem\n\nИтак, мы подключились к телефонной сети. Следующий шаг — передать сообщение из нашей сети в сеть, с которой мы хотим связаться. Чтобы сделать это, мы должны подключить нашу сеть к провайдеру услуг интернета (Internet Service Provider (ISP)). Провайдер — компания, которая обслуживает специальные маршрутизаторы, которые не только подключены друг к другу (объединяют в единую сеть всех клиентов провайдера), но также связаны с маршрутизаторами других провайдеров. Таким образом, наше сообщение, пройдя транзитом через сеть нескольких провайдеров, достигнет сеть назначения. Интернет — это сеть сетей, которая объединяет в себе всю вышеперечисленную инфраструктуру.\n\nFull Internet stack\n\nПоиск компьютера\nЧтобы послать сообщение какому-то компьютеру, необходимо как-то обратиться к нему, выделить среди других. Поэтому каждый компьютер, подключённый к сети, имеет свой уникальный адрес для связи: этот адрес называют IP-адресом (IP — сокращение для Internet Protocol, протокол интернета). В зависимости от версии протокола IP этот адрес может записываться по-разному. Самая широко используемая версия интернет-протокола — версия 4. Адреса IPv4 обычно записываются в виде четырёх чисел, разделённых точками, например: 192.168.2.10.\n\nТакие адреса отлично подходят для компьютеров, но людям очень сложно их запоминать. Чтобы упростить себе жизнь, мы можем присвоить каждому IP-адресу псевдоним с понятным для человека именем. Такой псевдоним называют доменным именем. Например, google.com — доменное имя, которое является псевдонимом IP-адреса 173.194.121.32. Использование доменного имени — самый простой способ обратиться к компьютеру в интернете.\n\nShow how a domain name can alias an IP address\n\nИнтернет и веб\nКак вы уже заметили, когда мы просматриваем Веб с помощью браузера, обычно мы используем доменное имя, чтобы обратиться к веб-сайту. Означает ли это, что Интернет и Веб — это одно и то же? Ответ не так прост. Мы уже знаем, что Интернет — это техническая основа, которая позволяет миллиардам компьютеров связываться друг с другом. Среди этих компьютеров есть небольшая группа (называемая веб-серверами), которые могут отправлять сообщения, распознаваемые браузерами. Интернет —  это инфраструктура, а Веб — это сервис, построенный на основе этой инфраструктуры. Стоит отметить, что кроме Веба есть и другие сервисы, построенные на базе Интернета. Например, электронная почта или IRC (en-US).","category":"interview","description":"Теоретическая база по TestOps"},{"title":"WEB тестирование. Список вопросов","path":"/web-testirovanie-spisok-voprosov/","content":"\n\n\n\nКак работает Веб\nНазад\nОбзор: Getting started with the web\nКак работает Веб даст упрощённое представление о том, что происходит при просмотре веб-страницы в браузере на вашем компьютере или телефоне.\n\nЭта теория не так важна для написания веб-кода в краткосрочной перспективе, но в скором времени вы действительно начнёте извлекать выгоду из понимания того, что происходит в фоновом режиме.\n\nКлиенты и серверы\nКомпьютеры, подключённые к сети называются клиентами и серверами. Упрощённая схема того, как они взаимодействуют, может выглядеть следующим образом:\n\n\n\nКлиенты являются обычными пользователями, подключёнными к Интернету посредством устройств (например, компьютер подключён к Wi-Fi, или ваш телефон подключён к мобильной сети) и программного обеспечения, доступного на этих устройствах (как правило, браузер, например, Firefox или Chrome).\nСерверы - это компьютеры, которые хранят веб-страницы, сайты или приложения. Когда клиентское устройство пытается получить доступ к веб-странице, копия страницы загружается с сервера на клиентский компьютер для отображения в браузере пользователя.\nОстальные части панели инструментов\nКлиент и сервер, о которых мы рассказали выше, не раскрывают всю суть. Есть много других компонентов, и мы опишем их ниже.\n\nА сейчас давайте представим, что Веб - это дорога. Одна сторона дороги является клиентом, который представляет собой ваш дом. Другая сторона дороги является сервером, который представляет собой магазин. Вы хотите что-то купить в нём.\n\n\n\nПомимо клиента и сервера, мы также должны уделить внимание:\n\nВаше Интернет-подключение: Позволяет отправлять и принимать данные по сети. Оно подобно улице между домом и магазином.\nTCP/IP: Протокол Управления Передачей и Интернет Протокол являются коммуникационными протоколами, которые определяют, каким образом данные должны передаваться по сети. Они как транспортные средства, которые позволяют сделать заказ, пойти в магазин и купить ваши товары. В нашем примере, это как автомобиль или велосипед (или собственные ноги).\nDNS: Система Доменных Имён напоминает записную книжку для веб-сайтов. Когда вы вводите веб-адрес в своём браузере, браузер обращается к DNS, чтобы найти реальный адрес веб-сайта, прежде чем он сможет его получить. Браузеру необходимо выяснить, на каком сервере живёт сайт, поэтому он может отправлять HTTP-сообщения в нужное место (см. Ниже). Это похоже на поиск адреса магазина, чтобы вы могли попасть в него.\nHTTP: Протокол Передачи Гипертекста - это протокол, который определяет язык для клиентов и серверов, чтобы общаться друг с другом. Он, как язык, который вы используете, чтобы заказать ваш товар.\nФайлы компонентов: сайт состоит из нескольких различных файлов, которые подобны различным отделам с товарами в магазине. Эти файлы бывают двух основных типов:\nФайлы кода: сайты построены преимущественно на HTML, CSS и JavaScript, хотя вы познакомитесь с другими технологиями чуть позже.\nМатериалы: это собирательное название для всех других вещей, составляющих сайт, такие как изображения, музыка, видео, документы Word и PDF.\nЧто же на самом деле происходит?\nКогда вы вводите веб-адрес в свой браузер (для нашей аналогии - посещаете магазин):\n\nБраузер обращается к DNS серверу и находит реальный адрес сервера, на котором \"живёт\" сайт (Вы находите адрес магазина).\nБраузер посылает HTTP запрос к серверу, запрашивая его отправить копию сайта для клиента (Вы идёте в магазин и заказываете товар). Это сообщение и все остальные данные, передаваемые между клиентом и сервером, передаются по интернет-соединению с использованием протокола TCP/IP.\nЕсли сервер одобряет запрос клиента, сервер отправляет клиенту статус \"200 ОК\", который означает: \"Конечно, вы можете посмотреть на этот сайт! Вот он\", а затем начинает отправку файлов сайта в браузер в виде небольших порций, называемых пакетными данными (магазин выдаёт вам ваш товар или вам привозят его домой).\nБраузер собирает маленькие куски в полноценный сайт и показывает его вам (товар прибывает к вашей двери — новые вещи, потрясающе!).\nDNS\nРеальные веб-адреса - неудобные, незапоминающиеся строки, которые вы вводите в адресную строку, чтобы найти ваши любимые веб-сайты. Эти строки состоят из чисел, например: 63.245.215.20.\n\nТакой набор чисел называется IP-адресом и представляет собой уникальное местоположение в Интернете. Впрочем, его не очень легко запомнить, правда? Вот почему изобрели DNS. Это специальные сервера, которые связывают веб-адрес, который вы вводите в браузере (например, \"mozilla.org\"), с реальным IP-адресом сайта.\n\nСайты можно найти непосредственно через их IP-адреса. Вы можете найти IP-адрес веб-сайта, введя его домен в инструмент, как IP Checker.\n\nПакеты\nРанее мы использовали термин \"пакеты\", чтобы описать формат, в котором данные передаются от сервера к клиенту. Что мы имеем в виду? В основном, когда данные передаются через Интернет, они отправляются в виде тысячи мелких кусочков, так что множество разных пользователей могут скачивать один и тот же сайт одновременно. Если бы сайты отправлялись одним большим куском, тогда бы только один пользователь мог скачать его за один раз, и это, очевидно, сделало бы пользование интернетом не эффективным и не очень радостным.\n\n\n\n- Веб формы и веб сервера\n## UI/UX и Pixel Perfect\n\n\n- Тестирование верстки, JS ошибок\n- Тестирование мобильной верстки\n- Тестирование функциональной безопасности SSL\n- Работа с Dev Tool\n- Подходы к тестированию веб приложений\n- Тестирование кросбраузерности, масштабируемости\n- Тестирование кодировок\n- Тестирование локализации, интернационализации\n- Конфигурационное тестирование\n- Работа с Cookie\n\n\n## особенности веб-тестирования\nhttps://www.softwaretestinghelp.com/web-application-testing/\n\n\nhttps://www.youtube.com/watch?v=-AqjiEfSrDE\n\nhttps://www.youtube.com/watch?v=WMjrSyUiXNA\n\nhttps://www.youtube.com/watch?v=7moC23y6G1Q","category":"interview","description":"WEB тестирование. Список вопросов"},{"title":"API тестирование","path":"/api-testirovanie/","content":"\n## Общая теория\n\n- https://www.guru99.com/api-testing.html\n\n## Postman\n\n- https://www.guru99.com/postman-tutorial.html\n\n## Что такое JSON\n\n- https://habr.com/ru/post/554274/\n- https://qaautomation.expert/2021/06/25/how-to-send-a-json-xml-file-as-payload-to-request-using-rest-assured/\n\nhttps://ruseller.com/lessons.php?rub=28&id=1212\n\nhttps://habr.com/ru/post/31225/\n\nhttps://www.youtube.com/watch?v=QYg5z6EGOk4\n\n\n## Тестирование API\n\n- Понимание клиент-серверной архитектуры, толстый тонкий клиенты\n- Взаиодействие сервера клиента и БД\n- REST vs SOAP\n- JSON vs XML vs WSDL\n- Response codes: 418, 403, 502, 302, 204\n- HTTP/HTTPS структура и методы\n- Аутентификация и авторизация\n- Mock servers\n- Написание тестов, assertions, запуск коллекций\n- Уровни переменных и работа с ними\n- Токены, pre-request scripts, debugging API\n- Monitoring and reports\n- Работа со Swagger\n- Описение Rest запросов (Open API)\n* Что такое Open API\n* Типы авторизации (basic auth, oAuth, jwt что-то типо того)\n* GET vs POST, POST vs PUT + идемпотентность\n* http 1.1 vs http 2\n* CSRF token\n\n\n\n## API\nhttps://atesting.ru/voprosy-na-sobesedovanii-po-testirovaniu-api/","category":"interview","description":"Ресурсы для изучения, вопросы на собеседованиях, общая теория"},{"title":"Тестирование Mobile","path":"/testirovanie-mobile/","content":"\n\n## Тестирование Mobile\n\n- Особенности тестирования мобильных приложений\n- Требования AppStore и PlayMarket к релизу\n- Классификация мобильных устройств и расширений\n- Виды мобильных приложений\n- Уровни тестирования mobile\n- Виды тестирования mobile\n- Симуляторы и эмуляторы\n- Составление юзабилити тестов\n- Тестирование утечки памяти\n- Тестирование жнергопотребления\n- Тестирование прерываний и человеческого фактора\n- Эвристики и мнемоники\n- Типичные баги\n- Тестирование игр на мобильных устройствах\n\nПод мобильное тестирование придется вооружиться знаниями работы драйверов Espresso, XCUITest, либо же иметь представление о работе с Appium.\n\nДополнительно плюсом будут навыки конфигурации фермы устройств и установка нужных эмуляторов, а также симуляторов.\n\n## особенности мобильного тестирования\n\nhttps://www.softwaretestinghelp.com/beginners-guide-to-mobile-application-testing/\nhttps://testlio.com/blog/10-mobile-testing-types-and-approaches/","category":"interview","description":"Основные темы и ссылки на статьи с объяснениями"},{"title":"SQL","path":"/sql/","content":"\n## Задачи\n\n- http://www.sql-tutorial.ru/\n\n- https://www.sql-ex.ru/\n\nhttps://sqlzoo.net/wiki/SQL_Tutorial\n\n## Обучающие курсы\n\n- https://www.freecodecamp.org/news/sql-and-databases-full-course/  \nhttps://www.youtube.com/watch?v=HXV3zeQKqGY\n\n- https://stepik.org/course/51562/promo\n\n## Статья со списком книг\n\n- https://progerlib.ru/sql-books\n\n## Статьи по теме\n\n- https://artoftesting.com/sql-for-testers\n","category":"interview","description":"Ресурсы для изучения, вопросы по SQL на собеседованиях, общая теория"},{"title":"Требования на вакансии QA Automation Engineer","path":"/trebovaniya-na-vakansii-qa-automation-engineer/","content":"\n\n## QA\n- Основы тест-дизайна\n- Жизненный цикл ПО и ПАК\n- методики тестирования\n\n- Теория тестирования UI: web, mobile\n- Теория тестирования API: RESTful (типы запросов, JSON over REST, Websocket), SOAP\n- Понимание работы клиент-серверных приложений\n- Работа с XML, JSON\n- Создание и выполнения тестовых планов и тестовых сценариев\n- Знание Unix/Linux операционных систем и команд пользователя\n- базовые навыки по работе с компьютерными сетями (TCP/IP)\n- Agile-практики (Scrum, Kanban)\n- Понимание принципов работы реляционных СУБД, знание транзакций БД, Опыт работы с БД на уровне написания простых запросов\n- Инструменты Web Debugging (fiddler, Wireshark, burp)\n\n## Программирование\n- Уверенное знание Python\n- Уверенное знание Java\n- Уверенное знание Kotlin\n- Знание bash\n- паттерны проектирования\n- code-review\n- объектно-ориентированное проектирование\n\n## Библиотеки для автотестирования\n- PyTest(request???)/TestNG/JUnit\n- Selenium\n- Maven/Gradle\n- Selenide\n- Allure\n- Системы контроля версий: Git\n- CI/CD (Jenkins(написание pipelin'ов), TeamCity, Gitlab CI, Bitbucket Pipelines)\n- Gitlab\n- Cucumber\n- Appium\n- Postman, SoapUI, Charles proxy, Fiddler, консоль разработчика Chrome\n- Jira, Confluence\n- RestAssured\n- системами управления тестированием: TestRail\n- Kibana и Jaeger\n- DevOps: Selenoid, Selenium Grid, Docker приложения\n- Систем логирования: Splunk, Graylog, Kibana\n- SQL и БД (PostgreSQL)\n- Swift, XCUITest\n\n## Остальное\n- Нагрузочное тестирование\n- Ansible и Terraform ????\n- опыт работы в рамках MSA, SOA\n- владение инструментами для получения и анализа log'ов\n- опыт работы с DB и message broker;\n\nПроекты автоматизации ui web, ui mobile, api","category":"interview","description":"Требования на вакансии QA Automation Engineer"},{"title":"Сайты для практики","path":"/sajty-dlya-praktiki/","content":"\n##  Потестить отдельные элементы\n\n- https://demoqa.com/auto-complete\n- https://demosite.executeautomation.com/index.html#\n- https://demoqa.com/\n- http://the-internet.herokuapp.com/\n- http://uitestingplayground.com/\n- https://www.w3schools.com/howto/\n- https://www.way2automation.com/demo.html\nеще один сайт с примерами разных элементов страницы для отработки взаимодействий в автотестах\n\n## Для тестирования API\n\n- https://jsonplaceholder.typicode.com/\n- https://reqres.in/\n- http://httpbin.org/\n\n- https://developer.marvel.com/docs\n- https://petstore.swagger.io/\n- https://ergast.com/mrd/\n- http://restful-booker.herokuapp.com/  \nhttp://restful-booker.herokuapp.com/apidoc/index.html\n- https://thinkingtester.com/new-api-and-ui-test-app/  \nhttps://thinking-tester-contact-list.herokuapp.com/\n\n## Для тестирования UI\n\n- https://www.zalando.co.uk/cart/\n\n- http://computer-database.gatling.io/computers\n\n- https://demo.guru99.com/\n\n- http://demowebshop.tricentis.com/\n\n- https://phptravels.com/demo\n\n- https://www.zazzle.com/\n\n- https://www.saucedemo.com/\n\n- https://www.globalsqa.com/website-automation-practice/\nhttps://www.globalsqa.com/demo-site/\n\n- http://automationpractice.com/index.php  \nпример интернет-магазина\n\n- https://blazedemo.com/index.php\n\n- https://phptravels.com/demo/  \nпример CRM системы, но формы логина не работают :(\n\n- https://github.com/TheJambo/ToDoInterviewTest\nhttp://todolist.james.am/#/\n\n- https://loginii.com/orangehrm-page  \nhttps://www.orangehrm.com/ - оригинал  \nhttps://www.softwaretestinghelp.com/free-online-software-testing-qa-training-course/ - тренинг по этому сайту;\nмного ссылок на web приложение, но тоже как то авторизация не отрабатывает\n\n- http://thelab.boozang.com/sortedList\n\n- https://www.opencart.com/\n\n- https://www.demoblaze.com/\n\n- https://www.globalsqa.com/angularJs-protractor/BankingProject/#/login\n\n- https://computer-database.gatling.io/computers\n- https://candymapper.com/\n\n- https://demowebsch.web-school.in/index.php/user/login  \nhttps://web-school.in/try-demo/  \nhttps://www.schoolerp.org/  \n\n- https://opensource-demo.orangehrmlive.com/  \nUsername : Admin | Password : admin123 )\n\n## Для тестирования мобильных приложений \n\n- https://github.com/fossasia/susi_android\n\n## Просто ресурсы\n\n- https://randomuser.me/changelog\nгенерация пользовательских данных\n\n- https://abstracta.us/blog/software-testing/best-demo-websites-for-practicing-different-types-of-software-tests/\n\n- https://www.blazemeter.com/blog/getting-started-jmeter-basic-tutorial\n\n- http://timvroom.com/selenium/playground/\n\n- https://www.softwaretestinghelp.com/sample-test-cases-testing-web-desktop-applications/\n\n\n- https://parabank.parasoft.com/parabank/index.htm\n\n- https://automationpanda.com/2021/12/29/want-to-practice-test-automation-try-these-demo-sites/\n\n- https://vc.ru/dev/199012-bystryy-start-gayd-po-avtomatizirovannomu-testirovaniyu-dlya-android-razrabotchika-jvm","category":"interview","description":"Сайты для практики"},{"title":"Пример резюме","path":"/primer-rezyume/","content":"\nhttps://les-company.ru/sobesedovaniye-dlya-qa-rezyume-voprosy-na-interv-yu-peregovory-o-zarplate-poleznyye-ssylki/\n\nДиаграммы Исикавы!!!!\n\nhttps://www.englishdom.com/blog/kak-sostavit-rezyume-testirovshhika-na-anglijskom/\n\n\nhttps://zen.yandex.ru/media/qadecret/sobesedovanie-na-poziciiu-qaspecialistatestirovscika-kak-vybrat-luchshuiu-kompaniiu-5f117cbc1015531af6e4aad8\n\nAutomation QA Engineer\nАктивно интересуюсь сферой информационных технологий. Много времени посвящаю самообразованию — занимался под руководством ментора, прохожу курсы повышения квалификации.\nЧлен Санкт-Петербургского сообщества тестировщиков. Организовал и был спикером на внутреннем QA митапе First Line Software.\n\nTest Design, Manual Testing, Автоматизация тестирования, Unit Testing, Selenium, Allure, Java, RabbitMQ, Ruby, RoR, SQL, PL/SQL, Docker, Redis\n\nУчаствовал во внутреннем хакатоне First Line Software\n\nРабота\nАвтоматизация тестирования бекенда на Oracle.\nСоздание стендов.\nUnit testing.\nСоздание инструментов тестирования.\nПоддержка тестов на Robot Framework и Java.\n\nAutomation QA Engineer\n— Настройка CI(TeamCity) для запуска тестов.\n— Код-ревью.\n— Поддержка существующего фреймворка.\n— Поддержка и развитие тестовой инфраструктуры.\n— Написание тестов на Java + Selenium(JDI) + Maven + TestNG.\n— Взаимодействие с заказчиком и разработчиками для определения наиболее приоритетной функциональности.\n\nПроект:\nПлатформа, предоставляеющая сервисы, автоматизирующие процессы создания и заказа типовой маркетинговой продукции: брошюр, буклетов, рекламной почтовой корреспонденции, а также аналогичных материалов в электронном формате, включая создание лендинговых страниц(B2B, B2C).\n\nОбщепроектная деятельность:\n— Постановка задач на улучшение и доработку приложения (UI,UX, функциональные доработки).\n— Анализ бизнес модели и выработка решений по её улучшению.\n— Взаимодействие с командой разработчиков\n\nТест Дизайн и ручное тестирование:\n— Составление плана тестирования продукта;\n— Функциональное, UI, usability тестирование;\n— Тестирование приложений на платформах iOS, Android;\n— Выявление, описание и контроль устранения дефектов;\n— Срочное тестирование без документации;\n— Тестирование требований;\n— Тестирование в условиях часто меняющихся требований;\n\nАвтоматизированное тестирование:\n— Написание автотестов для тестирования приложения\n(связка Cucumber + Capybara(Selenium) + SitePrism)\n— Написание генератора тестовых данных\n\nРабота с программами и фреймворками:\n— Selenium\n— Cucumber\n— Jira, Trello\n— Test Rail\n\nПроекты:\n— https://ondoc.me\nМедицинская Информационая Система предоставляющая:\n— клиникам: дополнительные возможности возврата пациентов\n— врачам: возможность оказания телемедицинских услуг,\n— пациентам: возможность получить телемедицинские услуги, записаться на очный прием/обследование, получить мед. данные в удобном виде, не пропустить прием лекарств.\nСервисы представлены в WEB, iOS, Android.\n— Кастомные приложения для VIP клиентов.\n\nОбщепроектная деятельность:\n— Участие в составлении пользовательских инструкций\n— Анализ бизнес модели клиента и выработка решений по её улучшению.\n— Взаимодействие с командой разработчиков, руководителей проектов и т.д.\n— Менторство над junior qa.\n\nТест Дизайн и ручное тестирование:\n— Проработка и написание тестовой документации (чек-листы, тестовые сценарии)\n— Функциональное, UI, usability тестирование\n— Кроссбраузерное тестирование\n— Выявление, описание и контроль устранения дефектов\n— Срочное тестирование без документации\n— Определение наиболее приоритетной функциональности для регрессионного тестирования\n\nРабота с программами и фреймворками:\n— Selenium (Webdriver)\n— RSpec\n— Redmine, Jira\n— Test Rail","category":"interview","description":"Основные темы и ссылки на статьи с объяснениями"},{"title":"Selenide","path":"/selenide/","content":"\n## Настройка таймаута\n\nВыполняется через System.setProperty();\n\n```java\nmvn -Dselenide.timeout=8000\n```\n\n## Коллекции\n\n$ - возвращает первый элемент\n$$ - возвращает список\n\n```java\n$$(\".error\").shouldHave(size(3));\n```\n\n```java\n$$(\"#employees tbody tr\").shouldHave(\n  tests(\n    \"John Belushi\",\n    \"Bruce Willis\",\n    \"John Malkovich\"\n  )\n);\n```\n\n## Коллекции: фильтрации\n```java\n$$(\"#employees tbody tr\")\n  .filter(visible)\n  .shouldHave(size(4));\n```\n\n## Поиск элементов\n\n```java\n$(\"#loginBtn\") = $(By.id(\"loginBtn\"));\n$(\".active\") = $(By.className(\"active\"));\n$(\"[name=username]\") = $(By.name(\"username\"));\n$x(\"//div//h1\") = $(By.xpath(\"//div//h1\"));\n```\n\n### Поиск по атрибутам\n```java\n$(by(\"type\", \"checkbox\"));\n$(by(\"readonly\", \"readonly\"));\n$(byTitle(\"Login form\"));\n$(byValue(\"Alert button\"));\n$(by(\"data-test-id\", \"alert-button\"));\n\n$(byText(\"Hello\"));\n$(withText(\"ello\"));\n```\n\n## Открываем браузер\n\n```java\nopen(\"url\");\n```\n\n## Ввести значение в поле\n\n```java\n$(By.name(\"user.name\")).setValue(\"john\");\n```\n\n## Кликнуть мышью один раз\n\n```java\n$(\"#submit\").click();\n```\n\n## Выполнить проверку по тексту элемента\n\n```java\n$(\".menu\").shouldHave(text(\"Hello, John!\"));\n```\n\n## Page Object\n\n```java\npublic class GooglePage {\n  public void search(String queue){\n    $(By.name(\"q\"))\n        .val(queue)\n        .pressEnter();\n  }\n}\n\nМожно вынести локатор в поле класса:\n\n```java\npublic class GooglePage {\n  private By query = By.name(\"q\");\n\n  public void search(String queue){\n    $(query)\n        .val(queue)\n        .pressEnter();\n  }\n}\n```\n\n```java\n@Test{\n  var page = new GooglePage();\n}\n```\n\nМожно вынести в поле весь элемент, но тогда нужно инициализировать класс страницы через специальный Factory метод.\n\n```java\npublic class GooglePage {\n  private SelenideElement query = $(By.name(\"q\"));\n\n  public void search(String queue){\n    query\n        .val(queue)\n        .pressEnter();\n  }\n}\n```\n\n```java\n@Test{\n  var page = page(GooglePage.class);\n}\n```\n\n## Аналог Yandex HtmlElements\n\n```java\npublic class HtmlElementsPage {\n  SelenideElement container = $(\"...\");\n  SelenideElement username = container.$(\"...\");\n  SelenideElement password = container.$(\"...\");\n\n  public void login(String un, String pwd){\n    username.val(un);\n    password.val(pwd);\n  }\n}\n```\nИли другой вариант:\n\n```java\npublic class HtmlElementsPage {\n  @FindBy(id=\"status\")\n  StatusBlock status;\n}\nclass StatusBlock extends ElementsContainer {\n  @FindBy(className=\"username\")\n  SelenideElement username;\n\n  @FindBy(className = \"password\")\n  SelenideElement password;\n}\n```\n\n## Навигация по DOM'у\n\n```java\n$.parent()\n$.closest(\"table\")\n```\n\n```java\n$(\"table td[data-foo='bar']\")\n.closest(\"table\")\n.find(\"tr\", 4)\n.find(byText(\"text\"));\n```\n\n## Задать тип браузера для запуска\n\n```java\njava -Dselenide.browser=chrome\njava -Dselenide.browser=firefox\njava -Dselenide.browser=ie\njava -Dselenide.browser=cy.test.MyWebDriver\n```\n\nЭти параметры удобно использовать когда в gradle.build мы создаем разные tasks или в pom.xml создаем разные profile\n\n```groovy\ntask chrome(type: Test){\n  systemProperties['selenide.browser'] = 'chrome'\n}\n\ntask firefox(type: Test){\n  systemProperties['selenide.browser'] = 'firefox'\n}\n```\n\n**Jenkins**\nJob 1: ./gradlew chrome  \nJob 2: ./gradlew firefox\n\nили можно задать браузер прямо в коде\n\n```java\n@Before\npublic void setUp(){\n  Configuration.browser = \"chrome\";\n  // or Configuration.browser = \"firefox\";\n  // or Configuration.browser = \"cy.MyWebDriver\";\n}\n```\n\n## Задать свой WebDriver (со своими настройками)\n\n- setWebDriver (не рекомендуется)  \nПри использовании этого способа, нужно самому закрывать драйвер.\n\n```java\n@Before\npublic void setUp(){\n  this.browser = new ChromeDriver(........);\n  WebDriverRunner.setWebDriver(browser);\n}\n```\n\n- WebDriverProvider  \nНужно только открыть закрывать и другие действия Selenide делает сам.\n\n```java\n@Before\npublic void setUp(){\n  Configuration.browser = MyWDProvider.class.getName();\n  open(\"https://google.com\");\n}\n\nstatic class MyWDProvider implements WebDriverProvider{\n  @Override\n  public WebDriver createDriver(DesiredCapabilities capabilities){\n    ChromeOptions options = new ChromeOptions();\n    options.setHeadless(true);\n    options.setArguments(\"--proxy-bypass-list=<-loopback>\");\n    options.merge(desiredCapabilities);\n    return new ChromeDriver(options);\n  }\n}\n```\n\n## Два браузера в одном тесте\n\n```java\nvar b1 = new SelenideDriver();\nb1.open(\"http://some.site.com\");\nb1.$(\"#username\").val(\"petja\").pressEnter();\nb1.$(\"#name\").shouldHave(text(\"Hello, Petja!\"));\n\nvar b2 = new SelenideDriver();\nb2.open(\"http://some.site.com/admin\");\nb2.$(\".block[data-username='petja']\").click();\n\nb1.$(\"#name\").shouldHave(text(\"Goodbye, Petja!\"));\n```\n\nПри вызове браузеров можно также передавать разные настройки:\n\n```java\nvar b1 = new SelenideDriver(\n  new SelenideConfig()\n  .timeout(6000)\n  .browser(\"chrome\")\n  .headless(true)\n);\n\nvar b2 = new SelenideDriver(\n  new SelenideConfig()\n  .timeout(90_000)\n  .browser(\"firefox\")\n  .proxyEnabled(true)\n);\n```\n\n## Прокси\n\n### Загрузка файлов\n\nЕсть два варианта: \n- Configuration.fileDownload = HTTPGET;  \nЕсли файл загружается по ссылке. Включен по умолчанию.\n\n```java\n@Test \npublic void userCanViewTerminalDetailsAsPDF() throws FileNotFoundException { \n  File detailsAsPdf = $(\"#print-pdf\").download(); \n  PDF pdf = new PDF(pdfFile); \n  assertThat(pdf, containsText(\"PP028004\")); \n  assertThat(pdf, containsText(\"Торговый терминал\")); \n  assertThat(pdf, containsTextCaseInsensitive(\"VeriFone VX 810\")); \n} \n```\n\n> Проверить pdf и xls можно с помощью:  \n> - github.com/codeborne/pdf-test  \n> - github.com/codeborne/xls-test\n\n- Configuration.fileDownload = PROXY;\nКогда по клику по элементу начинается загрузка файла.\nSelenide запускает свой прокси-сервер и перехватывает запросы/ответы.\n\nОн умеет: \n- Скачивать файлы \n- Подменять заголовки \n- Инжектить JS код на страницу \n- И т.д. и т.п.\n\nПо умолчанию он отключен так как если тесты запускаются на машине A а браузер на машине B и с машины B не видна машина A, то могут быть проблемы.\n\n```java\n@Before \npublic void setUp() { \n  Configuration.proxyEnabled = true; \n  open(\"https://google.com\"); \n}\n\n@Test \nvoid canAddInterceptorsToProxyServer() { \n  SelenideProxyServer proxy = getSelenideProxy(); \n\n  proxy.addRequestFilter(\"proxy-usages.request\", (request, \n  contents, messageInfo) -> { \n    String url = messageInfo.getUrl(); \n    log(url + \"nn\" + contents.getTextContents()); \n    return null; \n    });\n}\n```\n\n## Параллелизация\n\nПроблемы которые могут возникать:\n- Статические переменные \n- Одновременный доступ к данным \n- синхронизация \n- И т.д.\n\nЛучше запускать тесты в N процессов(forks).\n\n### Maven\n\npom.xml: \n\n```xml\n<plugin> \n  <groupId>org.apache.maven.plugins</groupId> \n  <artifactId>maven-surefire-plugin</artifactId> \n  <configuration> \n    <forkCount>3</forkCount> \n    <reuseForks>true</reuseForks> \n  </configuration> \n</plugin> \n```\n\n### Gradle\n\n```groovy\ntest {\n  maxParallelForks = 5\n}\n```\n\n## Трюки с JavaScript\n\n### Выбрать дату\n\n```java\nvoid setDateByName(String name, String date) { \n  executeJavaScript(\n    String.format(\"$('[name=\\\"%s\\\"]').val('%s')\", \n    name, date)); \n} \n\n@Test { \n  setDateByName(\"recurrent.startDate\", \"16.01.2009\"); \n}\n```\n\n### Выбрать опцию в bootstrap select\n\n```java\nvoid selectBS(WebElement select, String value) { \n  executeJavaScript( \n    \"$(arguments[0]).val(arguments[1]).trigger('change')\", \n    select, value); \n} \n\n@Test { \n  selectBS($(By.name(\"operationCode\")), \"11100\"); \n}\n```\n\n### Слайдер\n\n```java\nvoid setMaxYearlyFee(int value) { \n  executeJavaScript( \n    \"$('#sld').data('slider').value[0] = arguments[0];\" + \n    \"$('#sld').triggerHandler('slide');\" \n    ); \n} \n\n@Test { \n  setMaxYearlyFee(100); \n}\n```\n\n### Отключить Confirm окно\n\n```java\npublic static void mockConfirm() { \n  executeJavaScript( \n    \"window.confirm = function() {return true;};\" \n  ); \n}\n```\n\n### Контакты в мобильном \n\nЭмуляция функции.\n\n```java\nprivate void mockCordovaContactsAPI(String number) { \n  executeJavaScript( \n    \"window.plugins = {\" + \n    \" contactNumberPicker: { \" + \n    \" pick: function(callback) {\" + \n    \" callback({\" + \n    \" phoneNumber:\\\"\" + number + \"\\\"\"\"\n    });}}}\"); \n} \n    \n@Test { \n  mockCordovaContactsAPI(\"+79110080075\"); \n}\n```\n\n### Кол-во видимых элементов \n\nСелениум не умеет искать по jquery локатору.\n\n```java\n@Test { \n  $$(\".offer:visible\").shouldHave(size(3)); \n} \n@Test {\n  $$(\".offer\").filter(visible) .shouldHave(size(3)); \n} // это может быть медленно если на странице много элементов\n```\n\nЧерез JavaScript в разы быстрее:\n\n```java\nint sizeOf(String cssSelector) { \n  Number count = executeJavaScript( \n    \"return $(arguments[0]).length\", cssSelector); \n    return count.intValue(); \n} \n@Test { \n  assertEquals(1, sizeOf(\".offer:visible\")); \n}\n```\n\n### Из списка элементов исключить другой список \n\nЗадача: найти страны из excel и страны на странице и найти те которые есть на странице но нет в excel.\n\n```java\nList<String> страныИзЭксельки = ...; \nList<String> страныСоСтраницы = $$(“td:nth-child(3)”) \n  .excludeWith(text(“text”)) \n  .stream() \n  .map(el -> el.getText()) \n  .collect(toList()); // Это м.б. медленно :(\n```\n\n```java\nList<String> страныИзЭксельки = ...; \nList<String> страныСоСтраницы = executeJavascript( \n  \"return Array.from(\" + \n  \" document.querySelectorAll('td:nth-child(3)')\" \n  + \").map(x => x.textContent)\"\n); // А вот это быстро\n```\n\n### fast set value\n\nПроблема: \n\n1. $.sendKeys() медленный \n2. Иногда $.sendKeys() не работает:  \n  a. Элемент невидимый   \n  b. Маска на поле  \n  c. Какой-нибудь хитрый JS  \n  d. Какой-нибудь компонент типа DatePicker \n  \nНа помощь приходит JavaScript!\n\nРежим “fast set value” - значение не вводится по одному символу, а вставляется сразу через JS.\n\nДля того чтобы включить этот режим нужно:\n\nУстановить системную переменную:\n```\nmvn -Dselenide.fastSetValue=true \n```\nили\n\nВызвать метод:\n```java\n@Before public void setUp() { \n  Configuration.fastSetValue = true; \n} \n```\n\nВ этом случае setValue функция начинает работать через JS.\n\nТакде в любой момент можно выбирать:\n- $.setValue(“john”) - быстро \n- $.sendKeys(“john”) - если быстро никак \n\n\n## Самопальные команды\n\n### Слайдер \n\nИмеем функцию для установки значения слайдера:\n\n```java\n@Test { \n  setMaxYearlyFee($(“#slider”), 100); \n}\n\nvoid setMaxYearlyFee(WebElement slider, int value) { \n  executeJavaScript(...); \n} \n```\n\nНо вместо этой записи иногда удобнее иметь такую:\n```java\n@Test { \n  $(“#slider”).setMaxYearlyFee(100); \n} \n```\nА ещё круче вот так: \n\n```java\n@Test {\n  $(“#slider”) \n  .setMaxYearlyFee(100) \n  .setMinYearlyFee(15) \n  .selectFee(50) \n} \n```\n\nТак можно в Kotlin и Groovy Но не в Java!\n\nНо можно так: \n```java\n@Test { \n  $(“#slider”) \n  .execute(setMaxYearlyFee(100)) \n  .execute(setMinYearlyFee(15)) \n  .execute(selectFee(50)) \n} \n\nCommand<SelenideElement> setMaxYearlyFee(int fee) { \n  return (proxy, locator, args) -> { \n    executeJavaScript(\".... \" + fee); \n    return proxy; \n  }; \n} \n```\n\nСм. https://ru.selenide.org/2019/09/02/selenide-5.3.0/\n\n## Selenide и мобильники\n### Selenide для мобильников (Appium) \n\nМожно без аннотаций: \n\n```java\n@Test public void mobileCalculator() { \n  $(By.name(\"2\")).click(); \n  $(By.name(\"+\")).click(); \n  $(By.name(\"4\")).click(); \n  $(By.name(\"=\")).click(); \n  $(By.className(\"android.widget.EditText\")) \n  .shouldHave(text(\"6\")); \n} \n```\nhttps://github.com/selenide-examples/selenide-appium\n\n\n### Пэдж обжекты и Appium \n\nА можно и с аннотациями:\n\n```java\nclass MobileCalculatorPage { \n  @AndroidFindBy(id = \"op_add\") \n  @iOSFindBy(id = “op_add”); \n  SelenideElement plus; \n} \n```\nhttps://github.com/selenide/selenide-appium\n\n### Test setup\n\nСтандартного браузера нет поэтому нужно задавать класс своего драйвера.\nИспользуется для открытия приложения метод `open()` без параметра.\n\n```java\npublic class CalculatorTest {\n  @Before\n  public void setUp(){\n    Configuration.startMaximized = false;\n    Configuration.browserSize = null;\n    Configuration.browser = MyAndroidDriver.class.getName();\n    open();\n  }\n}\n```\n\n#### Android\n\n```java\npublic class MyAndroidDriver implements WebDriverProvider {\n  @Override\n  public WebDriver createDriver(DesiredCapabilities caps){\n    caps.setCapabilities(\"version\" ,\"4.4.2\");\n    caps.setCapabilities(\"automationName\" ,\"Appium\");\n    caps.setCapabilities(\"platformName\" ,\"Android\");\n    caps.setCapabilities(\"deviceName\" ,\"0123456789ABCDEF\");\n    caps.setCapabilities(\"appPackage\" ,\"com.android.calculator2\"); // т.к. калькулятор приложение Android по умолчанию, то достаточно указать только package\n    caps.setCapabilities(\"appActivity\" ,\"com.android.calculator2.Calculator\"); // запустится сразу указанное Activity\n\n    return new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), caps); // URL запущенного Appium Server\n  }\n}\n```\n\n#### iOS\n\n```java\npublic class MyIOSDriver implements WebDriverProvider {\n  @Override\n  public WebDriver createDriver(DesiredCapabilities caps){\n    caps.setCapabilities(\"platformName\" ,\"iOS\");\n    caps.setCapabilities(\"deviceName\" ,\"iPhone 11\");\n    caps.setCapabilities(\"platformVersion\" ,\"13.0\");\n    caps.setCapabilities(\"app\", resourcePath(\"apks/Wikipedia.app\"));\n    caps.setCapabilities(MobileCapabilityType.NEW_COMMAND_TIMEOUT, \"16\");\n    caps.setCapabilities(\"autoAcceptAlerts\", true);\n\n    return new IOSDriver(\"http://127.0.0.1:4723/wd/hub\", caps); // URL запущенного Appium Server\n  }\n}\n```\n\n### Универсальный Page Object (для iOS, Android, Web)\n\n```java\nclass MobileCalculatorPage {\n  @FindBy(id=\"op_add\")\n  @AndroidFindBy(id=\"op-add\")\n  @iOSFindBy(id=\"operandAdd\");\n  private SelenideElement plus;\n}\n```\n\nдля инициализации класса для web используется метод page, для mobile метод screen\n\n```java\nCalculatorPage calculator = page(CalculatorPage.class);\n```\n\n```java\nCalculatorPage calculator = screen(CalculatorPage.class);\ncalculator.number2.click();\ncalculator.plus.click();\ncalculator.number4.click();\ncalculator.equal.click();\ncalculator.result.shouldHave(text(\"6\"));\n```","category":"automation","description":"Selenide"},{"title":"Изоляция компонентов","path":"/izolyacziya-komponentov/","content":"\nПри выполнении теста с полным флоу можно встретить несколько проблем:\n- в интернет-магазине иногда нужно будет совершить оплату, чтобы закончить тест\n- задействовать реальную сервисную службу (чтобы собрать заказ)\n- зарезервировать ресурсы\n- долгая обратная связь тк нужно выполнить весь набор действий\n\nРешением этих проблем может стать идея тестирования приложения по частям.\n\n\n## Модульные(unit) тесты\n\n- Как правило тесты на функции или методы классов.\n- Для этих тестов не нужна сборка приложения.\n- Высокая скорость исполнения.\n\nСреди unit тестов выделяют:\n- Sociable - тесты, которые используют реальные модули приложения; \n- Solitary - тесты, которые используют подставные объекты или тестовые дублеры.\n\n### Тестовые дублеры\n\n#### Dummy\nКогда требуется передать в функцию объект, который в дальнейшем в тесте не будет использоваться. \nВ этом случае передается, например, пустая строка или пустой объект.\n\n#### Fake\nМожет иметь реальную реализацию, но не может использоваться в продакшене.\nНапример, использование In Memory DataBase вместо ORM(Object-Relational Mapping), которую скорее всего не получится использовать в продакшене.\n\n#### Stub\nВсегда возвращает статичный ответ по заданному запросу.\nЕсли нужно протестировать взаимодействие с внешним API, которое может быть недоступно, то его можно заменить stub'ом.\n\n#### Spy\nПохоже на stub, но еще может следить за вашим приложением.\nНапример, вы тестируете функцию в результате, которой происходит отправка письма пользователю, но в тестах не нужно рассылать настоящие письма, поэтому в функцию можно встроить \"шпиона\", который будет следить был ли вызвов отправки письма пользователю или нет, но при этом сам он отправлять письмо не будет. Такие тесты больше на поведение, чем на состояние.\n\n#### Mock\nВключает преимущества всех предыдущих дублеров. Это заранее запрограммированный объект который может принимать на вход различные значения и иметь некоторые ожидания. В зависимости от этих ожиданий, он возвращает ответ. ","category":"mobile","description":"Изоляция компонентов"},{"title":"Инструменты тестирования мобильных приложений","path":"/instrumenty-testirovaniya-mobilnyh-prilozhenij/","content":"\n## Симулятор vs Эмулятор\n\n### Симулятор \nОбычно используется для iOS.\n\n- Железо не эмулируется, только софтверная часть\n- Работает быстрее реальных устройстви мы не можем гарантировать что на реальном устройстве будет работать также\n- Невозможно установить телефонные приложений и работать с Siri\n- Невозможно проверить \"железные\" фичи: Bluetooth, NFC, звонки\n\nБаги возникающие на симуляторе в любом случае нужно править так как рано или поздно они могут появиться и на реальном устройстве:\n- Краш на симуляторе/девайсе\n- Разъезжается верстка\n\n### Эмулятор\nИспользуется для Android.\n\n- Имеется и Software и Hardware, можно задавать параметры памяти и т.д.\n- Работает медленно\n- Нет покупок внутри приложений\n- Google сервисы\n\nБаги:\n- Device-specific\n- Ошибки в транзакции\n- Библиотеки не под x86\n\nДостоинства:\n- Можно задавать различные разрешения\n- Можно работать с памятью\n- Тестировать GPS\n- Перехват и шейпинг(проверка траффика)\n\n## Реальные устройства\n\nОсновная проблема что не всегда есть возможность создать собственную ферму устройств\n\n- медленный Debug\n- iOS: разметка\n- Работа с памятью, сложно сэмулировать нужно забивать память вручную\n- Android: перехват трафика\n- Многообразие устройств\n\n## Среда разработки\n\nAndroid SDK, XCode\n\nADB - Android Debug Bridge - устанавливается вместе с Android SDK, и позволяет управлять устройством на базе Android. \n\nADB позволяет:\n- аосмотреть какие устройства подключены и могут работать с ADB\n- просматривать логи\n- копировать файлы с/на аппарат\n- устанавливать/удалять приложения\n- выполнять различные скрипты управления\n\n## Логи\n\nVerbose - вся информация с приложения\nDebug - логи для дебаг режима\nInfo - информация о состоянии\nWarn - предупреждение о нештатных ситуациях\nError - ошибка в приложении\n\nЕсли баг возникает у пользователя на проде, то проверяются логи в Fabric или Firebase Crashlitics.\n\nВ Firebase Crashlitics можно смотреть статистику работы без сбоев - какой процент пользователей работает без сбоев, список ошибок которые произошли и т.д.\n\nCrashlytics отображает:\n- Период возникновени ошибки\n- Тип ошибки\n    - Crash\n    - Warning\n- Версия приложения\n- Устройство\n- Операционная система\n- Идентификатор пользователя\n\n\n## Developer Console. Ошибки ANR и сбои\n\n1. Период возникновения ошибки\n2. Версия Android\n3. Версия приложения\n\nМинусы:\n1. Нет поиска по устройству\n2. Убрали поиск по отчетам пользователей\n\n## Перехват трафика\n\n- Charles\n- Fidler\n\nПроверяются запросы и ответы на клиенте и сервере.\n\nЕсли приходит ответ в зашифрованном виде то можно селать следущее чтобы его расшифровать\n\n1. Настроить прокси на устройстве или эмуляторе\n2. Установить SSL сертификат для HTTPS на устройстве с которого считываются запросы\n3. Выполнить действия с устройства\n4. Изучать необходимую информацию\n\n## Тестирование API\n\n- Postman\n    - Проверка сервера без клиента\n    - Проверка получаемых данных от сервера\n\n## Аналитика\n\n- Firebase - Firebase Debug View\n\nAndroid  \nadb shell setprop debug.firebase.analytics.app <package_name>\n\niOS  \nв командной строке Xcode:\n-FIRDebugEnabled\n\n- Google Analytics\n\nadb shell setprop log.tag.GAv4 DEBUG\n\nadb logcat -v time -s GAv4\n\nОтправляемые события будут отображаться в консоли но в самом Google Analytics нет реал тайм борда\nи в лучшем случае через сутки можно будет проверить что события дошли.\n\n- Яндекс AppMetrica\n\nВ самом кабинете можно указать устройство версию и не нужно никаких команд запускать.\n\n## Push уведомления\n\n- Firebase - Firebase Debug View\n\n- Яндекс AppMetrica\n\nМожно настраивать уведомления.\nНо иногда можно случайно отправить push на продакшен.\n\nНужно попросить разработчиков чтобы написали метод testPush.json, который будет отправлять push только на тестовое устройство. \n\n## Мнемоники\n\nПомогают выполнять важные проверки. \n\n### I SLICED UP FUN\n\n![I SLICED UP FUN](https://hsto.org/getpro/habr/upload_files/8f6/5c8/0c9/8f65c80c9c2cf5cf89c417c2240364be.png)\n\n## Автоматизация\n\n### Monkey UI/Application Exerciser Monkey\n\n```\nadb shell monkey\n-p your.package.name -v 500\n```\n\nhttps://developer.android.com/studio/test/monkey\n\nМожно указать ограничения по скорости, оганичить действия только внутри вашего приложения, можно указать id  и если приложение упадет можно по этом id воспроизвести действия, а также другие парамтры.\n\n\nИсточник:\n\n1. ❗ [«Инструменты тестирования мобильных приложений», Ксения Апачиди](https://www.youtube.com/watch?v=DH2XI5q1eUE)\n2. ❗ [Тестирование мобильных приложений: tips & tricks](https://habr.com/ru/company/badoo/blog/269189/)","category":"mobile","description":"Инструменты тестирования мобильных приложений"},{"title":"Мобильная автоматизация","path":"/mobilnaya-avtomatizacziya/","content":"\n## Сложности мобильной автоматизации\n\nОсновные сложности при автоматизации тестирования мобильных приложений:\n\n1. существует несколько платформ: Android, iOs;\n2. у Android есть разные лаунчеры, обертки, которые также хотелось бы покрыть;\n3. сложный деплой, сложнее чем на вебе, тк прежде чем запустить тесты нужно собрать билды (их нужно где то собирать и как то передавать в тесты).\nТакже сложные хот фиксы, их не так просто сделать  как в вебе, например, нужно проходить процесс ревью перед заливом в маркет;\n4. сложность в масштабировании (параллелизации и многопоточном запуске), т. к. используется много ресурсов для запуска мобильных тестов( и для эмуляторов, и для реальных устройств)\nзапустить всё во много потоков не так просто и дорого;\n5. дорогостоящая инфраструктура - есть простой вариант, использование cloud ферм для запуска тестов, но цена у них очень высокая. А для запуска на реальном железе - для iOs нужны Mac устройства, \nс хорошими ресурсами и это тоже дорого.\n6. нестабильные тесты - т.к. в моб приложении ограниченная зона видимости, мы видим только те элементы, которые отображаются на экране. Могут быть разнообразные popup, push сообщения, нотификации, которые перекрывают элементы.\n\nОднако, в автоматизации моб приложений мы используем тот же паттерн Page Objects, Selenium под капотом и тот же подход к написанию тестов (Arrange(подготавливаем данные) - Act(выполняем действие) - Assert(проверяем)).\n\n## Инструменты для мобильной автоматизации\n\n|                       |Appium     |Espresso         |XCUITest   |Detox     |Selendroid|\n|-----------------------|-----------|-----------------|-----------|----------|----------|\n|**iOS**                |+          |-                |+          |+         |+         |\n|**Android**            |+          |+                |-          |+         |+         |\n|**Type**               |Balck box  |White box        |Black box  |Grey box  |Black box |\n|**Programming Lang**   |Almost any |Kotlin           |Swift      |JavaScript|Java      |\n|**Cost**               |Free       |Free             |Free       |Free      |Free      |\n|**Community**          |Very active|Google           |Apple      |Wix       |Average   |\n|**Speed**              |Slow       |Fast             |Fast       |Fast      |Slow      |\n|**Web, native, hybrid**| +         |Hybrid and native|Only native|Only      |+         |\n\n\nSelendroid - достаточно старый инструмент, используется скорее теми компаниями которые взяли его еще давно, неизвестно поддерживается ли он на текущий день.\n\nDetox - подходит только для приложений на react native, нативные моб приложения им не получится автоматизировать.\n\nEspresso, XCUITest - нативные инструменты, заточные под свою платформу.\n\n\n## Преимущества Appium\n\n1. Возможность писать кросс платформенные тесты. \nНаписав один раз тест под одну платформу, нужно минимальное количество действий чтобы адаптировать его под другую (добавить соответсвующие локаторы и обработать индивидуальные особенности платформы);\n2. Позволяет писать тесты на практически любом языке программирования;\n3. Нет необходимости модифицировать код приложения. Appium - полный Black box и нам ненужно модифицировать код самого приложения;\n4. Работает на основе Selenium JSON wire protocol;\n5. Open source фреймворк с активным комьюнити. Спонсируется souce lab которая также предоставляет cloud решения;\n6. Поддержка параллельного запуска используя Selenium Grid;\n\n## Архитектура Appium\n\nAppium - это http сервер.\n\nУ нас есть тестовый скрипт, мы передаем его в Appium и Appium транслирует его на мобильные устройства, с помощью json wire protocol. \n\nAppium - это обертка над теми же нативными инструментами(XCUITest и UIAutomator, Expresso), т.к. он все свои команды дальше ретранслирует в команды понятные нативным инструментам.\n\nДля iOS используется XCUITest, для Android можно выбрать между UIAutomator и Expresso. \n\nДля Expresso добавили поддержку примерно в 2020 г, он на 20% быстрее, чем UIAutomator. Плюс Expresso делает Appium немного Grey box'ом, потому что есть возможность сделать backdoor к приложению и в целом делает немного более открытым код приложения.\n\nJSONWP(JSON wire protocol) - механизм, созданный командой разработчиков WebDriver. Этот протокол представляет собой набор четко определенных стандартизированных endpoints, открытых через RESTfull API.\n\n`AppiumDriver.getPageSource();` - этот метод вызовет HTTP-запрос, и получит ответ от API. Назад вернется page source в формате строки.\n\n`/session/:sessionId/source` - эндпоинт, который обрабатывает метод getPageSource.\n\n\n## Appium + Android\n\nAppium работает с Android через Espresso и UIAutomator. Поддерживается Google.\nEspresso быстрее чем UIAutomator. \n\n## Appium + iOS\n\nНесколько лет назад под капотом использовался не XCUITests, а другой фреймворк. Но Apple решила прекратить его поддержку и выпустила XCUITests. А XCUITests на тот момент противоречил философии Appium, в том что нам не нужно модифицировать код, т.к. XCUITests нужно было собирать вместе с приложением. \n\nИ некоторое время, Appium нельзя было использовать для iOS приложений. На помощь пришел Facebook и сделал WebDriverAgent Server. При запуске тестов на Appium'e на моб устройство также ставится WebDriverAgent и он транслирует команды от Appium к XCUITests.\n\n## Способы запуска\n\n- на реальных устройствах;\n\nЭто самый надежный вариант. Но построить свою ферму дорого и сложно поддерживать, тк устройства всегда были подключены к сети и нужно выполнять настройки, чтобы не всплывали всяки popup сообщения и если они всегда в сети, то нужно будет часто менять батарейку и собрать парк из разных девайсов будет дорого  и сложно.\n\n- на симуляторах/эмуляторах;\n\nОптимальный вариант. Не так много кейсов, которые репродьюсятся только на реальных устройствах. Они есть но их не много.\n\nдля iOS - используются симуляторы, на Android поднимаются эмуляторы. \n\nИспользуются стандартные эмуляторы, которые предоставляет Android Studio и симуляторы от XCode для iOS.\n\n- на cloud фермах \n    - Browser Stack (2 параллельных запуска ~ 400$ в месяц, 5 параллельных запусков ~ 1000$ в месяц)\n    - Sauce Labs\n    - AWS Device Farm\n    \nСамые удобные, тк просто указываем url на хост в ферме и запускаем. Но это очень дорого, плюс вопрос к секьюрности для запусков тестов. \n\n## Запуск тестов\n\n- для iOS\n\nПри запуске на реальном устройстве:\n1. собираем .ipa файл, подписанный сертификатом организации\n2. берем девайс, добавленный в провижен организации\n3. используется аккаунт с сертификатом разработчика\n\nПри запуске на симуляторе просто собираем через XCode .app файл.\nНа симуляторе нельзя установить файл с расширением .ipa, потому что там другая архитектура и он там не запустится.\n\n- для Android\n\nСобираем apk через Gradle и Android Studio на эмулятор и на реальное устройство и можно работать.\n\n## Что нужно чтобы начать?\n\n### Android\n- JDK (Java Development Kit)\n- Android SDK\n- Appium\n\n### iOS\n- Mac OS\n- XCode\n- JDK (Java Development Kit)\n- Homebrew\n- Node and npm\n\nhttps://qa-automation.git-doc.evo.dev/mobile/ubuntu.html\n\n## Стек инструментов\n\n- Appium\n- Java/Kotlin\n- TestNg\n- Maven\n- Allure REport\n- AssertJ\n- Log4J\n\n## Инструменты чтобы находить локаторы\n\n### Android\n\n- UIAutomatorViewer (Android)\n- Appium Inspector - делает скриншот текущего экрана и показывает состояние выбранного элемента.\n\nМожно искать элементы по id и по xPath:\n\n- Id\n\nresource-id = id\n```java\n@AndroidFindBy(id = \"tvProSalePay\")\n```\n\n- xPath\n```java\n@AndroidFindBy(xpath = \"//android.widget.TextView[@text = 'XL']\")\n```\n\n### iOS\n\nМожно использовать только Appium Inspector, так как нет других инструментов для этой цели.\n\nМожно искать по id, iOSClassChain, iOS predicate string (в порядке снижения скорости). \n\nПо xPath тоже можно но крайне не рекомендуется так как это происходит очень медленно из за того что в iOS приложениях нет xml дерева и appium его вычисляет самостоятельно а на это тратится время.\n\n- Id\n```java\n@iOSXCUITFindBy(id=\"client name\")\n```\n\n- iOSClassChain\nАналог xPath.\n\n```java\n@iOSXCUITFindBy(iOSClassChain=\"**/XCUIElementTypeButton[`name == 'icRatingStar'`]\")\n```\n\n- iOS predicate string\n\nСвой тип локаторов.\n\n```java\nString selector = \"type == 'XCUIElementTypeButton' AND value BEGINSWITH[c] 'bla' AND visible == 1\"\n```\n\n## Боли Appium \n\n### Недоступные элементы\n\nНекоторые объекты не имеют выделенного элемента в DOM дереве и сложно с ними взаимодействовать отдельно, например взять текст. Встречается в сообщениях об ошибке, тост сообщениями, поп-апами.\n\n**Решение:**\n\n1. Можно использовать библиотеку tesseract - для распознавания текста на изображении.\n2. Клики по координатам.  \nЕсли нужно кликнуть на элемент, которого нет в дом дереве.  \nВ этом случае лучше брать не координаты этого элемента, а стараться брать соотношение по экрану (находить центр и т.д.), потому что если мы поменяем устройство, на котором будем прогонять и там расширение экрана другое, то мы столкнемся с трудностями.\n\n### Ограниченная зона видимости\n\nКогда мы делаем скриншот в Appium, мы видим дерево только тех элементов, которые есть сейчас на экране, то что вне мы не видим. \n\n**Решение:**\n\nДойти до элементов вне зоны видимости мы можем только проскролив.\n\n- iOS\n\n```java\nHashMap<String, String> scrollObject = new HashMap<>();\nscrollObject.put(\"element\", element.getId());\nscrollObject.put(\"toVisible\", \"true\");\n\ndriver.executeScript(\"mobile:scroll\", scrollObject);\n```\n\n- Android\n\n```java\nprotected void scrollToElementAndroid(String scrollableListId, String selectionText){\n    ((AndroidDriver) driver).findElementByAndroidUIAutomator(\"new UiScrollable(new UiSelector().scrollable(true)\"\n    + \".resourceId(\\\"\" + scrollableListId + \"\\\"))\"\n    + \".setAsHorizontalList().scrollIntoView(new UiSelector().text(\\\"\" + selectionText + \"\\\"))\").click();\n}\n```\n\n**Универсальный скролл**\n\n```java\npublic void swipeUpToFindElement(By by, int maxSwipes){\n    int alreadySwiped = 0;\n    while(driver.findElements(by).size() == 0){\n        if (alreadySwiped > maxSwipes){\n            waitForElementToBePresent(by, \"Невозможно найти элемент по свайпу\", Constants.SMALL_TIMEOUT);\n            return;\n        }\n        swipeUpQuick();\n        Log.info(\"Выполнен свайп\");\n        ++alreadySwiped;\n    }\n}\n```\n\n### Платформозависимость\n\nУ Android и iOS есть свои особенности.\n\n- Разные атрибуты у элементов\niOS - value, android - text\niOs - visible, android - displayed\niOS - enabled, android - checked, checkable, enabled\n\n- Различия в основных флоу приложения на Android и на iOS\n\n- Часто при работе с веб вью на разных версиях Android у элементов разный xPath\n\n```java\n@AndroidFindAll(\n\n)\n```\n\nwatch?v=zp0qC6JT0rE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","category":"mobile","description":"Мобильная автоматизация"},{"title":"Особенности тестирования мобильных приложений","path":"/osobennosti-testirovaniya-mobilnyh-prilozhenij/","content":"\n## Виды мобильных приложений, их плюсы и минусы\n\n### Web приложения\n\nВеб-приложения представляют собой адаптированные веб-сайты, которые открываются через браузеры. \n\nПользователь не скачивает приложение и не хранит его на своем устройстве. Если его «скачивают», скорее всего, речь идет о том, что оно добавляется в закладки браузера. \n\nОдним из самых распространенных подвидов считают PWA — прогрессивные веб-приложения, которые, по сути, являются нативными приложениями внутри браузера. \n\nСложно выделить примеры, чтобы не ошибиться. Разные источники приводят в пример Google Maps, программы Microsoft Office.\n\n#### Плюсы\n- Не требуют настроек под операционную систему, что делает разработку быстрой и менее дорогой.\n- Не требуют загрузки, установки и не занимают место на устройстве пользователя.\n- Не требуют обновлений, поэтому в теории их проще поддерживать со стороны разработчика и, опять же, пользователю не надо устанавливать никакие обновления, чтобы работать с площадкой.\n\n#### Минусы\n- Веб-приложения зависят от браузера. И функции, которые доступны в одном браузере, могут не поддерживаться в другом. Это означает, что пользовательский опыт будет отличаться. \n- Веб-приложения не работают без подключения к интернету. \n- Не имеют доступа к ресурсам мобильного устройства, в связи с этим имеют ограниченную функциональность.\n\n### Нативные приложения\n\nНативные мобильные приложения — самый распространенный и дорогой в разработке вид, так как создается отдельно для каждой ОС (iOS, Android или другие). \n\nКогда мы говорим о мобильных приложениях, чаще всего имеем в виду именно нативные. Pokemon Go, Spotify и многие другие являются именно нативными приложениями.\n\n#### Плюсы\n- Высокая производительность (скорость работы и надежность). Это связано с тем, что приложение создается для каждого ОС с учетом его особенностей. В итоге это обеспечивает пользователю позитивный опыт взаимодействия.\n- Доступ к аппаратной части устройства (геолокации, камере, микрофону, акселерометру, датчикам освещенности, календарю, push-уведомлениям) и широкий функционал за счет этого; Это тоже упрощает и улучшает пользовательский опыт.\n- Adjust упоминает, что нативные приложения еще и более безопасны с точки зрения защиты данных пользователя.\n- Нет ограничения функционала скоростью и качеством Интернет-соединения, приложение может работать без выхода в сеть;\n- Можно распространять через магазин проложений.\n\n#### Минусы\n- Стоимость разработки. Нативное приложение нужно разрабатывать отдельно для каждой ОС, а потом поддерживать его. Все это требует расходов. \n- Нативные приложения занимают место в памяти устройства пользователя, причем с каждым новым обновлением это занятое место может расти.\n\n### Гибридные приложения\n\nНазвание говорит само за себя: это веб-приложения, которые выглядят как нативные и имеют их признаки. \n\nВ частности, иконки на рабочем столе мобильного устройства пользователя, хорошую производительность и возможность работать в автономном режиме. \n\nСреди гибридных приложений выделяют Uber, Evernote. Некоторые источники относят к гибридам и Instagram.\n\n#### Плюсы\n- Более бюджетная и быстрая разработка по сравнению с нативными. \n- Более быстрая загрузка — это хорошее преимущество для пользователя и возможность улучшения пользовательского опыта. \n- Возможность взаимодействия с ОС устройства. \n- Есть встроенный браузер.\n- Можно распространять через магазин прилодений.\n- Мультиплатформенные.\n\n#### Минусы\n- Все равно не такая хорошая производительность, как у нативных приложений.\n- Ограниченный доступ к ресурсам мобильного устройства.\n- Не полностью автономны, нужно подключение к интернету.\n\n## Отличия web и mobile тестирования\n\n1. Мобильные устройства можно переносить, в связи с этим появляются свои особенности, меняется геолокация и т.д.\n2. У мобильных устройств  высокая фрагментация (много устройств на которых можно использовать приложение) и больше пользователей\n3. Мобильные прилодения имеют ограничения в ресурсах (оперативной и постоянной памяти)\n4. Разное взаимодействие в отлечие от web'a (tap, swipe и т.д.)\n5. Разное поведение с подкючением к интернету и без подключения.\n\n## Тестирование mobile приложений\n\n1. Выбор устройств.\nИз всего зоопарка устройств нужно выбратьустройства для тестирования. Для этого можно обратиться к статистике и аналитике по использованию вашего приложения, если такой статистики нет то моно обратиться к статистике google илии apple.\n\n2. Размеры экрана и touch интерфейс\n- Элементы должны быть определенного размера чтобы пользователь смог попасть и не было мискликов.\n- Все сценарии в приложении не должны вести на пустые экраны.\n- В touch интерфейсе нужно проверять многократное нажатие на элементы, мультитач[^«множественное касание» — функция сенсорных систем ввода, осуществляющая одновременное определение координат двух и более точек касания.] и нативные жесты которые могут использоваться.\n- скорость отклика элементов (высокая; нажатая клавиша должна визуально отличаться)\n\n3. Ресурсы устройства\n- кейсы с утечкой памяти;\n    - можно проверить с помощью программы Instruments (стандартное приложение MacOS). Может быть не более 30мб на 2г айфон/айпод, примерно 70мб для всех девайсов до 2-го айпада\n    - уделить внимание окнам с большим количеством информации, при длительном пребывании пользователя в приложении\n- кейсы, когда не хватает памяти для установки и работы приложения;\n- кейсы, когда не хватает памяти для обновления и работы приложения;\n- кейсы, когда переносим или устанавливает приложение на sd карту;\n\n4. Разрешения экрана и версии ОС\n- можно столкнуться с ошибками верстки;\n- на разных разрешениях приложение зачастую выглядит по разному;\n- кейсы с портретной и альбомной ориентацией устройства;\n\nЕсли приложение работает с разными форматами файлов то нужно проверять все эти форматы, чтобы приложеине корректно работало с каждым.\n\n5. Реакция на внешнее прерывание\nВнешние прерывания:\n- входящие/исходящие звонки/сообщения/смс/ммс/напоминание/нотификацию ;\n- уведомления от других приложений;\n- разрядка устройства, переход устройства в энергосберегающий режим, переход устройства в режим ожидания, смена ориентации в режиме ожидания;\n- кейсы с разными подключениями (с разными сетями: wi-fi, 3G);\n- при включенной/отключенной функции bluetooth, геопозиция, режим полета, функции где используется камера;\n- кейсы с потерей связи;\n- кейсы с зарядкой устройства(разряд/изъятие батареи);\n- с извлечением/подключением sd карты/кабеля/зарядки;\n- закрыть приложение для того, чтобы открыть какое-то другое на некоторое время и вернуться к вашему приложению позже;\n- послать девайс в сон на некоторое время.\n\n6. Доступ к связи\n- позитивный кейс (наличие отличной постоянной связи);\n- наличие постоянной неотличной связи;\n- отсутствие связи;\n- потеря связи;\n\n7. Постоянная мобильность\n- Крэш в приложении при попытке восстановить приложение из бэкграунда с предварительной сменой ориентации экрана;\n- Крэш в приложении при “потряхивании” девайса в момент совершения этим девайсом фотосъёмки (приложение изначально создавалось для создания фото);\n\n8. Проверка работы приложений на ретина экранах и различных версия OS\n- корректное отображение различных элементов на экранах ретина/не ретина\n- установка приложения на корректную версию OS\n- проверить установку на все возможные девайсы\n- различные функции на девайсах: отсутствие/наличие камеры(ipad) (автофокуса), отсутствие/наличие GPS\n\n9. Проверка типа покупок (восстанавливаемые, не восстанавливаемые)\n- проверка соответствия фактической/заявленной стоимости приложения\n- проверка восстановления покупки независимо от девайса, а с привязкой к учетной записи\n\n10. Проверка работы обратной связи\n- сообщения при загрузке контента/прогресс\n- сообщения при ошибке доступа к сети\n- наличие сообщений при попытке удалить важную информацию\n- наличие экрана/сообщения при окончании процесса/игры (экран Game over)\n\n11. Проверка работы обновлений\n- проверка различных путей установки обновлений (wifi, bluetooth, usb)\n- проверка работы установленных изменений, мест, куда они вносились\n- убедиться в поддерживаемости обновлений более старыми операционками, чтобы элементы которые на новой системе работают хорошо не падали на более старых версиях.\n\n12. Реклама в мобильном приложении\n- реклама не должна перекрывать кнопки управления приложением\n- реклама должна иметь доступную кнопку закрытия, потому что чаще всего пользователь ее не ищет, а просто удаляет приложение с концами\n\n13. Проверка локализации\n- на другом языке на экране должно хватить места для текста\n- даты должны соответствовать формату установленного региона\n- временные настройки должны быть соблюдены\n\n14. Проверка энергопотребления\n- необходимо проверять насколько сильно ваше мощное приложение опустошает батарею устройства. Скорее всего пользователь удалит его, если из-за него мобилку придется под заряжать слишком часто.\n\n## Жизненный цикл приложения\n\nКогда мы тестируем кейсы на прерывание мы проверяем как правильно приложение работает с жизненным циклом.\n\n![Жизненный цикл приложения](https://metanit.com/java/android/pics/life_cycle.png)\n\n## Обратная связь с пользователем\n\nУ всех элементов нажатых пользователем должно быть соответсвующее состояние благодаря этому пользователь видит действительно ли нажатие случилось или нет.\n\nТакже нужно смотреть на отклик(реакция на нажатие), есть ли какая то скорость отклика она не должна быть достаточно быстрой и не должна быть достаточно медленной. При таком тестировании желательно использовать не самые топовые устройства(девайсы).\n\nКогда загружаем какой нибудь контент нужно использовать прогресс бар чтобы пользователь видел что идет загрузка. \n\nВсе сценарии должны иметь завершающий success экран, чтобы пользователь также видел что его кейс завершился и можно пойти на другой экран.  \n\nДолжны быть четкие и понятные сообщения об ошибках. Чтобы пользователь понимал чтоо ему нажимать, вдруг он удаляет какую то важную информацию. Текст сообщения должен быть крайне понятным и простым. \n\nТакже если используются уведомления на экране, например о покупках, можно использовать звуки и вибрацию. Звуки, вибрация и уведомления должны быть синхронизированы между собой, такой кейс тоже надо проверять. \n\n## Настройки разработчика в Android\n\nВ Android и iOS есть специальный режим разработчика, это список настроек/параметров которые мы можем использовать при тестировании.\n\nНапример:\n\n- **Профиль обработки GPU** - показывает насколько быстро рисуется интерфейс нашего приложения. Если будет выше зеленой линии значит не все так гладко с интерфейсом.\n\n- **Показывать ограничения макета** - показывает как все элементы расположены относительно друг друга.\nЕсли мы тестируем верстку можно включить этот режим и сравнить с макетом.\n\n- **Параметр \"Отладка\"** - используется при дебаге.\n\n- **Параметр \"Конфигурация USB\"** - как подключаться для отадки, для зарядки, для передачи файлов.\n\n- **Параметр \"Не сохранять операции\"(\"Do not keep activities\")** - используется для тестирования жизненого цикла. При включении этого параметра при навигации в новый экран предыдущий экран уничтожается, если мы снавигируемся назад то приложение падает. \n\nдля iOS есть такой же режим:\n\n- **Параметр \"Network Link Conditioner\"** - для тестирования с разным качеством связи(3G, LTE и т.д.) и с возможностью задавать собственные профайлы, кастомные со своими параметрами какая нам сеть нужна.\n\n## Помощь при релизах \n\n### Beta версии\n\n#### iOS\nПеред релизами можно использовать beta версии.\nДля iOS для этих целей можно использовать TestFlight, релиз выкладываетя и пояляется в TestFlight и далее смотрится как поведет себя приложение.\n\n#### Android\nНечто похожее также имеется и на Android.\nТакже используется Beta testing версии для внутреннего тестирования.\n\n### Выпуск автоматических обновлений\n\n#### iOS\nТакже в iOS есть функция поэтапного выпуска автоматических обновлений. Если включается этот параметр то в течение недели наше обновление будет выкатываться с 1% пользователей до 100%, каждый день постепенно увеличиваясь.\n\n#### Android\nВ Android также можно делать выпуск автоматических обновлений, но здесь есть больше контроля на этим процессом. \n\nЕсли мы желаем поэтапный релиз для iOS то мы можем его только остановить но не поменять проценты или другие настройки, в Google Play можно указать процент - сколько пользователей нужно от общего количества, в любой момент остановить и в любой момент продолжить, в любой момент поменять этот процент. \n\n### Отчеты о тестировании\n\nТакже в Google Play есть отчеты о тестировании. Когда вы загружаете свой apk файл и публикуете, через некоторое время там появится отчет о тестировании этой версии. \n\nGoogle на своей фабрике устройств тестирует нашу apk, в течении ~ 10 минут и в итоге выдает отчет по разным параметрам: по безопасности, будут видны краши если они были, видно на каких устройствах тестировалось, видно скриншоты и запись видео в том случае если что то пошло не так.  \n\n## Чек-лист тестирования мобильных приложений:\n\n- Геолокация.\n- Работа приложения в разных режимах: portrait/landscape, split screen.\n- Поля ввода.\n- Пуш уведомления.\n- Прерывания — входящие звонки, СМС, доступ к интернету, предупреждение о низком заряде батареи, внезапное отключение устройства и другие.\n- Поддержка платежных систем (если присутствуют платежные транзакции).\n- Соответствие гайдлайнам операционных систем.\n- Влияние на производительность устройства.\n\nТакже необходимо проанализировать сетевой трафик: обрыв сети и слабый интернет, исходящие запросы и полученные ответы. Для этого используют снифферы Charles/Fiddler, Proxyman и другие.\n\nПри необходимости выполняют тестирование API. Для этой задачи используют специализированные инструменты: Swagger, Postman, SOAPUI. Они помогают документировать запросы и выполнять их интерактивную проверку. Подробнее их мы рассмотрим дальше.\n\nДля тестирования на различных устройствах используют эмуляторы вроде Genymotion, BlueStacks. Однако успешные тесты на эмуляторе не гарантируют, что приложение будет работать без сбоев на реальных устройствах. Чтобы подключиться к реальным мобильным устройствам и интегрировать туда автотесты, используют фермы BrowserStack, Xamarin или AWS. Либо можно поднять собственную ферму на базе OpenSTF — это позволит всем сотрудникам иметь равный доступ к тестовым устройствам, что особо важно в условиях распределенных команд и удаленной работы.\n\nДля автоматизации UI тестирования мобильных приложений используют Appium, Detox, Ranorex — инструменты автоматизации для запуска сценариев и тестирования приложений на Android или iOS с помощью веб-драйвера. Подробнее инструменты для автоматизации тестирования мы рассмотрим ниже.\n\nКогда ваш проект имеет большое количество автотестов, будет полезно автоматизировать их запуск при каждой сборке нового билда. Чтобы настроить этот процесс, используйте системы CI/CD — Jenkins/TeamCity.\n\nИсточник:\n\n1. ❗ [«Особенности тестирования мобильных приложений», Игорь Плотников](https://www.youtube.com/watch?v=Vy_6hfmk34E)\n2. ❗ [Мобильное тестирование, автоматизация и тестирование API: С чем нужно уметь работать тестировщику в 2021 году](https://habr.com/ru/company/reksoft/blog/541344/)","category":"mobile","description":"Особенности тестирования мобильных приложений"},{"title":"Подходы Badoo","path":"/podhody-badoo/","content":"","category":"mobile","description":"Подходы Badoo"},{"title":"Тестирование мобильного приложения","path":"/testirovanie-mobilnogo-prilozheniya/","content":"\n## С чего начать?\n\n### Этап 1: Планирование\nКогда этап разработки приложения почти завершен, вы должны снова поставить перед собой вопрос - чего вы пытаетесь достичь разработкой данного приложения и какие у вас есть ограничения.\n\nВы должны определить следующее:\n\n- Взаимодействует ли ваше приложение с другими приложениями?\n- Насколько функциональны все возможности приложения?\n- Является ли тестируемое мобильное приложение нативным, Mobile-web или гибридным?\n- Ограничена ли задача тестирования приложения тестированием только внешнего интерфейса?\n- Стоят ли задачи на тестирование бэкенда?\n- Какова должна быть совместимость с различными беспроводными сетями?\n- Как сильно данные приложения и свободное пространство, занимаемое им, зависят от особенностей использования приложения?\n- Насколько быстро загружается ваше приложение, насколько быстро происходит серфинг по меню приложения и его функциям?\n- Как будет обрабатываться возможное увеличение нагрузки на приложение?\n- Влияют ли различные изменения в статусе и состоянии телефона на работу мобильного приложения?\n- Убедитесь, что вы договорились с командой тестировщиков о роли каждого из них и о ваших ожиданиях от процесса тестирования. В конце концов, общение является ключом к поддержанию правильной рабочей среды в команде.\n\nПравильное понимание ролей и задач также относится и к моменту прописывания списка тест кейсов. Вся команда QA должна поддерживать и обновлять этот документ с отчетами по тестированию всех функций, реализованных на протяжении всего процесса разработки.\n \n### Этап 2. Определение необходимых типов тестирования мобильных приложений\nПеред тестированием любых мобильных приложений определите, что именно в данном мобильном приложении вы хотите протестировать: набор функциональности, удобство использования, совместимость, производительность, безопасность и т. д. На этом же этапе имеет смысл выбрать методы тестирования мобильного приложения.\n\nОпределите, на какие целевые устройства направлено данное приложение, и какие требования  к функционалу следует проверить.\n\nВы также должны определить, какие целевые устройства нужно включить в список тестирования.\n\nВы можете сделать это следующим образом:\n\n- Выяснить, какие устройства будет поддерживать приложение;\n- Определить, какая версия операционной системы будет самой ранней из тех, что  поддерживаются приложением;\n\n- Выявить наиболее популярные модели мобильных устройств у целевой аудитории;\n- Определить набор не основных (дополнительных) устройств с экранами разных размеров, потенциально  поддерживаемых приложением;\n- Решить, будете ли вы использовать для тестирования физические устройства или их эмуляторы.\n\n### Этап 3: Тестовые случаи и разработка сценариев тестирования приложения\nПодготовьте документ, описывающий тестовые случаи (test cases) для каждой тестируемой функции и функциональности.\n\nВ дополнение к функциональным тестовым случаям, также должны быть охвачены некоторые отдельные моменты (кейсы):\n\n- Особенность использование батареи;\n- Скорость работы приложения;\n- Требования к данным;\n- Объем используемой памяти.\n\nТакже перед началом тестирования важно определиться, какое сочетание ручного и автоматического тестирования вы будете применять.\n\nПри необходимости подготовьте отдельные наборы ручных тестовых случаев и сценариев для автоматического тестирования и адаптируйте их согласно требованиям проекта.\n \n### Этап 4: Ручное и автоматическое тестирование\nТеперь пришло время для выполнения ручных и автоматизированных тестов.\nРанее, на предыдущих этапах, вы уже определили, какие тесты и скрипты использовать и подготовили их. Теперь, на текущем этапе, вы выполняете запуск тестов для проверки механизмов основной функциональности, чтобы убедиться в отсутствии поломок.\n\nАвтоматизированное тестирование мобильных приложений хорошо экономит время и другие ресурсы тестировщиков.\n\n### Этап 5: Тестирование юзабилити и бета-тестирование\nПосле того, как базовый функционал протестирован, настало время убедиться, что мобильное приложение является достаточно простым в использовании и обеспечивает удовлетворительный пользовательский опыт. На этом этапе необходимо поддерживать соответствие матрице кроссплатформенности, чтобы обеспечить охват пользователей различных платформ, достигнутый бета-тестерами.\n\nПосле того, как приложение будет протестировано внутри компании, вы сможете выпустить бета-версию приложения на рынок.\n\n**Тестирование совместимости**\n\nМобильные устройства различаются в зависимости от платформы, модели и версии их операционной системы. Важно выбрать такое подмножество устройств, которое будет соответствовать вашему приложению.\n\n**Тестирование пользовательского интерфейса**\n\nПользовательский опыт является ключевым элементом, при тестировании приложения. Ведь наше приложение разрабатывается именно для конечных пользователей. Вам следует качественно проверить удобство использования приложения, навигацию по его элементам и контент. Тестируйте меню, опции, кнопки, закладки, историю, настройки и навигацию приложения.\n\n**Тестирование интерфейса**\n\nТестирование пунктов меню, кнопок, закладок, истории, настроек и навигации по приложению.\n\n**Тестирование внешних факторов**\n\nПриложения для мобильных устройств не будут единственными приложениями на устройстве пользователя. Вместе с вашим приложением будут установлены приложения от сторонних разработчиков. Возможно десятки таких приложений. Следовательно, вашему приложению придётся взаимодействовать с этими сторонними приложениями и прерывать работу различных функций устройства, таких как различные типы сетевых подключений, обращение к SD-карте, телефонные звонки и другие функции устройства.\n\n**Тестирование доступности**\n\nМобильными устройствами могут пользоваться различные люди с ограниченными возможностями. По этой причине важно  протестировать возможность работы с приложением людей с дальтонизмом, нарушениями слуха, проблемами пожилого возраста и другими возможными проблемами.  Такое тестирование является важной частью общего тестирования юзабилити.\n\n### Этап 6: Тестирование производительности\nМобильные устройства предоставляют для приложений меньший объем памяти и меньшую доступную мощность процессора, чем стационарные компьютеры и ноутбуки. По этой причине в работе мобильных приложений очень важна эффективность использования предоставляемых ресурсов. Вам следует проверить работоспособность тестируемого приложения, изменив соединение с 2G, 3G на WIFI, проверить скорость отклика, потребление заряда батареи, стабильность работы и т. д.\n\nРекомендуется проверять приложение на предмет масштабируемости применения и наличие возможных проблем с производительностью.\n\nВ рамках этого этапа важно пройти и нагрузочное тестирование мобильного приложения.\n\n**Функциональное тестирование**\n\nФункциональность приложения должна быть полностью протестирована. Особое внимание следует уделить установке, обновлениям, регистрации и входу в систему, обеспечению, работе со специфическими функциями устройства и сообщениям об ошибках.\n\nФункциональное тестирование мобильного приложения, по большей части, может быть выполнено так же, как вы выполнили бы его для любого другого типа приложения. По этой причине мы не будем вдаваться в подробности этого типа тестирования. Однако следует указать области, которые имеют особое значение для мобильных приложений.\n\nИмейте в виду, что функциональное тестирование должно включать в себя тестирование всех функций приложения и не должно быть излишне сосредоточено на какой-то одной функции.\n\nВ рамках функционального тестирования, вам следует выполнить следующие тесты:\n\n- Тестирование процесса установки;\n- Тестирование возможности обновлений;\n- Эксплуатационное тестирование;\n- Тестирование процесса регистрации и авторизации;\n- Тестирование функций, специфических для устройства;\n- Тестирование отправки и получения сообщений об ошибках;\n- Низкоуровневое тестирование ресурсов: использование памяти, автоматическое освобождение ресурсов и т.д.\n- Тестирование сервисов: функционирование как в режиме онлайн, так и в автономном режиме.\n\n### Этап 7: Аттестационное тестирование и тестирование безопасности приложения\nБезопасность и конфиденциальность данных имеют огромное значение в наше время. Пользователи требуют, чтобы вся их информация хранилась безопасно и конфиденциально.\n\nУбедитесь, что тестируемое приложение надежно защищено. Выполните проверку на возможность внедрения SQL инъекций, на возможность перехвата сеансов, анализа дампов данных, анализа пакетов и SSL трафика.\n\nОчень важно проверить безопасность хранилища конфиденциальных данных вашего мобильного приложения и его поведение в соответствии с различными схемами разрешений для устройств.\n\nПомимо проверки безусловного шифрования имен пользователей и паролей, задайте себе следующие вопросы:\n\n- Есть ли у приложения сертификаты безопасности?\n- Использует ли приложение безопасные сетевые протоколы?\n- Существуют ли какие-либо ограничения, например количество попыток входа в систему до блокировки пользователей?\n \n### Этап 8: Тестирование устройства\nВыполните тесты по тем алгоритмам, которые вы ранее прописали в тестовых случаях и сценариях тестирования на всех определенных для тестирования устройствах, в облаке и / или на физических устройствах.\n\n### Этап 9: контрольный этап и резюме\nЭтот этап включает в себя подробное и полное тестирование - от ранних итеративных этапов тестирования до регрессионных тестов, которые все еще могут потребоваться для стабилизации работы приложения и выявления незначительных дефектов.\n\nНа этом этапе тестирования вы можете добавить для проверки новые функции и изменить настройки на те, которых не будет в финальной версии.\n\nПосле завершения тестирования приложения, дополнительные параметры и функции, добавленные для проверки на этом этапе, удаляются, и окончательная версия становится готовой для представления общественности.\n\n**Итоговый отчет о тестировании**\n\nВесь процесс тестирования мобильных приложений должен быть тщательно задокументирован. Проверьте дважды, сделаны ли нужные записи, и после этого сформируйте свой окончательный отчет о тестировании (test summary report).\n\nЭтот отчет должен включать:\n\n- Важную информацию, выявленную в результате проведенных испытаний;\n- Информацию о качестве проводимого тестирования;\n- Сводную информацию о качестве тестируемого мобильного приложения;\n- Статистику, полученную из отчетов об различных инцидентах;\n- Информацию о видах тестирования и времени, затраченном на каждый из них.\n\nСледует также указать в отчете, что:\n\n- данное мобильное приложение пригодно для использования в том качестве, в котором заявлено;\n- соответствует всем критериям приемлемости функционала и качества работы.\n\n","category":"mobile","description":"Тестирование мобильного приложения"},{"title":"Тестирование, Quality control, Quality assurance","path":"/testirovanie-quality-control-quality-assurance/","content":"\nПроцесс Тестирование является частью Quality Control, а Quality Control частью Quality Assurance.\n\n## Обеспечение качества (Quality Assurance)\n\nАктивности, направленные на обеспечение уверенности в том, что требования к качеству будут выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9E%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QA (Quality Assurance, обеспечение качества)** – это, собственно, весь комплекс процессов, обеспечивающих качество, наиболее обширное понятие. QA интегрировано во все этапы разработки: от описания проекта до тестирования, релиза и даже пост-релизного обслуживания.\n\nЭто уже проактивная работа, т.к. **_основная задача  обеспечения качества_** – это выстроить систему, которая будет превентивно работать на качество продукта, чтобы при тестировании количество дефектов было минимальным. \n\nВ зависимости от специфики проекта сюда может включаться тестирование документации, подготовка и установка стандартов, анализ качества, выбор инструментов, ревью кода на соответствие стандартам, внедрение каких-то методик по работе с качеством, коммуникационные активности и проч. \n\nЗанимаются Lead специалисты либо менеджеры.\n\n## Контроль качества (Quality Control)\n\nНабор действий, предназначенных для оценивания качества компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QC (Quality Control, контроль качества)** – это часть комплекса QA, которая отвечает за анализ результатов тестирования, поиск ошибок и их устранение. В него входят различные процессы, такие как анализ кода, технические обзоры, анализ дизайна, тестирование и прочее.\n\nQuality Control обеспечивает не только проверку продукта на соответствие требованиям, но и соответствие заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшен. \nЭто совокупность действий, проводимых над продуктом в процессе разработки, для получения информации о его актуальном состоянии в разрезах:\n- готовность продукта к выпуску,\n- соответствие зафиксированным требованиям,\n- соответствие заявленному уровню качества продукта. \n\n**_Основная задача контроля качества_** – предоставить объективную картину того, что происходит с качеством продукта на разных этапах разработки. \n\nЗанимаются middle специалисты.\n\n## Тестирование программного обеспечения\n\nПроцесс, содержащий все активности жизненного цикла, как динамические, так и статические, касающиеся планирования, подготовки и оценки компонента или системы и связанных с этим результатов работ с целью определить, что они соответствуют описанным требованиям, показать, что они пригодны для заявленных целей и для определения дефектов. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)]\n\n**Testing (Тестирование)** – это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям. А тестировщик — это специалист, который занимается такой проверкой. Он тестирует компоненты продукта или весь продукт целиком на предмет ошибок или неточностей разработки. Тестирование — один из ключевых процессов в системе обеспечения качества.\n\nПо факту это реактивная работа (выдали – проверил – описал дефекты – исправили), которая может помочь исправить дефекты в уже созданном программном обеспечении, но не более того. Это не значит, что тестирование – это просто (наоборот, профессиональные тестировщики – какие-то сверхлюди, по-моему), но это самая база и минимум, без которого выпускать продукт в принципе нельзя.\n\n**_Основная задача тестирования_** – выявить и зафиксировать дефекты.  \nМогут заниматься junior специалисты.\n\n\n## Пример\n\n**Требование**: В поставляемых тестовых документах должны отсутсвовать персональные данные сотрудников (фамилия и имя)\n\n**_Тестирование_**: Перед окончательным этапом поставки проверяем документацию на отсутсвие персональных данных по заранее составленному списку\n\nНо что делать, если вдруг сотрудник поменял Фамилию или пришел новый сотрудник? \n\n**_Контроль качества_**: Меняем процессы таким образом чтобы в случае если сотрудник поменял Фамилию или пришел новый сотрудник, эти данные добавлялись в текущий список\n\n**_Обеспечение качества_**: Для того чтобы предотвратить попадание ФИО наших сотрудников в тестовые данные мы переходим на процедурную генерацию ФИО. Тестировщикам больше не надо придумывать ФИО для заполнения полей, за них это сделает процедура. Более того, тестировщикам запрещено использовать данные полученные не из процедуры.\n\nВсе эти меры обеспечивают нам уверенность в том, что требование «В поставляемых тестах отсутствуют персональные данные» будет выполнено. Но важно понимать, что это никак не отменяет тестирования выходных данных на наличие ПД.\n\n## Цели тестирования\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет работать правильно при любых обстоятельствах.\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет соответствовать всем описанным требованиям.\n- Предоставление актуальной информации о состоянии продукта на данный момент.\n\n#### Источники информации\n\n1. ❗ [Artsiom Rusau QA Life: Тестировщик с нуля / Урок 3. QA, QC, тестирование. Верификация и валидация](https://youtu.be/f3Yjzjsh0aM)\n2. ❗ [Профессия тестировщик: разбираемся в QA, QC и testing](https://tproger.ru/blogs/qa-qc-tester-career/)\n3. ❗ [Что такое качество. Разбираемся в иерархии терминов «QA», «QC» и «тестирование»](https://habr.com/ru/company/rostelecom/blog/647963/)","category":"manual","description":"Разберем разницу между понятиями Тестирование, Quality Control и Quality Assurance в теории и на одном из примеров."},{"title":"Понятие качества, международные стандарты качества","path":"/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/","content":"\n## Качество программного обеспечения (Software Quality) по ISTQB\n\nСтепень того, насколько компонент или система соответствует сформулированным и подразумеваемым потребностям различных заинтересованных лиц. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE)]\n\n## Типы стандартов\n\n**Международные стандарты:**\n- ISO(International Organization for Standardization)/IEC(International Electrotechnical Commission)\n- IEEE(Institute of Electrical and Electronic Engineers.)\n- CMM(Capability Maturity Model - Модель Зрелости Процессов)/CMMI(Capability Maturity Model Integration - Интегрированная Модель Зрелости Процессов)\n\n**Национальные**\n- ГОСТ (применяется на уровне СНГ)\n- ГОСТ Р(РФ), СТБ(Беларуссия), ДСТУ(Украина)\n- BS (British Standard - применяются в Европе)\n\n**Отраслевые** (межнациональные)\n- DO-178B\n\n**Псевдостандарты - \"Стандарты де-факто\"** - стандарты которые были разработаны некоторыми организациями, а потом широко распространились среди какой то отрасли и(или) среди какой-то группы специалистов.\n- PMBOK - Project Menegement Body Of Knoledge, SWEBOK - SoftWare Enginering Body Of Knoledge\nНе имеют юридической силы. Могут иногда использоваться для сертификации, но эта сертификация не очень формальная и держится на уважении к какой-то организации.\n\n**Локальные стандарты внутри организации**\n- регламенты, правила, методики\n\nИмеют для отдельно взятой организации такую же силу как и внешние стандарты. Чаще всего разрабатываются на основе какого-то общепринятого стандарта, модифицированного под нужды конкретной организации.\n\n**Модели**\n- MSF, RUP, XP\n\n**Стандарты для людей**\n- ISTQB - International Software Testing Qualifications Board - подтверждает, что человек(специалист) обладает нужными характеристиками.\n\n## Определение качества ПО по международным стандартам\n\n### ISO/IEC 25010:2011 (ГОСТ Р ИСО/МЭК 25010-2015) Systems and software Quality Requirements and Evaluation (SQuaRE) - Продуктовый стандарт\n#### Требования и оценка качества систем и программного обеспечения (SQuaRE). Модели качества систем и программных продуктов\n\nСерия международных стандартов **_ISO/IEC 25000_**, также известных как _SQuaRE (System and Software Quality Requirements and Evaluation)_, определяет характеристики, по которым оценивается качество программного продукта.\n\nОбновленный стандарт **_ISO/IEC 25010_** содержит терминологию для определения, измерения и оценки качества систем и программных продуктов.  \nОн представляет восемь характеристик качества программного обеспечения, среди которых:   \n- функциональная пригодность\n- уровень производительности\n- совместимость \n- удобство использования\n- надежность\n- безопасность\n- удобство сопровождения\n- портативность\n\nСтандарт _ISO/IEC 25010_ является серьезным пересмотром стандарта _ISO/IEC 9126_. В новый стандарт добавлены дополнительные характеристики и подхарактеристики, которые более подробно описывают процесс качества программного продукта, а также введены уточнения и перегруппировка характеристик для более ясного их понимания.\n\n**Качество программного обеспечения (software quality)**: Степень удовлетворения программным продуктом заявленных и подразумеваемых потребностей при использовании в указанных условиях.\n\n### 1061-1998 IEEE Standard for Software Quality Metrics Methodology\nКачество программного обеспечения - это степень, в которой ПО обладает требуемой комбинацией свойств.\n\n\n### ISO 9000:2000 Quality Management and Quality Assurance\nКачество программного обеспечения - совокупность свойств и характеристик продукции или услуги, которые придают им способность удовлетворять обусловленные или предполагаемые потребности потребителя.\n\n## Характеристики качества ПО по стандарту ISO/IEC 25010\n\n1. **Функциональная Пригодность (Functional Suitability)**\n\nСтепень, в которой продукт или система обеспечивают выполнение функции в соответствии с заявленными и подразумеваемыми потребностями при использовании в указанных условиях.\n\n- **_функциональная полнота (functional completeness)_**: Степень покрытия совокупностью функций всех определенных задач и целей пользователя.\n- **_функциональная корректность (functional correctness)_**: Степень обеспечения продуктом или системой необходимой степени точности корректных результатов.\n- **_функциональная целесообразность (functional appropriateness)_**: Степень функционального упрощения выполнения определенных задач и достижения целей.\n\n_Пример:_ Для решения задачи пользователю предоставляется возможность выполнять только необходимые шаги, исключая любые ненужные.\n\n2. **Уровень Производительности (Performance Efficiency)**\n\nПроизводительность относительно суммы использованных при определенных условиях ресурсов[^Ресурсы могут включать в себя другие программные продукты, конфигурацию программного и аппаратного обеспечения системы и материалы (например, бумагу для печати, носители)].\n\n- **_временные характеристики (time behaviour)_**: Степень соответствия требованиям по времени отклика, времени обработки и показателей пропускной способности продукта или системы.\n- **_использование ресурсов (resource utilization)_**: Степень удовлетворения требований по потреблению объемов и видов ресурсов продуктом или системой при выполнении их функций.\n- **_потенциальные возможности (capacity)_**: Степень соответствия требованиям предельных значений параметров[^В качестве параметров могут быть возможное количество сохраняемых элементов, количество параллельно работающих пользователей, емкость канала, пропускная способность по транзакциям и размер базы данных] продукта или системы.\n\n3. **Совместимость (Compatibility)**\n\nСпособность продукта, системы или компонента обмениваться информацией с другими продуктами, системами или компонентами, и/или выполнять требуемые функции при совместном использовании одних и тех же аппаратных средств или программной среды.\n\n- **_сосуществование (совместимость) (co-existence)_**: Способность продукта совместно функционировать с другими независимыми продуктами в общей среде с разделением общих ресурсов и без отрицательного влияния на любой другой продукт.\n- **_функциональная совместимость (интероперабельность) (interoperability)_**: Способность двух или более систем, продуктов или компонент обмениваться информацией и использовать такую информацию.\n\n4. **Удобство Использования (Usability)**\n\nСтепень, в которой продукт или система могут быть использованы определенными пользователями для достижения конкретных целей с эффективностью, результативностью и удовлетворенностью в заданном контексте использования.\n\n- **_определимость пригодности (appropriateness recognizability)_**: Возможность пользователей понять, подходит ли продукт или система для их потребностей, сравним ли с функциональной целесообразностью (functional appropriateness).\nОпределимость пригодности зависит от возможности распознать уместность продукта или функций системы от первоначальных впечатлений о продукте или системе и/или от какой-либо связанной с ними документации.\n- **_изучаемость (learnability)_**: Возможность использования продукта или системы определенными пользователями для достижения конкретных целей обучения для эксплуатации продукта или системы с эффективностью, результативностью, свободой от риска и в соответствии с требованиями в указанном контексте использования.\n- **_управляемость (operability)_**: Наличие в продукте или системе атрибутов, обеспечивающих простое управление и контроль.\n- **_защищенность от ошибки пользователя (user error protection)_**: Уровень системной защиты пользователей от ошибок.\n- **_эстетика пользовательского интерфейса (user interface aesthetics)_**: Степень \"приятности\" и \"удовлетворенности\" пользователя интерфейсом взаимодействия с пользователем.\n- **_доступность (accessibility)_**: Возможность использования продукта или системы для достижения определенной цели в указанном контексте использования широким кругом людей с самыми разными возможностями[^В диапазон возможностей входят ограничения возможностей, связанные с возрастом].\n\n5. **Надежность (Reliability)**\n\nСтепень выполнения системой, продуктом или компонентом определенных функций при указанных условиях в течение установленного периода времени.\nВ программном обеспечении износа не происходит. Проблемы с надежностью возникают из-за недостатков в требованиях, при разработке и реализации или из-за изменений условий использования.\n\n- **_завершенность (maturity)_**: Степень соответствия системы, продукта или компонента при нормальной работе требованиям надежности.\n- **_готовность (availability)_**: Степень работоспособности и доступности системы, продукта или компонента.\nВ общем, готовность можно оценить как долю общего времени, в течение которого система, продукт или компонент находятся в работающем состоянии. Готовность, таким образом, определяется сочетанием завершенности, которая определяет частоту отказов, отказоустойчивости и восстанавливаемости, которая, в свою очередь, определяет продолжительность времени бездействия после каждого отказа.\n- **_отказоустойчивость (fault tolerance)_**: Способность системы, продукта или компонента работать как предназначено, несмотря на наличие дефектов программного обеспечения или аппаратных средств.\n- **_восстанавливаемость (recoverability)_**: Способность продукта или системы восстановить данные и требуемое состояние системы в случае прерывания или сбоя.\nВ некоторых случаях после сбоя вычислительная система находится в нерабочем состоянии некоторое время, продолжительность которого определяется ее восстанавливаемостью.\n\n6. **Защита, защищенность (Security)**\n\nСтепень защищенности информации и данных, обеспечиваемая продуктом или системой путем ограничения доступа людей, других продуктов или систем к данным в соответствии с типами и уровнями авторизации.\n\nЗащищенность применима также и к данным при передаче в случаях, когда данные сохраняются непосредственно в продукте или системе или вне их.\n\n_Жизнестойкость (survivability)_ (степень, в которой продукт или система продолжают выполнять свою миссию, предоставляя основные услуги своевременно, несмотря на присутствие атак) обеспечивается восстанавливаемостью.\n\n_Защищенность, иммунитет (immunity)_ (степень устойчивости продукта или системы к атакам) обеспечивается целостностью.\n\n_Защищенность (security)_ вносит свой вклад в доверие (trust).\n\n\n- **_конфиденциальность (confidentiality)_**: Обеспечение продуктом или системой ограничения доступа к данным только для тех, кому доступ разрешен.\n- **_целостность (integrity)_**: Степень предотвращения системой, продуктом или компонентом несанкционированного доступа или модификации компьютерных программ или данных.\n- **_неподдельность (non-repudiation)_**: Степень, с которой может быть доказан факт события или действия таким образом, что этот факт не может быть отвергнут когда-либо позже.\n- **_отслеживаемость (accountability)_**: Степень, до которой действия объекта могут быть прослежены однозначно.\n- **_подлинность (authenticity)_**: Степень достоверности тождественности объекта или ресурса требуемому объекту или ресурсу.\n\n7. **Сопровождаемость, модифицируемость (Maintainability)**\n\nРезультативность и эффективность, с которыми продукт или система могут быть модифицированы предполагаемыми специалистами по обслуживанию.\n\nМодификация может включать в себя исправления, улучшения или адаптацию программного обеспечения к изменениям в условиях использования, в требованиях и функциональных спецификациях. Модификации могут быть выполнены как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\n\nСопровождаемость включает в себя установку разного рода обновлений.\n\nСопровождаемость можно интерпретировать либо как присущее продукту или системе свойство, упрощающее процесс обслуживания, либо как качество при использовании, проверенное на практике специалистами по обслуживанию в целях поддержки продукта или системы.\n\n- **_модульность (modularity)_**: Степень представления системы или компьютерной программы в виде отдельных блоков таким образом, чтобы изменение одного компонента оказывало минимальное воздействие на другие компоненты.\n- **_возможность многократного использования (reusability)_**: Степень, в которой актив может быть использован в нескольких системах или в создании других активов.\n- **_анализируемость (analysability)_**: Степень простоты оценки влияния изменений одной или более частей на продукт или систему или простоты диагностики продукта для выявления недостатков и причин отказов, или простоты идентификации частей, подлежащих изменению.\n Конкретная реализация продукта или системы может включать в себя механизмы анализа собственных дефектов и формирования отчетов об отказах и других событиях.\n- **_модифицируемость (modifiabiIity)_**: Степень простоты эффективного и рационального изменения продукта или системы без добавления дефектов и снижения качества продукта.\n  - Реализация модификации включает в себя кодирование, разработку, документирование и проверку изменений.\n  - Модульность и анализируемость могут оказывать влияние на модифицируемость.\n  - Модифицируемость - это сочетание изменяемости и устойчивости.\n- **_тестируемость (testability)_**: Степень простоты эффективного и рационального определения для системы, продукта или компонента критериев тестирования, а также простоты выполнения тестирования с целью определения соответствия этим критериям.\n\n8. **Переносимость, мобильность (Portability)**\n\nСтепень простоты эффективного и рационального переноса системы, продукта или компонента из одной среды (аппаратных средств, программного обеспечения, операционных условий или условий использования) в другую.\n\nПереносимость можно интерпретировать либо как присущее продукту или системе свойство продукта или системы, упрощающее процесс переноса, либо как качество при использовании, предназначенное для переноса продукта или системы.\n\n- **_адаптируемость (adaptability)_**: Степень простоты эффективной и рациональной адаптации для отличающихся или усовершенствованных аппаратных средств, программного обеспечения, других операционных сред или условий использования.\nВ адаптируемость входит и масштабируемость внутренних потенциальных возможностей (например, экранных полей, таблиц, объемов транзакции, форматов отчетов и т.д.).\nАдаптация может быть выполнена как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\nЕсли система должна быть адаптирована конечным пользователем, то адаптируемость соответствует пригодности для индивидуализации, как это определено в ИСО 9241-110.\n- **_устанавливаемость (installability)_**: Степень простоты эффективной и рациональной, успешной установки и/или удаления продукта или системы в заданной среде.\nВ случае если продукт или система должны устанавливаться конечным пользователем, устанавливаемость может повлиять на результирующие функциональную целесообразность и управляемость.\n- **_взаимозаменяемость (replaceability)_**: Способность продукта заменить другой конкретный программный продукт для достижения тех же целей в тех же условиях.\nВзаимозаменяемость новой версии программного продукта важна для пользователя при обновлении продукта.\nВо взаимозаменяемость могут быть включены атрибуты как устанавливоемости, так и адаптируемости. Понятие было введено как отдельная подхарактеристика из-за ее важности.\nВзаимозаменяемость снижает риск блокировки таким образом, что, например, при стандартизации форматов файлов допускается применение других программных продуктов вместо используемого.\n\n\n\n#### Источники информации\n\n1. ❗ [ГОСТ Р ИСО/МЭК 25010-2015](https://docs.cntd.ru/document/1200121069)\n\n2. ❗ [Тестирование ПО: Стандарты в области тестирования и их применение на практике](https://youtu.be/kUvPuJuPI-g)\n\n#### Дополнительно можно посмотреть:\n\n❗ [Computer Science Center: Лекция 13. Качество ПО](https://youtu.be/zAxGTb0FFR0)\n","category":"manual","description":"Рассматриваем классификацию международных стандартов качества и характеристики качества по стандарту ISO/IEC 25010"},{"title":"Жизненный цикл дефекта","path":"/zhiznennyj-czikl-defekta/","content":"\n## Дефекты и ошибки (error/defect(bug)/failure)\n\n### Дефект/Баг (Bug)\n\nНесовершенство или недостаток рабочего продукта, проявляющееся в несоответствии требованиям или спецификациям. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82)]\n\n### Ошибка (Error)\n\nДействие человека, которое приводит к неправильному результату. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)]  \n_Пример: пользователь вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.)._\n\n### Отказ (Failure)\n\nСобытие, при котором компонент или система не выполняют требуемую функцию в соответствии со спецификацией. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%82%D0%BA%D0%B0%D0%B7)]  \n_Примет: аппаратный сбой, который не связан с работой самого продукта но приводящий к его не корректной работе._\n\nТак что же такое баг на практике? Когда мы имеем ситуацию “1 требование = 1 тест-кейс”, то вопрос отпадает сам собой - тест-кейс не прошёл, значит требование реализовано не правильно, значит баг. Но обычно вариантов куда больше:\n\n* работало, но вдруг перестало;\n* работает, но неправильно;\n* реализация не соответствует описанию и в задаче в явном виде не зафиксированы корректировки;\n* нужно изменить название кнопки/страницы/раздела, потому что в них есть опечатка или “Отменить отмену” (классика!);\n* опечатки в принципе (легко может иметь разный приоритет в зависимости от целей и задач проекта);\n* после сохранения информация не появляется на странице, даже если в консоли 200 ОК;\n* не все указанные при сохранении поля отображаются на странице, но поля неизменно показываются при редактировании;\n* при нажатии на кнопку “УДАЛИТЬ ВООБЩЕ ВСЕ ДАННЫЕ КЛИЕНТА” нет модального окна с подтверждением Да/Нет, да и сделать это может любой пользователь без авторизации, который нашел ссылку;\n* по переходу по прямой ссылке на услугу не проверяется какой пользователь сейчас авторизован и таким образом можно посмотреть чужие профили или детали услуг, если подобран валидный id;\n* можно cURL’ом заказать услугу другому клиенту или в Elements через DevTools изменить стоимость в корзине (не проворачивайте такие сценарии не на своих рабочих проектах);\n* информация торчит за границами своего блока или “наслаивается” на другой (ж-ж-ж-жуть, но на некоторых проектах этим можно легко пренебречь);\n* страница очень долго открывается, ну о-о-очень долго - секунд 30 на стабильном интернете (взбешенный клиент гарантирован);\n* система делает что-то, что она не должна делать согласно изначальной задумке. Например, закрытие аккаунта не только переводит его в статус “Закрыто”, но и возвращает клиенту все деньги, которые он принес проекту за всё время сотрудничества за уже оказанные услуги (о-о-ой!);\n* неудобно пользоваться. Например, чтобы посмотреть детали услуги клиента, нужно зайти на три вкладки вглубь аккаунта, а смотреть нужно 2-3 раза в день. Или неудобно копировать информацию со страницы, а по рабочим вопросам это нужно делать несколько раз в день - это баг интерфейса и он должен быть исправлен.\n\nПри этом часто может возникнуть извечный вопрос “баг или фича?”, когда баг-репорт заводить не нужно. Это фича-реквест, если:\n\n* нужно изменить название кнопки/страницы/раздела, потому что есть ощущение, что оно не отражает действительности;\n* фичу сделали, но после использования видно, что есть простор для существенных улучшений. Например, по услуге не хватает мониторинга или статистических данных по использованию, а за перерасход может взиматься дополнительная плата - клиент точно будет несчастлив в неведении;\n* знаете как улучшить ту или иную часть системы, чтобы было удобней. Например, меню необоснованно занимает 30% ширины экрана, а полезная информация ютится на оставшихся 70%;\n* пользователь регулярно делает рутинные монотонные действия, которые можно автоматизировать. Например, копировать однотипную информацию с 12 страниц пагинации, когда простая выгрузка бы решила проблему;\n* изобретаете велосипед из действующих фич продукта, чтобы добиться желаемого результата;\n* на странице не хватает какой-то информации или возможности её добавить;\n* на странице не хватает фильтров и пагинации, когда информации много и трудно найти нужное или отображение 1000+ элементов существенно сказывается на скорости загрузки страницы;\n* пользователь ведет дополнительную отчетность в блокноте/экселе, когда проблему можно решить выводом ID на странице и несколькими фильтрами.\n\nХорошо если в команде есть UX/UI дизайнер, а если нет? Тестировщику стоит различать что в дизайне баг, который может привести к печальным последствиям, а что запрос на улучшение, который сделает взаимодействие пользователей с системой более гладким и удобным, но может быть реализован позднее.\n\n## Классификация дефектов\n\nДефекты можно классифицировать по-разному. Для организации важно следовать единой схеме классификации и применять ее ко всем проектам. Некоторые дефекты можно отнести к нескольким классам или категориям. Из-за этой проблемы разработчики, тестировщики и сотрудники SQA должны стараться быть максимально последовательными при записи данных о дефектах.\n\n### Дефекты требований и спецификаций (Requirements and Specifications Defects)\nНачало жизненного цикла программного обеспечения важно для обеспечения высокого качества разрабатываемого программного обеспечения. Дефекты, введенные на ранних этапах, очень трудно устранить на более поздних этапах. Поскольку многие документы с требованиями написаны с использованием представления на естественном языке, они могут стать\n\n* Двусмысленными;\n* Противоречивыми;\n* Непонятными;\n* Избыточными;\n* Неточными.\n\nНекоторые специфические дефекты требований / спецификаций:\n\n* **Дефекты функционального описания:** Общее описание того, что делает продукт и как он должен себя вести (входы / выходы), неверно, двусмысленно и / или неполно;\n* **Дефекты функций:** описываются как отличительные характеристики программного компонента или системы. Дефекты функций связаны с отсутствием, неправильным, неполным или ненужным описанием функций;\n* **Дефекты взаимодействия функций:** это происходит из-за неправильного описания того, как функции должны взаимодействовать друг с другом;\n* **Дефекты описания интерфейсов:** это дефекты, которые возникают в описании взаимодействия целевого программного обеспечения с внешним программным обеспечением, оборудованием и пользователями.\n\n### Дефекты дизайна\nДефекты дизайна возникают когда неправильно спроектированы: Системные компоненты, Взаимодействие между компонентами системы, Взаимодействие между компонентами и внешним программным / аппаратным обеспечением или пользователями. Они включают дефекты в конструкции алгоритмов, управления, логики, элементов данных, описаний интерфейсов модулей и описаний внешнего программного обеспечения / оборудования / пользовательского интерфейса. К дефектам дизайна относятся:\n  * **Алгоритмические дефекты и дефекты обработки:** это происходит, когда этапы обработки в алгоритме, описанном псевдокодом, неверны;\n  * **Дефекты управления, логики и последовательности:** Дефекты управления возникают, когда логический поток в псевдокоде неверен;\n  * **Дефекты данных:** Они связаны с неправильным дизайном структур данных;\n  * **Дефекты описания интерфейсов модулей:** эти дефекты возникают из-за неправильного или непоследовательного использования типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * **Дефекты функционального описания:** к дефектам этой категории относятся неправильные, отсутствующие или неясные элементы дизайна;\n  * **Дефекты описания внешних интерфейсов:** они возникают из-за неправильных описаний дизайна интерфейсов с компонентами COTS, внешними программными системами, базами данных и аппаратными устройствами.\n\n### Дефекты кода\nДефекты кодирования возникают из-за ошибок при реализации кода. Классы дефектов кодирования аналогичны классам дефектов дизайна. Некоторые дефекты кодирования возникают из-за непонимания конструкций языка программирования и недопонимания с разработчиками.\n  * **Алгоритмические дефекты и дефекты обработки:**\n    * Непроверенные условия overflow and underflow;\n    * Сравнение несоответствующих типов данных;\n    * Преобразование одного типа данных в другой;\n    * Неправильный порядок арифметических операторов;\n    * Неправильное использование или пропуск круглых скобок;\n    * Потеря точности (Precision loss);\n    * Неправильное использование знаков.\n  * **Дефекты управления, логики и последовательности:** этот тип дефектов включает неправильное выражение операторов case, неправильное повторение циклов и пропущенные пути;\n  * **Типографические дефекты:** в основном это синтаксические ошибки, например неправильное написание имени переменной, которые обычно обнаруживаются компилятором, self-reviews, or peer reviews;\n  * **Дефекты инициализации:** этот тип дефектов возникает, когда операторы инициализации пропущены или неверны. Это может произойти из-за недопонимания или отсутствия связи между программистами или программиста и дизайнера, небрежности или непонимания среды программирования;\n  * **Дефекты потока данных:** дефекты потока данных возникают, когда код не следует необходимым условиям потока данных;\n  * **Дефекты данных:** на это указывает неправильная реализация структур данных;\n  * **Дефекты интерфейса модуля:** возникают из-за использования неправильных или несовместимых типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * **Дефекты документации кода:** когда документация по коду не описывает, что программа на самом деле делает, либо является неполной или двусмысленной;\n  * **Внешнее оборудование, дефекты программных интерфейсов:** эти дефекты возникают из-за проблем, связанных с Системными вызовами, Ссылками на базы данных, Последовательностью ввода / вывода, Использованием памяти, Использованием ресурсов, Обработкой прерываний и исключений, Обменом данными с оборудованием, Протоколами, Форматами, Интерфейсами с файлами сборки, Временными последовательностями.\n\n### Дефекты тестирования\nПланы тестирования, тестовые наборы, средства тестирования и процедуры тестирования также могут содержать дефекты. Эти дефекты называются дефектами тестирования. Дефекты в планах тестирования лучше всего обнаруживать с помощью методов review.\n  * **Дефекты тестовой обвязки:** Для тестирования программного обеспечения на уровне модулей и интеграции необходимо разработать вспомогательный код. Это называется Test Harness или scaffolding code. Test Harness должен быть тщательно спроектирован, реализован и протестирован, поскольку это рабочий продукт, и этот код можно повторно использовать при разработке новых версий программного обеспечения;\n  * **Дизайн тестового случая и дефекты процедуры тестирования:** сюда входят неправильные, неполные, отсутствующие, несоответствующие тестовые примеры и процедуры тестирования.\n\n## Жизненный цикл дефекта (Defect/Bug Life Cycle)\n\n**Жизненный цикл дефекта** - это представление различных состояний дефекта, в которых он пребывает от начального до конечного этапа своего существования. Он может варьироваться от компании к компании и настраиваться под процессы конкретного проекта.\n\n![https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png](https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png)\n\n### Статусы дефекта\n\n* **Новый** (New): когда новый дефект регистрируется и публикуется впервые;\n* **Назначен** (Assigned): после публикации бага тестировщиком руководитель тестировщика утверждает ошибку и передает ее команде разработчиков;\n* **Открыт** (Open): разработчик начинает анализ и работает над исправлением бага;\n* **Исправлен** (Fixed): разработчик внес необходимое изменение в код и проверил его;\n* **Ожидает повторного тестирования** (Pending retest): как только дефект будет исправлен, разработчик предоставляет тестировщику конкретный код для повторного тестирования кода. Поскольку тестирование программного обеспечения остается незавершенным со стороны тестировщиков, ему присваивается статус «ожидает повторного тестирования»;\n* **Повторное тестирование** (Retest): на этом этапе тестировщик выполняет повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком;\n* **Проверен** (Verified): тестировщик повторно тестирует баг после его исправления разработчиком. Если баг исправлен, то присваивается статус «проверено»;\n* **Переоткрыт** (Reopen): если баг сохраняется даже после того, как разработчик исправил баг, тестировщик меняет статус на «повторно открыт». И снова баг проходит жизненный цикл.\n* **Закрыт** (Closed): если баг больше не существует, тестировщик присваивает статус «Закрыто».\n* **Дубль** (Duplicate): если дефект повторяется дважды или дефект соответствует той же концепции ошибки, статус изменяется на «дублировать».\n* **Отклонен** (Rejected): если разработчик считает, что дефект не является таковым, он меняет статус на «отклонен»;\n* **Отложен** (Deferred): если текущий баг не является приоритетным и ожидается, что он будет исправлен ​​в следующем выпуске, таким багам присваивается статус «Отложено»;\n* **Не является багом** (Not a bug): если это не влияет на функциональность приложения, то багу присваивается статус «Не является багом».\n\n![https://www.guru99.com/images/defectcyclechart.png](https://www.guru99.com/images/defectcyclechart.png)\n\n### Утечка дефектов и релиз бага (Bug Leakage & Bug Release)\n\nУтечка бага (Bug Leakage): возникает когда пропускается баг в билде, который вышел в Production. Если баг был обнаружен конечным пользователем или заказчиком, мы называем это утечкой ошибок.\n\nВыпуск бага (Bug release): выпуск программного обеспечения в Production с некоторыми известными багами. Эти известные баги следует включить в примечания к выпуску (release notes). Другой вариант - передача программного обеспечения группе тестирования с некоторыми известными багами, серьезность и приоритет которых невысоки. Эти ошибки можно исправить перед выпуском в Production.\n\n### Основное отличие отладки от тестирования (Debugging) Vs. Testing\n\nПосле того, как разработчик получил баг-репорт, он приступает к исправлению бага. Но, прежде чем ошибку исправить, нужно ее воспроизвести, понять, как она происходит и где ее найти в коде. Дебаг, буквально “de”+”bug” - это и есть процесс поиска и устранения ошибок в коде. Специальная debug-версия билда приложения может иметь расширенный вывод для более информативных логов или любые другие модификации для упрощения понимания проблемы. Тактика отладки может включать интерактивную отладку, анализ потока управления, модульное тестирование, интеграционное тестирование, анализ логов, мониторинг на уровне приложения или системы, дампы памяти и профилирование. Многие языки программирования и инструменты разработки программного обеспечения также предлагают программы для помощи в отладке, известные как отладчики/дебаггеры.\n\n❗ [see video](https://www.youtube.com/watch?v=URH45Vx08n4)\n\n### Маскировка дефектов (Defect masking)\n\n_Маскирование дефектов (defect masking): Случай, когда один дефект препятствует нахождению другого. (IEEE 610)_\n\n### Скрытый дефект (Latent defect)\n\nДефект, который является существующим дефектом в системе, но еще не вызывал сбоев, поскольку подходящий набор входных данных для его проявления не был введен или его проявлению мешает другой дефект (Defect masking).\n\n### Сортировка дефектов (Bug triage)\n\nЭто формальный процесс определения серьезности и приоритета дефектов в зависимости от их severity, риска, повторяемости и т. д. во время Defect Triage Meeting. Такая встреча полезна в условиях ограниченных ресурсов, когда нужно разобраться с множеством ошибок и тем, какие из них приоритетные.\n\nПонятие сортировки пришло из медицины, где это процесс быстрого обследования пациентов, доставленных в больницу, чтобы решить, какие из них наиболее серьезно больны и нуждаются в лечении в первую очередь. В тестировании мы используем ту же концепцию к ошибкам, обнаруженным на этапе тестирования.\n\n### Подсев недочетов (fault seeding)\n\n_Процесс намеренного внесения дефектов в дополнение к тем, что уже существуют в компоненте или в системе, для целей отслеживания уровня обнаружения и устранения, а также оценивания количества оставшихся в системе дефектов. Подсев недочетов обычно является частью процесса тестирования разработки и может применяться на любом уровне тестирования (компонентном, интеграционном или системном). (IEEE 610)_\n\n## Валидация vs верификация \n\n### Верификация (Verification)\n\nДоказанное объективными результатами исследования подтверждение того, что определенные требования (спецификации, формальные требования) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Валидация (Validation)\n\nДоказанное объективными результатами исследования подтверждение того, что требования для ожидаемого конкретного использования приложения (соответствие ожиданиям и требованиям пользователей) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Пример\nЕсли попробовать привести очень упрощенный пример, представим блюдо в ресторане. Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.\n\n## Priority vs Severity\n\n### Приоритет (Priority)\n\nСтепень важности, присваеваемая объекту. Например, дефекту или задаче. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82)]  \nУказывает на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект. Выставляется менеджером, тимлидом или заказчиком.\n\n**Градация Приоритета дефекта (Priority):**\n- **_P1 Высокий (High)_**  \nОшибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.\n- **_P2 Средний (Medium)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.\n- **_P3 Низкий (Low)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.\n\n### Критичность/Серьезность (Severity)\n\nВажность воздействия конкретного дефекта на разработку или функционирование компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)]  \nХарактеризует влияние дефекта на работоспособность приложения. Выставляется тестировщиком.\n\n**Градация Критичности дефекта (Severity)**\n\n- **_S1 Блокирующая (Blocker)_**  \nБлокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.\n\n- **_S2 Критическая (Critical)_**  \nКритическая ошибка, неправильно работающая ключевая бизнес логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с ключевыми функциями тестируемой системой.\n\n- **_S3 Значительная (Major)_**  \nЗначительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.\n\n- **_S4 Незначительная (Minor)_**  \nНезначительная ошибка, не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.\n\n- **_S5 Тривиальная (Trivial)_**  \nТривиальная ошибка, не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.\n\n\n### Сочетания Severity и Priority\n\n- **High Priority and High Severity**  \nЛюбой Critical/major сбой бизнес-модели, критическая проблема, при которой полностью не работает большая часть функциональности или основной компонент системы:\n  - нажатие на определенную кнопку не запускает саму функцию, например, не работает кнопка отправки на странице входа, и клиенты не могут войти в приложение;\n  - выполнение определенной функции постоянно приводит к 500 ошибке сервера и потере данных;\n  - система дает сбой после того, как вы совершили платеж или когда вы не можете добавить товары в корзину;\nфункция банкомата, при которой после ввода правильного имени пользователя и пароля автомат не выдает деньги, но списывает их с вашего счета;\n  - на веб-сайте банка появляется сообщение об ошибке, когда клиент нажимает кнопку перевода денег.\n\n- **High Priority and Low Severity**  \nЛюбые minor severity дефекты, которые влияют на взаимодействие с пользователями / репутацию:\n  - ожидается, что функция покажет пользователю конкретную ошибку по коду ответа. В этом случае функционально код выдает ошибку, но сообщение должно быть более релевантным коду;\n  - ошибка в логотипе или названии компании на главной странице, или опечатки, бросающиеся в глаза и способные повлиять на репутацию компании;\n  опечатки в контактных данных;\n  - важные ошибки в соглашениях и юридических документах.\n\n- **Low Priority and High Severity**  \nПроблема, которая пока не повлияет на бизнес, но имеет большое влияние с точки зрения функциональности:\n  - присутствует серьезный баг, но есть workaround и исправление уже может быть запланировано в следующем релизе или функция будет удалена;\n  - функция генерации годового отчета, которая будет использована только через полгода;\n  - редкость проявления дефекта/сложность воспроизведения для юзеров.\n\n- **Low Priority and Low Severity**  \nЛюбые орфографические ошибки / начертание / несовпадение шрифта в абзаце 3-й или 4-й страницы заявки, а не на главной или титульной странице / заголовке. Эти дефекты возникают, когда это не влияет на функциональность, но все же в небольшой степени не соответствует стандартам. Обычно сюда классифицируются косметические ошибки или, скажем, размеры ячейки в таблице пользовательского интерфейса:\n  - в политике конфиденциальности веб-сайта есть орфографическая ошибка;\n  - страница часто задаваемых вопросов загружается очень долго;\n  - семейство шрифтов, размер шрифта, цвет или орфографическая ошибка в приложении или отчетах.","category":"manual","description":"Жизненный цикл дефекта"},{"title":"Жизненный цикл дефекта","path":"/zhiznennyj-czikl-defekta/","content":"\nhttps://www.youtube.com/watch?v=6YrgKBTzb5o\n\n## Дефекты и ошибки (error/defect(bug)/failure)\n\n### Дефект/Баг (Bug)\n\nНесовершенство или недостаток рабочего продукта, проявляющееся в несоответствии требованиям или спецификациям. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82)]\n\n### Ошибка (Error)\n\nДействие человека, которое приводит к неправильному результату. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)]  \n_Пример: пользователь вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.)._\n\n### Отказ (Failure)\n\nСобытие, при котором компонент или система не выполняют требуемую функцию в соответствии со спецификацией. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%82%D0%BA%D0%B0%D0%B7)]  \n_Примет: аппаратный сбой, который не связан с работой самого продукта но приводящий к его не корректной работе._\n\nТак что же такое баг на практике? Когда мы имеем ситуацию “1 требование = 1 тест-кейс”, то вопрос отпадает сам собой - тест-кейс не прошёл, значит требование реализовано не правильно, значит баг. Но обычно вариантов куда больше:\n\n* работало, но вдруг перестало;\n* работает, но неправильно;\n* реализация не соответствует описанию и в задаче в явном виде не зафиксированы корректировки;\n* нужно изменить название кнопки/страницы/раздела, потому что в них есть опечатка или “Отменить отмену” (классика!);\n* опечатки в принципе (легко может иметь разный приоритет в зависимости от целей и задач проекта);\n* после сохранения информация не появляется на странице, даже если в консоли 200 ОК;\n* не все указанные при сохранении поля отображаются на странице, но поля неизменно показываются при редактировании;\n* при нажатии на кнопку “УДАЛИТЬ ВООБЩЕ ВСЕ ДАННЫЕ КЛИЕНТА” нет модального окна с подтверждением Да/Нет, да и сделать это может любой пользователь без авторизации, который нашел ссылку;\n* по переходу по прямой ссылке на услугу не проверяется какой пользователь сейчас авторизован и таким образом можно посмотреть чужие профили или детали услуг, если подобран валидный id;\n* можно cURL’ом заказать услугу другому клиенту или в Elements через DevTools изменить стоимость в корзине (не проворачивайте такие сценарии не на своих рабочих проектах);\n* информация торчит за границами своего блока или “наслаивается” на другой (ж-ж-ж-жуть, но на некоторых проектах этим можно легко пренебречь);\n* страница очень долго открывается, ну о-о-очень долго - секунд 30 на стабильном интернете (взбешенный клиент гарантирован);\n* система делает что-то, что она не должна делать согласно изначальной задумке. Например, закрытие аккаунта не только переводит его в статус “Закрыто”, но и возвращает клиенту все деньги, которые он принес проекту за всё время сотрудничества за уже оказанные услуги (о-о-ой!);\n* неудобно пользоваться. Например, чтобы посмотреть детали услуги клиента, нужно зайти на три вкладки вглубь аккаунта, а смотреть нужно 2-3 раза в день. Или неудобно копировать информацию со страницы, а по рабочим вопросам это нужно делать несколько раз в день - это баг интерфейса и он должен быть исправлен.\n\nПри этом часто может возникнуть извечный вопрос “баг или фича?”, когда баг-репорт заводить не нужно. Это фича-реквест, если:\n\n* нужно изменить название кнопки/страницы/раздела, потому что есть ощущение, что оно не отражает действительности;\n* фичу сделали, но после использования видно, что есть простор для существенных улучшений. Например, по услуге не хватает мониторинга или статистических данных по использованию, а за перерасход может взиматься дополнительная плата - клиент точно будет несчастлив в неведении;\n* знаете как улучшить ту или иную часть системы, чтобы было удобней. Например, меню необоснованно занимает 30% ширины экрана, а полезная информация ютится на оставшихся 70%;\n* пользователь регулярно делает рутинные монотонные действия, которые можно автоматизировать. Например, копировать однотипную информацию с 12 страниц пагинации, когда простая выгрузка бы решила проблему;\n* изобретаете велосипед из действующих фич продукта, чтобы добиться желаемого результата;\n* на странице не хватает какой-то информации или возможности её добавить;\n* на странице не хватает фильтров и пагинации, когда информации много и трудно найти нужное или отображение 1000+ элементов существенно сказывается на скорости загрузки страницы;\n* пользователь ведет дополнительную отчетность в блокноте/экселе, когда проблему можно решить выводом ID на странице и несколькими фильтрами.\n\nХорошо если в команде есть UX/UI дизайнер, а если нет? Тестировщику стоит различать что в дизайне баг, который может привести к печальным последствиям, а что запрос на улучшение, который сделает взаимодействие пользователей с системой более гладким и удобным, но может быть реализован позднее.\n\n**Классификация дефектов**\n\nДефекты можно классифицировать по-разному. Для организации важно следовать единой схеме классификации и применять ее ко всем проектам. Некоторые дефекты можно отнести к нескольким классам или категориям. Из-за этой проблемы разработчики, тестировщики и сотрудники SQA должны стараться быть максимально последовательными при записи данных о дефектах.\n\n**Классы дефектов**:\n\n*   **Дефекты требований и спецификаций** (Requirements and Specifications Defects): Начало жизненного цикла программного обеспечения важно для обеспечения высокого качества разрабатываемого программного обеспечения. Дефекты, введенные на ранних этапах, очень трудно устранить на более поздних этапах. Поскольку многие документы с требованиями написаны с использованием представления на естественном языке, они могут стать\n\n    * Двусмысленными;\n    * Противоречивыми;\n    * Непонятными;\n    * Избыточными;\n    * Неточными.\n\n    Некоторые специфические дефекты требований / спецификаций:\n\n    * Дефекты функционального описания: Общее описание того, что делает продукт и как он должен себя вести (входы / выходы), неверно, двусмысленно и / или неполно;\n    * Дефекты функций: описываются как отличительные характеристики программного компонента или системы. Дефекты функций связаны с отсутствием, неправильным, неполным или ненужным описанием функций;\n    * Дефекты взаимодействия функций: это происходит из-за неправильного описания того, как функции должны взаимодействовать друг с другом;\n    * Дефекты описания интерфейсов: это дефекты, которые возникают в описании взаимодействия целевого программного обеспечения с внешним программным обеспечением, оборудованием и пользователями.\n* **Дефекты дизайна**: Дефекты дизайна возникают когда неправильно спроектированы: Системные компоненты, Взаимодействие между компонентами системы, Взаимодействие между компонентами и внешним программным / аппаратным обеспечением или пользователями. Они включают дефекты в конструкции алгоритмов, управления, логики, элементов данных, описаний интерфейсов модулей и описаний внешнего программного обеспечения / оборудования / пользовательского интерфейса. К дефектам дизайна относятся:\n  * Алгоритмические дефекты и дефекты обработки: это происходит, когда этапы обработки в алгоритме, описанном псевдокодом, неверны;\n  * Дефекты управления, логики и последовательности: Дефекты управления возникают, когда логический поток в псевдокоде неверен;\n  * Дефекты данных: Они связаны с неправильным дизайном структур данных;\n  * Дефекты описания интерфейсов модулей: эти дефекты возникают из-за неправильного или непоследовательного использования типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * Дефекты функционального описания: к дефектам этой категории относятся неправильные, отсутствующие или неясные элементы дизайна;\n  * Дефекты описания внешних интерфейсов: они возникают из-за неправильных описаний дизайна интерфейсов с компонентами COTS, внешними программными системами, базами данных и аппаратными устройствами.\n* **Дефекты кода**: Дефекты кодирования возникают из-за ошибок при реализации кода. Классы дефектов кодирования аналогичны классам дефектов дизайна. Некоторые дефекты кодирования возникают из-за непонимания конструкций языка программирования и недопонимания с разработчиками.\n  * Алгоритмические дефекты и дефекты обработки:\n    * Непроверенные условия overflow and underflow;\n    * Сравнение несоответствующих типов данных;\n    * Преобразование одного типа данных в другой;\n    * Неправильный порядок арифметических операторов;\n    * Неправильное использование или пропуск круглых скобок;\n    * Потеря точности (Precision loss);\n    * Неправильное использование знаков.\n  * Дефекты управления, логики и последовательности: этот тип дефектов включает неправильное выражение операторов case, неправильное повторение циклов и пропущенные пути;\n  * Типографические дефекты: в основном это синтаксические ошибки, например неправильное написание имени переменной, которые обычно обнаруживаются компилятором, self-reviews, or peer reviews;\n  * Дефекты инициализации: этот тип дефектов возникает, когда операторы инициализации пропущены или неверны. Это может произойти из-за недопонимания или отсутствия связи между программистами или программиста и дизайнера, небрежности или непонимания среды программирования;\n  * Дефекты потока данных: дефекты потока данных возникают, когда код не следует необходимым условиям потока данных;\n  * Дефекты данных: на это указывает неправильная реализация структур данных;\n  * Дефекты интерфейса модуля: возникают из-за использования неправильных или несовместимых типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * Дефекты документации кода: когда документация по коду не описывает, что программа на самом деле делает, либо является неполной или двусмысленной;\n  * Внешнее оборудование, дефекты программных интерфейсов: эти дефекты возникают из-за проблем, связанных с Системными вызовами, Ссылками на базы данных, Последовательностью ввода / вывода, Использованием памяти, Использованием ресурсов, Обработкой прерываний и исключений, Обменом данными с оборудованием, Протоколами, Форматами, Интерфейсами с файлами сборки, Временными последовательностями.\n* **Дефекты тестирования**: Планы тестирования, тестовые наборы, средства тестирования и процедуры тестирования также могут содержать дефекты. Эти дефекты называются дефектами тестирования. Дефекты в планах тестирования лучше всего обнаруживать с помощью методов review.\n  * Дефекты тестовой обвязки: Для тестирования программного обеспечения на уровне модулей и интеграции необходимо разработать вспомогательный код. Это называется Test Harness или scaffolding code. Test Harness должен быть тщательно спроектирован, реализован и протестирован, поскольку это рабочий продукт, и этот код можно повторно использовать при разработке новых версий программного обеспечения;\n  * Дизайн тестового случая и дефекты процедуры тестирования: сюда входят неправильные, неполные, отсутствующие, несоответствующие тестовые примеры и процедуры тестирования.\n\n\n## Жизненный цикл дефекта (Defect/Bug Life Cycle)\n\nЖизненный цикл дефекта - это представление различных состояний дефекта, в которых он пребывает от начального до конечного этапа своего существования. Он может варьироваться от компании к компании и настраиваться под процессы конкретного проекта.\n\n![https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png](https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png)\n\n**Статусы дефекта**:\n\n* **Новый** (New): когда новый дефект регистрируется и публикуется впервые;\n* **Назначен** (Assigned): после публикации бага тестировщиком руководитель тестировщика утверждает ошибку и передает ее команде разработчиков;\n* **Открыт** (Open): разработчик начинает анализ и работает над исправлением бага;\n* **Исправлен** (Fixed): разработчик внес необходимое изменение в код и проверил его;\n* **Ожидает повторного тестирования** (Pending retest): как только дефект будет исправлен, разработчик предоставляет тестировщику конкретный код для повторного тестирования кода. Поскольку тестирование программного обеспечения остается незавершенным со стороны тестировщиков, ему присваивается статус «ожидает повторного тестирования»;\n* **Повторное тестирование** (Retest): на этом этапе тестировщик выполняет повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком;\n* **Проверен** (Verified): тестировщик повторно тестирует баг после его исправления разработчиком. Если баг исправлен, то присваивается статус «проверено»;\n* **Переоткрыт** (Reopen): если баг сохраняется даже после того, как разработчик исправил баг, тестировщик меняет статус на «повторно открыт». И снова баг проходит жизненный цикл.\n* **Закрыт** (Closed): если баг больше не существует, тестировщик присваивает статус «Закрыто».\n* **Дубль** (Duplicate): если дефект повторяется дважды или дефект соответствует той же концепции ошибки, статус изменяется на «дублировать».\n* **Отклонен** (Rejected): если разработчик считает, что дефект не является таковым, он меняет статус на «отклонен»;\n* **Отложен** (Deferred): если текущий баг не является приоритетным и ожидается, что он будет исправлен ​​в следующем выпуске, таким багам присваивается статус «Отложено»;\n* **Не является багом** (Not a bug): если это не влияет на функциональность приложения, то багу присваивается статус «Не является багом».\n\n![https://www.guru99.com/images/defectcyclechart.png](https://www.guru99.com/images/defectcyclechart.png)\n\n**Утечка дефектов и релиз бага (Bug Leakage & Bug Release)**\n\nУтечка бага (Bug Leakage): возникает когда пропускается баг в билде, который вышел в Production. Если баг был обнаружен конечным пользователем или заказчиком, мы называем это утечкой ошибок.\n\nВыпуск бага (Bug release): выпуск программного обеспечения в Production с некоторыми известными багами. Эти известные баги следует включить в примечания к выпуску (release notes). Другой вариант - передача программного обеспечения группе тестирования с некоторыми известными багами, серьезность и приоритет которых невысоки. Эти ошибки можно исправить перед выпуском в Production.\n\n**Основное отличие отладки от тестирования (**[**Debugging**](https://www.youtube.com/watch?v=URH45Vx08n4) **Vs. Testing)**\n\nПосле того, как разработчик получил баг-репорт, он приступает к исправлению бага. Но, прежде чем ошибку исправить, нужно ее воспроизвести, понять, как она происходит и где ее найти в коде. Дебаг, буквально “de”+”bug” - это и есть процесс поиска и устранения ошибок в коде. Специальная debug-версия билда приложения может иметь расширенный вывод для более информативных логов или любые другие модификации для упрощения понимания проблемы. Тактика отладки может включать интерактивную отладку, анализ потока управления, модульное тестирование, интеграционное тестирование, анализ логов, мониторинг на уровне приложения или системы, дампы памяти и профилирование. Многие языки программирования и инструменты разработки программного обеспечения также предлагают программы для помощи в отладке, известные как отладчики/дебаггеры.\n\n**Маскировка дефектов (Defect masking)**\n\n_Маскирование дефектов (defect masking): Случай, когда один дефект препятствует нахождению другого. (IEEE 610)_\n\n**Скрытый дефект (Latent defect)**\n\nДефект, который является существующим дефектом в системе, но еще не вызывал сбоев, поскольку подходящий набор входных данных для его проявления не был введен или его проявлению мешает другой дефект (Defect masking).\n\n**Сортировка дефектов (Bug triage)**\n\nЭто формальный процесс определения серьезности и приоритета дефектов в зависимости от их severity, риска, повторяемости и т. д. во время Defect Triage Meeting. Такая встреча полезна в условиях ограниченных ресурсов, когда нужно разобраться с множеством ошибок и тем, какие из них приоритетные.\n\nПонятие сортировки пришло из медицины, где это процесс быстрого обследования пациентов, доставленных в больницу, чтобы решить, какие из них наиболее серьезно больны и нуждаются в лечении в первую очередь. В тестировании мы используем ту же концепцию к ошибкам, обнаруженным на этапе тестирования.\n\n**Подсев недочетов (fault seeding)**\n\n_Процесс намеренного внесения дефектов в дополнение к тем, что уже существуют в компоненте или в системе, для целей отслеживания уровня обнаружения и устранения, а также оценивания количества оставшихся в системе дефектов. Подсев недочетов обычно является частью процесса тестирования разработки и может применяться на любом уровне тестирования (компонентном, интеграционном или системном). (IEEE 610)_\n\n## Валидация vs верификация \n\n### Верификация (Verification)\n\nДоказанное объективными результатами исследования подтверждение того, что определенные требования (спецификации, формальные требования) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Валидация (Validation)\n\nДоказанное объективными результатами исследования подтверждение того, что требования для ожидаемого конкретного использования приложения (соответствие ожиданиям и требованиям пользователей) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Пример:\nЕсли попробовать привести очень упрощенный пример, представим блюдо в ресторане. Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.\n\n## Priority vs Severity\n\n### Приоритет (Priority)\n\nСтепень важности, присваеваемая объекту. Например, дефекту или задаче. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82)]  \nУказывает на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект. Выставляется менеджером, тимлидом или заказчиком.\n\n**Градация Приоритета дефекта (Priority):**\n- **_P1 Высокий (High)_**  \nОшибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.\n- **_P2 Средний (Medium)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.\n- **_P3 Низкий (Low)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.\n\n### Критичность/Серьезность (Severity)\n\nВажность воздействия конкретного дефекта на разработку или функционирование компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)]  \nХарактеризует влияние дефекта на работоспособность приложения. Выставляется тестировщиком.\n\n**Градация Критичности дефекта (Severity)**\n\n- **_S1 Блокирующая (Blocker)_**  \nБлокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.\n\n- **_S2 Критическая (Critical)_**  \nКритическая ошибка, неправильно работающая ключевая бизнес логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с ключевыми функциями тестируемой системой.\n\n- **_S3 Значительная (Major)_**  \nЗначительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.\n\n- **_S4 Незначительная (Minor)_**  \nНезначительная ошибка, не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.\n\n- **_S5 Тривиальная (Trivial)_**  \nТривиальная ошибка, не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.\n\n\n### Сочетания Severity и Priority\n\n- **High Priority and High Severity**  \nЛюбой Critical/major сбой бизнес-модели, критическая проблема, при которой полностью не работает большая часть функциональности или основной компонент системы:\n  - нажатие на определенную кнопку не запускает саму функцию, например, не работает кнопка отправки на странице входа, и клиенты не могут войти в приложение;\n  - выполнение определенной функции постоянно приводит к 500 ошибке сервера и потере данных;\n  - система дает сбой после того, как вы совершили платеж или когда вы не можете добавить товары в корзину;\nфункция банкомата, при которой после ввода правильного имени пользователя и пароля автомат не выдает деньги, но списывает их с вашего счета;\n  - на веб-сайте банка появляется сообщение об ошибке, когда клиент нажимает кнопку перевода денег.\n\n- **High Priority and Low Severity**  \nЛюбые minor severity дефекты, которые влияют на взаимодействие с пользователями / репутацию:\n  - ожидается, что функция покажет пользователю конкретную ошибку по коду ответа. В этом случае функционально код выдает ошибку, но сообщение должно быть более релевантным коду;\n  - ошибка в логотипе или названии компании на главной странице, или опечатки, бросающиеся в глаза и способные повлиять на репутацию компании;\n  опечатки в контактных данных;\n  - важные ошибки в соглашениях и юридических документах.\n\n- **Low Priority and High Severity**  \nПроблема, которая пока не повлияет на бизнес, но имеет большое влияние с точки зрения функциональности:\n  - присутствует серьезный баг, но есть workaround и исправление уже может быть запланировано в следующем релизе или функция будет удалена;\n  - функция генерации годового отчета, которая будет использована только через полгода;\n  - редкость проявления дефекта/сложность воспроизведения для юзеров.\n\n- **Low Priority and Low Severity**  \nЛюбые орфографические ошибки / начертание / несовпадение шрифта в абзаце 3-й или 4-й страницы заявки, а не на главной или титульной странице / заголовке. Эти дефекты возникают, когда это не влияет на функциональность, но все же в небольшой степени не соответствует стандартам. Обычно сюда классифицируются косметические ошибки или, скажем, размеры ячейки в таблице пользовательского интерфейса:\n  - в политике конфиденциальности веб-сайта есть орфографическая ошибка;\n  - страница часто задаваемых вопросов загружается очень долго;\n  - семейство шрифтов, размер шрифта, цвет или орфографическая ошибка в приложении или отчетах.","category":"manual","description":"Жизненный цикл дефекта"},{"title":"Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)","path":"/zhiznennyj-czikl-razrabotki-po-sdlc-software-development-life-cycle/","content":"\nЖизненный цикл программного обеспечения — это период времени, который начинается с момента принятия решения о создании программного продукта и заканчивается в момент его полного изъятия из эксплуатации.\n\nЖизненный цикл разработки ПО представляет собой несколько этапов (или фаз), которые проходит любое ПО. По сути, это подробный план, показывающий, как разрабатывать программное обеспечение, поддерживать его, изменять, улучшать.\n\nВ жизненном цикле разработки ПО можно выделить 6 основных этапов.\n\n## Этапы жизненного цикла ПО\n\n### 1. Анализ, составление требований к продукту\nНа этом этапе необходимо получить обратную связь и поддержку от соответствующих внутренних и внешних заинтересованных сторон и ответить на вопрос «Какие проблемы требуют решений?» Определяем и документируем требования конечного пользователя системы. Какие ожидания есть у нашего потребителя и как мы можем их осуществить? Можем ли мы это сделать вообще?\n\n### 2. Планирование\nНужно ответить на вопрос «Что мы хотим сделать?» Этот вопрос может вдохновить на понимание юнит-экономики плана (затраты и выгоды), факторов снижения рисков и ожидаемых стоимостей. По аналогии с планированием отпуска, нужно будет разложить вещи и подумать о том, что следует взять с собой. Определяем, что делаем и какие проблемы решаем. Ставим цели, выясняем, какие ресурсы нам нужны для реализации проекта. Изучаем рынок и конкурентов, прорабатываем альтернативные варианты разработки продукта.\n\n### 3. Проектирование и дизайн\nК этому этапу уже нужно знать требования продукта и в целом понимать чего вы хотите, и прежде чем приступить к написанию кода, этого понимания должно быть достаточно для ответа на следующий вопрос: «Как мы добьемся наших целей?» Иначе говоря, вам необходимо понять, что именно вы оптимизируете и проектировать соответствующе. Определяем элементы системы, ее компоненты, уровень безопасности, архитектуру, интерфейсы, типы данных. Рисуем дизайн, обсуждаем, проектируем.\n\n### 4. Разработка ПО\nЭтап процесса создания продукта. На этом этапе вы стремитесь не столько отвечать на вопросы, сколько произвести результаты, или, говоря точнее, вам необходимо склоняться к действиям и создать прототип или систему, испытать которую смогут другие. Пишем код, настраиваем систему под определенные требования и функции. К концу фазы система готова к установке и запуску.\n\n### 5. Тестирование\nЭтот этап регулирует обеспечение качественной работы продукта. По завершению этого этапа вы должны будете в состоянии обеспечить рабочее состояние продукта. Отслеживайте ошибки и неточности, выслушивайте чужие точки зрения, и глубоко погружайтесь в вопрос с целью поиска тормозящих выход финального продукта ошибок. Проверяем, получили мы в итоге то, что хотели, или же результаты работы оказались другими. Тестируем продукт автоматизированными тестами, командой, предлагаем поработать с системой потенциальным пользователям. Определяем дефекты и недостатки в работе системы и устраняем их.\n\n### 6. Развертывание\nЭтап использования финального продукта. Возьмите ваш продукт и пользуйтесь им. Предложите заинтересованным сторонам из первого этапа пользоваться вашим продуктом в естественных условиях. одготовка и выпуск обновлений, оценка производительности системы, замена/деактивация устаревших компонентов.\n\n## Стадии разработки ПО\nСтадии разработки ПО — это этапы, которые проходят команды разработчиков ПО, прежде чем программа станет доступной для широко круга пользователей. Разработка ПО начинается с первоначального этапа разработки (стадия «пре-альфа») и продолжается стадиями, на которых продукт дорабатывается и модернизируется. Финальным этапом этого процесса становится выпуск на рынок окончательной версии программного обеспечения («общедоступного релиза»).\n\nКаждой стадии разработки ПО присваивается определенный порядковый номер. Также каждый этап имеет свое собственное название, которое характеризует готовность продукта на этой стадии:\n- Пре-альфа\n- Альфа\n- Бета\n- Релиз-кандидат\n- Релиз\n- Пост-релиз","category":"manual","description":"Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)"},{"title":"Модели разработки ПО","path":"/modeli-razrabotki-po/","content":"\n## 1. Code and fix - Модель кодирования и устранения ошибок\n\nСовершенно простая модель, характерная для студентов ВУЗов. Именно по этой модели большинство студентов разрабатывают, например лабораторные работы. \n\n![Code and fix - Модель кодирования и устранения ошибок](https://leonardo.osnova.io/611da7e3-32e5-0dd5-8198-cb6d23d19310/-/preview/2100/-/format/webp/)\n\nЭто одна из самых старых моделей разработки: она очень проста и подойдет стартапам, где команда невелика, нет особых конфликтов, вы знаете, что хотите сделать и имеете представление, как это сделать.\n\nКак работает Code-and-Fix: у нас есть понимание, что мы хотим сделать. Начинаем программировать, затем смотрим, что получилось. Выявляем баги, правим их и снова смотрим — и так, пока наш продукт не начнет работать.\n\nДанная модель имеет следующий алгоритм:\n\n1. Постановка задачи\n2. Выполнение\n3. Проверка результата\n4. При необходимости переход к первому пункту\n\n### Преимущества\n- не нужно тратить время на планы, документацию, митинги.\n\n### Недостатки\n- иногда исправление одной ошибки приводит к тому, что у вас ломается вся система. В итоге приходится переделывать — снова и снова. Поэтому когда-то давно программисты, которые мучились с этой моделью разработки, решили уйти от ее мнимой простоты и изобрести другую.\n\nМодель ужасно устаревшая. Характерна для 1960-1970 гг., поэтому преимуществ перед следующими моделями практически не имеет, а недостатки на лицо.\n\n## 2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")\n\nПроцесс создания программного обеспечения представляет собой поток, последовательно проходящий фазы анализа, проектирования, реализации, тестирования, интеграции и поддержки.\n\nКаждая следующая стадия начинается только после того, как заканчивается предыдущая. Так обычно строится работа над крупными проектами с длительным сроком внедрения.\n\n![Каскадная модель (waterfall)](https://habrastorage.org/r/w1560/files/6e2/e05/23f/6e2e0523f58d4d74816ae0bcf46e2fa2.jpg)\n![Каскадная модель (waterfall)](https://leonardo.osnova.io/0e330a8b-7f21-f8fb-872c-986314b4d7da/-/preview/2100/-/format/webp/)\n![Каскадная модель (waterfall)](https://evergreens.com.ua/assets/images/articles/systems/waterfall.png)\n\nИмеет ряд преимуществ перед алгоритмом предыдущей модели, но также имеет и ряд весомых недостатков. \n\n### Преимущества\n- Последовательное выполнение этапов проекта в строгом фиксированном порядке;\n- высокий уровень формализации процессов => высокая прозрачность разработки и фаз проекта;\n- большое количество документации;\n- Разработку просто контролировать. Заказчик всегда знает, чем сейчас заняты программисты, может управлять сроками и стоимостью;\n- Стоимость проекта определяется на начальном этапе. Все шаги запланированы уже на этапе согласования договора, ПО пишется непрерывно «от и до»;\n- Позволяет оценивать качество продукта на каждом этапе;\n- Не нужно нанимать тестировщиков с серьёзной технической подготовкой. Тестировщики смогут опираться на подробную техническую документацию;\n\n\n### Недостатки\n- Жесткая последовательность этапов жизненного цикла без возможности возврата на предыдущий этап;\n- Заказчик видит готовый продукт в конце разработки и только тогда может дать обратную связь. Велика вероятность, что результат его не устроит.\n- Все требования должны быть известны в начале жизненного цикла проекта;\n- Разработчики пишут много технической документации, что задерживает работы. Чем обширнее документация у проекта, тем больше изменений нужно вносить и дольше их согласовывать.\n- Тестирование начинается на последних этапах разработки. Если в требованиях к продукту была допущена ошибка, то исправить её будет стоить дорого. Тестировщики обнаружат её, когда разработчик уже написал код, а технические писатели — документацию.\n- Возникает необходимость в жёстком управлении и регулярном контроле, иначе проект быстро выйдет из графиков\n- Отсутствует возможность учесть переделку, весь проект делается за один раз\n- Не соответствует реальным условиям разработки программного продукта\n\n«Водопад» подходит для разработки проектов в медицинской и космической отрасли, где уже сформирована обширная база документов (СНиПов и спецификаций), на основе которых можно написать требования к новому ПО. \n\nПри работе с каскадной моделью основная задача — написать подробные требования к разработке. На этапе тестирования не должно выясниться, что в них есть ошибка, которая влияет на весь продукт.\n\n### «Водоворот» или каскадная модель с промежуточным контролем\n\nВ этой модели предусмотрен промежуточный контроль за счет обратных связей. Но это достоинство порождает и недостатки. Затраты на реализацию проекта при таком подходе возрастают практически в 10 раз. Эта модель, как вы уже поняли, является незначительной модификацией предыдущей.\n\n![«Водоворот» или каскадная модель с промежуточным контролем](https://intuit.ru/EDI/08_01_19_2/1546899581-11707/tutorial/145/objects/2/files/02_04.gif)\n\nПри реальной работе в соответствии с моделью, допускающей движение только в одну сторону, обычно возникают проблемы при обнаружении недоработок и ошибок, сделанных на ранних этапах. Но еще более тяжело иметь дело с изменениями окружения, в котором разрабатывается ПО (это могут быть изменения требований, смена подрядчиков, изменения политик разрабатывающей или эксплуатирующей организации, изменения отраслевых стандартов, появление конкурирующих продуктов и пр.).\n\n## 3. V-model (V-образная модель, разработка через тестирование)\n\nЭто усовершенствованная каскадная модель, в которой заказчик с командой программистов одновременно составляют требования к системе и описывают, как будут тестировать её на каждом этапе. \n\nИстория этой модели начинается в 1980-х. Имеет обратные связи с каждым этапом жизненного цикла, при этом порождает очень весомый недостаток: 10-ти кратное увеличение затрат на разработку.\n\nЯвляется одной из основных практик экстремального программирования и предполагает регулярное тестирование продукта во время разработки.\n\n![V модель — разработка через тестирование](https://habrastorage.org/r/w1560/files/22d/21f/18f/22d21f18ffb244d082e181c813d4ff15.jpg)\n![V модель — разработка через тестирование](https://leonardo.osnova.io/4a602e4f-745f-b2cc-18de-bd9cdd148b55/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- **Минимизация рисков:**  \nV-образная модель делает проект более прозрачным и повышает качество контроля проекта путём стандартизации промежуточных целей и описания соответствующих им результатов и ответственных лиц. Это позволяет выявлять отклонения в проекте и риски на ранних стадиях и улучшает качество управления проектов, уменьшая риски.\n- **Повышение и гарантии качества:**  \nV-Model — стандартизованная модель разработки, что позволяет добиться от проекта результатов желаемого качества. Промежуточные результаты могут быть проверены на ранних стадиях. Универсальное документирование облегчает читаемость, понятность и проверяемость.\n- **Уменьшение общей стоимости проекта:**  \nРесурсы на разработку, производство, управление и поддержку могут быть заранее просчитаны и проконтролированы. Получаемые результаты также универсальны и легко прогнозируются. Это уменьшает затраты на последующие стадии и проекты.\n- **Повышение качества коммуникации между участниками проекта:**  \nУниверсальное описание всех элементов и условий облегчает взаимопонимание всех участников проекта. Таким образом, уменьшаются неточности в понимании между пользователем, покупателем, поставщиком и разработчиком.\n\n### Недостатки\n- Если при разработке архитектуры была допущена ошибка, то вернуться и исправить её будет стоить дорого, как и в «водопаде».\n\nV-модель подходит для проектов, в которых важна надёжность и цена ошибки очень высока. Например, при разработке подушек безопасности для автомобилей или систем наблюдения за пациентами в клиниках. \n\n## 4. Incremental Model - Инкрементная модель\n\nМодель приращения продукта позволяет параллельно выполнять ряд задач с непрерывным анализом результатов и корректировкой предыдущих этапов работы. Это более «скоростная» разработка для большого штата квалифицированных программистов.\n\nЭто модель разработки по частям (increment в переводе с англ. — приращение) уходит корнями в 1930-е. Рассмотрим её на примере создания социальной сети.\n\nЗаказчик решил, что хочет запустить соцсеть, и написал подробное техническое задание. Программисты предложили реализовать основные функции — страницу с личной информацией и чат. А затем протестировать на пользователях, «взлетит или нет».\n\nКоманда разработки показывает продукт заказчику и выпускает его на рынок. Если и заказчику, и пользователям социальная сеть нравится, работа над ней продолжается, но уже по частям.\n\nПрограммисты параллельно создают функциональность для загрузки фотографий, обмена документами, прослушивания музыки и других действий, согласованных с заказчиком. Инкремент за инкрементом они совершенствуют продукт, приближаясь к описанному в техническом задании.\n\n![Incremental Model - Инкрементная модель](https://habrastorage.org/r/w1560/files/8b7/4e2/a86/8b74e2a8640d4ad59e7ac82b991be970.jpg)\n![Incremental Model - Инкрементная модель](https://leonardo.osnova.io/5a2d52b7-7a12-f7d5-9f09-4054d8192694/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- Не нужно вкладывать много денег на начальном этапе. Заказчик оплачивает создание основных функций, получает продукт, «выкатывает» его на рынок — и по итогам обратной связи решает, продолжать ли разработку.\n- Можно быстро получить фидбэк от пользователей и оперативно обновить техническое задание. Так снижается риск создать продукт, который никому не нужен.\n- Ошибка обходится дешевле. Если при разработке архитектуры была допущена ошибка, то исправить её будет стоить не так дорого, как в «водопаде» или V-образной модели.\n\n### Недостатки\n\n- Каждая команда программистов разрабатывает свою функциональность и может реализовать интерфейс продукта по-своему. Чтобы этого не произошло, важно на этапе обсуждения техзадания объяснить, каким он будет, чтобы у всех участников проекта сложилось единое понимание. \n- Разработчики будут оттягивать доработку основной функциональности и «пилить мелочёвку». Чтобы этого не случилось, менеджер проекта должен контролировать, чем занимается каждая команда.\n\nИнкрементная модель подходит для проектов, в которых точное техзадание прописано уже на старте, а продукт должен быстро выйти на рынок.\n\n## 5. Iterative Model - Итеративная (или итерационная) модель\n\nЭто модель, при которой заказчик не обязан понимать, какой продукт хочет получить в итоге, и может не прописывать сразу подробное техзадание.\n\nРассмотрим на примере создания мессенджера, как эта модель работает.\n\nЗаказчик решил, что хочет создать мессенджер. Разработчики сделали приложение, в котором можно добавить друга и запустить чат на двоих.\nМессенджер «выкатили» в магазин приложений, пользователи начали его скачивать и активно использовать. Заказчик понял, что продукт пользуется популярностью, и решил его доработать.\n\nПрограммисты добавили в мессенджер возможность просмотра видео, загрузки фотографий, записи аудиосообщений. Они постепенно улучшают функциональность приложения, адаптируют его к требованиям рынка.\n\n![Iterative Model - Итеративная (или итерационная) модель](https://habrastorage.org/r/w1560/files/880/01d/a78/88001da784ab41ec880f84a7bb204a0b.jpg)\n![Iterative Model - Итеративная (или итерационная) модель](https://leonardo.osnova.io/ba33e029-3df5-ec0c-35b0-3b6060f93f81/-/preview/2100/-/format/webp/)\n![Iterative Model - Итеративная (или итерационная) модель](https://evergreens.com.ua/assets/images/articles/systems/iteration%20mod.png)\n\n### Преимущества\n\n- Быстрый выпуск минимального продукта даёт возможность оперативно получать обратную связь от заказчика и пользователей. А значит, фокусироваться на наиболее важных функциях ПО и улучшать их в соответствии с требованиями рынка и пожеланиями клиента.\n- Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки.\n\n### Недостатки\n\n- Использование на начальном этапе баз данных или серверов — первые сложно масштабировать, а вторые не выдерживают нагрузку. Возможно, придётся переписывать большую часть приложения.\n- Отсутствие фиксированного бюджета и сроков. Заказчик не знает, как выглядит конечная цель и когда закончится разработка.\n- Становится сложнее адекватно оценить текущее состояние проекта и спланировать долгосрочное развитие событий, а также предсказать сроки и ресурсы, необходимые для обеспечения определенного качества результата.\n\nИтеративная модель подходит для работы над большими проектами с неопределёнными требованиями, либо для задач с инновационным подходом, когда заказчик не уверен в результате. \n\nНа основе итеративной модели была создана Agile — не модель и не методология, а скорее подход к разработке.\n\n![](https://s.dou.ua/storage-files/dev-cycle-iter.gif)\n\n## 6. Spiral Model — спиральная модель\n\nСпиральная модель представляет собой процесс разработки программного обеспечения, сочетающий в себе как проектирование, так и постадийное прототипирование с целью сочетания преимуществ восходящей и нисходящей концепции. \n\nРассмотрим, как функционирует эта модель, на примере разработки системы «Умный дом». \n\nЗаказчик решил, что хочет сделать такую систему, и заказал программистам реализовать управление чайником с телефона. Они начали действовать по модели «водопад»: выслушали идею, провели анализ предложений на рынке, обсудили с заказчиком архитектуру системы, решили, как будут её реализовывать, разработали, протестировали и «выкатили» конечный продукт.\n\nЗаказчик оценил результат и риски: насколько нужна пользователям следующая версия продукта — уже с управлением телевизором. Рассчитал сроки, бюджет и заказал разработку. \n\nПрограммисты действовали по каскадной модели и представили заказчику более сложный продукт, разработанный на базе первого.\n\nЗаказчик подумал, что пора создать функциональность для управления холодильником с телефона. Но, анализируя риски, понял, что в холодильник сложно встроить Wi-Fi-модуль, да и производители не заинтересованы в сотрудничестве по этому вопросу. Следовательно, риски превышают потенциальную выгоду.\n\nНа основе полученных данных заказчик решил прекратить разработку и совершенствовать имеющуюся функциональность, чтобы со временем понять, как развивать систему «Умный дом».\n\nСпиральная модель похожа на инкрементную, но здесь гораздо больше времени уделяется оценке рисков. С каждым новым витком спирали процесс усложняется. Эта модель часто используется в исследовательских проектах и там, где высоки риски. \n\n![Spiral Model — спиральная модель](https://leonardo.osnova.io/595fed17-42da-c48b-1f17-f314f31301a4/-/preview/2100/-/format/webp/)\n![Spiral Model — спиральная модель](https://evergreens.com.ua/assets/images/articles/systems/spinner%20model.png)\n### Преимущества\n\n- Быстрое получение результата\n- Повышение конкурентоспособности\n- При изменении требований, не придется начинать все с «нуля».\n- Большое внимание уделяется проработке рисков\n\n### Недостатки\n\n- Отсутствие регламентации стадий\n- Есть риск застрять на начальном этапе — бесконечно совершенствовать первую версию продукта и не продвинуться к следующим.\n- Разработка длится долго и стоит дорого.\n\nИспользуя эту модель, заказчик и команда разработчиков серьёзно анализируют риски проекта и выполняют его итерациями. Последующая стадия основывается на предыдущей, а в конце каждого витка — цикла итераций — принимается решение, продолжать ли проект. Эту модель начали использовать в 1988 году.\n\n## 7. Chaos model — модель хаоса\n\nВкратце Стратегия хаоса — это стратегия разработки программного обеспечения основанная на модели хаоса. Главное правило — это,всегда решать наиболее важную задачу первой.\n\nЕё создатель Л.Б.С.Ракун отмечает, что такие модели управления проектами, как спиральная модель и каскадная модель, хотя и хороши в управлении расписаниями и персоналом, не обеспечивают методами устранения ошибок и решениями других технических задач, не помогают ни в управлении конечными сроками, ни в реагировании на запросы клиентов. Модель хаоса — это инструмент пытающийся помочь понять эти ограничения и восполнить пробелы.\n\n### Преимущества\n- учитывает взаимодействие между членами команды при внесении изменений в код;\n- ограничивает риск чрезмерного проектирования решения\n- прозрачность между желаниями руководства высокого уровня и пониманием командой разработчиков проблем и приоритетов.\n\n### Недостатки\n- критическая необходимость включить единый дизайн на уровне кода, который необходимо выполнить для удовлетворения требований на уровне программы.\n\n## 8. Prototype Model — прототипная модель\n\nДанная модель основывается на разработке прототипов и прототипирования продукта.\n\nПрототипирование используется на ранних стадиях жизненного цикла программного обеспечения:\n- Прояснить не ясные требования (прототип UI)\n- Выбрать одно из ряда концептуальных решений (реализация сцинариев)\n- Проанализировать осуществимость проекта\n\n### Классификация протопипов\n- Горизонтальные прототипы — моделирует исключительно UI не затрагивая логику обработки и базу данных.\n- Вертикальные прототипы — проверка архитектурных решений.\n- Одноразовые прототипы — для быстрой разработки.\n- Эволюционные прототипы — первое приближение эволюционной системы.\n\n## 9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений\n\n![RAD-Model, или Rapid Application Development Model - Модель быстрой разработки](https://leonardo.osnova.io/69673b21-a423-772e-3a1e-aca50d529348/-/preview/2100/-/format/webp/)\n\nРазновидность инкрементной модели. Появилась в конце 80-х годов и стала одной из попыток создания гибкого процесса разработки.\n\nRAD предусматривает небольшие команды разработки,сроки до 4 месяцев и активное привлечение заказчика с ранних этапов. Данная методология опирается на требования, но также существует возможность их изменений в период разработки системы. Обязательное требование этой модели — проект должен легко разбиваться на небольшие части, которые при необходимости могут создаваться параллельно друг другу несколькими командами. Такой подход позволяет сократить расходы и свести время разработки к минимуму.\n\n### Преимущества\n- быстрое развитие продукта;\n- разработка многоразовых мелких компонентов;\n- повторный обзор в процессе разработки;\n- интеграция повторно используемых компонентов на начальном уровне, следовательно, экономит усилия, несмотря на то, что не добавляются более крупные модули;\n- конструктивная реакция.\n\n### Недостатки\n- требуется много усилий для сбора всех требований на начальном этапе.\n- навыки моделирования имеют много зависимостей.\n- не подходит для малобюджетного проекта.\n\n## 10. Модель Большого Взрыва (Big Bang Model)\n\nBig Bang Model не имеет определенного процесса. Деньги и усилия объединяются, поскольку вход и выход представляют собой разработанный продукт, который может совпадать, а может и не совпадать с тем, что нужно заказчику. Модель Большого Взрыва не требует особого планирования и составления графиков. Разработчик выполняет анализ требований и кодирование, а также разрабатывает продукт в соответствии с его пониманием. Эта модель используется только для небольших проектов. Нет команды тестирования и формального тестирования не проводится, и это может быть причиной провала проекта.\n\n### Преимущества\n- Это очень простая модель. \n- Требуется меньше планирования и составления графиков. \n- Разработчик может создавать собственное программное обеспечение.\n\n### Недостатки\n- Модели Большого взрыва нельзя использовать для крупных, текущих и сложных проектов. \n- Высокий риск и неопределенность.\n\n## 11. Agile\n\nГибкая модель разработки, по которой сегодня работает большинство ИТ-проектов. Вы получаете определенный результат после каждой итерации, можете вносить изменения в первоначальное видение продукта практически в любой момент работы — исходя из того, какой функционал больше нравится пользователям вашего продукта.\n\n### Преимущества\n- чтобы начать работать над продуктом не нужно иметь детальное представление о том, что вы хотите получить в конце. Не нужно иметь весь бюджет и просчитывать все риски\n\n### Недостатки\n- готовый продукт может на рынок так никогда и не выйти, вы постоянно будете заниматься его усовершенствованиями, дополнениями, тем временем бюджет может закончиться\n\nAgile имеет множество вариаций и фреймворков. Среди самых известных: Scrum, Kanban, экстремальное программирование (XP), Lean.","category":"manual","description":"Модели разработки ПО"},{"title":"Методологии разработки ПО (Scrum, Kanban, RUP, DSDM, MSF, XP)","path":"/metodologii-razrabotki-po-scrum-kanban-rup-dsdm-msf-xp/","content":"\nМетодологии разработки — это применение той или иной модели на практике.\n\n## SCRUM\n\n**Scrum**[^Scrum (Скрам) — это не аббревиатура, этот термин взят из регби, который обозначает схватку вокруг мяча.] — это методология управления проектами, которая построена на принципах тайм-менеджмета. Основной ее особенностью является вовлеченность в процесс всех участников, причем у каждого участника есть своя определенная роль. \n\nСуть в том, что не только команда работает над решением задачи, но все те, кому интересно решение задачи, не просто поставили ее и расслабились, а постоянно «работают» с командой, и эта работа не означает только постоянный контроль.\n\n![SCRUM методология](https://leonardo.osnova.io/973a45ec-4e04-eb43-ecb1-03f639188c87/-/preview/2100/-/format/webp/)\n\n### Основные термины, которые используются в методологии\n\n**Владелец продукта (Product owner)** — человек, который имеет непосредственный интерес в качественном конечном продукте, он понимает, как это продукт должен выглядеть/работать. Этот человек не работает в команде, он работает на стороне заказчика/клиента (это может быть как другая компания, так и другой отдел), но этот человек работает с командой. И это тот человек, который расставляет приоритеты для задач.\n\n**Scrum-мастер** — это человек, которого можно назвать руководителем проекта, хотя это не совсем так. Главное, что это человек, «зараженный Scrum-бациллой» на столько, что несет ее как своей команде, так и заказчику, и соответственно следит за тем, чтобы все принципы Scrum соблюдались.\nScrum-команда — это команда, которая принимает все принципы Scrum и готова с ними работать.\n\n**Спринт** — отрезок времени, который берется для выполнения определенного (ограниченного) списка задач. Рекомендуется брать 2-4 недели (длительность определяется командой один раз).\n\n**Бэклог (backlog)** — это список всех работ. Можно сказать, что это ежедневник общего пользования.\n\nРазличают 2 вида бэклогов: Product-бэклог и спринт-бэклог.  \n**Product-бэклог** — это полный список всех работ, при реализации которых мы получим конечный продукт.  \n**Спринт-бэклог** — это список работ, который определила команда и согласовала с Владельцем продукта, на ближайший отчетный период (спринт). Задания в спринт-бэклог берутся из product-бэклога.\n\n**Планирование спринта** — это совещание, на котором присутствуют все (команда, Scrum-мастер, Владелец продукта). В течение этого совещания Владелец продукта определяет приоритеты заданий, которые он хотел бы увидеть выполнеными по истечении спринта. Команда оценивает по времени, сколько из желаемого они могут выполнить. В итоге получается список заданий, который не может меняться в течение спринта и к концу спринта должен быть полностью выполнен.\n\nПример работы PR-агентства. Как бы это могло выглядеть, если бы они работали по Scrum.\nКомпания клиент «Икс» хочет провести через 2 месяца масштабное мероприятие для своих партнеров и журналистов. Услуги по организации такого мероприятия компания «Икс» заказала у агентства «Зет». Компанию «Икс» представляет PR-менеджер, который отвечает за организацию мероприятия со стороны клиента. В терминологии Scrum — этот человек называется Владелец продукта. Со стороны агентства за организацию мероприятия отвечает account-менеджер (Scrum-мастер), в подчинении которого находится команда (Scrum-команда). На совместном совещании (планировании спринта) компания и агентство решают, что они будут отчитываться-планировать каждые 2 недели (длина спринта). На первые 2 недели они запланировали список задач (спринт-бэклог), однако команда оценила, что не все из этого списка они успеют выполнить. Тогда PR-менеджер (он же Владелец продукта), говорит какие из этого списка задач более приоритетные на ближайшие 2 недели, после чего команда берется за выполнение заданий. Единственное что здесь должно быть учтено, что на момент планирования первого спринта должен быть спланирован весь список заданий на 2 месяца (product-бэклог), чтобы не получилось так, что к моменту проведения мероприятия что-то не выполнено.\n\n### Жизненный цикл спринта\n\n1. **Планирование спринта**\nВ начале каждого спринта проводится планирование спринта. В планировании спринта участвуют заказчики, пользователи, менеджмент, Product Owner, Скрам Мастер и команда.\nПланирование спринта состоит из двух последовательных митингов.\n\n_Планирование спринта, митинг первый_\nУчастники: команда, Product Owner, Scrum Master, пользователи, менеджемент\nЦель: Определить цель спринта (Sprint Goal) и Sprint Backlog -функциональность, которая будет разработана в течение следующего спринта для достижения цели спринта.\nАртефакт: Sprint Backlog\n\n_Планирование спринта, митинг второй_\nУчастники: Скрам Мастер, команда\nЦель: определить, как именно будет разрабатываться определенная функциональность для того, чтобы достичь цели спринта. Для каждого элемента Sprint Backlog определяется список задач и оценивается их продолжительность.\nАртефакт: в Sprint Backlog появляются задачи\nЕсли в ходе спринта выясняется, что команда не может успеть сделать запланированное на спринт, то Скрам Мастер, Product Owner и команда встречаются и выясняют, как можно сократить scope работ и при этом достичь цели спринта.\n\n2. **Остановка спринта (Sprint Abnormal Termination)**\nОстановка спринта производится в исключительных ситуациях. Спринт может быть остановлен до того, как закончатся отведенные 30 дней. Спринт может остановить команда, если понимает, что не может достичь цели спринта в отведенное время. Спринт может остановить Product Owner, если необходимость в достижении цели спринта исчезла.\nПосле остановки спринта проводится митинг с командой, где обсуждаются причины остановки спринта. После этого начинается новый спринт: производится его планирование и стартуются работы.\n\n3. **Daily Scrum Meeting**\nЭтот митинг проходит каждое утро в начале дня. Он предназначен для того, чтобы все члены команды знали, кто и чем занимается в проекте. Длительность этого митинга строго ограничена и не должна превышать 15 минут. Цель митинга — поделиться информацией. Он не предназначен для решения проблем в проекте. Все требующие специального обсуждения вопросы должны быть вынесены за пределы митинга.\n\nСкрам митинг проводит Скрам Мастер. Он по кругу задает вопросы каждому члену команды:\n- Что сделано вчера?\n- Что будет сделано сегодня?\n- С какими проблемами столкнулся?\n\nСкрам Мастер собирает все открытые для обсуждения вопросы в виде Action Items в формате что/кто/когда, например\n- Обсудить проблему с отрисовкой контрола\n- Петя и Вася\n- Сразу после скрама\n\n4. **Диаграмма сгорания задач (Burndown chart)**\n\n![Диаграмма сгорания задач (Burndown chart)](https://upload.wikimedia.org/wikipedia/commons/0/05/SampleBurndownChart.png)\n\nДиаграмма, показывающая количество сделанной и оставшейся работы. Обновляется ежедневно с тем, чтобы в простой форме показать подвижки в работе над спринтом. График должен быть общедоступен.\n\nСуществуют разные виды диаграммы:\n- _диаграмма сгорания работ для спринта_ — показывает, сколько уже задач сделано и сколько ещё остаётся сделать в текущем спринте.\n- _диаграмма сгорания работ для выпуска проекта_ — показывает, сколько уже задач сделано и сколько ещё остаётся сделать до выпуска продукта (обычно строится на базе нескольких спринтов).\n\n5. **Ретроспектива**\nВ конце каждого Спринта, Скрам Команда собирается на Ретроспективу. Цель Ретроспективы пересмотреть качество существующих процессов, взаимоотношения людей и применяемые инструменты. Команда определяет, что прошло хорошо, а что не очень, а также выявляет потенциальные возможности для улучшений. Они создают план улучшений на будущее.\n\n## Kanban (Канбан)\n\nЯвляется одной из методологий Agile. Метод базируется на концепции бережливого производства, основанной на стремлении к устранению всех потерь — временных, производственных, логистических, качественных.\n\nОсобенность Kanban[^Термин Канбан имеет дословный перевод: «Кан» значит видимый, визуальный, и «бан» значит карточка или доска.] — задачи должны выполняться точно в срок, нагрузка между командой распределяется равномерно.\n\nНа практике это выглядит следующим образом. Каждая задача по проекту описывается в отдельной карточке и добавляется на доску — виртуальную или настоящую. Карточка и доска — неотъемлемые элементы Kanban. \n\n![Kanban (Канбан)](https://leonardo.osnova.io/48b8b2fb-95eb-fbf4-f30b-1a1f1620f54d/-/preview/2100/-/format/webp/)\n\nВсе задачи, которые необходимо сделать, собраны в специальной колонке, условно, она может называться **“сделать”/ “to do”**. Исполнитель выбирает задачу и перемещает в колонку **“в процессе” / “in progress”**. Когда задача сделана, она попадает в соответствующую колонку **“готово” / “done”**.\n\nНа практике колонок может быть гораздо больше, чем три. К примеру, колонки на доске могут выглядеть так: “обсуждается” (backlog), “согласовано” (ready), “кодируется” (coding), “тестируется” (testing), “подтверждается” (approval) и “сделано” (done).\n\n> Кейс “Тойота”. Методология Kanban родилась на производстве в компании Toyota. Мастера участков перечисляли выполняемые работы на бумаге и вывешивали их на видном месте — так и родилась доска канбан, один из элементов методологии. В основе производства Toyota — годовой план производства и сбыта авто, на базе которого составляются месячные и оперативные планы среднесуточного выпуска на каждом участке, основывающиеся на прогнозировании покупательского спроса. Методология базируется на принципе “точно в срок”, что, помимо четкого следования таймингу по каждой задаче, позволяет раскрывать дефекты производства вовремя. Например, ежедневные контроль запасов продукции и деталей выявляет неисправности или простои.\n\nКанбан — это даже еще более «гибкая» методология, чем SCRUM и XP. Это значит, что она не подойдет всем командам и для всех проектов. И это также значит, что команда должна быть еще более готовой к гибкой работе, чем даже команды, использующие SCRUM и XP.\n\n### Разница между Канбан и SCRUM\n- В Канбан нет таймбоксов ни на что (ни на задачи, ни на спринты)\n- В Канбан задачи больше и их меньше\n- В Канбан оценки сроков на задачу опциональные или вообще их нет\n- В Канбан «скорость работы команды» отсутствует и считается только среднее время на полную реализацию задачи\n\nКанбан разработка отличается от SCRUM в первую очередь ориентацией на задачи. Если в SCRUM основная ориентация команды — это успешное выполнение спринтов (надо признать, что это так), то в Канбан на первом месте задачи.\nСпринтов никаких нет, команда работает над задачей с самого начала и до завершения. Деплоймент задачи делается тогда, когда она готова. Презентация выполненной работы — тоже. Команда не должна оценивать время на выполнение задачи, ибо это имеет мало смысла и почти всегда ошибочно вначале.\nЕсли менеджер верит команде, то зачем иметь оценку времени? Задача менеджера — это создать приоритизированный пул задач, а задача команды — выполнить как можно больше задач из этого пула. Всё. Никакого контроля не нужно. Всё, что нужно от менеджера — это добавлять задачи в этот пул или менять им приоритет. Именно так он управляет проектом.\n\n## Экстремальное программирование (XP)\n\n![Экстремальное программирование (XP)](https://leonardo.osnova.io/5a5a58fa-3c54-6d7a-f158-b75c0868b05d/-/preview/2100/-/format/webp/)\n\neXtreme Programming, экстремальное программирование, XP — гибкая методология разработки, которая появилась в конце 90-х годов прошлого столетия. Авторы взяли лучшие, на их взгляд, практики гибкой разработки и усилили их до максимума — отсюда и слово “экстремальный” в названии.\n\nВ отличие от канбана, скрама, которые можно применять в самых разных стартапах и бизнесах, да и в организации личных дел, XP применяется исключительно в разработке программных продуктов. В рамках экстремального программирования выделяются четыре процесса: кодирование, тестирование, дизайн, слушание. Если описать эту методологию несколькими словами, то ее характеризуют оперативность, высокое качество, командная работа.\n\nОсобенностью XP являются некоторые практики, самая известная из которых — парное программирование. Суть его заключается в том, что два разработчика одновременно работают над кодом для одной функции продукта: сначала один пишет, а второй наблюдает и исправляет ошибки, затем они меняются местами. Таким образом, в процессе создания кода есть два альтернативных решения, на каждом этапе выбирается лучшее. Парное программирование работает по принципу: одна голова — хорошо, а две лучшею\n\nДругая особенность экстремального программирования заключается в том, что сначала готовятся тесты, и только потом — код. При этом тесты пишут сами программисты. Тестирование позволяет исправить большинство ошибок на стадии создания кода.\n\nТретья особенность — коллективное владение кодом: каждый программист в команде имеет доступ к коду продукта и может вносить в него изменения. В том случае, если изменения привели к некорректной работе системы, исправить все должен тот программист, который внес эти изменения.\n\nЭкстремальное программирование предполагает также работу в рамках небольших релизов — от одного дня до месяца. При этом чем короче релизы, тем лучше качество продукта.\n\nНаконец, интеграция новых частей в систему происходит так быстро как это возможно. Как только тесты показали, что функция работает корректно, она интегрируется в систему.\n\nДвенадцать основных приёмов экстремального программирования (по первому изданию книги Extreme programming explained) могут быть объединены в четыре группы:\n\n- Короткий цикл обратной связи (Fine-scale feedback)\n- Разработка через тестирование (Test-driven development)\n- Игра в планирование (Planning game)\n- Заказчик всегда рядом (Whole team, Onsite customer)\n- Парное программирование (Pair programming)\n- Непрерывный, а не пакетный процесс\n- Непрерывная интеграция (Continuous integration)\n- Рефакторинг (Design improvement, Refactoring)\n- Частые небольшие релизы (Small releases)\n- Понимание, разделяемое всеми\n- Простота (Simple design)\n- Метафора системы (System metaphor)\n- Коллективное владение кодом (Collective code ownership) или выбранными шаблонами проектирования (Collective patterns ownership)\n- Стандарт кодирования (Coding standard or Coding conventions)\n- Социальная защищенность программиста (Programmer welfare):\n- 40-часовая рабочая неделя (Sustainable pace, Forty-hour week)\n\n## DSDM (Dynamic Systems Development Model) \n\nМетодология, которая демонстрирует набор принципов, предопределенных типов ролей и техник.\n\nПринципы направлены на главную цель  - сдать готовый проект вовремя и уложиться в бюджет, с возможностью регулировать требования во время разработки. DSDM входит в семейство гибкой методологии разработки программного обеспечения, а также разработок не входящих в сферу информационных технологий.\n\n## RATIONAL UNIFIED PROCESS (RUP)\n\nЭто методология разработки программного обеспечения, созданная компанией Rational Software.\n\n![](https://upload.wikimedia.org/wikipedia/commons/1/19/Development-iterative.png)\n\n### Основные принципы\n\n- компонентная архитектура, реализуемая и тестируемая на ранних стадиях проекта;\n- работа над проектом в сплочённой команде, ключевая роль в которой принадлежит архитекторам;\n- ранняя идентификация и непрерывное устранение возможных рисков;\n- концентрация на выполнении требований заказчиков к исполняемой программе;\n- ожидание изменений в требованиях, проектных решениях и реализации в процессе разработки;\n- постоянное обеспечение качества на всех этапах разработки проекта.\n\nРазработка продукта при данном методе состоит из четырех фаз (начальная стадия, уточнение, построение, внедрение), каждая из которых включает в себя одну или несколько итераций. RUP огромная методология, которую трудно уложить в абзац текста, но методы, рекомендуемые RUP основаны на статистике коммерчески успешных проектов. \n\n## MICROSOFT SOLUTIONS FRAMEWORK\n\nМетодология разработки программного обеспечения, предложенная корпорацией Microsoft. MSF опирается на практический опыт Microsoft и описывает управление людьми и рабочими процессами в процессе разработки решения.\n\n![MICROSOFT SOLUTIONS FRAMEWORK](https://sbsoft.com/wp-content/uploads/2014/12/msf-2.png)\n\n### Базовые концепции и принципы модели процессов MSF\n\n- единое видение проекта — все заинтересованные лица и просто участники проекта должны чётко представлять конечный результат, всем должна быть понятна цель проекта;\n- управление компромиссами — поиск компромиссов между ресурсами проекта, календарным графиком и реализуемыми возможностями;\n- гибкость — готовность к изменяющимся проектным условиям;\n- концентрация на бизнес-приоритетах — сосредоточенность на той отдаче и выгоде, которую ожидает получить потребитель решения;\n- поощрение свободного общения внутри проекта;\n- создание базовых версии — фиксация состояния любого проектного артефакта, в том числе программного кода, плана проекта, руководства пользователя, настройки серверов и последующее эффективное управление изменениями, аналитика проекта.\n\nMSF предлагает проверенные методики для планирования, проектирования, разработки и внедрения успешных IT-решений. Благодаря своей гибкости, масштабируемости и отсутствию жестких инструкций MSF способен удовлетворить нужды организации или проектной группы любого размера. Методология MSF состоит из принципов, моделей и дисциплин по управлению персоналом, процессами, технологическими элементами и связанными со всеми этими факторами вопросами, характерными для большинства проектов.\n\n\n## Lean, Lean Software Development - бережливая разработка программного обеспечения\n\n![Lean, Lean Software Development - бережливая разработка программного обеспечения](https://leonardo.osnova.io/515471bd-ab0b-1836-4f32-124db73823d7/-/preview/2100/-/format/webp/)\n\nГибкая методология, основанная на концепции бережливого производства. Среди принципов методологии — исключение потерь (к ним относится все, что не добавляет ценности для потребителя — излишняя функциональность, паузы в процессе разработки, нечеткие требования и пр.); акцент на обучении (предполагаются короткие циклы разработки, раннее тестирование), принятие решений на основе фактов, мотивация команды.\n\n\nВиды методологий разработки ПО:\n• Каскадная или поэтапная разработка (в некоторых источниках её называют «водопадной моделью») — процесс создания программного обеспечения представляет собой поток, последовательно проходящий фазы анализа, проектирования, реализации, тестирования, интеграции и поддержки. Так обычно строится работа над крупными проектами с длительным сроком внедрения.\n• Итеративная или инкрементная (эволюционная) модель приращения продукта позволяет параллельно выполнять ряд задач с непрерывным анализом результатов и корректировкой предыдущих этапов работы. Это более «скоростная» разработка для большого штата квалифицированных программистов.\n• Спиральная методика характеризуется прохождением проектом повторяющегося цикла в каждой фазе развития: планирование — реализация — проверка — оценка (англ. plan-do-check-act cycle). Так обычно создаются проекты, с окончательно не сформированным видением результата, либо требующие ультрасрочного внедрения по этапам.\n• Гибкая методология Agile-разработки — т.н. быстрая разработка без ущерба качеству, когда во главу угла ставится работающий продукт, а не его документация. Наиболее современный неформализованный подход к созданию ПО, в процессе которого реагирование на изменения ценятся выше строгого следования плану. Для молодых стремительно развивающихся проектов, которые с каждой итерацией программного обеспечения по сути готовы к его релизу.\n","category":"manual","description":"Методологии разработки ПО (Scrum, Kanban, RUP, DSDM, MSF, XP)"},{"title":"Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)","path":"/zhiznennyj-czikl-testirovaniya-prilozhenij-stlc-software-testing-life-cycle/","content":"\n**STLC, или жизненный цикл тестирования** — это последовательность действий, проводимых в процессе тестирования, с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям. STLC включает действия по верификации и валидации. Тестирование состоит из серии действий, выполняемых по методике, с целью гарантирования качества продукта.\n\n![STLC, или жизненный цикл тестирования](https://testengineer.ru/wp-content/uploads/2021/08/zhiznennyj-cikl-testirovaniya-prilozhenij.svg)\n\nhttps://www.youtube.com/watch?v=bImOPDuXXiQ\n\n## Этапы STLC-цикла\n\nЦикл состоит из шести основных этапов:\n\n### 1. Анализ требований\n\nТестирование на этапе оценки требований (или анализа требований). На этом этапе отдел QA оценивает требования с точки зрения тестирования, ищет требования к софту, которые нужно предварительно оценить. Для этого QA-команда может обращаться к представителям заказчика. Требования могут быть «функциональными» или «нефункциональными», то есть касаться или не касаться функциональной составляющей софта. Также на этом этапе проводится оценка возможности применения автоматизированного тестирования.\n\n**Критерии входа:**\n- Есть документ о требованиях (как функциональных, так и нефункциональных).\n- Описаны критерии приемлемости.\n- Есть документ, описывающий архитектуру приложения.\n\n**Действия на этапе оценки требований:**\n- Анализ планируемой функциональности приложения.\n- Определение ролей пользователей.\n- Сбор требований о пользовательских интерфейсах, аутентификации, локализации и других особенностях.\n- Определение типов тестирования\n- Сбор информации о приоритетах в тестировании\n- Подготовка матрицы отслеживания требований (RTM — Requirement Traceability Matrix)\n- Определение тестового окружения\n- Анализ возможности автоматизации тестирования (если нужно)\n\n**Критерии выхода:**\n- Заполнена RTM-матрица.\n- Подготовлен и согласован отчет о возможности автоматизации\n\n**Результаты этапа оценки требований:**\n- Матрица отслеживания требований (RTM)\n- Отчет о возможности автоматизации (если нужно)\n\n### 2. Планирование тестирования\n\nНа этапе планирования руководитель команды QA определяет стратегию тестирования и оценивает трудозатраты. Также оцениваются ресурсы, тестовое окружение, возможные ограничения и график тестирования. На этом же этапе готовится и финализируется план тестирования.\n\n**Критерии входа:**\n- Есть документы с требованиями.\n- Есть RTM-матрица.\n- Есть документ о возможности автоматизации тестирования\n\n**Действия на этапе планирования:**\n- Анализ возможности различных методов тестирования.\n- Финализация наиболее подходящего метода тестирования.\n- Подготовка стратегии (или плана тестирования)\n- Выбор инструментов тестирования\n- Оценка трудозатрат\n- Планирование ресурсов, определение ролей и ответственности\n- Дополнительное обучение команды (если нужно)\n\n**Критерии выхода:**\n- Готов и согласован документа со стратегией тестирования.\n- Одобрен документ по оценке трудозатрат.\n\n**Результаты:**\n- Документ со стратегией тестирования\n- Документ с оценкой ресурсов\n\n### 3. Создание тест-кейсов\n\nНа этом этапе происходит подготовка тестовых данных и создаются тест-кейсы.\n\n**Критерии входа:**\n- Есть документы с требованиями.\n- Есть RTM-матрица и план тестирования.\n- Есть отчет о возможности автоматизации\n\n**Действия:**\n- Создание тест-кейсов (и автотестов, если будет применяться автоматизация)\n- Обновление тест-кейсов и автоматизированных тестов.\n- Подготовка исходных данных для тестирования\n\n**Критерии выхода:**\n- Готовы тест-кейсы и скрипты.\n- Готовы тестовые данные.\n\n**Результаты:**\n- Тест-кейсы и/или скрипты\n- Тестовые данные\n\n### 4. Настройка тестового окружения\n\nЭто настройка харда и софта, в которых будет осуществляться процесс тестирования. Это один из критически важных аспектов процесса, он может проходить параллельно этапу создания тест-кейсов. QA-команда может и не включаться в этот процесс, если тестовое окружение ей обеспечит команда разработки. QA-команда должна будет проверить работоспособность окружения (хотя бы smoke-тестом).\n\n**Критерии входа:**\n- Готовы документы по дизайну системы и ее архитектуре.\n- Есть план по настройке окружения.\n\n**Действия:**\n- Оценка архитектуры.\n- Создание списка требований к аппаратной и программной части окружения\n- Подготовка задач по настройке окружения.\n- Настройка тестового окружения и тестовых данных.\n- Провести smoke-тест окружения\n- Подготовка и проведение smoke-тестов билда приложения.\n\n**Критерии выхода:**\n- Окружение работает согласно списка требований.\n- Завершена подготовка тестовых данных.\n\n**Результаты:**\n- Настроенное окружение для проведения тестирования\n- Результаты smoke-тестирования окружения\n\n### 5. Выполнение тестирования\n\nНа этапе выполнения тестов QA проводит тестирование, выполняя подготовленные тест-кейсы. Процесс состоит из выполнения тестовых скриптов (при необходимости эти скрипты могут корректироваться). Далее идет создание баг-репортов. Если найдены баги, информация о них передается команде разработки для исправления и повторного тестирования QA-командой.\n\n**Критерии входа:**\n- Есть базовая RTM-матрица, план тестирования, тест-кейсы и/или автоматизированные скрипты.\n- Готово тестовое окружение.\n- Завершена настройка тестовых данных.\n\n**Действия:**\n- Выполнение тестирования в соответствии с планом\n- Получение и документирование результатов тестирования\n- Создание баг-репортов\n- Обновление тест-плана и тест-кейсов (если нужно).\n- Обновление RTM-матрицы (тест-кейсы из RTM-матрицы связываются с найденными багами)\n- Повторное тестирование исправленных багов\n- Регрессионное тестирование приложения.\n- Отслеживание проблемных мест, до закрытия тестирования.\n\n**Критерии выхода:**\n- Все запланированные тесты проведены.\n- Созданы баг-репорты.\n\n**Результаты:**\n- Завершенная RTM-матрица\n- Обновленные тест-кейсы\n- Найденные и описанные баги\n\n### 6. Завершение цикла тестирования\n\nНа этапе завершения тестирования создается отчет о результатах тестирования. QA-команда обсуждает и анализирует баги, делает выводы из возникших проблем, чтобы избежать подобных проблем в будущем.\n\n**Критерии входа:**\n- Тестирование завершено.\n- Есть результаты тестирования.\n- Есть баг-репорты.\n\n**Действия:**\n- Оценка критериев завершения цикла (основывается на времени, трудозатратах, покрытии тестами)\n- Подготовка метрик тестов\n- Подготовка документа с выводами, сделанными во время тестирования\n- Подготовка отчета о завершении тестирования\n- Подготовка отчета для клиента с количественными и качественными характеристиками тестируемой системы\n- Анализ результатов тестирования\n\n**Критерии выхода:**\n- Отчет о завершении тестирования утвержден клиентом.\n\n**Результаты:**\n- Отчет о завершении тестирования\n\n---\n\n**Этапы тестирования:**\n\n1. Анализ продукта\n2. Работа с требованиями\n3. Разработка стратегии тестирования\nи планирование процедур контроля качества\n4. Создание тестовой документации\n5. Тестирование прототипа\n6. Основное тестирование\n7. Стабилизация\n8. Эксплуатация","category":"manual","description":"Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)"},{"title":"Принципы тестирования, Agile принципы тестирования","path":"/princzipy-testirovaniya-agile-princzipy-testirovaniya/","content":"\n## Принципы тестирования\n\nподробнее см [7 принципов тестирования по книге «Foundations of Software Testing: ISTQB Certification» by Dorothy Graham, Erik van Veenendaal, Isabel Evans & Rex Black](https://ibs-training.ru/about/news/7_printsipov_testirovaniya_CHast_1/)\n\n### 1. Тестирование демонстрирует наличие дефектов (Testing shows presence of defects).\nТестирование может показать, что дефекты присутствуют, но не может доказать, что дефектов больше нет.\nСколько бы успешных тестов вы не провели, вы не можете утверждать, что нет таких тестов, которые не нашли бы ошибку.\n\n### 2. Исчерпывающее тестирование невозможно (Exhaustive testing is impossible).\nПолное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо (исключение — тривиальные случаи).\n\nДля проведения исчерпывающего тестирования придется протестировать все возможные входные значения и все пути выполнения программы, в большинстве случаев число таких вариаций стремится к бесконечности или просто на порядки превосходит отведенное время и бюджет. \n\nВместо попыток «протестировать все» нам нужен некий подход к тестированию (стратегия), который обеспечит правильный объем тестирования для данного проекта, данных заказчиков (и других заинтересованных лиц) и данного продукта. \n\nПри определении, какой объем тестирования достаточен, необходимо учитывать уровень риска, включая технические риски и риски, связанные с бизнесом, и такие ограничения проекта как время и бюджет. Оценка и управление рисками - одна из наиболее важных активностей в любом проекте.\n\n### 3. Раннее тестирование (Early testing).\nСледует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.\n\nТестовые активности должны начинаться как можно раньше в SDLC, а именно когда сформированы требования.\n\nЭтот принцип связан с понятием «цена дефекта» (cost of defect). Цена дефекта существенно растет на протяжении жизненного цикла разработки ПО. Чем раньше обнаружен дефект, тем быстрее, проще и дешевле его исправить. Дефект, найденный в требованиях, обходится дешевле всего.\n\nЕще одно важное преимущество раннего тестирования - экономия времени. Тестовые активности могут начинаться еще до того, как написана первая строчка кода. По мере того, как готовятся требования и спецификации, тестировщики могут приступать к разработке и ревью тест-кейсов. И когда появится первая тестовая версия, можно будет сразу приступать к выполнению тестов.\n\n### 4. Скопление дефектов (Defects clustering).\nБольшая часть дефектов находится в ограниченном количестве модулей.\n\nНебольшое количество модулей содержит большинство дефектов, обнаруженных на этапе предрелизного тестирования, или же демонстрируют наибольшее количество отказов на этапе эксплуатации.\n\nМногие тестировщики наблюдали такой эффект - дефекты «_кучкуются_». Это может происходить потому, что определенная область кода особенно сложна и запутана, или потому, что внесение изменений производит «_эффект домино_». Это знание часто используется для оценки рисков при планировании тестов - тестировщики фокусируются на известных «_проблемных зонах_». Также полезно проводить анализ _первопричин (root cause analysis)_, чтобы предотвратить повторное появление дефектов, обнаружить причины возникновения скоплений дефектов и спрогнозировать потенциальные скопления дефектов в будущем.\n\n### 5. Парадокс пестицида (Pesticide paradox).\nЕсли повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты.\n\nBoris Beizer в своей книге Software Testing Techniques объяснил парадокс пестицида как феномен, согласно которому чем больше вы тестируете ПО, тем более невосприимчивым оно становится к имеющимся тестам, т.е.\n- каждый метод и набор тестов, который используется для предотвращения или поиска ошибок, может оставлять часть не найденных ошибок, против которых эти методы и тесты неэффективны;\n- имеющиеся тесты устаревают после исправления дефекта и не могут обнаружить новые;\n\nИз чего следует, что набор тестов, тестовых данных и подходов нужно постоянно пересматривать и улучшать для выявления не найденных ошибок, а также необходимо обновлять тесты и тестовые данные после исправления уже найденных дефектов.\n\n### 6. Тестирование зависит от контекста (Testing is context depending). \nТестирование выполняется по-разному, в зависимости от контекста. Например, тестирование систем, критических с точки зрения безопасности, проводится иначе, чем тестирование сайта интернет-магазина.\n\nЭтот принцип тесно связан с понятием риска. Что такое риск? Риск - это потенциальная проблема. У риска есть вероятность (likelihood) - она всегда выше 0 и ниже 100% - и есть влияние (impact) - те негативные последствия, которых мы опасаемся. Анализируя риски, мы всегда взвешиваем эти два аспекта: вероятность и влияние.\n\nТо же можно сказать и о мире ПО: разные системы связаны с различными уровнями риска, влияние того или иного дефекта также сильно варьируется. Одни проблемы довольно тривиальны, другие могут дорого обойтись и привести к большим потерям денег, времени, деловой репутации, а в некоторых случаях даже привести к травмам и смерти.\n\nУровень риска влияет на выбор методологий, техник и типов тестирования.\n\n### 7. Заблуждение об отсутствии ошибок (Absence-of-errors fallacy). \nОтсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.\n\nНахождение и исправление дефектов бесполезно, если построенная система неудобна для использования и не соответствует нуждам и ожиданиям пользователей.\n\nЗаказчики ПО - люди и организации, которые покупают и используют его, чтобы выполнять свои повседневные задачи - на самом деле совершенно не интересуются дефектами и их количеством, кроме тех случаев, когда они непосредственно сталкиваются с нестабильностью продукта. Им также неинтересно, насколько ПО соответствует формальным требованиям, которые были задокументированы. Пользователи ПО более заинтересованы в том, чтобы оно помогало им эффективно выполнять задачи. ПО должно отвечать их потребностям, и именно с этой точки зрения они его оценивают.\nДаже если вы выполнили все тесты и ошибок не обнаружили, это еще не гарантия того, что ПО будет соответствовать нуждам и ожиданиям пользователей.\nИначе говоря, верификация не равна валидации.\n\n## Гибкое тестирование\n\n**Гибкое тестирование (agile testing):** Способ тестирования для проектов, использующих гибкие\nметодологии разработки программного обеспечения, включающий такие техники и методы, как\nэкстремальное программирование, и рассматривающий процесс разработки как потребителя\nпроцесса тестирования и делающий упор на парадигму раннего тестирования.\n\n## Принципы Agile тестирования  \n\nпо книге [E. Hendrickson - Agile Testing Nine Principles and Six Concrete Practies for Testing on Agile Teams](http://testobsessed.com/wp-content/uploads/2011/04/AgileTestingOverview.pdf)\n\n### 1. Тестирование продвигает проект вперед\nВ традиционных проектах тестирование обычно рассматривается как контроль качества, а QA/Test группа часто служит привратником качества. Предотвращение выход плохого программного обеспечения в поле, считается обязанностью\nтестирования. Результат этого подхода долгие, затяжные встречи по поиску ошибок, на которых мы спорим о приоритете ошибок, обнаруженных в ходе тестирования, и достаточно ли они важны и/или серьезные, чтобы задержать релиз.\n\nВ Agile-командах мы с самого начала хорошо создаем продукт, используя тестирование для предоставления обратной связи на постоянной основе о том, насколько хорошо новый продукт удовлетворяет потребности бизнеса.\nЭто выглядит как небольшое изменение, но оно имеет глубокие последствия. \n\nВраждебные отношения, которые некоторые организации поддерживают между тестировщиками и разработчиками, должны быть заменен духом сотрудничества. Это совершенно другое мышление.\n\n### 2. Тестирование — это НЕ один из этапов…\n…в Agile-командах тестирование — это образ жизни.\n\nAgile-команды постоянно тестируют. Это единственный способ убедиться, что функции реализованные во время данной итерации или спринта, фактически выполняются.\nНепрерывное тестирование — единственный способ обеспечить непрерывный прогресс.\n\n### 3. Все тестируют\nВ традиционных проектах независимые тестировщики несут ответственность за все действия по тестированию.\n\nВ Agile за проведение тестирования отвечает вся команда. Да, тестеры выполняют тесты. Разработчики тоже.\n\nНеобходимость провести все тесты за одну итерацию может означать, что команда просто не сможет сделать в каждом спринте столько, сколько они изначально думали. Если это так, то Agile сделал видимым несоответствие импеданса между тестом и разработчиком, которое уже\nсуществовал. А это значит, что команда двигалась не так быстро, как они думали. \n\nИм казалось, все идет быстро, потому что разработчики шли быстро. Но если тестирование не сделано, фичи не сделаны, и у команды просто нет той скорости о которой они думают.\n\nДругая точка зрения на эту идею состоит в том, что тестирование — это «травка» в команде. Теория ограничений гласит, что вся команда может только идти так быстро, как идет самая медленная часть. \nЧтобы работать быстрее, команда должна увеличить пропускную способность самой медленной часть процесса. Устранить узкое место; все тестируют.\n\n### 4. Сокращение оборотов обратной связи\n\nКак долго команда должна ждать информацию о том, как ведет себя программное обеспечение? Измерьте время между написанием программистом строки кода, и тем, когда кто-то или что-то выполняет этот код и предоставляет информацию о том, как он себя ведет. Это обратная связь.\n\nЕсли программное обеспечение не протестировано до самого конца длинного релиза, циклы обратной связи будут увеличены и могут измеряться месяцами. Это слишком долго.\n\nБолее короткие петли обратной связи повышают гибкость. К счастью, на Agile-проектах программное обеспечение готово к тестированию практически с самого начала. А Agile-команды обычно используют несколько уровней тестирования для выявления разных типов информации.\n\nАвтоматизированные модульные тесты проверяют поведение отдельных функций/методов и взаимодействие объектов. Они запускаются часто и предоставляют обратную связь в считанные минуты. Автоматизированные приемочные тесты обычно проверяют поведение системы от начала до конца. (Хотя иногда они обходят графический интерфейс, проверяя лежащую в основе бизнес-логику.) Как правило, они запускаются на зарегистрированном коде на постоянной основе, предоставляя обратную связь примерно через час. Гибкие проекты предпочитают автоматизированные тесты из-за быстрой обратной связи, которую они обеспечивают.\n\nРучные регрессионные тесты занимают больше времени и, поскольку человек должен быть доступен, могут начаться не сразу. Время обратной связи увеличивается до дней или недель.\n\nРучное тестирование, особенно ручное исследовательское тестирование, по-прежнему важно. Однако Agile-команды обычно обнаруживают, что быстрая обратная связь, обеспечиваемая автоматической регрессией, является ключом к быстрому обнаружению проблем, что снижает риск и количество доработок.\n\n### 5. Держите код в чистоте\nЭтот принцип является примером дисциплины Agile-команд. Требуется огромная внутренняя дисциплина, чтобы исправлять ошибки по мере их обнаружения. \n\nЕсли это настоящая ошибка, а не новая фича, она исправляется в ходе итерации. \n\nВ противном случае это все равно, что готовить на грязной кухне: для приготовления пищи требуется больше времени, чтобы пробраться через беспорядок, и полученная еда может быть съедобной, а может и не быть.\n\n### 6. Легкая документация\nВместо того, чтобы писать многословную исчерпывающую тестовую документацию, Agile-тестировщики:\n\n- Используют многоразовые чек листы, чтобы предлагать тесты\n- Сосредоточиваются на сути теста, а не на второстепенных деталях\n- Используют упрощенные стили/инструменты для документации.\n- Фиксируют идеи тестирования в чартерах для исследовательского тестирования\n- Используют документы для различных целей\n\n### 7. Использование одного тестового артефакта для ручных и автоматических тестов\nВместо того, чтобы вкладывать средства в обширные, тяжеловесные пошаговые сценарии ручного тестирования в Word или инструмент управления тестированием, мы фиксируем ожидания в формате, поддерживаемом системы автоматизированного тестирования, такие как FIT/Fitnesse. \n\nТест может быть выполнен вручную, но что более важно, тот же тестовый артефакт становится автоматическим тестом, когда программисты пишут приспособление для подключения теста к тестируемому программному обеспечению.\n\n### 8. «Сделано Сделано», а не просто Сделано\nВ традиционных средах со строгим разделением между разработкой и тестированием разработчики обычно говорят, что они «закончили» работу с функцией после ее реализации, но до ее тестирования.\n\nКонечно, функция не «готова», пока она не будет протестирована и не будут исправлены все ошибки. Вот почему в отрасли существует давняя шутка о том, что данный выпуск программного обеспечения обычно «готов на 90%» для 90% проекта. (Или, другими словами, последние 10 % усилий занимают 90 % времени.)\n\nAgile-команды не считают что-то «сделанным» и готовым к принятию владельцем продукта или заказчиком до тех пор, пока оно не будет реализовано и протестировано.\n\n### 9. Test-Last v. Test-Driven\nВ традиционных средах тесты создаются на основе артефактов проекта, таких как документы с требованиями. \n\nТребования и дизайн на первом месте, а затем тесты. И выполнение этих тестов происходит в конце проекта. Это подход «testlast».\n\nТем не менее, тесты предоставляют конкретные примеры того, что означает для нового программного обеспечения соответствие требованиям. \n\nФормирование тестов вместе с требованиями, а не после, и использование этих тестов для управления усилиями по разработке дает нам гораздо более четкие критерии выполнения и общее внимание к цели. \n\nЭтот подход, основанный на тестировании, можно увидеть в практиках TDD и ATDD.\n \n \n \n ---\n \nПринцип 1 — Тестирование демонстрирует наличие дефектов (Testing shows presence of defects)\nТестирование может показать, что дефекты присутствуют, но не может доказать, что их нет. Тестирование снижает вероятность наличия дефектов, находящихся в программном обеспечении, но, даже если дефекты не были обнаружены, это не доказывает его корректности.\n\nПринцип 2 — Исчерпывающее тестирование недостижимо (Exhaustive testing is impossible)\nПолное тестирование с использованием всех комбинаций вводов и предусловий физически невыполнимо, за исключением тривиальных случаев. Вместо исчерпывающего тестирования должны использоваться анализ рисков и расстановка приоритетов, чтобы более точно сфокусировать усилия по тестированию.\n\nПринцип 3 — Раннее тестирование (Early testing)\nЧтобы найти дефекты как можно раньше, активности по тестированию должны быть начаты как можно раньше в жизненном цикле разработки программного обеспечения или системы, и должны быть сфокусированы на определенных целях.\n\nПринцип 4 — Скопление дефектов (Defects clustering)\nУсилия тестирования должны быть сосредоточены пропорционально ожидаемой, а позже реальной плотности дефектов по модулям. Как правило, большая часть дефектов, обнаруженных при тестировании или повлекших за собой основное количество сбоев системы, содержится в небольшом количестве модулей.\n\nПринцип 5 — Парадокс пестицида (Pesticide paradox)\nЕсли одни и те же тесты будут прогоняться много раз, в конечном счете этот набор тестовых сценариев больше не будет находить новых дефектов. Чтобы преодолеть этот «парадокс пестицида», тестовые сценарии должны регулярно рецензироваться и корректироваться, новые тесты должны быть разносторонними, чтобы охватить все компоненты программного обеспечения,\nили системы, и найти как можно больше дефектов.\n\nПринцип 6 — Тестирование зависит от контекста (Testing is concept depending)\nТестирование выполняется по-разному в зависимости от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем сайт электронной коммерции.\nПринцип 7 — Заблуждение об отсутствии ошибок (Absence-of-errors fallacy)\nОбнаружение и исправление дефектов не помогут, если созданная система не подходит пользователю и не удовлетворяет его ожиданиям и потребностям.\n\n \n \n ","category":"manual","description":"Принципы тестирования, Agile принципы тестирования"},{"title":"Практики и подходы тестирования","path":"/praktiki-i-podhody-testirovaniya/","content":"\n## TDD - Test Driven Development\nРазработка на основе тестов основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест. Затем проводится рефакторинг написанного кода с постоянной проверкой прохождения тестов. \n\nЕсть два уровня TDD:\n\n- Acceptance TDD (ATDD): вы пишете один приемочный тест. Этот тест удовлетворяет требованиям спецификации или удовлетворяет поведению системы. После этого пишете достаточно производственного / функционального кода, чтобы выполнить этот приемочный тест. Приемочный тест фокусируется на общем поведении системы. ATDD также известен как BDD - Behavior Driven Development;\n- Developer TDD: вы пишете один тест разработчика, то есть модульный тест, а затем просто достаточно производственного кода для выполнения этого теста. Модульное тестирование фокусируется на каждой небольшой функциональности системы. Это называется просто TDD. Основная цель ATDD и TDD - определить подробные, выполнимые требования для вашего решения точно в срок (JIT). JIT означает принятие во внимание только тех требований, которые необходимы в системе, что повышает эффективность.\n\n## BDD - Behaviour Driven Development\nЭто разработка, основанная на описании поведения. Определенный человек(или люди) пишет описания вида \"я как пользователь хочу когда нажали кнопку пуск тогда показывалось меню как на картинке\" (там есть специально выделенные ключевые слова). Программисты давно написали специальные тулы, которые подобные описания переводят в тесты (иногда совсем прозрачно для программиста). А дальше классическая разработка с тестами (TDD);\n\n## TDD - Type Driven Development\nПри разработке на основе типов ваши типы данных и сигнатуры типов являются спецификацией программы. Типы также служат формой документации, которая гарантированно обновляется. Типы представляют из себя небольшие контрольные точки, благодаря которым, мы получаем множество мини-тестов по всему нашему приложению;\n\n## DDD - Domain Driven Design\nПредметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD - это набор правил, которые позволяют принимать правильные проектные решения. Это набор принципов и схем, направленных на создание оптимальных систем объектов. Процесс разработки сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом;\n\n## FDD - Features Driven Development\nПредставляет собой попытку объединить наиболее признанные в индустрии разработки программного обеспечения методики, принимающие за основу важную для заказчика функциональность (свойства) разрабатываемого программного обеспечения. Основной целью данной методологии является разработка реального, работающего программного обеспечения систематически, в установленные сроки;\n\n## MDD - Model Driven Development\nРазработка, управляемая моделями - это стиль разработки программного обеспечения, когда модели становятся основными артефактами разработки, из которых генерируется код и другие артефакты;\n\n## PDD - Panic Driven Development\nЭто своеобразный антипаттерн разработки, который, к сожалению, мы все время от времени практикуем. По сути это то, что получается, когда процессы плохо налажены и команда импровизирует в условиях горящих сроков (новые задачи приоритетнее старых, код решает конкретные срочные задачи, но копится технический долг, тестирование в конце и т.д.);\n\n## ADD - API Driven Development\nРазработка на основе API - это практика сначала проектирования и создания API, а затем создания на их основе остальной части приложения;\n\n## BDT - Behavior Driven Testing\nВ тестировании на основе поведения ваши тесты основаны на user stories, которые описывают некоторые конкретные ожидаемые действия приложения. Вместо проверки деталей реализации вы фактически проверяете то, что важно больше всего: правильно ли приложение выполняет user stories. Еще одним преимуществом является понятность тестов для менеджеров, аналитиков и т.п.;\n\n## MDT - Model Driven Testing\nТестирование на основе моделей - это метод тестирования черного ящика, при котором поведение тестируемого программного обеспечения во время выполнения проверяется на основе прогнозов, сделанных моделями. Модель - это описание поведения системы. Поведение может быть описано в виде наглядной схемы, Data Flow, Control Flow, Dependency Graphs, Decision Tables, State transition machines или mind map. Простой аналогией модели в тестировании является электрическая схема при разработке электроприбора. Этот подход к тестированию требуется, когда высока цена ошибки в большом продукте и нужно как можно раньше попытаться ее предотвратить;\n\n## DDT - Data Driven Testing (table-driven testing or parameterized testing)\nВ тестировании на основе данных тестовые данные хранятся в виде таблицы. Оно позволяет одним скриптом выполнять тесты для всех тестовых данных из таблицы и ожидать результатов теста в той же таблице;\n\n## VDT - Value Driven Testing\nТестирование на основе ценности - это подход, в основе которого лежит анализ ценности и экономической целесообразности тестирования.\n\n## Подход к тестированию (Test Approach)\n\n_Подход к тестированию (test approach): Реализация стратегии тестирования для определенного проекта. Обычно включает в себя заключения, сделанные на основе цели (тестирования) проекта и анализе рисков, стартовые точки процесса тестирования, применяемые методики разработки тестов, критерии выхода, типы тестирования, которые должны быть произведены. (ISTQB)_\n\n_Оценка риска (risk assessment): Процесс идентификации и последующего анализа определенного риска проекта или продукта с целью определить его уровень. Обычно состоит из назначения рейтинга вероятности и влияния. (ISTQB)_\n\n_Цель тестирования (test target): Набор критериев выхода. (ISTQB)_\n\nПодход к тестированию - это реализация стратегии тестирования для конкретного проекта.\n\nПодход к тестированию определяется и уточняется в test plans and test designs. Подход к тестированию обычно включает решения, принимаемые на основе цели (тестового) проекта и оценки рисков (risk assessment). Подход к тестированию является отправной точкой для планирования процесса тестирования, для выбора применяемых методов проектирования тестов и типов тестов, а также для определения критериев начала и окончания тестирования. Выбранный подход зависит от контекста и может учитывать риски, опасности и безопасность, доступные ресурсы и навыки, технологии, характер системы (например, [custom built](https://en.wikipedia.org/wiki/Custom\\_software) vs. [commercially available off-the-shelf (COTS)](https://en.wikipedia.org/wiki/Commercial\\_off-the-shelf)), цели тестирования (test objectives) и правила.\n\nПодход к тестированию включает две техники:\n\n* Упреждающий (Proactive) - подход, при котором test design process запускается как можно раньше, чтобы найти и исправить дефекты до создания сборки (build);\n* Реактивный (Reactive) - подход, при котором тестирование не начинается до завершения проектирования и разработки.\n\nРазличные подходы к тестированию:\n\n* **Аналитические подходы (Analytical approaches)**, такие как risk-based testing, когда тестирование направлено на области наибольшего риска;\n* **Подходы на основе моделей (Model-based approaches)**, такие как стохастическое тестирование с использованием статистической информации о частоте отказов (например, модели роста надежности) или использовании (например, рабочие профили);\n* **Методические подходы (Methodical approaches)**, такие как основанные на отказах (failure-based) (включая error guessing and fault attacks), основанные на опыте, на основе чек-листов и на основе характеристик качества (experience-based, checklist-based, and quality characteristic-based);\n* **Подходы, соответствующие процессам или стандартам (Process- or standard-compliant approaches)**, например, указанные в отраслевых стандартах или различных гибких методологиях;\n* **Динамические и эвристические подходы (Dynamic and heuristic approaches)**, такие как exploratory testing, при котором тестирование более реагирующее (reactive) на события, чем при запланированном заранее (pre-planned), и где выполнение и оценка (execution and evaluation) являются параллельными задачами;\n* **Консультативные подходы (Consultative approaches)** - подходы, при которых test coverage определяется в первую очередь советами и руководством экспертов в области технологий и / или бизнеса, не входящих в группу тестирования;\n* **Подходы против регрессии (Regression-averse approaches)** - подходы, которые включают повторное использование существующего тестового материала, обширную автоматизацию функциональных регрессионных тестов и стандартные наборы тестов.\n\nМожно комбинировать разные подходы, например, динамический подход, основанный на оценке риска.\n\n","category":"manual","description":"Практики и подходы тестирования"},{"title":"Виды тестирования","path":"/vidy-testirovaniya/","content":"\nТип тестирования (test type): Совокупность тестирующих действий, которая фокусируется на определенных показателях качества. (ГОСТ 56920) Прим.: в русскоязычной среде это “вид”.\n\n1. [Классификация по запуску кода на исполнение](/vidy-testirovaniya-po-zapusku-koda-na-ispolnenie/)\n\n2. [Классификация по доступу к коду и архитектуре приложения](/vidy-testirovaniya-po-dostupu-k-kodu-i-arhitekture-prilozheniya/)\n\n3. [Классификация по степени автоматизации](/vidy-testirovaniya-po-stepeni-avtomatizaczii/)\n\n4. [Классификация по уровню деталиции приложения (по уровню тестирования)](/vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/)\n\n5. [Классификация по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)](/vidy-testirovaniya-po-ubyvaniyu-stepeni-vazhnosti-testiruemyh-funkczij-po-urovnyu-funkczionalnogo-testirovaniya/)\n\n6. [Классификация по принципам работы с приложением](/vidy-testirovaniya-po-princzipam-raboty-s-prilozheniem/)\n\n7. [Классифкация по природе приложения](/vidy-testirovaniya-po-prirode-prilozheniya/)\n\n8. [Классификация по фокусировке на уровне архитектуры приложения](/vidy-testirovaniya-po-fokusirovke-na-urovne-arhitektury-prilozheniya/)\n\n9. [Классификация по привлечению конечных пользователей](/vidy-testirovaniya-po-privlecheniyu-konechnyh-polzovatelej/)\n\n10. [Классификация по степени формализации](/vidy-testirovaniya-po-stepeni-formalizaczii/)\n\n11. [Классификация по целям и задачам](/vidy-testirovaniya-po-czelyam-i-zadacham/)\n\n12. [Классификация по техникам и подходам](/vidy-testirovaniya-po-tehnikam-i-podhodam/)\n\n13. [Классификация по моменту выполнения (хронологии)](/vidy-testirovaniya-po-momentu-vypolneniya-hronologii/)\n\n14. [Другие виды тестирования](/drugie-vidy-testirovaniya/)\n\n![Виды тестирования](https://ic.pics.livejournal.com/qualityplan/44671565/741/741_900.png)\n","category":"manual","description":"Виды тестирования"},{"title":"Виды тестирования по запуску кода на исполнение","path":"/vidy-testirovaniya-po-zapusku-koda-na-ispolnenie/","content":"\n## Статическое тестирование (Static testing)\nПроизводится без запуска программного кода продукта.\n\nВ рамках этого подхода тестированию могут подвергаться:\n  - Документы (требования, спецификация, документация, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).\n  - Графические прототипы(например, эскизы пользовательского интерфейса).\n  - Код приложения (что часто выполняется самими программистами в рамках аудита кода (code review), являющегося специфической вариацией взаимного просмотра в применении к исходному коду). Код приложения также можно проверять с использованием техник тестирования на основе структур кода.\n  - Параметры(настройки) среды исполнения приложения.\n  - Подготовленные тестовые данные.\n\n## Динамическое тестирование (Dynamic testing)\nТестирование с запуском кода на исполнение. \n\nЗапускаться на исполнение может как код всего приложения целиком (системное тестирование), так и код нескольких взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) и даже отдельные участки кода. \n\nОсновная идея этого вида тестирования состоит в том, что проверяется реальное поведение (части) приложения.","category":"manual","description":"Виды тестирования по запуску кода на исполнение"},{"title":"Виды тестирования по степени формализации","path":"/vidy-testirovaniya-po-stepeni-formalizaczii/","content":"\n## Тестирование на основе тест-кейсов (Scripted testing, Test case based testing)\nФормализованный подход, в котором тестирование производится на основе заранее подготовленных тест-кейсов, наборов тест-кейсов и иной документации. \n\nЭто самый распространённый способ тестирования, который также позволяет достичь максимальной полноты исследования приложения за счёт строгой систематизации процесса, удобства применения метрик и широкого набора выработанных за десятилетия и проверенных на практике рекомендаций.\n\n## Исследовательское тестирование (Exploratory testing)\nЧастично формализованный подход, в рамках которого тестировщик выполняет работу с приложением по выбранному сценарию, который, в свою очередь, дорабатывается в процессе выполнения с целью более полного исследования приложения. \n\nКлючевым фактором успеха при выполнении исследовательского тестирования является именно работа по сценарию, а не выполнение разрозненных бездумных операций. Существует даже специальный сценарный подход, называемый сессионным тестированием (session-based testing). \n\nВ качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы, и тогда этот вид тестирования называют тестированием на основе чек-листов (checklist-based testing).\n\n## Свободное (интуитивное) тестирование (Ad hoc testing)\nПолностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев — тестировщик полностью опирается на свой профессионализм и интуицию (experience-based testing) для спонтанного выполнения с приложением действий, которые, как он считает, могут обнаружить ошибку. \n\nЭтот вид тестирования используется редко и исключительно как дополнение к полностью или частично формализованному тестированию в случаях, когда для исследования некоторого аспекта поведения приложения (пока?) нет тест-кейсов.\n\nНи в коем случае не стоит путать исследовательское и свободное тестирование. Это разные техники исследования приложения с разной степенью формализации, разными задачами и областями применения.","category":"manual","description":"Виды тестирования по степени формализации"},{"title":"Виды тестирования по целям и задачам","path":"/vidy-testirovaniya-po-czelyam-i-zadacham/","content":"\n## Классификация\n\n- Функциональное(«Что?» - проверяет весь функционал продукта)\n  - Тестирование данных\n  - Приемочное тестирование\n  - Операционное тестирование\n  - Тестирование пользовательского интерфейса (GUI Testing)\n\n- Нефункциональное(«Как?»)\n  - Тестирование производительности\n  - Нагрузочное тестирование\n  - Стрессовое тестирование\n  - Тестирование масштабируемости\n  - Объемное тестирование\n  - Тестирование надежности\n  - Тестирование восстанавливаемости\n  - Тестирование отказоустойчивости\n  - Тестирование безопасности\n  - Тестирование удобства использования\n  - Тестирование доступности -\n  - Тестирование совместимости\n  - Тестирование интернационализации\n  - Тестирование локализации\n  - Инсталяционное (тестирование установки)\n  - Конфигурационное тестирование -\n  - Конкурентное тестирование - \n  - Тестирование использоваиня ресурсов - \n  - Сравнительное тестирование - \n\n- Связанные с изменениями \n  - Дымовое\n  - Регрессионное\n  - Тестирвание сборки\n  - Санитарное тестирование\n  - Повторное тестирование\n\n## Функциональное тестирование (Functional/Behavioral testing)\nВид тестирования, направленный на проверку корректности работы функциональности приложения (корректность реализации функциональных требований). \n\nЧасто функциональное тестирование ассоциируют с тестированием по методу чёрного ящика, однако и по методу белого ящика вполне можно проверять корректность реализации функциональности.\n\nЧасто возникает вопрос, в чём разница между функциональным тестированием (functional testing) и тестированием функциональности (functionality testing).\n\nЕсли вкратце, то:\n- **_функциональное тестирование_** (как антоним нефункционального) направлено на проверку того, какие функции приложения реализованы, и что они работают верным образом;\n- **_тестирование функциональности_** направлено на те же задачи, но акцент смещён в сторону исследования приложения в реальной рабочей среде, после локализации и в тому подобных ситуациях.\n\n**Для функционального тестирования принято использовать две техники**:\n\n* Тестирование на основе требований: содержит все функциональные спецификации, которые составляют основу для всех тестов, которые будут проводиться;\n* Тестирование на основе бизнес-сценариев: содержит информацию о том, как система будет восприниматься с точки зрения бизнес-процесса;\n\n**Основные виды функционального тестирования**:\n\n- Юнит тестирование (Unit Testing)\n- Дымовое тестирование (Smoke Testing)\n- Санитарное тестирование (Sanity Testing)\n- Интеграционное тестирование (Integration Tests),\n- Бета тестирование (Beta Testing)\n- Системное тестирование (System testing)\n- End to end testing\n- Тестирование пользовательского интерфейса (GUI Testing)\n\n### Регрессионное тестирование (Regression testing)\nТестирование, направленное на проверку того факта, что в ранее работоспособной функциональности не появились ошибки, вызванные изменениями в приложении или среде его функционирования. \n\nФредерик Брукс в своей книге «Мифический человеко-месяц» писал: «Фундаментальная проблема при сопровождении программ состоит в том, что исправление одной ошибки с большой вероятностью (20–50 %) влечёт появление новой». Потому регрессионное тестирование является неотъемлемым инструментом обеспечения качества и активно используется практически в любом проекте.\n\n### Повторное тестирование (Re-testing, confirmation testing)\nВыполнение тест-кейсов, которые ранее обнаружили дефекты, с целью подтверждения устранения дефектов. \n\nФактически этот вид тестирования сводится к действиям на финальной стадии жизненного цикла отчёта о дефекте, направленным на то, чтобы перевести дефект в состояние «проверен» и «закрыт».\n\n### Приёмочное тестирование (Acceptance testing)\nФормализованное тестирование, направленное на проверку приложения с точки зрения конечного пользователя/заказчика и вынесения решения о том, принимает ли заказчик работу у исполнителя (проектной команды).\n\nМожно выделить следующие подвиды приёмочного тестирования (хотя упоминают их крайне редко, ограничиваясь в основном общим термином «приёмочное тестирование»):\n\n- **_Производственное приёмочное тестирование (Factory acceptance testing)_**  \nВыполняемое проектной командой исследование полноты и качества реализации приложения с точки зрения его готовности к передаче заказчику. Этот вид тестирования часто рассматривается как синоним альфа-тестирования.\n\n- **_Операционное приёмочное тестирование (Operational acceptance testing, production acceptance testing)_** \nОперационное тестирование, выполняемое с точки зрения выполнения инсталляции, потребления приложением ресурсов, совместимости с про- граммной и аппаратной платформой и т. д.\n\n- **_Итоговое приёмочное тестирование (Site acceptance testing)_**  \nТестирование конечными пользователями (представителями заказчика) приложения в реальных условиях эксплуатации с целью вынесения решения о том, требует ли приложение доработок или может быть принято в эксплуатацию в текущем виде.\n\n### Операционное тестирование (Operational testing)\nТестирование, проводимое в реальной или приближенной к реальной операционной среде (operational environment), включающей операционную систему, системы управления базами данных, серверы приложений, веб-серверы, аппаратное обеспечение и т. д.\n\n### Тестирование интерфейса (Interface testing)\nТестирование, направленное на проверку интерфейсов приложения или его компонентов. \n\nПо определению ISTQB-глоссария этот вид тестирования относится к интеграционному тестированию, и это вполне справедливо для таких его вариаций как тестирование интерфейса прикладного программирования (API testing182) и интерфейса командной строки (CLI testing), хотя последнее может выступать и как разновидность тестирования пользовательского интерфейса, если через командную строку с приложением взаимодействует пользователь, а не другое приложение. Однако многие источники предлагают включить в состав тестирования интерфейса и тестирование непосредственно интерфейса пользователя (GUI testing).\n\n## Нефункциональное тестирование (Non-Functional testing)\n\nВид тестирования, направленный на проверку нефункциональных особенностей приложения (корректность реализации нефункциональных требований), таких как удобство использования, совместимость, производительность, безопасность и т.д.\n\nВ большинстве случаев это выполняется методом black box testing. Оно проверяет, соответствует ли поведение системы требованиям по всем аспектам, не охваченные функциональным тестированием. \n\nВ нашем повседневном тестировании много внимания уделяется функциональному тестированию и функциональным требованиям и клиенты также заинтересованы в выполнении функциональных требований, которые напрямую связаны с функциональностью приложения, но когда ПО выходит на рынок и используется реальными конечными пользователями, у них есть шансы столкнуться с проблемами. Эти проблемы не связаны с функциональностью системы, но могут негативно повлиять на пользовательский опыт.\n\n**Нефункциональные требования могут быть отражены как**:\n\n* Пользовательские / Технические истории (User /Technical Stories): запись нефункциональных требований в виде пользовательской истории такая же, как и запись любых других требований. Единственная разница между пользователем и технической историей заключается в том, что пользовательская история требует обсуждения и имеет видимость (? visibility);\n* В критериях приемки (Acceptance criteria): это точка, которая определяется для принятия продукта заказчиком. Нефункциональное требование должно быть включено в критерии приемки, но иногда невозможно проверить нефункциональные требования с каждой историей, то есть с каждой итерацией. Следовательно, требования следует добавлять или тестировать только с соответствующей итерацией;\n* В артефактах (Artifact): для нефункциональных требований следует подготовить отдельный артефакт, это, в свою очередь, поможет лучше понять, что нужно тестировать и как это можно делать в итерациях;\n\n### Инсталляционное тестирование (Installation testing, Installability testing)\nТестирование, направленное на выявление дефектов, влияющих на протекание стадии инсталляции (установки) приложения. \n\nВ общем случае такое тестирование проверяет множество сценариев и аспектов работы инсталлятора в таких ситуациях, как:\n- новая среда исполнения, в которой приложение ранее не было инсталлировано;\n- обновление существующей версии(«апгрейд»);\n- изменение текущей версии на более старую(«даунгрейд»);\n- повторная установка приложения с целью устранения возникших проблем («переинсталляция»);\n- повторный запуск инсталляции после ошибки, приведшей к невозможности продолжения инсталляции;\n- удаление приложения;\n- установка нового приложения из семейства приложений;\n- автоматическая инсталляция без участия пользователя.\n\n### Тестирование удобства использования (Usability testing)\nТестирование, направленное на исследование того, насколько конечному пользователю понятно, как работать с продуктом (understandability, learnability, operability), а также на то, насколько ему нравится использовать продукт (attractiveness). И это не оговорка — очень часто успех продукта зависит именно от эмоций, которые он вызывает у пользователей. \n\nДля эффективного проведения этого вида тестирования требуется реализовать достаточно серьёзные исследования с привлечением конечных пользователей, проведением маркетинговых исследований и т. д.\n\nТестирование удобства использования (usability testing) и тестирование интерфейса пользователя (GUI testing) — не одно и то же! \nНапример, корректно работающий интерфейс может быть неудобным, а удобный может работать некорректно.\n\n### Тестирование доступности (Accessibility testing)\nТестирование, направленное на исследование пригодности продукта к использованию людьми с ограниченными возможностями (слабым зрением и т.д.)\n\n### Тестирование безопасности (Security testing)\nТестирование, направленное на проверку способности приложения противостоять злонамеренным попыткам получения доступа к данным или функциям, права на доступ к которым у злоумышленника нет.\n\nПроверяется:\n\n* Аутентификация (Authentication): только достоверный пользователь может войти в систему;\n* Авторизация (Authorized): пользователь должен иметь возможность входить в те модули, для которых он авторизован или к которым пользователю был предоставлен доступ;\n* Пароль: Требование пароля должно быть подтверждено, т.е. пароль должен соответствовать тому, как это требование определяется, то есть длине, специальным символам, числам и т. д.;\n* Тайм-аут: если приложение неактивно, оно должно истечь по таймауту в указанное время;\n* Резервное копирование данных: резервное копирование данных должно быть выполнено в указанное время и данные должны быть скопированы в безопасное место;\n* Внутренние ссылки на веб-приложение не должны быть доступны, если размещены непосредственно в браузере;\n* Вся коммуникация должна быть зашифрована;\n\n### Тестирование интернационализации (Internationalization testing, I18n testing, Globalization testing, Localizability testing)\nТестирование, направленное на проверку готовности продукта к работе с использованием различных языков и с учётом различных национальных и культурных особенностей. \n\nЭтот вид тестирования не подразумевает проверки качества соответствующей адаптации (этим занимается тестирование локализации, см. следующий пункт), оно сфокусировано именно на проверке возможности такой адаптации (например: что будет, если открыть файл с иероглифом в имени; как будет работать интерфейс, если всё перевести на японский; может ли приложение искать данные в тексте на корейском и т. д.).\n\n### Тестирование локализации (Localization testing, L10n)\nТестирование, направленное на проверку корректности и качества адаптации продукта к использованию на том или ином языке с учётом национальных и культурных особенностей. \n\nЭто тестирование следует за тестированием интернационализации (см. предыдущий пункт) и проверяет корректность перевода и адаптации продукта, а не готовность продукта к таким действиям.\n\n### Тестирование совместимости (Compatibility testing, Interoperability testing)\nТестирование, направленное на проверку способности приложения работать в указанном окружении. \n\nЗдесь, например, может проверяться:\n- Совместимость с аппаратной платформой, операционной системой и сетевой инфраструктурой (конфигурационное тестирование, configuration testing).\n- Совместимость с браузерами и их версиями (кросс-браузерное тестирование, cross-browser testing).\n- Совместимость с мобильными устройствами (mobile testing).\n- И так далее.\n\nВ некоторых источниках к тестированию совместимости добавляют (хоть и подчёркивая, что это — не его часть) т.н. тестирование соответствия (compliance testing, conformance testing, regulation testing).\n\n### Тестирование данных (Data quality testing) и баз данных (Database integrity testing)\nДва близких по смыслу вида тестирования, направленных на исследование таких характеристик данных, как полнота, непротиворечивость, целостность, структурированность и т. д. \n\nВ контексте баз данных исследованию может подвергаться адекватность модели предметной области, способность модели обеспечивать целостность и консистентность данных, корректность работы триггеров, хранимых процедур и т.д.\n\n### Тестирование использования ресурсов (Resource utilization testing, Efficiency testing, Storage testing)\nСовокупность видов тестирования, проверяющих эффективность использования приложением доступных ему ресурсов и зависимость результатов работы приложения от количества доступных ему ресурсов. Часто эти виды тестирования прямо или косвенно примыкают к техникам тестирования производительности.\n\n### Сравнительное тестирование (Comparison testing)\nТестирование, направленное на сравнительный анализ преимуществ и недостатков разрабатываемого продукта по отношению к его основным конкурентам.\n\n### Демонстрационное тестирование (Qualification testing)\nФормальный процесс демонстрации заказчику продукта с целью подтверждения, что продукт соответствует всем заявленным требованиям. В отличие от приёмочного тестирования этот процесс более строгий и всеобъемлющий, но может проводиться и на промежуточных стадиях разработки продукта.\n\n### Избыточное тестирование (Exhaustive testing)\nТестирование приложения со всеми возможными комбинациями всех возможных входных данных во всех возможных условиях выполнения. Для сколь бы то ни было сложной системы нереализуемо, но может применяться для проверки отдельных крайне простых компонентов.\n\n### Тестирование надёжности (Reliability testing)\nТестирование способности приложения выполнять свои функции в заданных условиях на протяжении заданного времени или заданного количества операций.\n\n### Тестирование восстанавливаемости (Recoverability testing)\nТестирование способности приложения восстанавливать свои функции и заданный уровень производительности, а также восстанавливать данные в случае возникновения критической ситуации, приводящей к временной (частичной) утрате работоспособности приложения.\n\n### Тестирование отказоустойчивости (Failover testing)\nТестирование, заключающееся в эмуляции или реальном создании критических ситуаций с целью проверки способности приложения задействовать соответствующие механизмы, предотвращающие нарушение работоспособности, производительности и повреждения данных.\n\n### Тестирование производительности (Performance testing)\nИсследование показателей скорости реакции приложения на внешние воздействия при различной по характеру и интенсивности нагрузке. \n\nПроверяется:\n* Время отклика (The response time) приложения, то есть сколько времени требуется для загрузки приложения, за какое время любой ввод, предоставленный приложению, обеспечивает вывод, время обновления браузера и т. д.;\n* Пропускную способность (Throughput) следует проверять по количеству транзакций, завершенных во время нагрузочного теста;\n* Настройка среды (Environment) должна быть такой же, как и в реальной среде, иначе результаты не будут такими же;\n* Время процесса (Process time) - такие действия, как импорт и экспорт Excel, любые вычисления в приложении должны быть протестированы;\n* Совместимость (Interoperability) должна быть проверена, т.е. программное обеспечение должно иметь возможность взаимодействовать с другим программным обеспечением или системами;\n* Необходимо проверить время ETL, то есть время, затраченное на извлечение, преобразование и загрузку данных из одной базы данных в другую;\n* Необходимо проверить возрастающую нагрузку (Load) на приложение;\n\nВ рамках тестирования производительности выделяют следующие подвиды:\n\n- **_Нагрузочное тестирование (Load testing, Capacity testing)_**\nИсследование способности приложения сохранять заданные показатели качества при нагрузке в допустимых пределах и некотором превышении этих пределов (определение «запаса прочности»).\n\n- **_Тестирование масштабируемости (Scalability testing)_**\nИсследование способности приложения увеличивать показатели производительности в соответствии с увеличением количества доступных приложению ресурсов.\n\n- **_Объёмное тестирование (Volume testing)_**\nИсследование производительности приложения при обработке различных (как правило, больших) объёмов данных.\n\n- **_Стрессовое тестирование (Stress testing)_**\nИсследование поведения приложения при нештатных изменениях нагрузки, значительно превышающих расчётный уровень, или в ситуациях недоступности значительной части необходимых приложению ресурсов. Стрессовое тестирование может выполняться и вне контекста нагрузочного тестирования: тогда оно, как правило, называется «тестированием на разрушение» (destructive testing) и представляет собой крайнюю форму негативного тестирования.\n\n- **_Конкурентное тестирование (Concurrency testing)_**\nИсследование поведения приложения в ситуации, когда ему приходится обрабатывать большое количество одновре- менно поступающих запросов, что вызывает конкуренцию между запросами за ресурсы (базу данных, память, канал передачи данных, дисковую подсистему и т. д.) \n\nИногда под конкурентным тестированием понимают также исследование работы многопоточных приложений и корректность синхронизации действий, производимых в разных потоках.\n\nВ качестве отдельных или вспомогательных техник в рамках тестирования производительности могут использоваться тестирование использования ресурсов, тестирование надёжности, тестирование восстанавливаемости, тестирование отказоустойчиво-сти и т. д.","category":"manual","description":"Виды тестирования по целям и задачам"},{"title":"Виды тестирования по техникам и подходам","path":"/vidy-testirovaniya-po-tehnikam-i-podhodam/","content":"\n## Классификация по принципам работы с приложением\n- Позитивное\n- Негативное\n\n## Тестирование на основе опыта тестировщика, сценариев, чек-листов\n- Исследовательское\n- Свободное(интуитивное)\n\n## Классификация по степени вмешательства в работу приложения\n### Инвазивное тестирование (Intrusive testing)\nТестирование, выполнение которого может повлиять на функционирование приложения в силу работы инструментов тестирования (например, будут искажены показатели производительности) или в силу вмешательства (level of intrusion) в сам код приложения (например, для анализа работы приложения было добавлено дополнительное протоколирование, включён вывод отладочной информации и т.д.) \n\nНекоторые источники рассматривают инвазивное тестирование как форму негативного или даже стрессового тестирования.\n\n### Неинвазивное тестирование (Nonintrusive testing)\nТестирование, выполнение которого незаметно для приложения и не влияет на процесс его обычной работы.\n\n## Классификация по техникам автоматизации:\n### Тестирование под управлением данными ( Data-driven testing)\nCпособ разработки автоматизированных тест-кейсов, в котором входные данные и ожидаемые результаты выносятся за пределы тест-кейса и хранятся вне его — в файле, базе данных и т. д.\n\n### Тестирование под управлением ключевыми словами (Keyword-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором за пределы тест-кейса выносится не только набор входных данных и ожидаемых результатов, но и логика поведения тест-кейса, которая описывается ключевыми словами (командами).\n\n### Тестирование под управлением поведением (Behavior-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором основное внимание уделяется корректности работы бизнес-сценариев, а не отдельным деталям функционирования приложения.\n\n## Классификация на основе(знания) источников ошибок\n### Тестирование предугадыванием ошибок (Error guessing)\nТехника тестирования, в которой тесты разрабатываются на основе опыта тестировщика и его знаний о том, какие дефекты типичны для тех или иных компонентов или областей функциональности приложения. \n\nМожет комбинироваться с техникой т.н. «ошибкоориентированного» тестирования (failure-directed testing), в котором новые тесты строятся на основе информации о ранее обнаруженных в приложении проблемах.\n\n### Эвристическая оценка (Heuristic evaluation)\nТехника тестирования удобства использования, направленная на поиск проблем в интерфейсе пользователя, представляющих собой отклонение от общепринятых норм.\n\n### Мутационное тестирование (Mutation testing)\n Nехника тестирования, в которой сравнивается поведение нескольких версий одного и того же компонента, причём часть таких версий может быть специально разработана с добавлением ошибок (что позволяет оценить эффективность тест-кейсов — качественные тесты обнаружат эти специально добавленные ошибки). \n\nМожет комбинироваться со следующим в этом списке видом тестирования (тестированием добавлением ошибок).\n\n### Тестирование добавлением ошибок (Error seeding)\nТехника тестирования, в которой в приложение специально добавляются заранее известные, специально продуманные ошибки с целью мониторинга их обнаружения и устранения и, таким образом, формирования более точной оценки показателей процесса тестирования. \n\nМожет комбинироваться с предыдущим в этом списке видом тестирования (мутационным тестированием).\n\n## Классификация на основе выбора входных данных или спецификаций\n### Тестирование на основе классов эквивалентности (Equivalence partitioning)\nТехника тестирования, направленная на сокращение количества разрабатываемых и выполняемых тест-кейсов при сохранении достаточного тестового покрытия. \n\nСуть техники состоит в выявлении наборов эквивалентных тест-кейсов (каждый из которых проверяет одно и то же поведение приложения) и выборе из таких наборов небольшого подмножества тест-кейсов, с наибольшей вероятностью обнаруживающих проблему.\n\n### Тестирование на основе граничных условий (Boundary value analysis)\nИнструментальная техника тестирования на основе классов эквивалентности, позволяющая выявить специфические значения исследуемых параметров, относящиеся к границам классов эквивалентности. \n\nЭта техника значительно упрощает выявление наборов эквивалентных тест-кейсов и выбор таких тест-кейсов, которые обнаружат проблему с наибольшей вероятностью.\n\n### Доменное тестирование (Domain analysis, Domain testing)\nТехника тестирования на основе классов эквивалентности и граничных условий, позволяющая эффективно создавать тест-кейсы, затрагивающие несколько параметров (переменных) одновременно (в том числе с учётом взаимозависимости этих параметров). \n\nДанная техника также описывает подходы к выбору минимального множества показательных тест-кейсов из всего набора возможных тест-кейсов.\n\n### Попарное тестирование (Pairwise testing)\nТехника тестирования, в которой тест-кейсы строятся по принципу проверки пар значений параметров (переменных) вместо того, чтобы пытаться проверить все возможные комбинации всех значений всех параметров. Эта техника является частным случаем N-комбинационного тестирования (n-wise testing) и позволяет существенно сократить трудозатраты на тестирование (а иногда и вовсе сделать возможным тестирование в случае, когда количество «всех комбинаций всех значений всех параметров» измеряется миллиардами).\n\nПопарное тестирование (pairwise testing) — это НЕ парное тестирование (pair testing)!\n\n### Тестирование на основе ортогональных массивов (Orthogonal array testing)\nИнструментальная техника попарного и N-комбинационного тестирования, основанная на использовании т.н. «ортогональных массивов» (двумерных массивов, обладающих следующим свойством: если взять две любые колонки такого массива, то получивший- ся «подмассив» будет содержать все возможные попарные комбинации значений, представленных в исходном массиве).\n\n## Классификация на основе среды выполнения\n### Тестирование в процессе разработки (Development testing)\nТестирование, выполняемое непосредственно в процессе разработки приложения и/или в среде выполнения, отличной от среды реального использования приложения. Как правило, выполняется самими разработчиками.\n\n### Операционное тестирование\n\n## Тестирование на основе кода (Code based testing)\nВ различных источниках эту технику называют по-разному (чаще всего — тестированием на основе структур, причём некоторые авторы смешивают в один набор тестирование по потоку управления и по потоку данных, а некоторые строго разделяют эти стратегии). \n\nПодвиды этой техники также организуют в разные комбинации, но наиболее универсально их можно классифицировать так:\n\n- **_Тестирование по потоку управления (Control flow testing)_**\nСемейство техник тестирования, в которых тест-кейсы разрабатываются с целью активации и проверки выполнения различных последовательностей событий, которые определяются посредством анализа исходного кода приложения. \n\n- **_Тестирование по потоку данных (Data-flow testing)_**\nСемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных.\n\n- **_Тестирование по диаграмме или таблице состояний (State transition testing)_**\nТехника тестирования, в которой тест-кейсы разрабатываются для проверки переходов приложения из одного состояния в другое. Состояния могут быть описаны диаграммой состояний (state diagram) или таблицей состояний (state table).\n\nИногда эту технику тестирования также называют «тестированием по принципу конечного автомата» (finite state machine testing). \nВажным преимуществом этой техники является возможность применения в ней теории конечных автоматов (которая хорошо формализована), а также возможность использования автоматизации для генерации комбинаций входных данных.\n\n- **_Инспекция (аудит) кода (Code review, Code inspection)_**\nСемейство техник повышения качества кода за счёт того, что в процессе создания или совершенствования кода участвуют несколько человек. Степень формализации аудита кода может варьироваться от достаточно беглого просмотра до тщательной формальной инспекции. \n\nВ отличие от техник статического анализа кода (по потоку управления и потоку данных) аудит кода также улучшает такие его характеристики, как понятность, поддерживаемость, соответствие соглашениям об оформлении и т.д. Аудит кода выполняется в основном самими программистами.\n\n## Тестирование на основе структур кода (Structure-based techniques)\nПредполагает возможность исследования логики выполнения кода в зависимости от различных ситуаций и включает в себя:\n\n- **_Тестирование на основе выражений (Statement testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется корректность (и сам факт) выполне- ния отдельных выражений в коде.\n\n- **_Тестирование на основе ветвей (Branch testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных ветвей кода (под ветвью понимается атомарная часть кода, выполнение которой происходит или не происходит в зависимости от истинности или ложности некоторого условия).\n\n- **_Тестирование на основе условий (Condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных условий (условием считается выражение, которое может быть вычислено до значения «истина» или «ложь»).\n\n- **_Тестирование на основе комбинаций условий(Multiple condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных (составных) условий.\n\n- **_Тестирование на основе отдельных условий, порождающих ветвление («решающих условий») (Modified condition decision coverage testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение таких отдельных условий в составе сложных условий, которые в одиночку определяют результат вычисления всего сложного условия.\n\n- **_Тестирование на основе решений (decision testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных ветвлений (с двумя и более возможными вариантами). Несмотря на то что «два варианта» сюда также подходит, формально такую ситуацию стоит отнести к тестированию на основе условий.\n\n- **_Тестирование на основе путей (path testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение всех или некоторых специально выбранных путей в коде приложения.\n\nЕсли говорить строго научно, то определения большинства видов тестирования на основе структур кода должны звучать чуть-чуть иначе, т.к. в программировании условием считается выражение без логических операторов, а решением — выражение с логическими операторами. Но глоссарий ISTQB не делает на этом акцента, а потому приведённые выше определения можно считать корректными.\n\n## Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)\n### Тестирование по таблице принятия решений (Decision table testing)\nтехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе т.н. таблицы принятия решений, в которой отражены входные данные (и их комбинации) и воздействия на приложение, а также соответствующие им выходные данные и реакции приложения.\n\n### Тестирование по диаграмме или таблице состояний\n\n### Тестирование по спецификациям (Specification-based testing, black box testing)\n\n### Тестирование по моделям поведения приложения (Model-based testing)\nТехника тестирования, в которой исследование приложения (и разработка тест-кейсов) строится на некой модели: таблице принятия решений, таблице или диаграмме состояний, пользовательских сценариев, модели нагрузки и т. д.\n\n### Тестирование на основе вариантов использования (Use case testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе вариантов использования. Варианты использования выступают в основном источником информации для шагов тест-кейса, в то время как наборы входных данных удобно разрабатывать с помощью техник выбора входных данных. \n\nВ общем случае источником информации для разработки тест-кейсов в этой технике могут выступать не только варианты использования, но и другие пользовательские требования в любом их виде. \n\nВ случае если методология разработки проекта подразумевает использование пользовательских историй, этот вид тестирования может быть заменён тестированием на основе пользовательских историй (user story testing).\n\n### Параллельное тестирование (Parallel testing)\nТехника тестирования, в которой поведение нового (или модифицированного) приложения сравнивается с поведением эталонного приложения (предположительно работающего верно). \n\nТермин «параллельное тестирование» также может использоваться для обозначения способа проведения тестирования, когда несколько тестировщиков или систем автоматизации выполняют работу одновременно, т. е. параллельно. Очень редко (и не совсем верно) под парал- лельным тестированием понимают мутационное тестирование.\n\n### Тестирование на основе случайных данных (Random testing)\nТехника тестирования (по методу чёрного ящика), в которой входные данные, действия или даже сами тест-кейсы выбираются на основе (псевдо)случайных значений так, чтобы соответствовать операционному профилю (operational profile) — подмножеству действий, соответствующих некоей ситуации или сценарию работы с приложением. Не стоит пу- тать этот вид тестирования с т.н. «обезьяньим тестированием» (monkey testing).\n\n### A/B-тестирование (A/B testing, Split testing)\nТехника тестирования, в которой исследуется влияние на результат выполнения операции изменения одного из входных параметров. Однако куда чаще можно встретить трактовку A/B-тестирования как технику тестирования удобства использования, в которой пользователям случайным образом предлагаются разные варианты элементов интерфейса, после чего оценивается разница в реакции пользователей.\n\n## Тестирование на основе дерева классификаций(Classification tree method)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе иерархически организованных наборов эквивалентных входных и выходных данных.\n\n## Тестирование на основе синтаксиса (Syntax testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе определения наборов входных и выходных данных.\n\n## Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)\nСпособ выбрать подходящий набор комбинаций тестовых данных для достижения установленного уровня тестового покрытия в случае, когда проверка всех возможных наборов значений тестовых данных невозможна за имеющееся время. \n\nСуществуют следующие комбинаторные техники:\n- Тестирование всех комбинаций (All combinations testing)\nтестирование всех воз- можных комбинаций всех значений всех тестовых данных (например, всех параметров функции).\n\n- Попарное тестирование\n\n- Тестирование с выбором значений-представителей (Each choice testing)\nтестирование, при котором по одному значению из каждого набора тестовых данных должно быть использовано хотя бы в одном тест-кейсе.\n\n- Тестирование с выбором базового набора значений (Base choice testing)\nтестирование, при котором выделяется набор значений (базовый набор), который используется для проведения тестирования в первую очередь, а далее тест-кейсы строятся на основе выбора всех базовых значений, кроме одного, которое заменяется значением, не входящим в базовый набор.\n\n## Тестирование по графу причинно-следственных связей (Cause-effect graphing)\nтех- ника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе графа причинно-следственных связей (графического представления входных дан- ных и воздействий со связанными с ними выходными данными и эффектами).\n\n## Тестирование по потоку данных (Data-flow testing)\nсемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных. \n\nЭти техники позволяют обнаружить такие ситуации, как: \n- переменная определена, но нигде не используется;\n- переменная используется, но не определена; \n- переменная определена несколько раз до того, как она используется;\n- переменная удалена до последнего случая использования.\n\nЗдесь придётся немного погрузиться в теорию. Над переменной в общем случае может выполняться несколько действий (покажем на примере переменной x):\n- объявление (declaration): `int x;`\n- определение (definition, d-use): `x = 99;`\n- использование в вычислениях (computation use, c-use): `z = x + 1;` \n- использование в условиях (predicate use, p-use): `if (x > 17) { ... }; - удаление (kill, k-use): x = null;`\n\nТеперь можно рассмотреть техники тестирования на основе потока данных.\n\n- **_Проверка использования всех объявлений (All-definitions testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от её определения к её использованию в вычислениях или условиях.\n\n- **_Проверка всех вычислений на основе всех объявлений (All-c-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в вычислениях.\n\n- **_Проверка всех ветвлений на основе всех объявлений (All-p-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в условиях.\n\n- **_Проверка всех вычислений и ветвлений на основе всех объявлений (All-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует хотя бы один путь от каждого её определения к каждому её использованию в вычислениях и в условиях.\n\n- **_Проверка использования всех объявлений и всех путей без переобъявлений (без циклов или с однократными повторениями циклов) (All-du-paths testing)_**\nТестовым набором для каждой переменной проверяются все пути от каждого её определения к каждому её использованию в вычислениях и в условиях (самая мощная стратегия, которая в то же время требует наибольшего количества тест-кейсов).","category":"manual","description":"Виды тестирования по техникам и подходам"},{"title":"Виды тестирования по моменту выполнения (хронологии)","path":"/vidy-testirovaniya-po-momentu-vypolneniya-hronologii/","content":"\nНесмотря на многочисленные попытки создать единую хронологию тестирования, предпринятые многими авторами, по-прежнему можно смело утверждать, что общепринятого решения, которое в равной степени подходило бы для любой методологии управления проектами, любого отдельного проекта и любой его стадии, просто не существует.\n\nЕсли попытаться описать хронологию тестирования одной общей фразой, то можно сказать, что происходит постепенное наращивание сложности самих тест-кейсов и сложности логики их выбора.\n\n## Общая универсальная логика последовательности тестирования \nСостоит в том, чтобы начинать исследование каждой задачи с простых позитивных тест-кейсов, к которым постепенно добавлять негативные (но тоже достаточно простые). Лишь после того, как наиболее типичные ситуации покрыты простыми тест-кейсами, следует переходить к более сложным (опять же, начиная с позитивных). \n\nТакой подход — не догма, но к нему стоит прислушаться, т. к. углубление на начальных этапах в негативные (к тому же — сложные) тест-кейсы может привести к ситуации, в которой приложение отлично справляется с кучей неприятностей, но не работает на элементарных повседневных задачах.\n\nЕщё раз суть универсальной последовательности:\n1) простое позитивное тестирование; \n2) простое негативное тестирование; \n3) сложное позитивное тестирование; \n4) сложное негативное тестирование.\n\n## Последовательность тестирования, построенная по иерархии компонентов\n### Восходящее тестирование (Bottom-up testing)\nинкрементальный подход к интеграционному тестированию, в котором в первую очередь тестируются низкоуровневые компоненты, после чего процесс переходит на всё более и более высокоуровневые\nкомпоненты.\n\n### Нисходящее тестирование (Top-down testing)\nинкрементальный подход к интеграционному тестированию, в котором в первую очередь тестируются высокоуровневые компоненты, после чего процесс переходит на всё более и более низкоуровневые компоненты.\n\n### Гибридное тестирование (hybrid testing)\nкомбинация восходящего и нисходящего тестирования, позволяющая упростить и ускорить получение результатов оценки приложения.\n\nПоскольку термин «гибридное» является синонимом «комбинированное», под «гибридным тестированием» может пониматься практически любое сочетание двух и более видов, техник или подходов к тестированию. Всегда уточняйте, о гибриде чего именно идёт речь.\n\n## Последовательность тестирования, построенная по концентрации внимания на требованиях и их составляющих\n\n1) Тестирование требований, которое может варьироваться от беглой оценки в стиле «всё ли нам понятно» до весьма формальных подходов, в любом случае первично по отношению к тестированию того, как эти требования реализованы.\n\n2) Тестирование реализации функциональных составляющих требований логично прово- дить до тестирования реализации нефункциональных составляющих, т. к. если что-то просто не работает, то проверять производительность, безопасность, удобство и прочие нефункциональные составляющие бессмысленно, а чаще всего и вовсе невозможно.\n\n3) Тестирование реализации нефункциональных составляющих требований часто ста- новится логическим завершением проверки того, как реализовано то или иное требование.\n\n## Типичные общие сценарии \nиспользуются в том случае, когда не существует явных пред-посылок к реализации иной стратегии. Такие сценарии могут видоизменяться и комбинироваться (например, весь «типичный общий сценарий 1» можно повторять на всех шагах «типичного общего сценария 2»).\n\n- Типичный общий сценарий 1\n1) Дымовое тестирование.\n2) Тестирование критического пути.\n3) Расширенное тестирование.\n\n- Типичный общий сценарий 2:\n1) Модульное тестирование.\n2) Интеграционное тестирование. \n3) Системное тестирование.\n\n- Типичный общий сценарий 3:\n1) Альфа-тестирование. \n2) Бета-тестирование. \n3) Гамма-тестирование.","category":"manual","description":"Виды тестирования по моменту выполнения (хронологии)"},{"title":"Другие виды тестирования","path":"/drugie-vidy-testirovaniya/","content":"\nВообще виды тестирования можно классифицировать по самым разным критериям, поэтому можно встретить и такие схемы:\n\n![](http://habrastorage.org/files/bd6/dcb/bb7/bd6dcbbb7d7c44a485b65ae29b4c0ae4.png)\n\n![](https://camo.githubusercontent.com/ed9d0730f15e3d205bb59eb8fdb36312587304818cb39f519a4ee1c2fc1cdc36/68747470733a2f2f7777772e65766b6f76612e6f72672f65766b6f766175706c6f61642f6a6f622f3134343437362f322e706e67)\n\n![](https://camo.githubusercontent.com/742df04d9e28c9d20777e09e08413a16b2757a94b945b41cd84692ff1d16bce1/68747470733a2f2f7374617469632e74696c646163646e2e636f6d2f74696c64333133372d363336342d343833342d623733382d3335333536353632363433382f70686f746f2e706e67)\n","category":"manual","description":"Другие виды тестирования"},{"title":"Виды тестирования по доступу к коду и архитектуре приложения","path":"/vidy-testirovaniya-po-dostupu-k-kodu-i-arhitekture-prilozheniya/","content":"\n## Метод белого ящика (White box testing, open box testing, clear box testing, glass box testing)\n\nУ тестировщика есть доступ к внутренней структуре и коду приложения, а также есть достаточно знаний для понимания увиденного. \n\nВыделяют даже сопутствующую тестированию по методу белого ящика глобальную технику — тестирование на основе дизайна (design-based testing). Для более глубокого изучения сути метода белого ящика рекомендуется ознакомиться с техниками исследования потока управления или потока данных, использования диаграмм состояний. \n\nНекоторые авторы склонны жёстко связывать этот метод со статическим тестированием, но ничто не мешает тестировщику запустить код на выполнение и при этом периодически обращаться к самому коду (а модульное тестирование и вовсе предполагает запуск кода на исполнение и при этом работу именно с кодом, а не с «приложением целиком»).\n\n### Преимущества\n- Показывает скрытые проблемы и упрощает их диагностику.\n- Допускает достаточно простую автоматизацию тест-кейсов и их выполнение на самых ранних стадиях развития проекта.\n- Обладает развитой системой метрик, сбор и анализ которых легко автоматизируется.\n- Стимулирует разработчиков к написанию качественного кода.\n- Многие техники этого метода являются проверенными, хорошо себя зарекомендовавшими решениями, базирующимися на строгом техническом подходе.\n\n### Недостатки\n- Не может выполняться тестировщиками, не обладающими достаточными знаниями в области программирования.\n- Тестирование сфокусировано на реализованной функциональности, что повышает вероятность пропуска нереализованных требований.\n- Поведение приложения исследуется в отрыве от реальной среды выполнения и не учитывает её влияние.\n- Поведение приложения исследуется в отрыве от реальных пользовательских сценариев.\n\n## Метод чёрного ящика (black box testing, closed box testing, specification-based testing)\n\nУ тестировщика либо нет доступа к внутренней структуре и коду приложения, либо недостаточно знаний для их понимания, либо он сознательно не обращается к ним в процессе тестирования. При этом абсолютное большинство видов тестирования работают по методу чёрного ящика, идею которого в альтернативном определении можно сформулировать так: тестировщик оказывает на приложение воздействия (и проверяет реакцию) тем же способом, каким при реальной эксплуатации приложения на него воздействовали бы пользователи или другие приложения. \n\nВ рамках тестирования по методу чёрного ящика основной информацией для создания тест-кейсов выступает документация (особенно — требования (requirements-based testing)) и общий здравый смысл (для случаев, когда поведение приложения в некоторой ситуации не регламентировано явно; иногда это называют «тестированием на основе неявных требований», но канонического определения у этого подхода нет).\n\n### Преимущества\n- Тестировщик не обязан обладать (глубокими) знаниями в области программирования.\n- Поведение приложения исследуется в контексте реальной среды выполнения и учитывает её влияние.\n- Поведение приложения исследуется в контексте реальных пользовательских сценариев.\n- Тест-кейсы можно создавать уже на стадии появления стабильных требований.\n- Процесс создания тест-кейсов позволяет выявить дефекты в требованиях.\n- Допускает создание тест-кейсов, которые можно многократно использовать на разных проектах.\n\n### Недостатки\n- Возможно повторение части тест-кейсов, уже выполненных разработчиками.\n- Высока вероятность того,что часть возможных вариантов поведения приложения останется непротестированной.\n- Для разработки высокоэффективных тест-кейсов необходима качественная\nдокументация.\n- Диагностика обнаруженных дефектов более сложна в сравнении с техниками метода белого ящика.\n- В связи с широким выбором техник и подходов затрудняется планирование и оценка трудозатрат.\n- В случае автоматизации могут потребоваться сложные дорогостоящие инструментальные средства.\n\n## Метод серого ящика (gray box testing) \n\nКомбинация методов белого ящика и чёрного ящика, состоящая в том, что к части кода и архитектуры у тестировщика доступ есть, а к части — нет. Обычно говорят о методах белого или чёрного ящика в применении к тем или иным частям приложения, при этом понимая, что «приложение целиком» тестируется по методу серого ящика.\n\nНекоторые авторы определяют метод серого ящика как противопоставление методам белого и чёрного ящика, особо подчёркивая, что при работе по методу серого ящика внутренняя структура тестируемого объекта известна частично и выясняется по мере исследования. Этот подход, бесспорно, имеет право на существование, но в своём предельном случае он вырождается до состояния «часть системы мы знаем, часть — не знаем», т. е. до всё той же комбинации белого и чёрного ящиков.\n\nСочетает преимущества и недостатки методов белого и чёрного ящика.\n\n\n\n|Вид тестирования (русскоязычное название)| Вид тестирования (англоязычное название)|Белый ящик|Чёрный ящик|\n|---|---|---|---|   \n|Статическое тестирование|Static testing|Да|Нет|\n|Динамическое тестирование|Dynamic testing|Изредка|Да|\n|Ручное тестирование|Manual testing|Мало|Да|\n|Автоматизированное тестирование|Automated testing|Да|Да|\n|Модульное (компонентное) тестирование|Unit testing, Module testing, Component testing|Да|Нет|\n|Интеграционное тестирование|Integration testing|Да|Да|\n|Системное тестирование|System testing|Мало|Да|\n|Дымовое тестирование|Smoke test, Intake test, Build verification test|Мало|Да|\n|Тестирование критического пути|Critical path test|Мало|Да|\n|Расширенное тестирование|Extended test|Мало|Да|\n|Позитивное тестирование|Positive testing|Да|Да|\n|Негативное тестирование|Negative testing, Invalid testing|Да|Да|\n|Тестирование веб-приложений|Web-applications testing|Да|Да|\n|Тестирование мобильных приложений|Mobile applications testing|Да|Да|\n|Тестирование настольных приложений|Desktop applications testing|Да|Да|\n|Тестирование уровня представления|Presentation tier testing|Мало| Да|\n|Тестирование уровня бизнес-логики|Business logic tier testing|Да |Да|\n|Тестирование уровня данных|Data tier testing|Да |Мало|\n|Альфа-тестирование|Alpha testing|Мало |Да|\n|Бета-тестирование|Beta testing|Почти никогда |Да|\n|Гамма-тестирование|Gamma testing|Почти никогда |Да|\n|Тестирование на основе тест-кейсов|Scripted testing, Test case based testing|Да |Да|\n|Исследовательское тестирование|Exploratory testing|Нет |Да|\n|Свободное (интуитивное) тестирование|Ad hoc testing|Нет |Да|\n|Функциональное тестирование|Functional testing|Да |Да|\n|Нефункциональное тестирование|Non-functional testing|Да |Да|\n|Инсталляционное тестирование|Installation testing|Изредка |Да|\n|Регрессионное тестирование|Regression testing|Да| Да|\n|Повторное тестирование|Re-testing, Confirmation testing|Да |Да|\n|Приёмочное тестирование|Acceptance testing|Крайне редко |Да|\n|Операционное тестирование|Operational testing|Крайне редко |Да|\n|Тестирование удобства использования|Usability testing|Крайне редко|Да|\n|Тестирование доступности|Accessibility testing|Крайне редко |Да|\n|Тестирование интерфейса|Interface testing|Да| Да|\n|Тестирование безопасности|Security testing|Да |Да|\n|Тестирование интернационализации|Internationalization testing|Мало|Да|\n|Тестирование локализации|Localization testing|Мало| Да|\n|Тестирование совместимости|Compatibility testing|Мало |Да|\n|Конфигурационное тестирование|Configuration testing|Мало| Да|\n|Кросс-браузерное тестирование|Cross-browser testing|Мало |Да|\n|Тестирование данных и баз данных|Data quality testing and Database integrity testing|Да |Мало|\n|Тестирование использования ресурсов|Resource utilization testing|Крайне редко |Да|\n|Сравнительное тестирование|Comparison testing|Нет| Да|\n|Демонстрационное тестирование|Qualification testing|Нет| Да|\n|Избыточное тестирование|Exhaustive testing|Крайне редко| Нет|\n|Тестирование надёжности|Reliability testing|Крайне редко|Да|\n|Тестирование восстанавливаемости|Recoverability testing|Крайне редко|Да|\n|Тестирование отказоустойчивости|Failover testing|Крайне редко|Да|\n|Тестирование производительности|Performance testing|Крайне редко|Да|\n|Нагрузочное тестирование|Load testing, Capacity testing|Крайне редко|Да|\n|Тестирование масштабируемости|Scalability testing|Крайне редко|Да|\n|Объёмное тестирование|Volume testing|Крайне редко|Да|\n|Стрессовое тестирование|Stress testing|Крайне редко|Да|\n|Конкурентное тестирование|Concurrency testing|Крайне редко|Да|\n|Инвазивное тестирование|Intrusive testing|Да|Да|\n|Неинвазивное тестирование|Nonintrusive testing|Да|Да|\n|Тестирование под управлением данными|Data-driven testing|Да|Да|\n|Тестирование под управлением ключевыми словами|Keyword-driven testing|Да|Да|\n|Тестирование предугадыванием ошибок|Error guessing|Крайне редко|Да|\n|Эвристическая оценка|Heuristic evaluation|Нет|Да|\n|Мутационное тестирование|Mutation testing|Да|Да|\n|Тестирование добавлением ошибок|Error seeding|Да|Да|\n|Доменное тестирование|Domain testing, Domain analysis|Да|Да|\n|Попарное тестирование|Pairwise testing|Да|Да|\n|Тестирование в процессе разработки|Development testing|Да|Да|\n|Тестирование на основе классов эквивалентности|Equivalence partitioning|Да|Да|\n|Тестирование на основе граничных условий|Boundary value analysis|Да|Да|\n|Тестирование на основе ортогональных массивов|Orthogonal array testing|Да|Да|\n|Тестирование по потоку управления|Control flow testing|Да|Нет|\n|Тестирование по потоку данных|Data flow testing|Да|Нет|\n|Тестирование по диаграмме или таблице состояний|State transition testing|Да|Нет|\n|Инспекция (аудит) кода|Code review, code inspection|Да|Нет|\n|Тестирование на основе выражений|Statement testing|Да|Нет|\n|Тестирование на основе ветвей|Branch testing|Да|Нет|\n|Тестирование на основе условий|Condition testing|Да|Нет|\n|Тестирование на основе комбинаций условий|Multiple condition testing|Да|Нет|\n|Тестирование на основе отдельных условий, порождающих ветвление («решающих условий»)|Modified condition decision coverage testing|Да|Нет|\n|Тестирование на основе решений|Decision testing|Да|Нет|\n|Тестирование на основе путей|Path testing|Да|Нет|\n|Тестирование по таблице принятия решений|Decision table testing|Да|Да|\n|Тестирование по моделям поведения приложения|Model-based testing|Да|Да|\n|Тестирование на основе вариантов использования|Use case testing|Да|Да|\n|Параллельное тестирование|Parallel testing|Да|Да|\n|Тестирование на основе случайных данных|Random testing|Да|Да|\n|A/B-тестирование|A/B testing, Split testing|Нет|Да|\n|Восходящее тестирование|Bottom-up testing|Да|Да|\n|Нисходящее тестирование|Top-down testing|Да|Да|\n|Гибридное тестирование|Hybrid testing|Да|Да|\n|Тестирование на основе дерева классификаций|Classification tree method|Да|Да|\n|Тестирование на основе синтаксиса|Syntax testing|Да|Да|\n|Комбинаторные техники (комбинаторное тестирование)|Combinatorial testing|Да|Да|\n|Тестирование всех комбинаций|All combinations testing|Да|Нет|\n|Тестирование с выбором значений-представителей|Each choice testing|Да|Нет|\n|Тестирование с выбором базового набора значений|Base choice testing|Да|Нет|\n|Тестирование по графу причинно-следственных связей|Cause-effect graphing|Мало|Да|\n|Проверка использования всех объявлений|All-definitions testing|Да|Нет|\n|Проверка всех вычислений на основе всех объявлений|All-c-uses testing|Да|Нет|\n|Проверка всех ветвлений на основе всех объявлений|All-p-uses testing|Да|Нет|\n|Проверка всех вычислений и ветвлений на основе всех объявлений|All-uses testing|Да|Нет|\n|Проверка использования всех объявлений и всех путей без переобъявлений (без циклов или с однократными повторениями циклов)|All-du-paths testing|Да|Нет|","category":"manual","description":"Виды тестирования по доступу к коду и архитектуре приложения"},{"title":"Виды тестирования по степени автоматизации","path":"/vidy-testirovaniya-po-stepeni-avtomatizaczii/","content":"\n## Ручное тестирование (Manual testing)\nТестирование, в котором тест-кейсы выполняются человеком вручную без использования средств автоматизации. Несмотря на то что это звучит очень просто, от тестировщика в те или иные моменты времени требуются такие качества, как терпеливость, наблюдательность, креативность, умение ставить нестандартные эксперименты, а также умение видеть и понимать, что происходит «внутри системы», т. е. как внешние воздействия на приложение трансформируются в его внутренние про- цессы.\n\n## Автоматизированное тестирование (Automated testing, test automation)\nНабор техник, подходов и инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования. Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка тест-кейсов, подготовка данных, оценка результатов выполнения, написания отчётов об обнаруженных дефектах — всё это и многое другое по-прежнему делает человек.\n\n### Преимущества\n- Скорость выполнения тест-кейсов может в разы и на порядки превосходить возможности человека.\n- Отсутствие влияния человеческого фактора в процессе выполнения тест-кейсов (усталости, невнимательности и т. д.)\n- Минимизация затрат при многократном выполнении тест-кейсов (участие человека здесь требуется лишь эпизодически).\n- Способность средств автоматизации выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов.\n- Способность средств автоматизации собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.\n- Способность средств автоматизации выполнять низкоуровневые действия с приложением, операционной системой, каналами передачи данных и т. д.\n\n### Недостатки\n- Необходим высококвалифицированный персонал в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, кодом и т. д.)\n- Высокие затраты на сложные средства автоматизации, разработку и сопровождение кода тест-кейсов.\n- Автоматизация требует более тщательного планирования и управления рисками, т. к. в противном случае проекту может быть нанесён серьёзный ущерб.\n- Средств автоматизации крайне много, что усложняет проблему выбора того или иного средства и может повлечь за собой финансовые затраты (и риски), необходимость обучения персонала (или поиска специалистов).\n- В случае ощутимого изменения требований, смены технологического домена, переработки интерфейсов (как пользовательских, так и программных) многие тест-кейсы становятся безнадёжно устаревшими и требуют создания заново.\n\n\nНекоторые авторы говорят отдельно о «полуавтоматизированном» тестировании как варианте ручного с частичным использованием средств автоматизации и отдельно об «автоматизированном» тестировании (относя туда области тестирования, в которых компьютер выполняет ощутимо большой процент задач). Но т.к. без участия человека всё равно не обходится ни один из этих видов тестирования, не станем усложнять набор терминов и ограничимся одним понятием «автоматизированное тестирование».","category":"manual","description":"Виды тестирования по степени автоматизации"},{"title":"Виды тестирования по уровню деталиции приложения (по уровню тестирования)","path":"/vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/","content":"\n## Модульное (компонентное) тестирование (Unit testing, Module testing, Component testing)\nНаправлено на проверку отдельных небольших частей приложения, которые (как правило) можно исследовать изолированно от других подобных частей. \n\nПри выполнении данного тестирования могут проверяться отдельные функции или методы классов, сами классы, взаимодействие классов, небольшие библиотеки, отдельные части приложения. Часто данный вид тестирования реализуется с использованием специальных технологий и инструментальных средств автоматизации тестирования, значительно упрощающих и ускоряющих разработку соответствующих тест-кейсов.\n\n«Юнит-тестирование», как правило, направлено на тестирование атомарных участков кода, «Модульное» — на тестирование классов и небольших библиотек, «Компонентное» — на тестирование библиотек и структурных частей приложения. Но эта классификация не стандартизирована, и у различных авторов можно встретить совершенно разные взаимоисключающие трактовки.\n\n## Интеграционное тестирование (Integration testing, Component integration testing, Pairwise integration testing, System integration testing, Incremental testing, Interface testing, Thread testing) \nНаправлено на проверку взаимодействия между несколькими частями приложения (каждая из которых, в свою очередь, проверена отдельно на стадии модульного тестирования). К сожалению, даже если мы работаем с очень качественными отдельными компонентами, «на стыке» их взаимодействия часто возникают проблемы. Именно эти проблемы и выявляет интеграционное тестирование. (См. также техники вос- ходящего, нисходящего и гибридного тестирования в хронологической классификации по иерархии компонентов.)\n\nПодходы к интеграционному тестированию:\n\n- Снизу вверх (Bottom Up Integration)\n\nВсе низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.\n\n- Сверху вниз (Top Down Integration)\n\nВначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.\n\n- Большой взрыв («Big Bang» Integration)\n\nВсе или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.\n\n## Системное тестирование (System testing) \nНаправлено на проверку всего приложения как единого целого, собранного из частей, проверенных на двух предыдущих стадиях. Здесь не только выявляются дефекты «на стыках» компонентов, но и появляется возможность полноценно взаимодействовать с приложением с точки зрения конечного пользователя, применяя множество других видов тестирования, перечисленных в данной главе.\n\n---\n\nС классификацией по уровню детализации приложения связан интересный печальный факт: если предыдущая стадия обнаружила проблемы, то на следующей стадии эти проблемы точно нанесут удар по качеству; если же предыдущая стадия не обнаружила проблем, это ещё никоим образом не защищает нас от проблем на следующей стадии.\n\nЕсли обратиться к словарю ISTQB и прочитать определение уровня тестирования (test level), то можно увидеть, что аналогичное разбиение на модульное, интеграционное и системное тестирование, к которым добавлено ещё и приёмочное тестирование, используется в контексте разделения областей ответственности на проекте. Но такая классификация больше относится к вопросам управления проектом, чем к тестированию в чистом виде, а потому выходит за рамки рассматриваемых нами вопросов.\n\n- Приемочное\n","category":"manual","description":"Виды тестирования по уровню деталиции приложения (по уровню тестирования)"},{"title":"Виды тестирования по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)","path":"/vidy-testirovaniya-po-ubyvaniyu-stepeni-vazhnosti-testiruemyh-funkczij-po-urovnyu-funkczionalnogo-testirovaniya/","content":"\nВ некоторых источниках эту разновидность классификации также называют «по глубине тестирования».\n\n## Дымовое тестирование (Smoke test, Intake test, Build verification test) \nНаправлено на проверку самой главной, самой важной, самой ключевой функциональности, неработоспособность которой делает бессмысленной саму идею использования приложения (или иного объекта, подвергаемого дымовому тестированию).\n\nДымовое тестирование проводится после выхода нового билда, чтобы определить общий уровень качества приложения и принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного тестирования. \n\nПоскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но при этом очень часто повторяются, они являются хорошими кандидатами на автоматизацию. В связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто выставляется равным 100 % или близким к 100 %.\n\n## Тестирование критического пути (Critical path test) \nНаправлено на исследование функциональности, используемой типичными пользователями в типичной повседневной деятельности. \n\nСуществует большинство пользователей, которые чаще всего используют некое подмножество функций приложения. Именно эти функции и нужно проверить, как только мы убедились, что приложение «в принципе работает» (дымовой тест прошёл успешно). Если по каким-то причинам приложение не выполняет эти функции или выполняет их некорректно, очень многие пользователи не смогут достичь множества своих целей. \n\nПороговое значение метрики успешного прохождения «теста критического пути» уже немного ниже, чем в дымовом тестировании, но всё равно достаточно высоко (как пра- вило, порядка 70–80–90 % — в зависимости от сути проекта).\n\n## Расширенное тестирование (Extended test)\nНаправлено на исследование всей заявленной в требованиях функциональности — даже той, которая низко проранжирована по степени важности. При этом здесь также учитывается, какая функциональность является более важной, а какая — менее важной. Но при наличии достаточного количества времени и иных ресурсов тест-кейсы этого уровня могут затронуть даже самые низкоприоритетные требования.\n\nЕщё одним направлением исследования в рамках данного тестирования являются нетипичные, маловероятные, экзотические случаи и сценарии использования функций и свойств приложения, затронутых на предыдущих уровнях. \n\nПороговое значение метрики успешного прохождения расширенного тестирования существенно ниже, чем в тестировании критического пути (иногда можно увидеть даже значения в диапазоне 30–50 %, т.к. подавляющее большинство найденных здесь дефектов не представляет угрозы для успешного использова- ния приложения большинством пользователей).\n\nК сожалению, часто можно встретить мнение, что дымовое тестирование, тестирование критического пути и расширенное тестирование напрямую связаны с позитивным тестированием и негативным тестированием, и негативное появляется только на уровне тестирования критического пути. Это не так. Как позитивные, так и негативные тесты могут (а иногда и обязаны) встречаться на всех перечисленных уровнях. Например, деление на ноль в калькуляторе явно должно относиться к дымовому тестирова- нию, хотя это яркий пример негативного тест-кейса.","category":"manual","description":"Виды тестирования по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)"},{"title":"Виды тестирования по принципам работы с приложением","path":"/vidy-testirovaniya-po-princzipam-raboty-s-prilozheniem/","content":"\n## Позитивное тестирование (Positive testing) \nНаправлено на исследование приложения в ситуации, когда все действия выполняются строго по инструкции без каких бы то ни было ошибок, отклонений, ввода неверных данных и т.д. \n\nЕсли позитивные тест-кейсы завершаются ошибками, это тревожный признак — приложение работает неверно даже в идеальных условиях (и можно предположить, что в неидеальных условиях оно работает ещё хуже). \n\nДля ускорения тестирования несколько позитивных тест-кейсов можно объединять (например, перед отправкой заполнить все поля формы верными значениями) — иногда это может усложнить диагностику ошибки, но существенная экономия времени компенсирует этот риск.\n\n## Негативное тестирование (Negative testing, Invalid testing)\nНаправлено на исследование работы приложения в ситуациях, когда с ним выполняются (некорректные) операции и/или используются данные, потенциально приводящие к ошибкам (классика жанра — деление на ноль). \n\nПоскольку в реальной жизни таких ситуаций значительно больше (пользователи допускают ошибки, злоумышленники осознанно «ломают» приложение, в среде работы приложения возникают проблемы и т. д.), негативных тест-кейсов оказывается значительно больше, чем позитивных (иногда — в разы или даже на порядки). \n\nВ отличие от позитивных негативные тест-кейсы не стоит объединять, т. к. подобное решение может привести к неверной трактовке поведения приложения и пропуску (необнаружению) дефектов.","category":"manual","description":"Виды тестирования по принципам работы с приложением"},{"title":"Виды тестирования  по природе приложения","path":"/vidy-testirovaniya-po-prirode-prilozheniya/","content":"\nДанный вид классификации является искусственным, поскольку «внутри» речь будет идти об одних и тех же видах тестирования, отличающихся в данном контексте лишь концентрацией на соответствующих функциях и особенностях приложения, использованием специфических инструментов и отдельных техник.\n\n## Тестирование веб-приложений (Web-applications testing) \nСопряжено с интенсивной деятельностью в области тестирования совместимости (в особенности — кросс-браузерного тестирования), тестирования производительности, автоматизации тестирования с использованием широкого спектра инструментальных средств.\n\n## Тестирование мобильных приложений (Mobile applications testing) \nТакже требует повышенного внимания к тестированию совместимости, оптимизации производительности (в том числе клиентской части с точки зрения снижения энергопотребления), автоматизации тестирования с применением эмуляторов мобильных устройств.\n\n## Тестирование настольных приложений (Desktop applications testing) \nЯвляется самым классическим среди всех перечисленных в данной классификации, и его особенности зависят от предметной области приложения, нюансов архитектуры, ключевых показателей качества и т. д.\n\nЭту классификацию можно продолжать очень долго. Например, можно отдельно рассматривать тестирование консольных приложений (console applications testing) и приложений с графическим интерфейсом (GUI-applications testing), серверных приложений (server applications testing) и клиентских приложений (client applications testing) и т. д.","category":"manual","description":"Виды тестирования  по природе приложения"},{"title":"Виды тестирования по фокусировке на уровне архитектуры приложения","path":"/vidy-testirovaniya-po-fokusirovke-na-urovne-arhitektury-prilozheniya/","content":"\nДанный вид классификации, как и предыдущий, также является искусственным и отражает лишь концентрацию внимания на отдельной части приложения.\n\n## Тестирование уровня представления (Presentation tier testing) \nСконцентрировано на той части приложения, которая отвечает за взаимодействие с «внешним миром» (как пользователями, так и другими приложениями). Здесь исследуются вопросы удобства использования, скорости отклика интерфейса, совместимости с браузерами, корректности работы интерфейсов.\n\n## Тестирование уровня бизнес-логики (Business logic tier testing)\nОтвечает за проверку основного набора функций приложения и строится на базе ключевых требований к приложению, бизнес-правил и общей проверки функциональности.\n\n## Тестирование уровня данных (Data tier testing) \nСконцентрировано на той части приложения, которая отвечает за хранение и некоторую обработку данных (чаще всего — в базе данных или ином хранилище). Здесь особый интерес представляет тестирование данных, проверка соблюдения бизнес-правил, тестирование производительности.\n ","category":"manual","description":"Виды тестирования по фокусировке на уровне архитектуры приложения"},{"title":"Виды тестирования по привлечению конечных пользователей","path":"/vidy-testirovaniya-po-privlecheniyu-konechnyh-polzovatelej/","content":"\nВсе три перечисленных ниже вида тестирования относятся к операционному тестированию.\n\n## Альфа-тестирование (Alpha testing) \nВыполняется внутри организации-разработчика с возможным частичным привлечением конечных пользователей. Может являться формой внутреннего приёмочного тестирования. \n\nВ некоторых источниках отмечается, что это тестирование должно проводиться без привлечения команды разработчиков, но другие источники не выдвигают такого требования. \n\nСуть этого вида вкратце: продукт уже можно периодически показывать внешним пользователям, но он ещё достаточно «сырой», потому основное тестирование выполняется организацией-разработчиком.\n\n## Бета-тестирование (Beta testing) \nВыполняется вне организации-разработчика с активным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования. \n\nСуть этого вида вкратце: продукт уже можно открыто показывать внешним пользователям, он уже достаточно стабилен, но проблемы всё ещё могут быть, и для их выявления нужна обратная связь от реальных пользователей.\n\n## Гамма-тестирование (Gamma testing)\nФинальная стадия тестирования перед выпуском продукта, направленная на исправление незначительных дефектов, обнаруженных в бета-тестировании.\nКак правило, также выполняется с максимальным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования. \n\nСуть этого вида вкратце: продукт уже почти готов, и сейчас обратная связь от реальных пользователей используется для устранения последних недоработок.","category":"manual","description":"Виды тестирования по привлечению конечных пользователей"},{"title":"Уровни тестирования","path":"/urovni-testirovaniya/","content":"\n## Пирамида тестирования (Test Pyramid)\n\n«Пирамида тестов» - метафора, которая означает группировку динамических тестов программного обеспечения по разным уровням. Она также дает представление, какое количество тестов должно быть в каждой из этих групп. Основной принцип разделения уровней - тест должен быть на том же уровне, что и тестируемый объект. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты тестами более низкого уровня.\n\n![](https://lh6.googleusercontent.com/yDN1s-lXbEFI5tsd429c2fT5DkHxfDNFpTotktfGZe2tdXVAdo218WSOksJIhBx5VDJffYvMOcadII\\_r7ln-kvX4iKFuuQ75io5IEimepSLJq\\_qkkZ\\_JH5x5UfdSXdF2PqbBPqpV)\n\n## Уровни тестирования(Testing Levels)\n\n* Unit/component/program/module testing - тестируется минимально-атомарный модуль программы, чаще всего это одна функция или метод. Таких тестов должно быть больше всего;\n* Integration testing - несколько модулей программы тестируются вместе;\n* System testing - вся программа тестируется полностью;\n* Acceptance testing - программа принимается заказчиком на соответствие заявленным требованиям либо тестировщики проходят end-to-end сценарии с точки зрения пользователя;\n\n### Модульное/юнит/компонентное тестирование (Module/Unit/Component testing)\n\nС этими терминами часто происходит путаница. Если ссылаться на глоссарий ISTQB, то все они - синонимы:\n\n* _**Модуль, юнит (module, unit): См. компонент.**_\n* _**Модульное, юнит тестирование (module testing, unit testing): См. компонентное тестирование.**_\n* _**Компонент (component): Наименьший элемент программного обеспечения, который может быть протестирован отдельно.**_\n* _**Компонентное тестирование (component testing): Тестирование отдельных компонентов программного обеспечения (IEEE 610).**_&#x20;\n\nТем не менее, некоторые источники описывают ситуацию несколько иначе и я решил выписать другую точку зрения.\n\n**Модульное тестирование (оно же юнит-тестирование)** используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups).\n\n**Компонентное тестирование** - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA. Для каждого из этих компонентов будет определен сценарий тестирования, который затем будет приведен к Test case высокого уровня -> детальным Test case низкого уровня с предварительными условиями.\n\nИсходя из глубины уровней тестирования, компонентное тестирование можно классифицировать как:\n\n* Тестирование компонентов в малом (CTIS - Component testing In Small): тестирование компонентов может проводиться с или без изоляции остальных компонентов в тестируемом программном обеспечении или приложении. Если это выполняется с изоляцией другого компонента, то это называется CTIS;\n* Тестирование компонентов в целом (CTIL - Component testing In Large) - тестирование компонентов, выполненное без изоляции других компонентов в тестируемом программном обеспечении или приложении;\n\n| **Module/Unit testing**                                                                                        | **Component testing**                                                                                        |\n| -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| Тестирование отдельных классов, функций для демонстрации того, что программа выполняется согласно спецификации | Тестирование каждого объекта или частей программного обеспечения отдельно с или без изоляции других объектов |\n| Проверка в(на) соответствии с design documents                                                                 | Проверка в(на) соответствии с test requirements, use case                                                    |\n| Пишутся и выполняются разработчиками                                                                           | Тестировщиками                                                                                               |\n| Выполняется первым                                                                                             | Выполняется после Unit                                                                                       |\n\nДругой источник:\n\nПо-существу эти уровни тестирования представляют одно и тоже, разница лишь в том, что в компонентном тестировании в качестве параметров функций используют реальные объекты и драйверы, а в модульном/unit тестировании - конкретные значения.\n\n\\*В контексте юнит-тестирования еще можно встретить понятие [golden testing](https://ro-che.info/articles/2017-12-04-golden-tests). Оно означает те же юнит тесты, но с ожидаемыми результатами хранящимися в отдельном файле. Таким образом после прогона выходные значения тестов сравниваются с golden (эталонным) файлом.\n\n\\*Иногда юнит-тесты называют одинокими (solitary) в случае тотального применения имитаций и заглушек или общительными (sociable) в случае реальных коммуникаций с другими участниками.\n\n\\*Правило трех А(AAA) (arrange, act, assert) или триада «дано, когда, тогда» - хорошая мнемоника, чтобы поддерживать хорошую структуру тестов.\n\n### Интеграционное тестирование (Integration testing)\n\n_Интеграционное тестирование (integration testing): Тестирование, выполняемое для обнаружения дефектов в интерфейсах и во взаимодействии между интегрированными компонентами или системами. См. также тестирование интеграции компонентов, системное интеграционное тестирование. (ISTQB)_\n\n_Системное интеграционное тестирование (system integration testing): Тестирование интеграции систем и пакетов программ, тестирование интерфейсов связи с внешними системами (интернет и т.д.). (ISTQB)_\n\n_Интеграционное тестирование в малом (integration testing in the small): См. тестирование интеграции компонентов. (ISTQB)_\n\n_Интеграционное тестирование в целом (integration testing in the large): См. системное интеграционное тестирование. (ISTQB)_\n\n_Изоляционное тестирование (isolation testing): Тестирование отдельных компонентов в изоляции от окружающих компонентов в окружении компонентов, которые при необходимости эмулируются заглушками и драйверами. (ISTQB)_\n\n_Попарное интеграционное тестирование (pairwise integration testing): Вид интеграционного тестирования, нацеленного на пары компонентов, работающих совместно соответственно графу вызовов. (ISTQB)_\n\nИнтеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). С технологической точки зрения интеграционное тестирование является количественным развитием компонентного, поскольку также оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки (Stub) на месте отсутствующих модулей. Основная разница между компонентным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа. В частности, на уровне интеграционного тестирования часто применяются методы, связанные с покрытием интерфейсов, например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой.\n\n**Уровни интеграционного тестирования**:\n\n* **Компонентный интеграционный уровень** (CIT - [Component Integration testing](https://www.testing.guru/what-is-component-integration-testing/)): Проверяется взаимодействие между компонентами одной системы после проведения компонентного тестирования. Программные компоненты или модули могут быть определены в разное время совершенно разными группами спецификаций, component integration testing выполняется чтобы убедиться, что даже после различий в разработке модулей интеграция всего работает вместе. В этом случае также важно учесть отрицательные случаи, так как компоненты могут делать предположения относительно данных;\n* **Системный интеграционный уровень** (SIT - [System Integration testing](https://www.softwaretestinghelp.com/system-integration-testing/)): - это полное тестирование всей системы, состоящей из множества подсистем. Основная цель SIT - обеспечить правильное функционирование всех зависимостей программных модулей и сохранение целостности данных между отдельными модулями всей системы. SUT ([System Under Test](https://www.tutorialspoint.com/software\\_testing\\_dictionary/system\\_under\\_test.htm)) может состоять из аппаратного обеспечения, базы данных, программного обеспечения, комбинации аппаратного и программного обеспечения или системы, требующей взаимодействия с человеком (HITL - [Human in the Loop](https://en.wikipedia.org/wiki/Human-in-the-loop) Testing). SIT имеет предварительное условие, при котором несколько базовых интегрированных систем уже прошли системное тестирование. Затем SIT проверяет необходимые взаимодействия между этими системами в целом. Результаты SIT передаются в UAT (пользовательское приемочное тестирование);\n\n**Интеграция может быть как программной, так и софт-железо**:\n\n* **HSIT** - Hardware Software Integration Testing: представляет собой процесс тестирования компонентов компьютерного программного обеспечения (CSC - Computer Software Components) на предмет функциональности высокого уровня в целевой аппаратной среде. Тестирование черного ящика - это основной тип тестирования, используемый на этом уровне тестирования. Целью тестирования интеграции аппаратного / программного обеспечения является проверка поведения разработанного программного обеспечения, интегрированного в аппаратный компонент. Цель тестирования интеграции аппаратного и программного обеспечения на основе требований (Requirement based Hardware-Software Integration Testing) - убедиться, что программное обеспечение на целевом компьютере удовлетворяет высокоуровневым требованиям (high-level requirements);\n* **SSIT** - Software Software Integration Testing: это Computer Software Component Testing, работающего в среде целевого компьютера при моделировании всей системы (других CSC), и на функциональности высокого уровня. Оно фокусируется на поведении CSC в смоделированной среде хоста / цели. Для проверки интеграции программного обеспечения используются разные подходы;\n\n**Подходы к интеграционному тестированию**:\n\n* **Подход Большого взрыва (Big Bang Approach)**: _“Вид подхода к интеграционному тестированию, при котором элементы программного или аппаратного обеспечения, или и то и другое, собираются в компонент или в целую систему сразу, а не по этапам.” ( IEEE 610)_. Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если Test case и их результаты записаны неверно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования;\n* **Инкрементальный подход (Incremental Approach)**: при таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. Осуществляется разными методами:\n  * **Нисходящий подход (Top-Down Approach)**: Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Преимущества: Локализация неисправностей проще. Возможность получить ранний прототип. Основные недостатки дизайна могут быть найдены и исправлены в первую очередь. Недостатки: Нужно много заглушек. Модули на более низком уровне тестируются недостаточно;\n  * **Восходящий подход (Bottom-Up Approach)**: В восходящей стратегии каждый модуль на более низких уровнях последовательно тестируется с более высокоуровневыми модулями, пока не будут протестированы все модули. Требуется помощь драйверов для тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения. Пример низкоуровневого модуля - модуль, который заведует хранением токенов авторизации. Высокоуровневый - модуль авторизации, в состав которого помимо прочего входит модуль токенов. Преимущества: Локализация ошибок проще. Не тратится время на ожидание разработки всех модулей, в отличие от подхода Большого взрыва. Недостатки: Критические модули (на верхнем уровне архитектуры ПО), которые контролируют поток приложения, тестируются последними и могут быть подвержены дефектам. Ранний прототип невозможен;\n  * [**Гибридный/сэндвич-подход**](https://www.ques10.com/p/38806/describe-bi-directionalsandwitch-integration-testi/) **(Sandwich/Hybrid/Bi-Directional Approach)**: Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны;\n\n**Критерии начала и окончания Integration Testing**:\n\nОбычно при выполнении интеграционного тестирования используется стратегия [ETVX](https://vijaybn.wordpress.com/2012/09/06/etvx-entry-task-validation-exit/) (Entry Criteria, Task, Validation, Exit Criteria).\n\n* Критерии начала:\n  * завершено модульное тестирование;\n* На входе:\n  * Software Requirements Data;\n  * Software Design Document;\n  * Software Verification Plan;\n  * Software Integration Documents;\n* Действия:\n  * На основе требований высокого и низкого уровня (High and Low-level requirements) создайте test cases and procedures;\n  * Комбинируйте сборки низкоуровневых модулей, которые реализуют общую функциональность;\n  * Разработайте тестовую обвязку (test harness);\n  * Протестируйте сборку;\n  * После прохождения теста сборка объединяется с другими сборками и тестируется до тех пор, пока система не будет интегрирована как единое целое;\n  * Повторите все тесты на целевой processor-based platform и получите результаты;\n* Критерии выхода:\n  * Успешное завершение интеграции Программного модуля на целевое Hardware;\n  * Правильная работа программного обеспечения в соответствии с указанными требованиями;\n* На выходе:\n  * Integration test reports;\n  * SVCP - Software Test Cases and Procedures;\n\n[_Test Harness_](https://www.softwaretestinghelp.com/what-is-test-harness/)_- (тестовая обвязка): Тестовое окружение, включающее в себя заглушки и драйверы, необходимые для проведения теста. (ISTQB)_\n\n[Test Driver и Test Stub](https://www.geeksforgeeks.org/difference-between-stubs-and-drivers/) являются искусственными заменами компонентов программы на время тестов по аналогии с моками в тестировании API. Тестовый драйвер - то, что вызывает тестируемый компонент. Тестовая заглушка - то, что возвращает тестируемому компоненту фиктивный ответ. Т.е. заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с тестируемым модулем.\n\n[**Тестирование интерфейса**](https://www.softwaretestinghelp.com/what-is-interface-testing/) - это тип интеграционного теста, который проверяет, правильно ли установлена ​​связь между двумя различными программными системами или их частями (модулями). Соединение, которое объединяет два компонента, называется интерфейсом. Этот интерфейс в компьютерном мире может быть чем угодно, как API, так и веб-сервисами и т. д. Тестирование интерфейса включает в себя тестирование двух основных сегментов:\n\n* Интерфейс веб-сервера и сервера приложений\n* Интерфейс сервера приложений и базы данных\n\n**Тестирование потоков (Thread testing)** - это вид тестирования программного обеспечения, который проверяет основные функциональные возможности конкретной задачи (потока). Обычно проводится на ранней стадии фазы интеграционного тестирования. Тестирование на основе потоков является одной из дополнительных стратегий, принятых в ходе System Integration Testing. Поэтому его, вероятно, следует более правильно назвать «тестом взаимодействия потоков» (thread interaction test).\n\nThread Testing подразделяется на две категории:\n\n* Однопоточное тестирование (Single thread testing) включает одну транзакцию приложения за раз;\n* Многопоточное тестирование (Multi-thread testing) включает одновременно несколько активных транзакций;\n\nКак проводить Thread Testing:\n\n* Тестирование на основе потоков является обобщенной формой тестирования на основе сеансов (session-based testing), в котором сеансы являются формой потока, но поток не обязательно является сеансом;\n* Для тестирования потока, поток или программа (небольшая функциональность) интегрируются и тестируются постепенно как подсистема, а затем выполняются для всей системы;\n* На самом низком уровне оно предоставляет интеграторам лучшее представление о том, что тестировать;\n* Вместо непосредственного тестирования программных компонентов требуется, чтобы интеграторы сосредоточились на тестировании логических путей выполнения в контексте всей системы;\n\nСоветы:\n\n* Протестируйте свою многопоточную программу, многократно выполняя ее с другим набором запущенных приложений;\n* Протестируйте свою многопоточную программу, активировав одновременно несколько экземпляров программы;\n* Выполняйте многопоточную программу на разных моделях оборудования с различными уровнями нагрузки и рабочими нагрузками;\n* Инспекция кода;\n* Собирайте только ошибки и сбои, которые произошли в потоках, отличных от основного;\n\n\n### Системное тестирование (System Testing)\n\nСистемное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.\n\n**Основное внимание уделяется следующему**:\n\n* Внешние интерфейсы;\n* Многопрограммность и сложный функционал;\n* Безопасность;\n* Восстановление;\n* Производительность;\n* Гладкое (smooth) взаимодействие оператора и пользователя с системой;\n* Возможность установки;\n* Документация;\n* Удобство использование;\n* Нагрузка / стресс;\n\n**Зачем нужно системное тестирование**?\n\n* Очень важно завершить полный цикл тестирования, и ST - это этап, на котором это делается;\n* ST выполняется в среде, аналогичной production environment, и, следовательно, заинтересованные стороны могут получить хорошее представление о реакции пользователя;\n* Это помогает свести к минимуму устранение неполадок после развертывания и количество обращений в службу поддержки;\n* На этом этапе STLC тестируются архитектура приложения и бизнес-требования. Это тестирование очень важно, и оно играет важную роль в предоставлении клиенту качественного продукта;\n\n**Критерии начала системного тестирования**:\n\n* Система должна соответствовать критериям окончания интеграционного тестирования, то есть все test cases должны быть выполнены, и не должно быть открытых критических ошибок или ошибок с приоритетом P1, P2;\n* System Test Plan должен быть одобрен и подписан;\n* Test cases/scenarios/scripts должны быть готовы к выполнению;\n* Все нефункциональные требования должны быть доступны, и для них должны быть созданы test cases;\n* Среда тестирования должна быть готова;\n\n**Критерии окончания системного тестирования**:\n\n* Все test cases должны быть выполнены;\n* В открытом состоянии не должно быть критических, приоритетных или связанных с безопасностью ошибок;\n* Если какие-либо ошибки со средним или низким приоритетом находятся в открытом состоянии, они должны быть исправлены с согласия клиента;\n* Отчет о выходе (Exit Report) должен быть отправлен;\n\n**Чем отличается системное тестирование от сквозного** (E2E - end-to-end testing)?\n\nСквозное тестирование - это методология тестирования программного обеспечения для тестирования flow приложения от начала до конца. Целью сквозного тестирования является моделирование реального пользовательского сценария и проверка тестируемой системы и ее компонентов на предмет интеграции и целостности данных.\n\nСистемное тестирование - этап предпоследний этап STLC и уровень тестирования, а E2E - подход к тестам. Обычно сквозные тесты выполняют после системного тестирования и перед приемочным, а также после внесения изменений (smoke и regression). E2E выполняется от начала до конца в реальных сценариях, таких как взаимодействие приложения с оборудованием, сетью, базой данных и другими приложениями. Основная причина проведения этого тестирования - определение различных зависимостей приложения, а также обеспечение передачи точной информации между различными компонентами системы.\n\n\n### Приемочное тестирование (AT - Acceptance testing)\n\n_Приемочное тестирование (acceptance testing): Формальное тестирование по отношению к потребностям, требованиям и бизнес процессам пользователя, проводимое с целью определения соответствия системы критериям приемки и дать возможность пользователям, заказчикам или иным авторизированым лицам определить, принимать систему или нет. (IEEE 610)_\n\n_Эксплуатационное приемочное тестирование (operational acceptance testing): Эксплуатационное тестирование в фазе приемочного тестирования, обычно выполняемое пользователем и/или сотрудниками с администраторским доступом, в рабочей среде (возможно, стимулированной), фокусируясь на функциональных аспектах. Например, восстанавливаемость, поведение ресурсов, устанавливаемость и техническое соответствие. (ISTQB)_\n\nПосле того, как процесс тестирования системы завершен командой тестирования, весь продукт передается клиенту и/или нескольким его пользователям для проверки приемлемости (acceptability). Е2Е бизнес-потоки проверяются аналогично в сценариях в реальном времени. Подобная производственной среда будет тестовой средой для приемочного тестирования (Staging, Pre-Prod, Fail-Over, UAT environment). Это метод тестирования черного ящика, при котором проверяется только функциональность, чтобы убедиться, что продукт соответствует указанным критериям приемки.\n\n**Виды приемочного тестирования**:\n\n* **Пользовательское** приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям. Могут существовать такие бизнес-требования и процессы, которые известны только конечным пользователям, и они либо пропускаются, либо неправильно интерпретируются, поэтому приемочное тестирование выполняется конечными пользователями, знакомыми с бизнес-требованиями;\n* **Бизнес -** приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам. BAT в основном фокусируется на бизнес-преимуществах (финансах), которые являются довольно сложными из-за меняющихся рыночных условий / прогрессирующих технологий, так что текущая реализация может претерпеть изменения, которые приведут к дополнительным затратам. Даже Продукт, отвечающий техническим требованиям, может не пройти BAT по этим причинам;\n* **Контрактное** приемочное тестирование (CAT - Contract Acceptance Testing) - это контракт, который определяет, что после того, как Продукт будет запущен в течение заранее определенного периода, должен быть проведен приемочный тест, и он должен пройти все приемочные тест-кейсы. Подписанный здесь контракт называется Соглашением об уровне обслуживания (SLA), которое включает условия, по которым платеж будет производиться только в том случае, если услуги Продукта соответствуют всем требованиям, что означает, что контракт выполнен. Иногда этот контракт может заключаться до того, как Продукт будет запущен. В любом случае, контракт должен быть четко определен с точки зрения периода тестирования, областей тестирования, условий по проблемам, возникающим на более поздних этапах, платежей и т. д.;\n* **Правовое** приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается. Это может быть непреднамеренным, но отрицательно скажется на бизнесе. Обычно разрабатываемый Продукт / приложение, предназначенный для выпуска во всем мире, должен пройти RAT, поскольку в разных странах / регионах действуют разные правила и положения, определенные его руководящими органами. Если какие-либо правила и нормы нарушаются для какой-либо страны, то этой стране или конкретному региону в этой стране не будет разрешено использовать Продукт и это будет считаться отказом (Failure). Вендоры Продукта несут прямую ответственность, если Продукт будет выпущен даже при наличии нарушения;\n* **Эксплуатационное** приемочное тестирование ([OAT - Operational Acceptance testing](https://en.wikipedia.org/wiki/Operational\\_acceptance\\_testing)) - это тип тестирования программного обеспечения, который оценивает эксплуатационную готовность программного приложения до его выпуска в производство. Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment). В основном это тестирование восстановления, совместимости, ремонтопригодности, доступности технической поддержки, надежности, восстановления после сбоя, локализации и т. д (recovery, compatibility, maintainability, technical support availability, reliability, fail-over, localization);\n* **Альфа-тестирование** ([Alpha Testing](https://www.softwaretestinghelp.com/alpha-testing/)) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. Здесь отзывы и предложения тестировщиков помогают улучшить использование Продукта, а также исправить определенные ошибки;\n* **Бета-тестирование, полевые испытания** ([Beta Testing](https://www.softwaretestinghelp.com/beta-testing/), Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде. Собирается постоянная обратная связь от пользователей, и проблемы устраняются. Кроме того, это помогает в улучшении Продукта, чтобы обеспечить удобство работы пользователей. Тестирование происходит неконтролируемым образом, что означает, что у пользователя нет ограничений на использование Продукта;\n\n**Уровни Тестирования**\n1. Модульное тестирование (Unit Testing)\nКомпонентное (модульное) тестирование проверяет функциональность и ищет дефекты в частях приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты, классы, функции и т.д.).\n\n2. Интеграционное тестирование (Integration Testing)\nПроверяется взаимодействие между компонентами системы после проведения компонентного тестирования.\n\n3. Системное тестирование (System Testing)\nОсновной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.\n\n4. Операционное тестирование (Release Testing).\nДаже если система удовлетворяет всем требованиям, важно убедиться в том, что она удовлетворяет нуждам пользователя и выполняет свою роль в среде своей эксплуатации, как это было определено в бизнес моделе системы. Следует учесть, что и бизнес модель может содержать ошибки. Поэтому так важно провести операционное тестирование как финальный шаг валидации. Кроме этого, тестирование в среде эксплуатации позволяет выявить и нефункциональные проблемы, такие как: конфликт с другими системами, смежными в области бизнеса или в программных и электронных окружениях; недостаточная производительность системы в среде эксплуатации и др. Очевидно, что нахождение подобных вещей на стадии внедрения — критичная и дорогостоящая проблема. Поэтому так важно проведение не только верификации, но и валидации, с самых ранних этапов разработки ПО.\n\n5. Приемочное тестирование (Acceptance Testing)\nФормальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:\n• определения удовлетворяет ли система приемочным критериям;\n• вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.\n","category":"manual","description":"Уровни тестирования"},{"title":"Техники тест-дизайна","path":"/tehniki-test-dizajna/","content":"# Тест-дизайн и техники тест-дизайна (Test Design and Software Testing Techniques)\n\n_Проектирование теста (test design): Процесс перевода общих причин тестирования в конкретные тестовые условия и тестовые сценарии. (ISTQB)_\n\n_Причина тестирования (test objective): Причина или цель разработки и выполнения теста. (ISTQB)_\n\n_Тестовое условие (test condition): Объект или событие в компоненте или системе, которое должно быть проверено одним или несколькими тестовыми наборами. Например: функция, транзакция, свойство, атрибут качества или структурный элемент. (ISTQB)_\n\n**Тест-дизайн** - важный этап STLС, а именно деятельность по получению и определению тестовых примеров из test objectives и test conditions. Проще говоря, цель тест-дизайна - создать максимально эффективный набор кейсов, покрывающий наиболее важные аспекты тестируемого ПО, т.е. минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок.\n\n**Тест дизайн** — это этап процесса тестирования ПО, на котором проектируются и создаются тестовые сценарии (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования.\nРоли, ответственные за тест дизайн:\n• Тест аналитик — определяет «ЧТО тестировать?»\n• Тест дизайнер — определяет «КАК тестировать?»\n\nОдним из наиболее важных аспектов теста является то, что он проверяет, выполняет ли система то, что она должна делать. Copeland говорит: “По сути, тестирование - это процесс сравнения того, что есть с тем, что должно быть”. Если мы просто введем какие-то данные и подумаем, что это было весело, я предполагаю, что с системой, вероятно, все в порядке, потому что она не крашнулась, но действительно ли мы ее тестируем? Beizer называет это «детским тестированием» (kiddie testing). Мы можем не знать каждый раз, какой правильный ответ в деталях, и иногда мы все равно можем получить некоторую выгоду от этого подхода, но на самом деле это не проверка. Чтобы знать, что система должна делать, нам нужен источник информации о правильном поведении системы - это называется «оракул» или тестовый оракул (test oracle). После того, как заданное входное значение было выбрано, тестировщику необходимо определить, каким будет ожидаемый результат ввода этого входа, и задокументировать его как часть тестового примера.\n\nДавайте проясним. Требования или пользовательские истории с критериями приемлемости (формы test basis) определяют, что вы должны тестировать (test objects and test conditions), и исходя из этого, вы должны выяснить способ тестирования, то есть спроектировать тестовые примеры. Один из наиболее важных вопросов заключается в следующем: какие факторы влияют на успешный дизайн теста? Если вы читаете разные блоги, статьи или книги, вы найдете примерно следующее:\n\n* Время и бюджет, доступные для тестирования;\n* Соответствующие знания и опыт вовлеченных людей;\n* Определен целевой уровень покрытия (измерение уровня достоверности (measuring the confidence level));\n* Способ организации процесса разработки программного обеспечения (например, водопад или гибкая разработка);\n* Устанавливается соотношение методов создания тестов (например, ручных и автоматических);\n\nЭто неправда! Без достаточного времени и бюджета вы, вероятно, вообще не начнете ни одного проекта. Если у вас нет квалифицированных специалистов по тестированию программного обеспечения, включая дизайн тестов, то, вероятно, вы тоже не начнете проект. Однако, хороший дизайн теста включает три предварительных условия:\n\n* Полная спецификация (Complete specification)(test bases);\n* Анализ рисков и сложности (Risk and complexity analysis);\n* Исторические данные ваших предыдущих разработок;\n\nТребуются некоторые пояснения. Полная спецификация не означает безошибочную спецификацию, так как во время разработки теста можно найти и исправить множество проблем (предотвращение дефектов). Это только означает, что у нас есть все необходимые требования или в Agile разработке у нас есть все эпики, темы и пользовательские истории с критериями приемлемости (acceptance criteria). Существует минимальная ценность в одновременном рассмотрении затрат на тестирование и затрат на исправление дефектов, и цель хорошего тест-дизайна - выбрать подходящие методы тестирования, приближающиеся к этому минимуму. Это можно сделать, проанализировав сложность, риски и используя исторические данные. Таким образом, анализ рисков неизбежен для определения тщательности тестирования. Чем выше риск использования функции / объекта, тем более тщательное тестирование необходимо. То же самое можно сказать и о сложности кода. Для более рискованного или сложного кода мы должны сначала применить больше НЕкомбинаторных методов проектирования тестов вместо одного чисто комбинаторного.\n\nНаше другое и правильное представление о дизайне тестирования состоит в том, что если у вас есть соответствующая спецификация (тестовая база) и надежный анализ рисков и сложности, то, зная ваши исторические данные, вы можете выполнить дизайн теста оптимальным образом. Вначале у вас нет исторических данных, и вы, вероятно, не достигнете оптимума. Нет проблем, давайте сделаем предварительную оценку. Например, если риск и сложность низкие, используйте только исследовательское тестирование. Если они немного выше, используйте исследовательское тестирование и простые методы, основанные на спецификациях, такие как классы эквивалентности с анализом граничных значений. Если риск высок, вы можете использовать исследовательское тестирование, комбинационное тестирование, предотвращение дефектов, статический анализ и обзоры (reviews).\n\nЕще одно важное замечание. Критерии выбора тестов и адекватности тестовых данных различны. Первый - неотъемлемая часть любой техники тест-дизайна. Второй проверяет набор тестов. В результате процесса разработки тестов создаются независимые от реализации тестовые примеры, которые проверяют требования или пользовательские истории. Напротив, тесты, которые создаются на основе отсутствия покрытия по выбранным критериям адекватности тестовых данных, подтверждают проблемы, зависящие от реализации; однако это НЕ дизайн теста, это создание теста. Очень важно использовать метод «сначала тестирование» (test-first method), т. е. дизайн теста должен быть отправной точкой разработки. Дизайн тестов также очень эффективен для предотвращения дефектов, если он применяется до внедрения.\n\nИтак, хороший **процесс тест-дизайна** выглядит так:\n\n* Сбор информации, чтобы понять требования пользователей;\n* Получение всех важных бизнес-сценариев;\n* Создание тестовых сценариев для каждого производного критически важного бизнес-сценария;\n* Назначение всех запланированных тестовых сценариев различным тестовым случаям;\n\nЗатем вам нужно будет выбрать технику тест-дизайна для каждого требования. На этом этапе, если все реализовано правильно, вы можете внести значительные изменения, которые чрезвычайно повлияют на ваш [ROI](https://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D1%83%D0%BF%D0%B0%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C\\_%D0%B8%D0%BD%D0%B2%D0%B5%D1%81%D1%82%D0%B8%D1%86%D0%B8%D0%B9).\n\n**Роли**, ответственные за тест дизайн:\n\n* **Тест аналитик** (test analyst) - определяет \"ЧТО тестировать?\":\n  * Исследует продукт:\n    * Понимание цели создания продукта;\n    * Какими способами цель должна достигаться;\n    * Какие и основные и вспомогательные возможности предоставляет продукт пользователям;\n    * Оценка, правильно ли понял разработчик заказчика.\n  * Составляет логическую карту продукта: Интеллект - карта - это техника представления любого процесса, события, мысли или идеи в систематизированной визуальной форме;\n  * Разбивает программный продукт на основные части:\n    * Система расчленяется только по одному, постоянному для всех уровней признаку (Они должны отвечать на один и тот же вопрос, по отношению к своему родителю);\n    * Вычленяемые подсистемы должны взаимно исключать друг друга, а в сумме - характеризовать систему;\n    * На каждом уровне рекомендуется использовать не более 7 подсистем;\n  * Расставляет приоритеты для тестирования:\n    * Требования клиента;\n    * Степень риска;\n    * Сложность системы;\n    * Временные ограничения;\n* **Тест дизайнер** - определяет \"КАК тестировать?\";\n\nПопросту говоря, задача тест аналитиков и дизайнеров сводится к тому, чтобы используя различные стратегии и техники тест дизайна, создать набор Test case, обеспечивающий оптимальное тестовое покрытие тестируемого приложения. Однако, на большинстве проектов эти роли не выделяется, а доверяется обычным тестировщикам, что не всегда положительно сказывается на качестве тестов, тестировании и, как из этого следует, на качестве ПО (конечного продукта).\n\n**Техники тест дизайна**\n\n• _Эквивалентное Разделение (Equivalence Partitioning — EP)_. Как пример, у вас есть диапазон допустимых значений от 1 до 10, вы должны выбрать одно верное значение внутри интервала, скажем, 5, и одно неверное значение вне интервала — 0.\n\n• _Анализ Граничных Значений (Boundary Value Analysis — BVA)_. Если взять пример выше, в качестве значений для позитивного тестирования выберем минимальную и максимальную границы (1 и 10), и значения больше и меньше границ (0 и 11). Анализ Граничный значений может быть применен к полям, записям, файлам, или к любого рода сущностям имеющим ограничения.\n\n• _Причина / Следствие (Cause/Effect — CE)_. Это, как правило, ввод комбинаций условий (причин), для получения ответа от системы (Следствие). Например, вы проверяете возможность добавлять клиента, используя определенную экранную форму. Для этого вам необходимо будет ввести несколько полей, таких как «Имя», «Адрес», «Номер Телефона» а затем, нажать кнопку «Добавить» — это «Причина». После нажатия кнопки «Добавить», система добавляет клиента в базу данных и показывает его номер на экране — это «Следствие».\n\n• _Предугадывание ошибки (Error Guessing — EG)_. Это когда тестировщик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы «предугадать» при каких входных условиях система может выдать ошибку. Например, спецификация говорит: «пользователь должен ввести код». Тестировщик будет думать: «Что, если я не введу код?», «Что, если я введу неправильный код? », и так далее. Это и есть предугадывание ошибки.\n\n• _Исчерпывающее тестирование (Exhaustive Testing — ET)_ — это крайний случай. В пределах этой техники вы должны проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике применение этого метода не представляется возможным, из-за огромного количества входных значений.\n\n• _Попарное тестирование (Pairwise Testing)_ — это техника формирования наборов тестовых данных. Сформулировать суть можно, например, вот так: формирование таких наборов данных, в которых каждое тестируемое значение каждого из проверяемых параметров хотя бы единожды сочетается с каждым тестируемым значением всех остальных проверяемых параметров.\n\nДопустим, какое-то значений (налог) для человека рассчитывается на основании его пола, возраста и наличия детей — получаем три входных параметра, для каждого из которых для тестов выбираем каким-то образом значения. Например: пол — мужской или женский; возраст — до 25, от 25 до 60, более 60; наличие детей — да или нет. Для проверки правильности расчётов можно, конечно, перебрать все комбинации значений всех параметров:\n\n№\tпол\tвозраст\tдети\n1\tмужчина\tдо 25\tдетей нет\n2\tженщина\tдо 25\tдетей нет\n3\tмужчина\t25-60\tдетей нет\n4\tженщина\t25-60\tдетей нет\n5\tмужчина\tстарше 60\tдетей нет\n6\tженщина\tстарше 60\tдетей нет\n7\tмужчина\tдо 25\tдети есть\n8\tженщина\tдо 25\tдети есть\n9\tмужчина\t25-60\tдети есть\n10\tженщина\t25-60\tдети есть\n11\tмужчина\tстарше 60\tдети есть\n12\tженщина\tстарше 60\tдети есть\nА можно решить, что нам не нужны сочетания значений всех параметров со всеми, а мы хотим только убедиться, что мы проверим все уникальные пары значений параметров. Т.е., например, с точки зрения параметров пола и возраста мы хотим убедиться, что мы точно проверим мужчину до 25, мужчину между 25 и 60, мужчину после 60, а также женщину до 25, женщину между 25 и 60, ну и женщину после 60. И точно так же для всех остальных пар параметров. И таким образом, мы можем получить гораздо меньше наборов значений (в них есть все пары значений, правда некоторые дважды):\n\n№\tпол\tвозраст\tдети\n1\tмужчина\tдо 25\tдетей нет\n2\tженщина\tдо 25\tдети есть\n3\tмужчина\t25-60\tдети есть\n4\tженщина\t25-60\tдетей нет\n5\tмужчина\tстарше 60\tдетей нет\n6\tженщина\tстарше 60\tдети есть\nТакой подход примерно и составляет суть техники pairwise testing — мы не проверяем все сочетания всех значений, но проверяем все пары значений.\n\n\n**Техники тест-дизайна (Software testing techniques)**\n\n* Cтатические (Static):\n  * Reviews:\n    * Неформальное ревью (Informal review)\n    * Прохождение (Walkthrough)\n    * Техническое ревью (Technical Review)\n    * Инспекция (Inspection)\n  * Статический анализ (Static Analysis):\n    * Поток данных (Data Flow)\n    * Поток управления (Control Flow)\n    * Путь (Path)\n    * Стандарты (Standards)\n* Динамические (Dynamic):\n  * Белый ящик (White-box, Structure-Based)\n    * Выражение (Statement)\n    * Решение (Decision)\n    * Ветвь (Branch)\n    * Условие (Condition)\n    * Конечный автомат (FSM)\n  * Основанные на опыте (Experience-based):\n    * Предугадывание ошибки (Error Guessing - EG);\n    * Исследовательское тестирование (Exploratory testing);\n    * Ad-hoc testing;\n    * [Attack ](https://www.softwaretestinggenius.com/anatomy-of-various-types-of-experience-based-testing-techniques/)Testing;\n  * Черный ящик (Black-box, Specification-based):\n    * Эквивалентное Разделение (Equivalence Partitioning - EP)\n    * Анализ Граничных Значений (Boundary Value Analysis - BVA)\n    * Комбинаторные техники ([Combinatorial Test Techniques](https://sysgears.com/articles/test-design-techniques-overview/#combinatorial))\n    * Переходы между состояниями (State transition)\n    * Случаи использования (Use case testing)\n    * Domain testing\n    * Decision Table Testing\n    * Classification Tree Method\n    * State Transition Testing\n    * Cause-Effect Graphing\n    * Scenario Testing\n    * Random Testing\n    * Syntax Testing\n    * Check List Based Testing\n    * Risk-Based Testing\n    * User Journey Test\n\n\n## Static - Reviews\n\n_Рецензирование (review): Оценка состояния продукта или проекта с целью установления расхождений с запланированными результатами и для выдвижения предложений по совершенствованию. Примерами рецензирования могут служить: управленческое рецензирование, неформальное рецензирование, технический анализ, инспекция и разбор. (ISTQB)_\n\n_Неформальное рецензирование (informal review): Рецензирование, которое не основано на формальной (документированной) процедуре. (ISTQB)_\n\n_Разбор (walkthrough): Пошаговый разбор, проводимый автором документа для сбора информации и обеспечения одинакового понимания содержания документа. (IEEE 1028)_\n\n_Равноправный анализ (peer review): Рецензирование разрабатываемого программного продукта, проводящееся сотрудниками компании-разработчика с целью нахождения дефектов и внесение улучшений. Примерами рецензирования являются: инспекция, технический анализ и разбор. (ISTQB)_\n\n_Инспекция (inspection): Тип равноправного анализа, основанный на визуальной проверке документов для поиска ошибок. Например, нарушение стандартов разработки и несоответствие документации более высокого уровня. Наиболее формальная методика рецензирования и поэтому всегда основывается на документированной процедуре. (IEEE 610, IEEE 1028). См. также равноправный анализ._\n\nМетоды статического тестирования делятся на две основные категории, одной из которых являются ревью. Ранжирование по уровню формальности:\n\n![https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/peer\\_review.jpg](https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/peer\\_review.jpg)\n\n### Экспертные обзоры (Peer Reviews): \nРецензирование - это стандартизированный метод проверки правильности исходного кода при разработке программного обеспечения, который проводится для выявления дефектов на ранних этапах жизненного цикла и которые не могут быть обнаружены с помощью методов тестирования черного ящика.\n\n### Прохождение/просмотр/пошаговый разбор (walkthrough ):\nМетод проведения неформального группового / индивидуального просмотра. В walkthrough автор описывает и объясняет рабочий продукт на неформальной встрече своим коллегам или руководителю, чтобы получить обратную связь. Здесь проверяется применимость предложенного решения для рабочего продукта. Либо рабочий продукт проверяется на наличие дефектов несколькими лицами, кроме человека, который его фактически произвел;\n\n### Технический обзор (Technical Review):\nЭто метод более высокого уровня по сравнению с inspection или walkthrough, поскольку он также включает в себя управление. Этот метод используется для оценки (assess and evaluate) продукта путем проверки его соответствия стандартам разработки, руководствам и спецификациям. У него нет определенного процесса, и большая часть работы выполняется модератором, как описано ниже:\n\n* Модератор собирает и раздает материал и документацию всем членам команды;\n* Модератор также готовит набор показателей для оценки продукта в соответствии со спецификациями и уже установленными стандартами и гайдлайнами:\n  * последовательность;\n  * документация;\n  * соблюдение стандартов;\n  * полнота;\n  * определение проблемы и требования (? problem definition and requirements);\n* Результаты фиксируются в документе, который включает как дефекты, так и предложения;\n* Наконец, устраняются дефекты и учитываются предложения по улучшению продукта;\n\n### Инспекция: \nИнспекция определяется как наиболее формальная, тщательная, глубокая групповая проверка, направленная на выявление проблем как можно ближе к их исходной точке. Процесс проверки выполняется на ранних этапах SDLC и применяется к определенной части продукта, такой как SRS, код, дизайн продукта. и т. д. Это включает в себя ручное изучение различных компонентов продукта на более ранних этапах. Инспекционная деятельность следует определенному процессу, и участники играют четко определенные роли. Инспекционная группа состоит из трех-восьми человек, которые играют роли модератора, автора, читателя, записывающего и инспектора. Например, разработчик может выступать в качестве инспектора во время проверки кода, в то время как представитель по обеспечению качества может действовать как исполнитель стандартов.\n\n**Software inspection process:**\n\n* Планирование встречи: на этом этапе основное внимание уделяется определению продукта, подлежащего инспекции, и цели этой инспекции. На этом этапе назначается модератор, который управляет всем процессом. Назначенный модератор проверяет, готов продукт к инспекции или нет. Модератор также выбирает инспекционную группу и назначает им их роли. Модератор также планирует инспекционную встречу и раздает необходимые материалы инспекционной группе;\n* Обзор: на этом этапе инспекционной группе предоставляется вся справочная информация для инспекционного совещания. Автор, который является программистом или дизайнером, ответственным за разработку продукта, представляет свою логику и рассуждения о продукте, включая функции продукта, его предполагаемое назначение и подход или концепцию, использованные при его разработке. Удостоверяется, что каждый член инспекционной группы понял и знаком с задачами и целью инспекционного совещания, которое должно быть проведено;\n* Индивидуальная подготовка участников: на этом этапе члены инспекционной группы индивидуально готовятся к инспекционной встрече, изучая материалы, предоставленные на более ранних этапах. Члены команды выявляют потенциальные ошибки или недочеты в продукте и записывают их в журнал. Журнал передается модератору. Затем модератор собирает все журналы, полученные от участников, и отправляет их автору. Инспектор - лицо, ответственное за проверку и выявление ошибок и несоответствий в документах или программах, проверяет продукт и записывает все обнаруженные в нем проблемы (как общие, так и специфические). Инспектор записывает проблемы или issues в журнал вместе со временем, затраченным на подготовку. Модератор просматривает логи, чтобы проверить, готова ли команда к инспекционной встрече или нет. Наконец, модератор отправляет автору все скомпилированные логи;\n* Инспекционная встреча (Inspection Meeting): на этом этапе автор обсуждает вопросы, поднятые членами команды в скомпилированном журнале. Участники приходят к решению, является ли поднятый вопрос ошибкой или нет. Модератор завершает встречу и подводит итоги встречи - это список ошибок, обнаруженных в продукте, которые должен устранить автор.\n* Переделка: доработка проводится автором согласно сводному списку, представленному модератором на предыдущем этапе. Автор исправляет все ошибки и сообщает модератору;\n* Follow - up: модератор проверяет, все ли ошибки устранены или нет. Затем модератор готовит отчет. Если все ошибки исправлены и устранены, модератор выпускает документ. В противном случае в отчет добавляются нерешенные вопросы и назначается еще одно инспекционное собрание;\n\n![](https://lh3.googleusercontent.com/3Zp7j69Y1F9v2cNbZ6e6xR128Uc9GOtuq-Y-Rl44fuWU6cPb8ZC6S1E\\_V2AGJf1LVjIRQ6r2S2YaOc1E6-3qZBV5x9P9K4nVkbfn4C75dbz\\_ePadqrjDLY1XYAQjBzWnbaf5a2\\_Q)\n\n## Static - Static Analysis\n\n_Статический анализ (static analysis): Анализ артефактов разработки программного обеспечения, таких как требования или программный код, проводимый без исполнения этих программных артефактов. Статический анализ обычно выполняется при помощи вспомогательных инструментов. (ISTQB)_\n\nСтатический анализ - это анализ программных артефактов, таких как программный код (или требования, дизайн), выполняемый статически, т.е. без запуска и, очевидно, методом белого ящика. Основная цель этого анализа - как можно раньше найти ошибки, независимо от того, могут ли они вызывать отказы (failures). Как и в случае с обзорами (reviews), статический анализ обнаруживает ошибки (bugs), а не отказы. Обычно статический анализ проводят до формальной проверки, даже до unit testing, путём добавления этих проверок специалистами DevOps в пайплайн проекта. Статический анализ не связан с динамическими свойствами требований, дизайна и кода, такими как покрытие тестами (test coverage). Существует множество инструментов для статического анализа, которые в основном используются разработчиками до или во время тестирования компонентов или интеграции (чаще новые и измененные классы и функции), а также дизайнерами во время моделирования программного обеспечения. Инструменты могут отображать не только структурные атрибуты, такие как глубина вложенности или число цикломатической сложности и проверка на соответствие стандартам кодирования, но также графические изображения потока управления, взаимосвязи данных и количество отдельных путей от одной строки кода к другой. Информация может использоваться вплоть до формальных методов, которые математически подтверждают свойства данной программы.\n\n**Инструменты помогают в выявлении следующих дефектов:**\n\n* Неиспользуемые переменные;\n* Части кода, которые никогда не выполнятся;\n* Бесконечные циклы;\n* Переменная с неопределенным значением;\n* Неправильный синтаксис;\n* Несогласованные интерфейсы между модулями и компонентами, такие как неправильное использование объекта, метода или функции, включая неправильные параметры;\n* Уязвимости безопасности, такие как проблемы безопасности, связанные с переполнением буфера, возникающим из-за невозможности проверить длину буфера перед копированием в буфер;\n* Различные типы нарушения стандартов программирования, как нарушения, создающие риск фактического сбоя, так и нарушения, которые усложняют тестирование, анализ и поддерживаемость кода;\n\n**Методы статического анализа**:\n\n### Анализ управления (Control Analysis)\n\nФокусируется на изучении элементов управления, используемых в структуре вызовов, анализе потока управления и анализе переходов состояний (calling structure, control flow analysis and state transition analysis). Структура вызова связана с моделью путем идентификации вызовов и их структуры. Вызывающая структура может быть процессом, подпрограммой, функцией или методом. Анализ потока управления проверяет последовательность передачи управления и может выявить неэффективные конструкции в модели. Создается граф модели (CFG - Control Flow Graph), в котором условные ветви и стыки модели представлены узлами. По итогам также можно рассчитать цикломатическую сложность программы. Для анализа потока управления [могут быть](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7\\_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0\\_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F#:\\~:text=%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-,%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D0%B1%D1%8B%D1%82%D1%8C,-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D1%8B%3A%20%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%B5%D1%80%D1%82%D0%B0%D1%86%D0%B8%D1%8F) использованы: Абстрактная интерпретация, Удовлетворение ограничений, Типизация данных;\n\n### Анализ данных (Data Analysis)\n\nОбеспечивает правильную работу с объектами данных, такими как структуры данных и связанные списки. Кроме того, этот метод также обеспечивает правильное использование определенных данных. Анализ данных включает два метода, а именно: зависимость данных и анализ потока данных (data dependency and data flow analysis). Зависимость данных необходима для оценки точности синхронизации между несколькими процессорами. Анализ потока данных проверяет определение и контекст переменных. Виды анализа потока данных:\n  * Reaching Definitions;\n  * Available Expressions;\n  * Constant Propagation;\n  * Very Busy Expressions;\n  * Live Variables;\n  * Use-Definition & Definition-Use;\n* Анализ неисправностей / отказов (Fault/Failure Analysis): анализирует неисправности (некорректный компонент) и отказ (некорректное поведение компонента модели) в модели. Этот метод использует описание преобразования ввода-вывода для определения условий, являющихся причиной сбоя. Для определения отказов в определенных условиях проверяется проектная спецификация модели (model design specification);\n* Анализ интерфейса (Interface Analysis): проверяет взаимодействующие и распределенные модели для проверки кода (This software verifies and verifies interactive and distribution simulations to check the code). Существует два основных метода анализа интерфейса, и анализ пользовательского интерфейса исследует интерфейсы подмоделей и определяет точность структуры интерфейса. Анализ пользовательского интерфейса исследует модель пользовательского интерфейса и меры предосторожности, предпринимаемые для предотвращения ошибок во время взаимодействия пользователя с моделью. Этот метод также фокусируется на том, насколько точно интерфейс интегрирован в общую модель и симуляцию.\n\nАнализ потока управления (Control Flow Analysis) и анализ потока данных (Data Flow Analysis) взаимозависимы: чтобы получить точные результаты для анализа потока данных, необходимо учитывать поток управления (поскольку порядок операций влияет на возможные значения данных в конкретном месте программы). Чтобы получить точные результаты для анализа потока управления, необходимо учитывать поток данных, поскольку поток динамического управления (решение, принимаемое во время выполнения) зависит от значений данных в конкретных местах программы. Однако эти два анализа преследуют разные цели.\n\n### Граф потока управления (Control Flow Graph)\n\nГраф потока управления (CFG) - это графическое представление потока управления или вычислений во время выполнения программ или приложений. Графы потока управления в основном используются в статическом анализе, а также в приложениях-компиляторах, поскольку они могут точно представлять поток внутри программного модуля. Характеристики графа потока управления:\n\n* Граф потока управления процессно-ориентированный (process oriented);\n* Граф потока управления показывает все пути, которые можно пройти во время выполнения программы;\n* Граф потока управления - это [ориентированный](https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9\\_%D0%B3%D1%80%D0%B0%D1%84) граф;\n* Рёбра в CFG изображают пути потока управления, а узлы в CFG изображают базовые блоки.\n\n[Полное описание возможных элементов графа](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84\\_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0\\_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F).\n\n### Цикломатическая сложность (Cyclomatic Complexity)\n\nЦикломатическая сложность - это метрика для измерения сложности кода, основанная на графе потока управления. Независимый путь определяется как путь, имеющий хотя бы одно ребро, которое ранее не проходило ни в одном другом пути.\n\nОпределение из книги Ли Копланда - “A Practitioner's Guide to Software Test Design”, Главы 10:\n\nЦикломатическая сложность​ - это конечное минимальное количество независимых, нецикличных маршрутов (называемых основными маршрутами), которые могут образовывать все возможные линейные пути в программном модуле.\n\nЦикломатическая сложность может быть рассчитана относительно функций, модулей, методов или классов в программе как вручную, так и с помощью автоматизированных инструментов.\n\nМатематически цикломатическая сложность структурированной программы определяется с помощью ориентированного графа, узлами которого являются блоки программы, соединенные ребрами, если управление может переходить с одного блока на другой. Тогда сложность определяется как\n\n_M = E − N + 2P_,\n\nгде:\n\n* M = цикломатическая сложность,\n* E = количество ребер в графе,\n* N = количество узлов в графе,\n* P = количество компонент связности.\n\nВ другой формулировке используется граф, в котором каждая точка выхода соединена с точкой входа. В этом случае граф является сильносвязным, и цикломатическая сложность программы равна цикломатическому числу этого графа (также известному как первое число Бетти), которое определяется как\n\n_M = E − N + P_.\n\nЭто определение может рассматриваться как вычисление числа линейно независимых циклов, которые существуют в графе, то есть тех циклов, которые не содержат в себе других циклов. Так как каждая точка выхода соединена с точкой входа, то существует по крайней мере один цикл для каждой точки выхода.\n\nДля простой программы, или подпрограммы, или метода P всегда равно 1. Однако цикломатическая сложность может применяться к нескольким таким программам или подпрограммам (например, ко всем методам в классе), в таком случае P равно числу подпрограмм, о которых идет речь, так как каждая подпрограмма может быть представлена как независимая часть графа.\n\nМожет быть показано, что цикломатическая сложность любой структурированной программы с только одной точкой входа и одной точкой выхода эквивалентна числу точек ветвления (то есть, операторов if или условных циклов), содержащихся в этой программе, плюс один.\n\nЦикломатическая сложность может быть распространена на программу с многочисленными точками выхода; в этом случае она равна\n\n_π − s + 2_,\n\nгде:\n\n* π - число точек ветвления в программе,\n* s - число точек выхода.\n\nПрименение:\n\n* Ограничение сложности при разработке: одно из первоначально предложенных Маккейбом применений состоит в том, что необходимо ограничивать сложность программ во время их разработки. Он рекомендует, чтобы программистов обязывали вычислять сложность разрабатываемых ими модулей и разделять модули на более мелкие всякий раз, когда цикломатическая сложность этих модулей превысит 10. Эта практика была включена НИСТ-ом в методику структурного тестирования с замечанием, что со времени исходной публикации Маккейба выбор значения 10 получил весомые подтверждения, однако в некоторых случаях может быть целесообразно ослабить ограничение и разрешить модули со сложностью до 15. В данной методике признается, что иногда могут существовать причины для выхода за рамки согласованного лимита. Это сформулировано как рекомендация: «Для каждого модуля следует либо ограничивать цикломатическую сложность до согласованных пределов, либо предоставить письменное объяснение того, почему лимит был превышен»;\n* Применение при тестировании программного обеспечения: определение количества тестов, необходимых для полного покрытия кода. Цикломатическая сложность M имеет два свойства, для конкретного модуля:\n  * M - оценка сверху для количества тестов, обеспечивающих покрытие условий (точек ветвления);\n  * M - оценка снизу для количества маршрутов через граф потока управления и, таким образом, количества тестов для полного покрытия путей.\n* В составе других метрик: используется в качестве одного из параметров в индексе удобства сопровождения (англ. maintainability index).\n\n## Dynamic - White box\n\n_Разработка тестов методом белого ящика (white-box test design technique): Процедура разработки или выбора тестовых сценариев на основании анализа внутренней структуры компонента или системы. (ISTQB)_\n\n_Основанные на структуре методы проектирования тестирования используются для получения контрольных примеров из структурной характеристики, например структуры исходного кода или структуры меню. Если эти методы применяются к исходному коду приложения, то ожидаемые результаты для контрольных примеров получаются из базиса тестирования. Выбор, какие из основанных на структуре методов проектирования тестирования использовать в каждом конкретном случае, зависит от природы базиса тестирования и от присущих рисков. (ГОСТ 56920)_\n\n_Поток данных (data flow): Абстрактное представление последовательности и возможных изменений состояния объектов данных, при котором состояние объекта это: создание, использование либо уничтожение. (Beizer)_\n\n_Поток управления (control flow): Последовательность событий (путей) в процессе выполнения компонента или системы. (ISTQB)_\n\n**Динамическое тестирование методом белого ящика** - это стратегия, основанная на внутренних путях, структуре и реализации тестируемого программного обеспечения. Тесты здесь выполняются динамически, т.е. с запуском объекта тестирования и основаны на различных видах покрытии кода (путей исполнения программы).\n\nГлобально основных техник динамического тестирования методом белого ящика всего две:\n\n- **Тестирование потока управления** (Control Flow Testing);\n- **Тестирование потока данных** (Data Flow Testing).\n\nФактически, это динамическая часть одного цельного тестирования, статическая часть которого - анализ и построение графа, описывается в предыдущей теме про статический анализ, а на этом определяется целевое покрытие (Coverage Target), создаются соответствующие тест-кейсы, тесты исполняются и результаты выполнения тестов анализируются.\n\n### Уровни тестового покрытия в тестировании потока управления (Control Flow Testing)\n\nПод “покрытием\" имеется в виду отношение объема кода, который уже был проверен, к объему, который осталось проверить. В тестировании потока управления покрытие определяется в виде нескольких различных уровней. Заметим, что эти уровни покрытия представлены не по порядку. Это потому, что в некоторых случаях проще определить более высокий уровень покрытия, а затем определить более низкий уровень покрытия в условиях высокого.\n\n1. **100% покрытие операторов** (Statement/node coverage). Оператор (statement) - это сущность языка программирования, обычно являющаяся минимальным неделимым исполняемым блоком (ISTQB). Покрытие операторов - это метод проектирования тестов методом белого ящика, который включает в себя выполнение всех исполняемых операторов (if, for и switch) в исходном коде как минимум один раз. Процентное отношение операторов, исполняемых набором тестов, к их общему количеству является метрикой покрытия операторов. Борис Бейзер написал: \"тестирование, меньшее чем это (100% покрытие операторов), для нового программного обеспечения является недобросовестным и должно быть признано преступлением. …”. Несмотря на то, что это может показаться разумной идеей, на таком уровне покрытия может быть пропущено много дефектов и затруднен анализ покрытия некоторых управляющих структур. Покрытие операторов позволяет найти:\n\n* Неиспользованные выражения (Unused Statements);\n* Мертвый код (Dead Code);\n* Неиспользуемые ветви (Unused Branches);\n* Недостающие операторы (Missing Statements);\n\n2. **100% покрытие альтернатив/ветвей** (Decision/branch/all-edges/basis path/DC/C2/ decision-decision-path/edge coverage). «Решение» - это программная точка, в которой control flow имеет два или более альтернативных маршрута (ветви). На этом уровне достаточно такого набора тестов, в котором каждый узел с ветвлением (альтернатива), имеющий TRUE или FALSE на выходе, выполняется как минимум один раз, таким образом, для покрытия по веткам требуется как минимум два тестовых примера. На данном уровне не учитываются логические выражения, значения компонент которых получаются вызовом функций. В отличие от предыдущего уровня покрытия данный метод учитывает покрытие условных операторов с пустыми ветками. Покрытие альтернатив не гарантирует покрытие всех путей, но при этом гарантирует покрытие всех операторов;\n\nДля более полного анализа компонент условий в логических операторах существуют следующие три метода, учитывающих структуру компонент условий и значения, которые они принимают при выполнении тестовых примеров.\n\n3. **100% покрытие условий** (Condition/Toggle Coverage). Рассматриваются только выражения с логическими операндами, например, AND, OR, XOR. На этом уровне достаточно такого набора тест-кейсов, в котором каждое условие, имеющее TRUE и FALSE на выходе, выполнено как минимум один раз. Покрытие условий обеспечивает лучшую чувствительность к control flow, чем decision coverage. Для обеспечения полного покрытия по данному методу каждая компонента логического условия в результате выполнения тестовых примеров должна принимать все возможные значения, но при этом не требуется, чтобы само логическое условие принимало все возможные значения, т.е. Condition Coverage не дает гарантии полного decision coverage;\n\n4. **100% покрытие условий + альтернатив** (Decision + Condition coverage). На этом уровне тест-кейсы создаются для каждого условия и для каждой альтернативы, т.е. данный метод сочетает требования предыдущих двух методов - для обеспечения полного покрытия необходимо, чтобы как логическое условие, так и каждая его компонента приняла все возможные значения;\n\n5. **100% покрытия множественный условий** (Multiple condition coverage). Для выявления неверно заданных логических функций был предложен метод покрытия по всем условиям. При данном методе покрытия должны быть проверены все возможные наборы значений компонент логических условий: условий, альтернатив и условий/альтернатив. Т.е. в случае n компонент потребуется 2^n тестовых примеров, каждый из которых проверяет один набор значений. Тесты, необходимые для полного покрытия по данному методу, дают полную таблицу истинности для логического выражения. Несмотря на очевидную полноту системы тестов, обеспечивающей этот уровень покрытия, данный метод редко применяется на практике в связи с его сложностью и избыточностью. Еще одним недостатком метода является зависимость количества тестовых примеров от структуры логического выражения. Кроме того, покрытие множественных условий не гарантирует покрытие всех путей;\n\n6. **Покрытие бесконечного числа путей**. Если, в случае зацикливания, количество путей становится бесконечным, то имеет смысл существенно их сократить, ограничив количество циклов выполнения, что позволит уменьшить количество тестовых случаев. Первый вариант - не выполнять цикл совсем; второй - выполнить цикл один раз; третий - выполнить цикл n раз, где n - это небольшое значение, представляющее символическое количество повторений цикла; четвертый - выполнить цикл m раз, где m - максимальное количество повторений цикла. Кроме того, можно выполнить цикл m-1 и m+1 раз. Перед тем, как начинать тестирование потока управления, должен быть выбран соответствующий уровень покрытия;\n\n7. **100% покрытие путей** (Path coverage). Проверяет каждый линейно независимый путь в программе, что означает, что число тестовых примеров будет эквивалентно цикломатической сложности программы. Для кода модулей без циклов количество путей, как правило, достаточно мало, поэтому на самом деле можно построить тест-кейсы для каждого пути. Для модулей с циклами количество путей может быть огромным, что представляет неразрешимую проблему тестирования.\n\nПуть на самом деле является направлением, потоком выполнения, который следует за последовательностью инструкций. Он охватывает функцию от входа до точки выхода. Он охватывает statement, branch/decision coverage. Покрытие пути можно понять в следующих терминах:\n\n* **Loop coverage**: используется для проверки того, что все циклы были выполнены и сколько раз они были выполнены. Цель этого метода покрытия - убедиться, что циклы соответствуют предписанным условиям и не повторяются бесконечно и не завершаются ненормально. Цикл тестирования направлен на мониторинг от начала до конца цикла. Ценным аспектом этой метрики является определение того, выполняются ли циклы while и for более одного раза, т.к. эта информация не сообщается другими метриками;\n* **Function coverage**: показывает, вызывали ли вы каждую функцию или процедуру;\n* **Call coverage**: показывает, выполняли ли вы каждый вызов функции. Гипотеза состоит в том, что ошибки обычно возникают в интерфейсах между модулями (вызывающая функция и вызываемая функция). Также известен как покрытие пары вызовов (call pair coverage);\n\n7 вышеперечисленных уровней описываются в книге Копленда “A Practitioner's Guide to Software Test Design”, но можно найти и другие\n\n**FSM coverage (Finite State Machine Coverage)**\n\nКонечные автоматы (FSM) имеют конечное число состояний, условий, которые приводят к внутренним переходам между состояниями, и соответствующее поведение ПО в каждом состоянии автомата. Автомат обычно моделирует поведение управляющей логики.\n\nПокрытие FSM - покрытие конечного автомата, безусловно, является наиболее сложным методом покрытия кода. В этом методе покрытия вам нужно посмотреть, как много было переходов/посещений определенных по времени состояний (time-specific states). Оно также проверяет, сколько последовательностей включено в конечный автомат. Конечные автоматы могут иметь множество ветвей и несколько функциональных путей, а также любой скрытый путь (функциональный путь, пропущенный при проверке, или путь, непреднамеренно введенный на этапе реализации) в дизайне может вызвать серьезное нарушение функциональности, а также может создать тупик (система не может самостоятельно выйти из определенного состояния, даже если намеченный стимул присутствует).\n\n**Basis Path testing**\n\nЦель тестирования базового пути - в отличии от D-D Path (Decision-to-decision path) получить полное покрытие тех путей, которые находятся между точками принятия решений (decisions points) с высоким бизнес-риском и высокой бизнес-ценностью, т.к. проверять все возможные пути обходится слишком дорого. Это гибрид branch testing и path testing\n\n**LCSAJ coverage**\n\n_LCSAJ (LCSAJ): Последовательность линейного кода с переходами, состоящая из трех элементов (условно определяемая номерами строк исходного кода):_\n\n* _начало линейной последовательности выполняемых операторов_\n* _конец линейной последовательности_\n* _целевая строка кода, получающая управление после конца линейной последовательности_\n\n_(ISTQB)_\n\nLCSAJ (linear code sequence and jump) «линейная последовательность кода и переход». Каждый LCSAJ представляет собой сегмент кода, который выполняется последовательно от начальной точки до конечной точки, а затем прерывает последовательный поток для передачи потока управления. Каждая строка кода имеет плотность (density), то есть количество раз, когда номер строки появляется в LCSAJ.\n\nОдин LCSAJ состоит из трех компонентов:\n\n* Начало сегмента, который может быть ветвью или началом программы;\n* Конец сегмента, который может быть концом ветви или концом программы;\n* Конкретная целевая линия;\n\nЕго основное применение при динамическом анализе программного обеспечения, чтобы помочь ответить на вопрос «Сколько тестирования достаточно?». Динамический анализ программного обеспечения используются для измерения качества и эффективности тестовых данных программного обеспечения, где количественное определение выполняются в терминах структурных единиц кода при тестировании. В более узком смысле, LCSAJ является хорошо определенным линейным участком кода программы. При использовании в этом смысле, LCSAJ также называют JJ-путь (jump-to-jump path). 100% LCSAJ означает 100% Statement Coverage, 100% Branch Coverage, 100% procedure или Function call Coverage, 100% Multiple condition Coverage (в ISTQB говорится только о 100% Decision coverage).\n\nОпределенные метрики используются для проверки покрытия кода. Эти показатели могут помочь нам определить, достаточно ли тестирования или нет. Эти показатели называются коэффициентом эффективности тестирования (TER - Test Effectiveness Ratio):\n\n* TER-1: количество операторов, выполненных с помощью тестовых данных, деленное на общее количество операторов;\n* TER-2: количество ветвей потока управления, выполненных тестовыми данными, деленное на общее количество ветвей потока управления;\n* TER-3: количество LCSAJ, выполненных тестовыми данными, деленное на общее количество LCSAJ;\n\nИсследователи ссылаются на коэффициент покрытия путей длиной n LCSAJ как на коэффициент эффективности теста (TER) n + 2.\n\n### Data Flow Testing\n\nТестирование потока данных - это еще один набор методов / стратегий белого ящика, который связан с анализом потока управления, но с точки зрения жизненного цикла переменной. Переменные определяются, используются и уничтожаются, когда в них больше нет необходимости. Аномалии в этом процессе, такие как использование переменной без ее определения или после ее уничтожения, могут привести к ошибке. Рапс и Вьюкер, популяризаторы данного метода, писали: \"Мы уверены, что, как нельзя чувствовать себя уверенным в программе без выполнения каждого ее оператора в рамках какого-то тестирования, так же не следует быть уверенным в программе без видения результатов использования значений, полученных от любого и каждого из вычислений\".\n\nКогда «поток данных» через информационную систему представлен графически, он известен как диаграмма потока данных (Data Flow Diagram). Она также используется для визуализации обработки данных. Но не нужно путать это с графом потока данных (Data Flow Graph), который используется в Data Flow Testing. Граф потока данных похож на граф потока управления тем, что показывает поток обработки через модуль. Дополнительно к этому, он детализирует определение, использование и уничтожение каждой из переменных модуля. Мы построим эти диаграммы и убедимся, что шаблоны определение-использование-уничтожение являются подходящими. Сначала мы проведем статический анализ. Под \"статическим\" мы имеем в виду, что мы исследуем диаграмму (формально через проверки или неформально беглыми просмотрами). Потом мы проведем динамические тесты модуля. Под \"динамическими\" мы понимаем, что мы создаем и исполняем тестовые сценарии.\n\nТак как тестирование потока данных основано на потоке управления модуля, то, предположительно, поток управления в основном верный. Процесс тестирования потока данных сводится к выбору достаточного количества тестов, таких как:\n\n* каждое \"определение\" прослеживается для каждого его \"использования\";\n* каждое \"использование\" прослеживается из соответствующего ему \"определения\";\n\nЧтобы сделать это, перечислим маршруты в модуле. Порядок выполнения такой же, как и в случае с тестированием потока управления: начинаем с точки входа в модуль, строим самый левый маршрут через весь модуль и заканчиваем на выходе из него. Возвращаемся в начало и идём по другому направлению в первом разветвлении. Прокладываем этот путь до конца. Возвращаемся в начало и идём по другому направлению во втором разветвлении, потом в третьем и т.д., пока не пройдем все возможные пути. Затем создадим хотя бы один тест для каждой переменной, чтобы покрыть каждую пару определение-использование.\n\nСуществуют условные обозначения, которые могут помочь в описании последовательных во времени пар в жизненном цикле переменной:\n\n* \\~ - переменная еще не существует или предыдущий этап был последним\n* d - определено, создано, инициализировано\n* k - не определено, убито\n* u - используется (c - использование вычислений; p - использование предикатов)\n\nТаким образом, \\~ d, du, kd, ud, uk, uu, k \\~, u \\~ являются вполне допустимыми комбинациями, когда \\~ u, \\~ k, dd, dk, kk, ku, d \\~ являются аномалиями, потенциальными или явными ошибками. В настоящее время практически все они эффективно обнаруживаются компиляторами или, по крайней мере, IDE, и нам редко требуется выполнять статический анализ для обнаружения этих аномалий. То же самое относится и к динамическому анализу, который сфокусирован на исследовании / выполнении du пар - современные языки программирования снижают вероятность возникновения проблем, связанных с du. Так что в настоящее время такая проверка в основном не стоит усилий.\n\n\n## Dynamic - Black box\n\n_Разработка тестов методом черного ящика (black box test design technique): Процедура создания и/или выбора тестовых сценариев, основанная на анализе функциональной или нефункциональной спецификации компонента или системы без знания внутренней структуры. (ISTQB)_\n\n_Основанные на спецификации методы проектирования тестирования используются для получения контрольных примеров из базиса тестирования, определяющего ожидаемое поведение элемента тестирования. При использовании этих методов входные данные для тестирования контрольного примера и ожидаемый результат получаются из базиса тестирования. Выбор, какие из основанных на спецификации методов проектирования тестирования использовать в каждой конкретной ситуации, зависит от природы базиса тестирования и/или элемента тестирования, и от присущих рисков. (ГОСТ 56920)_\n\nВсе specification-based или Black Box testing techniques могут быть удобно описаны и систематизированы с помощью следующей таблицы:\n\n| **Группа**                                                                                                                                                                                                                                                                                                                                  | **Техника**                                                                                                                                                         | **Когда используется**                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| <p>Элементарные техники:</p><ul><li>сосредоточены на анализе входных / выходных параметров;</li><li>можно комбинировать для лучшего покрытия;</li><li>обычно не используют и не зависят от других методик;</li></ul>                                                                                                                        | Equivalence Partitioning                                                                                                                                            | Входные и выходные параметры имеют большое количество возможных значений                                                                                       |\n| Boundary Value Analysis                                                                                                                                                                                                                                                                                                                     | Значения параметров имеют явные (например, четко определенные в документации) границы и диапазоны или неявные (например, известные технические ограничения) границы |                                                                                                                                                                |\n| <p>Комбинаторные стратегии:</p><ul><li>объединяют возможные значения нескольких параметров ввода / вывода;</li><li>могут использовать элементарные приемы для уменьшения количества возможных значений;</li></ul>                                                                                                                           | All Combinations                                                                                                                                                    | Количество возможных комбинаций входных значений достаточно мало, или каждая отдельная комбинация входных значений приводит к определенному выходному значению |\n| Pairwise Testing                                                                                                                                                                                                                                                                                                                            | Количество входных комбинаций чрезвычайно велико и должно быть сокращено до приемлемого набора кейсов                                                               |                                                                                                                                                                |\n| Each Choice Testing                                                                                                                                                                                                                                                                                                                         | У вас есть функции, при которых скорее конкретное значение параметра вызывает ошибку, нежели комбинация значений                                                    |                                                                                                                                                                |\n| Base Choice Testing                                                                                                                                                                                                                                                                                                                         | Вы можете выделить набор значений параметров, который имеет наибольшую вероятность использования                                                                    |                                                                                                                                                                |\n| <p>Продвинутые техники:</p><ul><li>помогают проанализировать Систему с точки зрения бизнес-логики, иерархических отношений, сценариев и т. д.;</li><li>анализ основан на данных, организованных в таблицы, диаграммы и шаблоны;</li><li>может полагаться на элементарные и комбинаторные методы для разработки тестовых примеров;</li></ul> | Decision Table Testing                                                                                                                                              | Существует набор комбинаций параметров и их выходных данных, описываемых бизнес-логикой или другими правилами                                                  |\n| Classification Tree Method                                                                                                                                                                                                                                                                                                                  | У вас есть иерархически структурированные данные, или данные могут быть представлены в виде иерархического дерева                                                   |                                                                                                                                                                |\n| State Transition Testing                                                                                                                                                                                                                                                                                                                    | В функциональности есть очевидные состояния, переходы которых регулируются правилами (например, потоки)                                                             |                                                                                                                                                                |\n| Cause-Effect Graphing                                                                                                                                                                                                                                                                                                                       | Причины (входы) и следствия (выходы) связаны большим количеством сложных логических зависимостей                                                                    |                                                                                                                                                                |\n| Scenario Testing                                                                                                                                                                                                                                                                                                                            | В функционале есть четкие сценарии                                                                                                                                  |                                                                                                                                                                |\n| Другие техники                                                                                                                                                                                                                                                                                                                              | Random Testing                                                                                                                                                      | Вам необходимо имитировать непредсказуемость реальных вводных данных, или функциональность имеет несистематические дефекты                                     |\n| Syntax Testing                                                                                                                                                                                                                                                                                                                              | Функциональность имеет сложный синтаксический формат для входных данных (например, коды, сложные имена электронной почты и т. д.)                                   |                                                                                                                                                                |\n\n### Эквивалентное разделение (Equivalence Partitioning (ISTQB/Myers 1979) / Equivalence Class Testing (Lee Copeland))\n\nКласс эквивалентности представляет собой набор данных, которые либо одинаково обрабатываются модулем, либо их обработка выдает одинаковые результаты. При тестировании любое значение данных, входящее в класс эквивалентности, аналогично любому иному значению класса.\n\nЭквивалентное разделение - это разделение всего набора данных ввода / вывода на такие разделы. Таким образом, вам не нужно выполнять тесты для каждого элемента подмножества, и достаточно одной проверки, чтобы охватить все подмножество. Хитрость заключается в том, чтобы увидеть и идентифицировать разделы, т.к. далеко не всегда они представляют собой числа.\n\nПример: Мы пишем модуль для системы отдела кадров, который определяет, в каком порядке нужно рассматривать заявления о приеме на работу в зависимости от возраста кандидата.\n\nПравила нашей организации таковы:\n\n* от 0 до 16​ - не принимаются;\n* от 16 до 18​ - могут быть приняты только на неполный рабочий день;\n* от 18 до 55​ - могут быть приняты как сотрудники на полный рабочий день;\n* от 55 до 99​ - не принимаются;\n\nЧто в коде выглядит как:\n\n* If (applicantAge >= 0 && applicantAge <=16)\n  * hireStatus=\"NO\";\n* If (applicantAge >= 16 && applicantAge <=18)\n  * hireStatus=\"PART\";\n* If (applicantAge >= 18 && applicantAge <=55)\n  * hireStatus=\"FULL\";\n* If (applicantAge >= 55 && applicantAge <=90)\n  * hireStatus=\"NO\";\n\nИз чего очевидно, что вместо 100 кейсов нам понадобится 4 по числу эквивалентных классов, все остальные кейсы внутри своих классов будут давать одинаковый результат тестов и являются избыточными.\n\nТеперь мы готовы начать тестирование? Вероятно, нет. Что насчет таких входных данных как 969, -42, FRED или &$#! ? Должны ли мы создавать тестовые сценарии для некорректных входных данных? Для того, чтобы понять ответ, мы должны проверить подход, который пришел из объектно-ориентированного мира, названный \"проектирование-по-контракту\".\n\nВ подходе \"проектирование-по-контракту\" модули (в парадигме объектно-ориентированного программирования они называются \"методами\", но \"модуль\" является более общим термином) определены в терминах предусловий и постусловий. Постусловия определяют, что модуль обещает сделать (вычислить значение, открыть файл, напечатать отчет, обновить запись в базе данных, изменить состояние системы и т.д.). Предусловия описывают требования к модулю, при которых он переходит в состояние, описываемое постусловиями.\n\nНапример, если у нас есть модуль \"openFile\", что он обещает сделать? Открыть файл. Какие будут разумные предусловия для этого модуля?\n\n* файл должен существовать,\n* мы должны предоставить имя (или другую идентифицирующую информацию),\n* файл должен быть \"открываемым\", т.е. он не может быть открытым в другом процессе,\n* у нас должны быть права доступа к файлу и т.д.\n\nПредусловия и постусловия основывают контракт между модулем и всеми, кто его вызывает. Тестирование-по-контракту основывается на философии проектирования-по-контракту. При использовании данного подхода мы создаем только те тест-кейсы, которые удовлетворяют нашим предусловиям. Например, мы не будем тестировать модуль \"openFile\", если файл не существует. Причина проста. Если файл не существует, то openFile не обещает работать. Если не существует требования работоспособности в определенных условиях, то нет необходимости проводить тестирование в этих условиях.\n\nВ этот момент тестировщики обычно возражают. Да, они согласны, что модуль не претендует на работу в этом случае, но что делать, если предусловия нарушаются в процессе разработки? Что делать системе? Должны ли мы получить сообщение об ошибке на экране или дымящуюся воронку на месте нашей компании? Другим подходом к проектированию является оборонительное проектирование. В этом случае модуль предназначен для приема любого входного значения. Если выполнены обычные предусловия, то модуль достигнет своих обычных постусловий. Если обычные предварительные условия не выполняются, то модуль сообщит вызывающему, возвратив код ошибки или бросив исключение (в зависимости от используемого языка программирования). На самом деле, это уведомление является еще одним из постусловий модуля.\n\nНа основе этого подхода мы могли бы определить оборонительное тестирование: подход, который анализирует как обычные, так и необычные предварительные условия.\n\nНужно ли нам делать проверку с такими входными значениями, как -42, FRED и &$#! @? Если мы используем проектирование-по-контракту и тестирование-по-контракту, то ответ \"Нет\". Если мы используем оборонительное проектирование и, поэтому, оборонительное тестирование, то ответ \"Да\". Спросите ваших проектировщиков, какой подход они используют. Если их ответом будет «контрактный» либо «оборонительный», то вы знаете, какой стиль тестирования использовать. Если они ответят \"Хм?\", то это значит, что они не думают о том, как взаимодействуют модули. Они не думают о предусловиях и постусловиях контрактов. Вам стоит ожидать, что интеграционное тестирование будет главным источником дефектов, будет более сложным и потребует больше времени, чем ожидалось.\n\nНесмотря на то, что тестирование классов эквивалентности полезно, его величайшим вкладом является то, что оно приводит нас к тестированию граничных значений.\n\n### Анализ граничных значений (BVA - Boundary Value Analysis (Myers 1979)/range checking)\n\nТестирование классов эквивалентности - это самая основная методика тест-дизайна. Она помогает тестировщикам выбрать небольшое подмножество из всех возможных тестовых сценариев и при этом обеспечить приемлемое покрытие. У этой техники есть еще один плюс. Она приводит к идее о тестировании граничных значений - второй ключевой технике тест-дизайна.\n\nПример. Выше описывались правила, которые указывали, каким образом будет происходить обработка заявок на вакансии в зависимости от возраста соискателя.\n\nОбратите внимание на проблемы на границах - это \"края\" каждого класса. Возраст \"16\" входит в два различных класса эквивалентности (как и \"18\", и \"55\"). Первое правило гласит не нанимать шестнадцатилетних. Второе правило гласит, что шестнадцатилетние могут быть наняты на неполный рабочий день Тестирование граничных значений фокусируется на границах именно потому, что там спрятано очень много дефектов. Опытные тестировщики сталкивались с этой ситуацией много раз. У неопытных тестировщиков может появиться интуитивное ощущение, что ошибки будут возникать чаще всего на границах. Эти дефекты могут быть в требованиях, или в коде, если программист ошибется с указанием границ в коде (включительно/не включительно, индекс +-1).\n\nПопробуем исправить приведенный выше пример:\n\n* от 0 до 15​ - не принимаются;\n* от 16 до 17​ - могут быть приняты только на неполный рабочий день;\n* от 18 до 54​ - могут быть приняты как сотрудники на полный рабочий день;\n* от 55 до 99​ - не принимаются;\n\nА что насчет возраста -3 и 101? Обратите внимание, что требования не указывают, как должны быть рассмотрены эти значения. Мы можем догадаться, но \"угадывание требований\" не является приемлемой практикой. Следующий код реализует исправленные правила:\n\n* if (applicantAge >= 0 && applicantAge <= 15)\n  * hireStatus = \"NO\";\n* if (applicantAge >= 16 && applicantAge <= 17)\n  * hireStatus = \"PART\";\n* if (applicantAge >= 18 && applicantAge <= 54)\n  * hireStatus = \"FULL\";\n* if (applicantAge >= 55 && applicantAge <= 99)\n  * hireStatus = \"NO\";\n\nВ этом примере интересными значениями на границах или вблизи них являются {-1, 0, 1}, {15, 16, 17}, {17, 18, 19}, {54, 55, 56} и {98, 99, 100}. Другие значения, например {-42, 1001, FRED, %$#@} могут быть включены в зависимости от предусловий документации модуля.\n\nДля создания тест-кейсов для каждого граничного значения определите классы эквивалентности, выберите одну точку на границе, одну точку чуть ниже границы и одну точку чуть выше границы. Стоит отметить, что точка чуть выше границы может входить в другой класс эквивалентности. В таком случае не нужно дублировать тест. То же самое может быть верно по отношению точки чуть ниже границы.\n\nТестирование граничных значений является наиболее подходящим там, где входные данные являются непрерывным диапазоном значений.\n\n### Тестирование таблиц решений (Decision Table testing)\n\nЭтот простой, но эффективный метод заключается в документировании бизнес-логики в таблице как наборы правил, условий выполнения действий и самих действий. Тестирование таблиц принятия решений может быть использовано, когда система должна реализовывать сложные бизнес-правила, когда эти правила могут быть представлены в виде комбинации условий и когда эти условия имеют дискретные действия, связанные с ними.\n\nПример. Компания по автострахованию дает скидку водителям, которые состоят в браке и/или хорошо учатся.\n\n| -                | **Правило 1** | **Правило 2** | **Правило 3** | **Правило 4** |\n| ---------------- | ------------- | ------------- | ------------- | ------------- |\n| **Условия**      | -             | -             | -             | -             |\n| Состоит в браке? | Да            | Да            | Нет           | Нет           |\n| Хороший студент? | Да            | Нет           | Да            | Нет           |\n| -                | -             | -             | -             | -             |\n| **Действия**     | -             | -             | -             | -             |\n| Скидка ($)       | 60            | 25            | 50            | 0             |\n\nэта таблица содержит все комбинации условий. Задав два бинарных условия (\"да\" или \"нет\"), возможные комбинации будут: (\"да\", \"да\"), (\"да\", \"нет\"), (\"нет\", \"да\") и (\"нет\", \"нет\"). Каждое правило представляет собой одну из этих комбинаций. Нам, тестировщикам, нужно будет проверить, что определяются все комбинации условий. Пропущенное сочетание может привести к разработке такой системы, которая не сможет правильно обработать определенный набор исходных данных. Каждое правило является причиной \"запуска\" действия. Каждое правило может задать действие, уникальное для этого правила, или правила могут иметь общие действия. Для каждого правила с помощью таблицы решений можно указать более одного действия. Опять же, эти правила могут быть уникальными или быть общими. В такой ситуации выбрать тесты просто - каждое правило (вертикальная колонка) становится тест-кейсом. Условия указывают на входные значения, а действия - на ожидаемые результаты.\n\nЕсли тестируемая система имеет сложные бизнес-правила, а у ваших бизнес-аналитиков или проектировщиков нет документации этих правил, то тестировщикам следует собрать эту информацию и представить ее в виде таблицы решений. Причина проста: представляя поведение системы в такой полной и компактной форме, тест-кейсы могут быть созданы непосредственно из таблицы решений. При тестировании для каждого правила создается как минимум один тест-кейс. Если состояния этого правила бинарные, то должно быть достаточно одного теста для каждого сочетания. С другой стороны, если состояние является диапазоном значений, то тестирование должно учитывать и нижнюю, и высшую границы диапазона. Таким образом мы объединяем идею тестирования граничных значений с тестированием таблиц решений.\n\nЧтобы создать тестовую таблицу, просто измените заголовки строк и столбцов: правила станут тест-кейсами, условия входными значениями, а действия ожидаемыми результатами.\n\n### Комбинаторные техники тест-дизайна (Combination Strategies)\n\n_Комбинаторное тестирование (combinatorial testing): Метод, позволяющий выделить подходящую подгруппу тестовых комбинаций с целью добиться предопределенного уровня покрытия при тестировании объекта с множественными параметрами в случаях, когда эти параметры сами по себе состоят из нескольких значений, что приводит к появлению большего числа комбинаций, чем можно успеть протестировать за отведенное время. См. также метод дерева классификации, попарное тестирование, n-мерное (переборное) тестирование, тестирование с использованием ортогонального массива. (ISTQB)_\n\nТестовые примеры выбираются на основе некоторого понятия покрытия, и цель стратегии комбинирования состоит в том, чтобы выбрать тестовые примеры из набора тестов таким образом, чтобы было достигнуто 100% покрытие.\n\n* 1-wise coverage (each-used) - это самый простой критерий покрытия. Для 100% each-used покрытия требуется, чтобы каждое значение каждого параметра было включено хотя бы в один тестовый пример в наборе тестов.\n* 2-wise (pair-wise) coverage требует, чтобы каждая возможная пара значений любых двух параметров была включена в некоторый тестовый пример. Обратите внимание, что один и тот же тестовый пример часто охватывает более одной уникальной пары значений.\n* Естественным продолжением 2-wise coverage является t-wise coverage, которое требует включения всех возможных комбинаций интересных значений параметров t в какой-либо тестовый пример в наборе тестов.\n* Самый тщательный критерий покрытия, N-wise coverage, требует набора тестов, который содержит все возможные комбинации значений параметров в input parameter model (IPM).\n\n**Все комбинации** (All combinations): как видно из названия, этот алгоритм подразумевает генерацию всех возможных комбинаций. Это означает исчерпывающее тестирование и имеет смысл только при разумном количестве комбинаций. Например, 3 переменные с 3 значениями для каждой дают нам матрицу параметров 3х3 с 27 возможными комбинациями.\n\n**Тестирование каждого выбора** (EC - Each choice testing): эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример (Ammann & Offutt, 1994). Это также определение 1-wise coverage.\n\n**Тестирование базового выбора** (BC - Base choice testing): алгоритм стратегии комбинирования базового выбора начинается с определения одного базового тестового примера. Базовый тестовый пример может быть определен по любому критерию, включая простейший, наименьший или первый. Критерий, предложенный Амманном и Оффуттом (Ammann & Offutt, 1994), - это «наиболее вероятное значение» с точки зрения конечного пользователя. Это значение может быть определено тестировщиком или основано на рабочем профиле, если таковой существует. Из базового тестового примера создаются новые тестовые примеры, изменяя интересующие значения одного параметра за раз, сохраняя значения других параметров фиксированными в базовом тестовом примере. Базовый выбор включает каждое значение каждого параметра по крайней мере в одном тестовом примере, поэтому он удовлетворяет 1-wise coverage.\n\n### Попарное тестирование** (Pairwise testing)\n\nPairwise testing - техника тест-дизайна, а именно метод обнаружения дефектов с использованием комбинационного метода из двух тестовых случаев. Он основан на наблюдениях о том, что большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как правило менее критичны). Следовательно, выбирается пара двух тестовых параметров, и все возможные пары этих двух параметров отправляются в качестве входных параметров для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование. Захватывающей надеждой попарного тестирования является то, что путем создания и запуска 1-20% тестов вы найдете 70-85% от общего объема дефектов.\n\nПример: По ТЗ сайт должен работать в 8 браузерах, используя различные плагины, запускаться на различных клиентских операционных системах, получать страницы от разных веб-серверов, работать с различными серверными, операционными системами. Итого:\n\n* 8 браузеров;\n* 3 плагина;\n* 6 клиентских операционных систем;\n* 3 сервера;\n* 3 серверных операционных системы;\n\n\\= 1296 комбинаций. Количество комбинаций настолько велико, что, скорее всего, у нас не хватит ресурсов, чтобы спроектировать и пройти тест-кейсы. Не следует пытаться проверить все комбинации значений для всех переменных, а нужно проверять комбинации пар значений переменных.\n\nИспользование всех пар для создания тест-кейсов основывается на двух техниках:\n\n* ортогональные массивы (OA - Orthogonal Array): это двумерный массив символов. На примере выше мы составляем таблицу, где столбцы представляют собой переменные (браузер, плагин, клиентская операционная система, веб-сервер и серверная операционная система, а строки - значения каждой переменной (Chrome/Opera, Windows 8/10/11 и т.п.). После чего нужно определить ортогональный массив, у которого будет столбец для каждой переменной (каждый столбец ортогонального массива имеет столько же вариантов значений, сколько имеет ваша переменная). Используя ортогональный массив для примера выше, все пары всех значений всех переменных могут быть покрыты всего лишь 64-мя тестами.\n* алгоритм Allpairs​: генерирует пары непосредственно, не прибегая к таким к ортогональным массивам. \"Несбалансированный\" характер алгоритма выбора всех пар требует только 48 тестов для примера. Следует отметить, что комбинации, выбранные методом ортогонального массива, могут быть не такими же, как те, которые выбраны Allpairs. Но это не важно. Важно лишь то, чтобы были выбраны все парные комбинации параметров. Это будут комбинации, которые мы хотим проверить.\n\nПодробнее с разбором примера см. у Копленда в главе 6.\n\nНа практике же вручную эти массивы никто не формирует, всю механику реализуют автоматизированные инструменты, самый популярный из них PICT. Тестировщику остается лишь подготовить и скормить данные.\n\n### Classification tree method\n\n_Метод дерева классификации (classification tree method): Разработка тестов методом черного ящика, в которой тестовые сценарии, описанные средствами дерева классификации, разрабатываются для проверки комбинаций выборок входных и/или выходных подмножеств. (Grochtmann) См. также комбинаторное тестирование._\n\nДерево классификации (Classification tree): структура, показывающее иерархически упорядоченные классы эквивалентности, которое используется для разработки тестовых примеров в методе дерева классификации (Classification tree method). Не путать с [Decision tree](https://en.wikipedia.org/wiki/Decision\\_tree).\n\nМетод дерева классификации: вид комбинаторной техники, в которой тестовые примеры, описанные с помощью дерева классификации, предназначены для выполнения комбинаций представителей входных и / или выходных доменов.\n\n![https://aneejian.com/assets/images/Classification-Tree-Database-System.png](https://aneejian.com/assets/images/Classification-Tree-Database-System.png)\n\nЧтобы рассчитать количество тестовых примеров, нам необходимо проанализировать требования, определить соответствующие тестовые функции (классификации) и их соответствующие значения (классы).\n\nОбычно для создания Classification tree используется инструмент Classification Tree Editor. Если же взять лист бумаги и ручку, то у нас есть тестовый объект (целое приложение, определенная функция, абстрактная идея и т. д.) вверху как корень. Мы рисуем ответвления от корня как классификации (проверяем соответствующие аспекты, которые мы определили). Затем, используя классы эквивалентности и анализ граничных значений, мы определяем наши листья как классы из диапазона всех возможных значений для конкретной классификации. И если некоторые из классов могут быть классифицированы далее, мы рисуем под-ветку / классификацию с собственными листьями / классами. Когда наше дерево завершено, мы делаем проекции листьев на горизонтальной линии (Test case), используя одну из комбинаторных стратегий (all combinations, each choice и т. д.), и создаем все необходимые комбинации.\n\nМаксимальное количество тестовых примеров - это декартово произведение всех классов всех классификаций в дереве, быстро приводящее к большим числам для реалистичных тестовых задач. Минимальное количество тестовых примеров - это количество классов в классификации с наиболее содержащимися классами. На втором этапе тестовые примеры составляются путем выбора ровно одного класса из каждой классификации дерева классификации.\n\n### Тестирование переходов между состояниями (State Transition testing)\n\n_Таблица состояний (state table): Таблица, показывающая конечные переходы для каждого состояния вследствие каждого возможного события, как для корректных, так и для некорректных переходов. (ISTQB)_\n\nТестирование переходов между состояниями определяется как метод тестирования ПО, при котором изменения входных условий вызывают изменения состояния в тестируемом приложении (AUT). В этом методе тестировщик предоставляет как положительные, так и негативные входные значения теста и записывает поведение системы. Это модель, на которой основаны система и тесты. Любая система, в которой вы получаете разные выходные данные для одного и того же ввода, в зависимости от того, что произошло раньше, является системой конечных состояний. Техника тестирования переходов между состояниями полезна, когда вам нужно протестировать различные системные переходы. Этот подход лучше всего подходит там, где есть возможность рассматривать всю систему как конечный автомат. Для наглядности возьмем классический пример покупки авиабилетов:\n\n![https://quality-lab.ru/wp-content/uploads/2017/02/unnamed-file.jpg](https://quality-lab.ru/wp-content/uploads/2017/02/unnamed-file.jpg)\n\n* Состояние (state, представленное в виде круга на диаграмме) - это состояние приложения, в котором оно ожидает одно или более событий. Состояние помнит входные данные, полученные до этого, и показывает, как приложение будет реагировать на полученные события. События могут вызывать смену состояния и/или инициировать действия;\n* Переход (transition, представлено в виде стрелки на диаграмме) - это преобразование одного состояния в другое, происходящее по событию;\n* Событие (event, представленное ярлыком над стрелкой) - это что-то, что заставляет приложение поменять свое состояние. События могут поступать извне приложения, через интерфейс самого приложения. Само приложение также может генерировать события (например, событие «истек таймер»). Когда происходит событие, приложение может поменять (или не поменять) состояние и выполнить (или не выполнить) действие. События могут иметь параметры (например, событие «Оплата» может иметь параметры «Наличные деньги», «Чек», «Приходная карта» или «Кредитная карта»);\n* Действие (action, представлено после «/» в ярлыке над переходом) инициируется сменой состояния («напечатать билет», «показать на экране» и др.). Обычно действия создают что-то, что является выходными/возвращаемыми данными системы. Действия возникают при переходах, сами по себе состояния пассивны;\n* Точка входа обозначается черным кружком;\n* Точка выхода показывается на диаграмме в виде мишени;\n\nВсе начинается с точки входа. Мы (клиенты) предоставляем авиакомпании информацию для бронирования. Служащий авиакомпании является интерфейсом между нами и системой бронирования авиабилетов. Он использует предоставленную нами информацию для создания бронирования. После этого наше бронирование находится в состоянии «Создано». После создания бронирования система также запускает таймер. Если время таймера истекает, а забронированный билет еще не оплачен, то система автоматически снимает бронь.\n\nКаждое действие, выполненное над билетом, и соответствующее состояние (отмена бронирования пользователем, оплата билета, получение билета на руки, и т. д.) отображаются в блок-схеме.\n\nНа основании полученной схемы составляется набор тестов.\n\nОпределим четыре разных уровня покрытия:\n\n1. Набор тестов, в котором все состояния​ будут посещены как минимум один раз. Этому требованию удовлетворяет набор из трех тестов, показанный ниже. Обычно это низкий уровень тестового покрытия.\n2. Набор тестов, в котором все события​ выполнятся как минимум один раз. Следует отметить, что тест-кейсы, которые покрывают каждое событие, могут быть точно теми же, которые покрывают каждое состояние. Опять же, это низкий уровень покрытия.\n3. Набор тестов, в котором все пути​ будут пройдены как минимум один раз. Несмотря на то, что этот уровень является наиболее предпочтительным из-за его уровня покрытия, это может быть неосуществимо. Если диаграмма состояний и переходов содержит петли, то количество возможных путей может быть бесконечным.\n4. Набор тестов, в котором все переходы​ будут осуществлены как минимум один раз. Этот уровень тестирования обеспечивает хороший уровень покрытия без порождения большого количества тестов. Этот уровень, как правило, один из рекомендованных.\n\nДиаграмма состояний и переходов - не единственный способ документирования поведения системы. Диаграммы, возможно, легче в понимании, но таблицы состояний и переходов могут быть проще в использовании на постоянной и временной основе. Таблицы состояний и переходов состоят из четырех столбцов - \"Текущее состояние​\", \"Событие​\", \"Действие\"​ и \"Следующее состояние\"​. Преимущество таблицы состояний и переходов в том, что в ней перечисляются все возможные комбинации состояний и переходов, а не только допустимые. При крайне необходимом тестировании систем с высокой степенью риска, например авиационной радиоэлектротехники или медицинских устройств, может потребоваться тестирование каждой пары состояние-переход, включая те, которые не являются допустимыми. Кроме того, создание таблицы состояний и переходов часто извлекает комбинации, которые не были определены, задокументированы или рассмотрены в требованиях. Очень полезно обнаружить эти дефекты до начала кодирования.\n\nИспользование таблицы состояний и переходов может помочь обнаружить дефекты в реализации, которые позволяют недопустимые пути из одного состояния в другое. Недостатком таких таблиц является то, что, когда количество состояний и событий возрастает, они очень быстро становятся огромными. Кроме того, в таблицах, как правило, большинство клеток пустые.\n\nПодробнее с разбором примера см. у Копленда в главе 7.\n\n### Domain testing\n\n_Анализ доменов (domain analysis): Методика разработки тестов, относящаяся к методу черного ящика, использующаяся для определения действенных и эффективных тестовых сценариев в случаях, когда множественные параметры могут или должны быть протестированы одновременно. Методика базируется и обобщает методы эквивалентного разбиения и анализа граничных значений/ (ISTQB)_\n\nВ главах по тестированию классов эквивалентности и граничных значений мы рассмотрели тестирование одиночных переменных, которые требовали оценки в указанных диапазонах. В этой главе мы рассмотрим тестирование нескольких переменных одновременно. Существуют две причины, по которым стоит обратить на это внимание:\n\n* у нас редко будет достаточно времени на создание тест-кейсов для каждой переменной в нашей системе. Их просто слишком много;\n* часто переменные взаимодействуют. Значение одной переменной ограничивает допустимые значения другой. В этом случае, если проверять переменные поодиночке, можно не обнаружить некоторые дефекты;\n\nDomain-тестирование​ - это техника, которая может применяться для определения эффективных и действенных тест-кейсов, когда несколько переменных (например, поля ввода) должны проверяться вместе - либо для эффективности, либо по причине их логического взаимодействия. Она использует и обобщает тестирование классов эквивалентности и граничных значений в n одномерных измерениях. Подобно этим техникам, мы ищем случаи, где граница была неверно определена или реализована. Несмотря на то, что эта техника лучше всего подходит для числовых значений, она может быть обобщена и на другие типы - boolean, string, enumeration и т.д.\n\nВ двухмерном измерении (с двумя взаимодействующими параметрами) могут возникнуть следующие дефекты:\n\n* сдвиг границы - граница, перемещённая вертикально или горизонтально;\n* направление границы - граница, повёрнутая под неправильным углом;\n* пропущенная граница;\n* лишняя граница\n\n![https://disk.yandex.ru/i/BspCpS91-UdJUw](https://lh4.googleusercontent.com/Q0kwVDWxN\\_6wbhcAEbxtNXlQm1sjQ\\_oBQDRPezEP3Dlz-ldlgAX02ai93tOLgAIi28rhUvJNnaCCWJgs7UYStLFPbeQAuyjlEDujShl60Wjkp7esyku4GlFDU67K6rVtcbCBb7p2)\n\nПодробнее с разбором примера см. у Копленда в главе 8.\n\n### Use case-based Testing\n\n_Сценарий использования системы (use case): Последовательность операций во взаимодействии актера и компонента или системы со значимым результатом, при которой актером может быть как пользователь, так и все, что может обмениваться информацией с системой. (ISTQB)_\n\nДо сих пор мы исследовали техники разработки тестовых сценариев для частей системы - входные переменные с их диапазонами и границами, бизнес-правила, представленные в виде таблиц решений, а также поведения системы, представленные с помощью диаграмм состояний и переходов. Теперь пришло время рассмотреть тестовые сценарии, которые используют системные функции с начала и до конца путем тестирования каждой из их индивидуальных операций.\n\nСегодня самым популярным подходом определения выполняемых системой операций является [диаграмма вариантов использования](https://habr.com/ru/post/566218/) (диаграмма прецедентов, Use case diagram). Как и таблицы решений и диаграммы состояний и переходов, диаграммы вариантов использования обычно создаются разработчиками для разработчиков. Но, как и другие техники, диаграммы вариантов использования содержат много полезной информации и для тестировщиков. Варианты использования были созданы Иваром Якобсоном и объяснены в его книге \"Объектно-ориентированная разработка программ: подход, основанный на вариантах использования\". Якобсон определил\n\nВариант использования (Use Case) - это сценарий, который описывает использование системы действующим лицом для достижения определенной цели (Ивар Якобсон - \"Объектно-ориентированная разработка программ: подход, основанный на вариантах использования\").\n\n* Действующее лицо (или актер) - это пользователь, играющий роль с уважением к системе, старающегося использовать систему для достижения чего-то важного внутри конкретного контекста. Действующими лицами в основном являются люди, хотя действующими лицами также могут выступать другие системы;\n* \"Сценарий\" - это последовательность шагов, которые описывают взаимодействия между актером и системой. Заметьте, что варианты использования определены с точки зрения пользователя, а не системы. Заметьте также, что операции, выполняемые внутри системы, хоть и важны, но не являются частью определения вариантов использования. Набор вариантов использования составляет функциональные требования системы.\n\nПрежде чем использовать сценарии для создания Test case, их необходимо подробно описать с помощью шаблона. Шаблоны могут варьироваться от проекта к проекту. Но среди таких обычных полей, как имя, цель, предварительные условия, актер (ы) и т. д., всегда есть основной успешный сценарий и так называемые расширения (плюс иногда подвариации). Расширения - это условия, которые влияют на основной сценарий успеха. А подвариации - это условия, которые не влияют на основной flow, но все же должны быть рассмотрены. После того, как шаблон заполнен данными, мы создаем конкретные Test case, используя методы эквивалентного разделения и граничных значений. Для минимального охвата нам нужен как минимум один тестовый сценарий для основного сценария успеха и как минимум один Test case для каждого расширения. Опять же, этот метод соответствует общей формуле «получите условия, которые меняют наш результат, и проверьте комбинации». Но способ получить это - проанализировать поведение Системы с помощью сценариев.\n\nПольза вариантов использования в том, что они:\n\n* позволяют выявить функциональные требования системы с точки зрения пользователя несмотря на техническую перспективу и независимо от того, какая парадигма разработки использовалась;\n* могут быть использованы для активного вовлечения пользователей в процесс сбора требований и определений;\n* предоставляют базис для идентификации ключевых компонентов системы, структур, баз данных и связей;\n* служат основанием для разработки тест-кейсов системы на приемочном уровне.\n\nПодробнее с разбором примера см. у Копленда в главе 8.\n\nКак создать хорошие сценарии (Сэм Канер):\n\n1. Напишите истории жизни для объектов в системе.\n2. Перечислите возможных пользователей, проанализируйте их интересы и цели.\n3. Подумайте об отрицательных пользователях: как они хотят злоупотреблять вашей системой?\n4. Перечислите «системные события». Как система справляется с ними?\n5. Перечислите «особые события». Какие приспособления система делает для них?\n6. Перечислите преимущества и создайте сквозные задачи, чтобы проверить их.\n7. Интервью пользователей об известных проблемах и сбоях старой системы.\n8. Работайте вместе с пользователями, чтобы увидеть, как они работают и что они делают.\n9. Читайте о том, что должны делать подобные системы.\n10. Изучите жалобы на предшественника этой системы или ее конкурентов.\n11. Создать фиктивный бизнес. Относитесь к нему как к реальному и обрабатывайте его данные.\n12. Попробуйте преобразовать реальные данные из конкурирующего или предшествующего приложения.\n\n### Cause/Effect, Cause-Effect (CE)\n\n_Таблица причинно-следственных решений (cause-effect decision table): См. таблица решений._\n\n_Таблица решений (decision table): Таблица, отражающая комбинации входных данных и/или причин с соответствующими выходными данными и/или действиям (следствиям), которая может быть использована для проектирования тестовых сценариев. (ISTQB)_\n\nТестовые примеры должны быть разработаны так, чтобы проявлять принципы, которые характеризуют взаимосвязь между входными и выходными данными компонента, где каждый принцип соответствует единственной возможной комбинации входных данных компонента, которые были выражены как логические значения. Для каждого тестового примера следует уточнить:\n\n* Логическое состояние для каждого эффекта;\n* Логическое состояние (истина или ложь) по любой причине;\n\nГраф причинно-следственных связей (Cause-Effect Graph) использует такую ​​модель логических взаимосвязей между причинами и следствиями для компонента. Каждая причина выражается как условие, которое может быть истинным, ложным на входе или комбинацией входных данных компонента. Каждый эффект выражается в виде логического выражения, представляющего результаты или комбинацию результатов для произошедшего компонента (?Every effect is expressed as a Boolean expression representing results, or a combination of results, for the component having occurred). Модель обычно представлена ​​как логический граф, связывающий производные логические выражения ввода и вывода с использованием логических операторов:\n\n* И (AND);\n* ИЛИ (OR);\n* Истина, если не все входные данные верны («не оба») ([NAND](https://en.wikipedia.org/wiki/NAND\\_gate));\n* Истина, когда ни один из входов не является истиной (\"ни один\") ([NOR](https://en.wikipedia.org/wiki/NOR\\_gate));\n* НЕ (NOT).\n\nCause-Effect Graph также известен как диаграмма Исикавы, поскольку он был изобретен Каору Исикава, или как диаграмма рыбьей кости из-за того, как он выглядит.\n\n![https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/cause\\_effect\\_graph.jpg](https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/cause\\_effect\\_graph.jpg)\n\nГраф причинно-следственных связей похож на Decision Table и также использует идею объединения условий. И иногда они описываются как один метод. Но если между условиями существует много логических зависимостей, может быть проще их визуализировать на cause-effect graph.\n\n### Syntax testing\n\n_Синтаксическое тестирование (syntax testing): Разработка тестов методом черного ящика, в которой тестовые сценарии строятся на основе области определения входящих и/или выходных значений. (ISTQB)_\n\nСинтаксическое тестирование используется для проверки формата и правильности входных данных в случаях символьных текстовых полей, проверки соответствия формату файла, схеме базы данных, протоколу и т.д., при этом данные могут быть формально описаны в технических или установленных и определенных обозначениях, таких как BNF ([Форма Бэкуса - Наура](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0\\_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0\\_%E2%80%94\\_%D0%9D%D0%B0%D1%83%D1%80%D0%B0)).\n\n![https://globalcdh.org/files/shell/regex-match-in-cli.png](https://globalcdh.org/files/shell/regex-match-in-cli.png)\n\nКак правило, синтаксические тесты автоматизированы, так как они предполагают создание большого количества кейсов. Синтаксис тестируется с использованием двух условий:\n\n* Валидные: Проверка нормального состояния с использованием покрывающего набора путей синтаксического графа для минимально необходимых требований (?Testing the normal condition using the covering set of paths of the syntax graph, for the minimum necessary requirements). Иными словами находим возможные варианты значений, допускаемые отдельными элементами определения BNF, а затем разрабатываем кейсы, чтобы просто охватить эти варианты;\n* Невалидные: Проверка мусорных условий (garbage condition)\\* с использованием недопустимого набора входных данных.\n\nПримечание \\*: Мусорные условия - это метод проверки устойчивости системы к неверным или грязным данным. Условие выполняется путем предоставления в систему грязных данных (недопустимых данных), которые не поддерживаются указанным форматом и грамматикой синтаксиса. Для создания таких данных мы определяем и применяем возможные мутации (например, отсутствующий элемент, нежелательный дополнительный элемент, недопустимое значение для элемента и т. д.) к отдельным элементам определения BNF. Затем мы разрабатываем наши кейсы, применяя мутации, которые могут давать отличительные результаты (случаи, которые приводят к действительным комбинациям, исключаются).\n\n### Check List Based Testing\n\nТестирование на основе контрольного списка (чеклиста) выполняется с использованием предварительно подготовленного опытными тестировщиками чеклиста, который продолжает обновляться с учетом любых новых дефектов, обнаруженных при выполнении контрольных примеров контрольного списка. При любых изменениях в продукте прогоняется быстрый чеклист, чтобы убедиться, что из-за изменений не возникло новых дефектов. Этот контрольный список не имеет отношения к пользовательским историям.\n\n### User Journey Test\n\nUser Journey test, как следует из названия, охватывает полное путешествие пользователя по системе. Он охватывает сквозные тесты, из-за которых процент покрытия тестами больше по сравнению с другими методами. Этот метод помогает уменьшить количество тестовых примеров, поскольку тестовые примеры являются исчерпывающими и охватывают большую часть функциональности в одном сценарии. Сценарии написаны для самого сложного путешествия. Тесты взаимодействия с пользователем не связаны с пользовательскими историями (user stories).\n\n### User Story Testing (Agile)\n\nПользовательская история - это краткое и простое описание требований клиентов или конечного пользователя. Пользовательские истории написаны владельцем продукта (Product owner), поскольку именно он получает от клиента информацию о продукте, который будет создан. Если пользовательская история большая, она разбивается на несколько более мелких историй. Истории пользователей записываются на учетных карточках и вывешиваются на стене для обсуждения. Обсуждая важные аспекты функции, выберите те, которые в дальнейшем используются в пользовательской истории. Приемочные испытания - это заключительный этап, на котором продукт принимает заказчик после того, как он соответствует всем критериям выхода. Критерии приемлемости определяются владельцем продукта, заказчик на поставку также может привлекать разработчиков, определяя то же самое.\n\n### Exhaustive testing\n\n_Исчерпывающее тестирование (exhaustive testing): Методика тестирования, в которой набор тестов включает в себя все комбинации входных данных и предусловий. (ISTQB)_\n\nИсчерпывающее тестирование (Exhaustive testing - ET) - это крайний случай. В пределах этой техники вы должны проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике применение этого метода почти всегда не представляется возможным, из-за огромного количества входных значений.\n\n## Dynamic - Experience based\n\n### Error Guessing\n\n_Предположение об ошибках (EG - error guessing): Метод проектирования тестов, когда опыт тестировщика используется для предугадывания того, какие дефекты могут быть в тестируемом компоненте или системе в результате сделанных ошибок, а также для разработки тестов специально для их выявления. (ISTQB)_\n\nПредугадывание ошибки (Error Guessing - EG). Это когда тест аналитик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы \"предугадать\" при каких входных условиях система может выдать ошибку. Например, спецификация говорит: \"пользователь должен ввести код\". Тест аналитик, будет думать: \"Что, если я не введу код?\", \"Что, если я введу неправильный код? \", и так далее. Это и есть предугадывание ошибки.\n\nНекоторые факторы использующиеся при Error Guessing:\n\n* Уроки, извлеченные из прошлых релизов;\n* Исторические знания;\n* Интуиция;\n* Тикеты с прода;\n* Review checklist;\n* Пользовательский интерфейс приложения;\n* Отчеты о рисках программного обеспечения;\n* Тип данных, используемых для тестирования;\n* Общие правила тестирования;\n* Результаты предыдущих тестов;\n* Знание об AUT (тестируемое приложение);\n\n### Исследовательское тестирование (Exploratory testing)\n\n_Исследовательское тестирование (exploratory testing): Неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых и улучшенных тестов. (Bach)_\n\n_Исследовательское тестирование (exploratory testing): Тестирование, основанное на опыте, при котором тестер спонтанно разрабатывает и выполняет тестирования на основе существующих соответствующих знаний тестера, предшествующих исследований элемента тестирования (включая и результаты предыдущих тестирований) и эвристических \"эмпирических правил\" для общего поведения программного обеспечения и типов отказа. Примечание - Исследовательское тестирование направлено на выявление скрытых свойств (включая и скрытое поведение), которые сами по себе, с одной стороны, вполне возможно, безобидны, но, с другой стороны, могут повлиять на другие свойства тестируемого программного обеспечения и тем увеличить риск того, что программное обеспечение перестанет работать. (ГОСТ 56920)_\n\nИсследовательское Тестирование - одновременно является и техникой, и видом тестирования. В общем виде мы так или иначе всегда используем комбинацию сценарного и исследовательского подходов. Exploratory testing подразумевает под собой одновременно изучение проекта, функционала, тест-дизайн в уме и тут же исполнение тестов, после чего данный цикл может повторяться необходимое количество раз, каждый раз улучшая создаваемые кейсы и документируя пройденные сессии.\n\nДжеймс Бах указал на важную характеристику исследовательского тестирования - тестировщик участвует когнитивно. Он активно, целенаправленно, с любопытством исследует тестируемое программное обеспечение, всегда принимая на себя ответственность каждую минуту решать, какой путь к тому, что он выбрала для исследования, является наиболее многообещающим. Нет никаких искусственных ограничений на разведку. Тестировщик может свободно использовать любые доступные источники информации, включая спецификации, записи службы технической поддержки, реализации сопоставимого программного обеспечения конкурентами и (конечно) эксперименты (тесты), которые эмпирически раскрывают информацию. Нет никаких ограничений на методы тестирования, которые могут использовать исследователи - например, любая степень автоматизации подойдет. Однако исследователь не просто перезапускает старые тесты, а тестирует чтобы учиться. Вероятно, он будет внимательно изучать поведение программы во время ее тестирования, ища новые идеи о том, как она может выйти из строя, как ее можно было бы в дальнейшем протестировать или измерить, и насколько полезны эти тесты на данном этапе разработки. Выполнение тестов можно автоматизировать, а мышление - нет. Антитезой исследования является тестирование по сценарию, в котором тестировщик (или машина) следует набору процедур, изложенных давно, сравнивая наблюдаемое поведение с любыми результатами, которые разработчик тестов считал актуальными или интересными в то время. Познание произошло тогда, а не сейчас. Объем исследования такой же, как и объем самого тестирования. Разница в том, что исследователь выполняет их в любой полезной последовательности, смешивая исследование, дизайн, выполнение, интерпретацию и общение, чтобы постоянно открывать новую информацию и идти в ногу с текущими изменениями на рынке, платформе, дизайне и реализации тестируемого программного обеспечения.\n\n**Подход к тестированию**:\n\n* Используйте эвристики для управления тестированием;\n* Выполнение и создание тест-кейсов идут рука об руку;\n* Тест-кейсы продолжают развиваться на основе наблюдений и обучения тестировщиков;\n* К ET могут применяться различные методы тестирования, такие как анализ граничных значений, классы эквивалентности и т. д.;\n* ET можно использовать сессионно , чтобы сделать его более структурированным и сфокусированным;\n* Тестировщики могут развивать свои идеи, но никогда не отклоняться от своей миссии;\n* Тестирование ET не использует сценарии, а зависит от интуиции, навыков и опыта тестировщика;\n\n**Туры в исследовательском тестировании**: Чтобы систематизировать исследовательское тестирование можно использовать идею туров. Туры - это идеи и инструкции по исследованию программного продукта, объединенные определенной общей темой или целью. Туры, как правило, ограничены по времени - длительность тестовой сессии не должна превышать 4 часа. Идею туров развивали в своих работах Канер, Бах, Хендриксон, Болтон, Кохл и другие. Джеймс Виттакер (James A. Whittaker), хоть и не придумал саму идею туров, но предложил свой подход к исследовательскому тестированию с использованием туров и в своей книге “Exploratory Software Testing” в доступной форме озвучил идею туров и описал сами туры.\n\nТур - это своего рода план тестирования, он отражает основные цели и задачи, на которых будет сконцентрировано внимание тестировщика во время сессии исследовательского тестирования. При этом Виттакер использует метафору, что тестировщик - это турист, а тестируемое приложение - это город. Обычно у туриста (тестировщика) мало времени, поэтому он выполняет конкретную задачу в рамках выбранного тура, ни на что другое не отвлекаясь. Город (ПО) разбит на районы: деловой центр, исторический район, район развлечений, туристический район, район отелей, неблагополучный район.\n\n![https://www.software-testing.by/wp-content/uploads/2015/09/328.png](https://www.software-testing.by/wp-content/uploads/2015/09/328.png)\n\n### Свободное / Интуитивное тестирование (Adhoc, Ad-hoc Testing)\n\n_Свободное тестирование (ad hoc testing): Тестирование, выполняемое неформально; без формальной подготовки тестов, формальных методов проектирования тестов, определения ожидаемых результатов и руководства по выполнению тестирования. (ISTQB)_\n\n_Парное тестирование (pair testing): Два человека (двое тестировщиков, разработчик и тестировщик, или конечный пользователь и тестировщик), работающих вместе над поиском дефектов. Обычно они работают за одним компьютером, в течение работы, передавая управление друг другу. (ISTQB)_\n\nСвободное тестирование (ad-hoc testing) - это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. Такой способ тестирования в большинстве случаев дает большее количество заведенных отчетов об ошибке. Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.\n\nЧаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт. Однако при тестировании ad-hoc тестировщик должен иметь полные знания и осведомленность о тестируемой системе, особенно если проект очень сложный и большой. Поэтому нужно хорошее представление о целях проекта, его назначении, основных функциях и возможностях.\n\n**Виды свободного тестирования** (ad-hoc testing):\n\n* Buddy testing - процесс, когда 2 человека, как правило разработчик и тестировщик, работают параллельно и находят дефекты в одном и том же модуле тестируемого продукта. Сразу после того, как разработчик завершает модульное тестирование, тестировщик и разработчик вместе работают над модулем. Этот вид тестирования позволяет обеим сторонам рассматривать эту функцию в более широком масштабе. Разработчик получит представление обо всех различных тестах, выполняемых тестером, а тестировщик получит представление о том, какова внутренняя конструкция, которая поможет ему избежать разработки недействительных сценариев;\n* Pair testing - в этом тестировании два тестировщика (лучше с разным опытом) работают вместе над одним модулем. Идея, лежащая в основе этой формы тестирования состоит в том, чтобы заставить двух тестировщиков провести мозговой штурм идей и методов, чтобы выявить ряд дефектов. Оба могут разделять работу по тестированию и делать необходимую документацию по всем сделанным наблюдениям;\n* Monkey testing - произвольное тестирование продукта с целью как можно быстрее, используя различные вариации входных данных, нарушить работу программы или вызвать ее остановку (простыми словами - сломать);\n\n**Основные преимущества ad-hoc testing**:\n\n* нет необходимости тратить время на подготовку документации;\n* самые важные дефекты зачастую обнаруживаются на ранних этапах;\n* часто применяется, когда берут нового сотрудника. С помощью этого метода, человек усваивает за 3 дня то, что, разбираясь тестовыми случаями, разбирал бы неделю - это называется форсированное обучение новых сотрудников;\n* возможность найти трудновоспроизводимые и трудноуловимые дефекты, которые невозможно было бы найти, используя стандартные сценарии проверок;\n\n| Adhoc Testing                                                                                | Exploratory Testing                                                                  |\n| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |\n| Начинается с изучения приложения, а затем - с фактического процесса тестирования             | Начинается с тестирования приложения, а затем его понимания посредством исследования |\n| Самостоятельный вид тестирования                                                             | Разновидность Adhoc Testing                                                          |\n| Не требуется никакой документации                                                            | Обязательно наличие документации по деталям тестирования.                            |\n| Adhoc Testing проводят тестировщики, обладающие глубокими знаниями о приложении              | Для изучения приложения не обязательно иметь эксперта.                               |\n| Тестирование начинается после того, как будут собраны все данные для проведения тестирования | Сбор данных и тестирование происходят одновременно.                                  |\n| Это работает для отрицательных сценариев тестирования                                        | В основном это касается положительных сценариев                                      |\n| Ориентировано на улучшение процесса тестирования                                             | Ориентировано на изучение приложения                                                 |\n| Зависит от творческих способностей и интуиции тестировщика                                   | Зависит от любопытства и понимания тестировщика                                      |\n| Нет ограничений по времени                                                                   | Это ограниченный по времени метод                                                    |\n\n### Attack Testing\n\n_Атака (attack): Направленная и нацеленная попытка оценить качество, главным образом надежность, объекта тестирования за счет попыток вызвать определенные отказы. См. также негативное тестирование. (ISTQB)_\n\n\\_Тестирование на основе атак (attack-based testing): Методика тестирования на основе опыта, использующая программные атаки с целью провоцирования отказов, в частности - отказов, связанных с защищенностью. (ISTQB) \\_\n\n\nДиаграмма связей — это инструмент управления качеством, основанный на определении логических взаимосвязей между различными данными. Применяется этот инструмент для сопоставления причин и следствий по исследуемой проблеме.\n\n![](http://sixsigmaonline.ru/imgs/001/a0194.png)\n\n\n\nэквивалентные класы \nграничные значения\n\nдобавить еще\n\ndesign table \n\nэто все specification base\n\nнужно добавить white box техники\n\n","category":"manual","description":"Техники тест-дизайна"},{"title":"Тестовая документация","path":"/testovaya-dokumentacziya/","content":"\n- [Тестовая политика и стратегия](/testovaya-politika-i-strategiya/)\n- [Международные стандарты тестовой документации](/mezhdunarodnye-standarty-testovoj-dokumentaczii/)\n- [Master Test Plan и тестовые планы для каждого уровня](/master-test-plan-i-testovye-plany-dlya-kazhdogo-urovnya/)\n- [Понятие Test Case и Test Suite](/ponyatie-test-case-i-test-suite/)\n- [Понятие Test Basis, Test Condition и Test Procedure](/ponyatie-test-basis-test-condition-i-test-procedure/)\n- [Check-list, как представитель Experience-Based](/check-list-kak-predstavitel-experience-based/)\n- [Bug Report](/bug-report/)\n- [Summary Report](/summary-report/)\n- [Requirements Tracebility Matrix](/requirements-tracebility-matrix/)\n- [Test Data Tables](/test-data-tables/)\n- [Test Scenario](/test-scenario/)\n- [External Test Reports](/external-test-reports/)\n- [Критерии приемки](/kriterii-priemki/)\n- [Метрики тестирования](/metriki-testirovaniya/)\n- [Требования](/trebovaniya/)\n- [Тестовый оракул](/testovyj-orakul/)\n\n\n## Виды тестовой документации\n\n### Тестовая поставка (test deliverable)\nЛюбой тестовый (рабочий) продукт, который должен быть доставлен кому-то другому, кроме автора тестового (рабочего) продукта. (ISTQB)\n\n### Тестовое обеспечение (testware)\nАртефакты, создаваемые во время процесса тестирования и требующиеся для планирования, разработки и выполнения тестов. Например: документация, сценарии, входы, ожидаемые результаты, процедуры установки и удаления, файлы, базы данных, окружение и любое другое дополнительное программное обеспечение или инструменты, используемые в тестировании. (Fewster and Graham)\n\n### Артефакт (artifact)\nЭто один из многих видов материальных побочных продуктов, возникающих в процессе STLC. Это не только документация, а в принципе всё, что создаётся для того, чтобы быть задействованным в тестировании.\n\n### Результаты тестирования (Test Deliverables)\nЭто артефакты, которые передаются заинтересованным сторонам проекта программного обеспечения в течение жизненного цикла разработки программного обеспечения. На каждом этапе жизненного цикла разработки программного обеспечения существуют разные результаты тестирования. Некоторые результаты тестирования предоставляются до этапа тестирования, некоторые - на этапе тестирования, а некоторые - после завершения циклов тестирования.\n\nНаличие или отсутствие документации, ее актуальность, как и используемые виды варьируются от компании к компании и даже от проекта к проекту. Создание и ведение документации требует весомого количества времени (и компетенций), а потому важно знать основные документы и их роль в процессах, учитывать требования всех заинтересованных лиц, нормативную и законодательную базу, политику и стандарты компании и особенности проекта чтобы понимать, какие из них необходимы (и обоснованны для бизнеса) в каждом случае. Существует огромное количество вариантов документов, часть из которых вы можете никогда и не встретить в реальной работе.\n\nПо Куликову документацию можно разделить на два больших вида в зависимости от времени и места ее использования:\n\n* Продуктная документация (product documentation, development documentation) используется проектной командой во время разработки и поддержки продукта. Она включает:\n  * План проекта (project management plan) и в том числе тестовый план (test plan);\n  * Требования к программному продукту (product requirements document, PRD) и функциональные спецификации (functional specifications document, FSD; software requirements specification, SRS);\n  * Архитектуру и дизайн (architecture and design);\n  * Тест-кейсы и наборы тест-кейсов (test cases, test suites);\n  * Технические спецификации (technical specifications), такие как схемы баз данных, описания алгоритмов, интерфейсов и т.д.;\n* Проектная документация (project documentation) включает в себя как продуктную документацию, так и некоторые дополнительные виды документации и используется не только на стадии разработки, но и на более ранних и поздних стадиях (например, на стадии внедрения и эксплуатации). Она включает:\n  * Пользовательскую и сопроводительную документацию (user and accompanying documentation), такую как встроенная помощь, руководство по установке и использованию, лицензионные соглашения и т.д.;\n  * Маркетинговую документацию (market requirements document, MRD), которую представители разработчика или заказчика используют как на начальных этапах (для уточнения сути и концепции проекта), так и на финальных этапах развития проекта (для продвижения продукта на рынке).\n\nМожно встретить и другие классификации.\n\n* Внутренняя документация подробно описывает процесс разработки продукта, например стандарты, проектную документацию, заметки о деловой переписке и т. д. Внешняя документация относится к документам, которые подробно описывают сам продукт, например, Системная документация и Пользовательская документация.\n* К внешней документации можно отнести Test policy, Test strategy, различные отчеты, Defect Report, Замечание, Запрос на изменение (улучшение), к внутренней всё от чеклиста до плана тестирования, тестовые данные и т.п. Пользовательская документация (User documentation) - это вся документация, которая будет передана конечному пользователю в комплекте с ПО.\n\n\n### Политика качества (Quality policy)\nОтражает видение компании в отношении производства и поставки качественного продукта;\n### Политика тестирования (Test policy)\nДокумент высокого уровня, в котором описаны принципы, методы и все важные цели тестирования в организации;\n### Стратегия тестирования (Test strategy)\nСтатический документ документ высокого уровня (high-level), обычно разрабатываемый менеджером проекта (project manager). Это документ, который отражает подход к тестированию продукта и достижению целей. Обычно он выводится из Спецификации бизнес-требований (BRS - Business Requirement Specification). На основе стратегии тестирования готовится План тестирования;\n### План тестирования (Test plan)\nДокумент, который содержит план всех действий по тестированию, которые необходимо выполнить для получения качественного продукта. План тестирования является производным от описания продукта (Product Description), SRS (Software requirements specification) или сценариев использования (Use Case) для всех будущих действий проекта. Обычно его готовит руководитель тестирования или менеджер по тестированию (Test Lead or Test Manager);\n### Отчет об оценке усилий (Effort Estimation Report)\nВ этом отчете группы тестирования оценивают усилия для завершения процесса тестирования;\n### Сценарий тестирования (Test Scenario)\nЭлемент или событие программной системы, которое может быть проверено одним или несколькими тестовыми случаями;\n### Тестовый набор/комплект** (Test Suite)\n“Комплект тестовых наборов для исследуемого компонента или системы, в котором обычно постусловие одного теста используется в качестве предусловия для последующего.” (ISTQB)_. Некоторый набор формализованных Test case, объединенных между собой по общему логическому признаку;\n### Тестовый случай/пример (Test case)\nНабор положительных и отрицательных исполняемых шагов тестового сценария, который имеет набор предварительных условий, тестовых данных, ожидаемого результата, пост-условий и фактических результатов;\n### Тест сурвей (Test Survey)\nВ рунете только [один источник](https://www.a1qa.ru/blog/obespechivaem-kachestvo-mobilnyh-prilozhenij-shag-2-planirovanie-testovyh-aktivnostej/) о нем, но есть упоминания в истории чатов коммьюнити. Test Survey по детализации занимает место посередине между чек-листом и тест-кейсом, а именно содержит в себе только summary и expected result. Т.е. подробнее чек-листов, где только заголовки, но с ожидаемым результатом и без шагов и прочего как в тест-кейсах;\n### Чек-лист (Check List)\nПеречень формализованных Test case в упрощенном виде удобном для проведения проверок, часто только список из заголовков кейсов;\n### Матрица прослеживаемости требований (Requirements Traceability Matrix)\nДокумент, который соотносит требования с тестовыми примерами;\n### Тестовые данные (Test Data)\nДанные, которые существуют (например, в базе данных) на начало выполнения теста и влияют на работу, или же испытывают влияние со стороны тестируемой системы или компонента.” (ISTQB). “Созданные или отобранные данные, удовлетворяющие входным требованиям для выполнения одного или более контрольных примеров, которые могут быть определены в плане тестирования, контрольном примере или процедуре тестирования. (ГОСТ 56920)\n### Отчет о дефектах (Defect Report)\nЦель документа заключается в том, чтобы зафиксировать факт ошибки и передать разработчикам подробную информацию о ней;\n### Отчет о выполнении теста (Test Execution Report)\nСодержит результаты тестирования и сводку действий по выполнению тестов;\n### Сводный отчет о тестировании (Test summary report)\nПредставляет собой документ высокого уровня, в котором резюмируются проведенные действия по тестированию, а также результаты тестирования;\n### Графики и метрики (Graphs and Metrics)\nПредназначены для мониторинга и управления процессом и продуктом. Это помогает без отклонений вести проект к намеченным целям. Метрики отвечают на разные вопросы. Важно решить, на какие вопросы вы хотите получить ответы;\n### Отчет о тестовых инцидентах (Test incident report)\nСодержит все инциденты, разрешенные или неразрешенные, обнаруженные во время тестирования;\n### Отчет о завершении тестирования (Test closure report)\nСодержит подробный анализ обнаруженных ошибок, удаленных ошибок и несоответствий, обнаруженных в программном обеспечении;\n### Отчет о статусе тестирования (Test status report)\nПредназначен для отслеживания статуса тестирования. Его готовят периодически или еженедельно. В нем указаны работы, выполненные до настоящего времени, и работы, которые еще не завершены;\n### Еженедельный отчет о статусе (менеджер проекта для клиента)\nWeekly status report похож на отчет о статусе тестирования, но генерируется еженедельно;\n### Отчет об улучшении (?Enhancement report)\nОписание неявных/некритичных косвенных требований, которые не были учтены при планировании/реализации продукта, но несоблюдение, которых может вызвать неприятие у конечного потребителя;\n### Запрос на модификацию (Modification Request)\nЗапрос клиента на изменение существующей функциональности;\n### Примечания к выпуску (Release Note)\nПримечания к выпуску будут отправлены клиенту, заказчику или заинтересованным сторонам вместе со сборкой. Он содержит список новых выпусков, исправления ошибок;\n### Руководство по установке / настройке (Installation/configuration guide)\nЭто руководство помогает установить или настроить компоненты, из которых состоит система, и ее аппаратные и программные требования;\n### Руководство пользователя (User guide)\nэто руководство помогает конечному пользователю понять как пользоваться продуктом;\n### Документы требований**.\n\n![https://api.docs.cntd.ru/img/12/00/13/49/98/1a71a934-c9ab-4de5-af4b-f4fa89eeb93d/P0020.png](https://lh6.googleusercontent.com/IJjhp1x7295N97WqgjsR90wavx8yHHm2iitMKK5LCcXu98Y6Jva60iyylSJt\\_hpnhJbD43DTXTXxg5d7gtJbb7pMFxue-tP-TtucTH8d1aXapLgjwXZUUtdfwLmuyGq\\_1rI\\_3OdQ)\n\nИсточник:\n\n* [Test Deliverables in Software Testing - Detailed Explanation](https://www.softwaretestingmaterial.com/test-deliverables/)\n\nДоп. материал:\n\n* [ГОСТ Р 56922-2016/ISO/IEC/IEEE 29119-3:2013 Часть 3: “Документация тестирования”](https://docs.cntd.ru/document/1200134998)\n* [ГОСТ Р ИСО/МЭК 15910-2002: “Процесс создания документации пользователя программного средства”](https://docs.cntd.ru/document/1200030141)\n* [ГОСТ Р 57100-2016/ISO/IEC/IEEE 42010:2011 “Описание архитектуры”](https://docs.cntd.ru/document/1200139542)\n* [Podlodka#223 - Техническая документация](https://www.youtube.com/watch?v=S8kiPiG0jW8)\n* [Пользовательская документация](https://habr.com/ru/post/542288/#:\\~:text=2.%C2%A0-,%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F,-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F)\n* [What Is Test Data? Test Data Preparation Techniques With Example](https://www.softwaretestinghelp.com/tips-to-design-test-data-before-executing-your-test-cases/)\n* [Что такое тестовая документация и зачем она нужна?](https://testengineer.ru/chto-takoe-testovaya-dokumentaciya-i-zachem-ona-nuzhna/)\n* [Шаблон улучшения](http://okiseleva.blogspot.com/2015/10/blog-post\\_16.html)\n\n\n\n\n## виды тестовой документации\nhttps://www.freecodecamp.org/news/how-to-write-qa-documentation-that-will-work/\n\n\n","category":"manual","description":"Тестовая документация"},{"title":"Тестовая политика и стратегия","path":"/testovaya-politika-i-strategiya/","content":"\n## Политика качества и политика тестирования (Quality policy and Test policy)\n\n### Политика качества\n\nЭто заявления, сделанные организациями для передачи своих долгосрочных стратегических целей, задач, видения в отношении производства и поставки качественного продукта. \n\nВ этих политиках излагаются основные принципы организации, которые помогают им следовать установленным процедурам при разработке и тестировании продукта и постоянно стремиться к улучшению как продукта, так и процесса. \n\nПолитика в области качества отражает основные ценности организации, что помогает понять их представления об атрибуте качества, о том, что для них означает качество, подходах, ключевых областях внимания и приоритетах при обеспечении качества для своих клиентов.\n\nНаличие четко определенной политики в области качества в соответствии со стандартами ISO 9001 является обязательным требованием для организации. Quality policy составляют CEO и Quality Manager.\n\nПри написании политики подчеркиваются следующие ключевые области:\n\n* **Внимание клиентов**  \nПотребности и ожидания клиентов являются важнейшим ключевым критерием, который помогает в достижении перспектив качества продукта. Таким образом, основное внимание следует уделять информированию о текущих и будущих потребностях клиента, а также их выполнению;\n* **Лидерство**  \nДолжна быть в состоянии моделировать и создавать мотивационную и восторженную среду, чтобы извлекать максимум из каждого человека для достижения качества;\n* **Постоянное улучшение**  \nДолжна стремиться к постоянному совершенствованию процедуры и подхода, чтобы улучшить качество;\n* **Процесс**  \nДолжна отражать соблюдение и следование всем стандартным методам и процессам, что способствует повышению качества;\n* **Отношения**  \nДолжна быть направлена на укрепление отношений с клиентом / покупателем;\n* **Создание и распространение осведомленности**  \nИнформирование людей как внутри (персонал), так и за пределами (целевые клиенты) организации о стандартах, принципах и практиках, которым следует организация.\n\nКроме того, она должна обеспечивать прочную основу для достижения целей в области качества и периодически пересматриваться и обновляться, чтобы постоянно соответствовать существующим требованиям и ожиданиям. Вкратце можно сказать, что политика в области качества, определяемая организациями, действует как зеркало и отражает их виртуальный образ в реальном мире, на основе которого внешние организации могут воспринимать и понимать свои основные принципы и обязательства по отношению к вкладу в качество.\n\n### Политика тестирования\n\n_Политика тестирования (test policy): Документ высокого уровня, описывающий принципы, подход и основные цели организации в отношении тестирования. (ISTQB)_\n\n**Политика тестирования** объясняет философию тестирования компании в целом и указывает направление, которого отдел тестирования должен придерживаться и которому следует следовать. Это должно относиться как к новым проектам, так и к проектам на поддержке. \n\nУстановление старшими менеджерами соответствующей политики тестирования обеспечивает прочную основу, в которой могут работать специалисты-практики. Это поможет обеспечить максимальную стратегическую ценность каждого проекта.\n\nПолитика тестирования является частью политики качества, если она есть, в таких случаях политика качества разъяснит общую цель менеджмента в отношении качества. В ином случае этот документ верхний в иерархии тестовой документации. Политика тестирования содержит следующее:\n\n* Обозначение преимуществ тестирования и коммерческой ценности, которые оправдывают [затраты на качество](https://tryqa.com/what-is-cost-of-quality-in-software-testing/);\n* Определяет [цели тестирования](https://tryqa.com/what-is-the-software-testing-objectives-and-purpose/), такие как укрепление доверия, обнаружение дефектов и снижение рисков для качества;\n* Описывает методы измерения эффективности тестирования и результативности выполнения задач тестирования;\n* Обобщает [процессы](https://tryqa.com/what-is-fundamental-test-process-in-software-testing/), используемые при тестировании;\n* Описывает для организации способы [улучшения процессов](https://tryqa.com/software-testing-process-improvements-for-test-qa-managers/) тестирования.\n\nПолитика тестирования также должна включать действия по тестированию, необходимые для поддержки текущего проекта, а также разработки новых проектов.\n\nИсточники:\n\n* [Quality Policy](https://www.professionalqa.com/quality-policy)\n* [What is Test Policy? What does it contain?](https://tryqa.com/what-is-test-policy-what-does-it-contain/)\n\nДоп. материал:\n\n* [ISO 9001 Quality Policy - How to Write & Communicate your Policy Statement](https://www.iso-9001-checklist.co.uk/5.2-quality-policy.htm)\n\n## Стратегия тестирования (Test strategy)\n\n_Стратегия тестирования (test strategy): Высокоуровневое описание уровней тестирования, которые должны быть выполнены, и тестирования, входящего в эти уровни, для организации или программы из одного или более проектов. (ISTQB)_\n\nСтратегия тестирования - это статический документ высокого уровня, обычно разрабатываемый менеджером проекта. \n\nЭто документ, который отражает подход к тестированию продукта и достижению целей, и дает четкое представление о том, что команда тестирования будет делать для всего проекта. Обычно он выводится из Спецификации бизнес-требований (BRS).\n\nКак только стратегия тестирования готова, группа тестирования начинает писать подробный план тестирования и продолжает дальнейшие этапы тестирования. \n\nВ мире Agile некоторые компании не тратят время на подготовку плана тестирования из-за минимального времени для каждого выпуска, но они поддерживают документ стратегии тестирования. Это один из важных документов в test deliverables, которым команда тестирования делится с заинтересованными сторонами для лучшего понимания объема проекта, рисков, подходов к тестированию и других важных аспектов.\n\nСодержание стратегии будет разным в зависимости от проекта, поэтому нет единого для всех шаблона. Можно найти эвристики в помощь, множество зарубежных статей на тему составления стратегии и некоторые общие пункты, которые чаще используются:\n\n* **Обзор и объем** (Scope and overview): объем работ по тестированию (что тестировать и зачем тестировать) и обзор тестируемого продукта;\n* **Подход к тестированию** (Test Approach):\n  * Уровни тестирования (Test levels);\n  * Виды тестирования (Test Types);\n  * Роли и обязанности (Roles and responsibilities);\n  * Требования к окружениям (Environment requirements);\n* **Инструменты тестирования** (Testing tools): инструменты, необходимые для проведения тестов (TMS, багтрекинговая система, стек автоматизации);\n* **Отраслевые стандарты**, которым необходимо следовать (Industry standards to follow): В этом разделе описывается отраслевой стандарт для производства высококачественной системы, которая соответствует ожиданиям клиентов или превосходит их. Обычно менеджер проекта определяет модели и процедуры тестирования, которым необходимо следовать для достижения целей проекта;\n* **Результаты тестирования** (Test deliverables): документация, которую необходимо создать до, во время и по окончании тестирования;\n* **Метрики тестирования** (Testing metrics): метрики, которые следует использовать в проекте для анализа статуса проекта;\n* **Матрица отслеживания требований** (RTM);\n* **Риски и способы их снижения** (Risk and mitigation): все риски тестирования и план по их снижению;\n* **Инструмент отчетности** (Reporting tool): как будут отслеживаться дефекты и проблемы;\n* **Результаты тестов** (Test Summary): виды сводных отчетов о тестах, которые будут создаваться, с указанием периодичности. Сводные отчеты о тестах будут генерироваться ежедневно, еженедельно или ежемесячно, в зависимости от критичности проекта.\n\nИсточники:\n\n* [The Complete Guide To Writing Test Strategy](https://www.softwaretestingmaterial.com/test-strategy/)\n\nДоп. материал:\n\n* [Большая качественная подборка материалов по теме](https://www.huibschoots.nl/wordpress/?page\\_id=441#strategy)\n* [Practical test strategy using heuristics](https://huddle.eurostarsoftwaretesting.com/resources/test-management/practical-test-strategy-using-heuristics/)\n* [Creating a Quality Strategy](https://thinkingtester.com/creating-a-quality-strategy/)\n* [Стратегия обеспечения качества и вопросы в процессе ее составления](https://testengineer.ru/strategiya-obespecheniya-kachestva/)\n* [6 Ways to Come Up with a Solid Test Strategy](https://blog.gurock.com/solid-test-strategy/)\n* [Creating a quality strategy](https://theqalead.com/topics/creating-a-quality-strategy/)\n* Примеры: [раз](https://www.experimentus.com/itm/15\\_Project\\_Test\\_Strategy\\_Agile.pdf), [два](https://strongqa.com/qa-portal/testing-docs-templates/test-strategy), [три](https://www.template.net/business/strategy-templates/sample-test-strategy-template/)\n\n\n\n","category":"manual","description":"Тестовая политика и стратегия"},{"title":"Test Data Tables","path":"/test-data-tables/","content":"","category":"manual","description":"Test Data Tables"},{"title":"Test Scenario","path":"/test-scenario/","content":"","category":"manual","description":"Test Scenario"},{"title":"External Test Reports","path":"/external-test-reports/","content":"## Виды отчетов (Reports)\n\nОтчет - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.\n\nНам важно понять, для кого, для чего и в каких условиях мы это делаем и на сколько это улучшит восприятие излагаемой нами информации. Надо помнить, что каждое действие преследует определенную цель. В случае отчета нам важно понять, для кого, для чего и в каких условиях мы это делаем.\n\nНиже перечислены наиболее известные варианты отчетов в тестировании.\n\n**Отчет по инциденту (incident report)**\n\n_Отчет по инциденту (incident report): Документ, описывающий событие, которое произошло, например, во время тестирования, и которое необходимо исследовать. (IEEE 829)_\n\nОтчет об инцидентах можно определить как письменное описание инцидента, наблюдаемого во время тестирования. Чтобы лучше понять, давайте начнем с того, что такое «инцидент». Инцидент при тестировании программного обеспечения можно определить как наблюдаемое изменение или отклонение поведения системы от ожидаемого. Это может быть отклонение от функционального требования или от настроек среды. Очень часто инцидент называют дефектом или ошибкой, но это не всегда так. Инцидент - это в основном любое неожиданное поведение или реакция программного обеспечения, требующая расследования.\n\nИнцидент необходимо расследовать, и на основании расследования инцидент может быть преобразован в дефект. Чаще всего это оказывается дефектом, но иногда это может произойти из-за различных факторов, например:\n\n* Человеческий фактор;\n* Требование отсутствует или неясно;\n* Проблема среды, например отсутствие ответа от внутреннего сервера, вызывающее периодическое непредвиденное поведение или ошибку. Либо неправильная конфигурация среды;\n* Ошибочные тестовые данные;\n* Некорректный ожидаемый результат.\n\nIncident report призван зафиксировать и сообщить об инциденте заинтересованным лицам, провести расследование. Составляется аналогично баг-репорту, возможно с упором на расследование, обсуждение, влияние (impact) и может быть назначен не на разработчиков для уточнения деталей.\n\n**Отчет о результатах тестирования (test result report)**\n\nОтчет о результатах тестирования - периодический отчет, в котором документируется подробная информация о выполнении теста и его результате. Также он содержит условия, предположения, ограничения теста, какой элемент теста кем тестируется. Помимо этого вносится подробная информация об оставшейся работе, чтобы показать, сколько еще работы необходимо выполнить в проекте.\n\n**Отчет о выполнении теста (Test Execution Report)**\n\nОтчет о выполнении теста содержит детали выполнения и результат выполнения теста. Обычно его готовят для отправки вышестоящему руководству от группы тестирования, чтобы показать состояние выполнения теста и ход тестирования. Когда мы доставляем программное обеспечение клиенту, мы вкратце отправим полную информацию о выполнении теста. Это даст клиенту лучшее понимание выполненного теста и покрытия.\n\n**Отчет о ходе тестирования (test progress report)**\n\n_Отчет о ходе тестирования (test progress report): Документ, подводящий итог задачам и результатам, составляемый с определенной периодичностью с целью сравнения прогресса тестирования с базовой версией (например, с исходным планом тестирования) и извещения о рисках и альтернативах, требующих решения руководства. (ISTQB)_\n\n**Аналитический отчет о тестировании (test evaluation report)**\n\n_Аналитический отчет о тестировании (test evaluation report): Документ, создаваемый в конце процесса тестирования и подводящий итог тестовым активностям и результатам. Также в нем содержится оценка процесса тестирования и полученный опыт. (ISTQB)_\n\n**Итоговый отчет о тестировании (test summary report)**\n\n_Итоговый отчет о тестировании (test summary report): Документ, подводящий итог задачам и результатам тестирования, также содержащий оценку соответствующих объектов тестирования относительно критериев выхода. (IEEE 829)_\n\nСводный отчет о тестировании содержит подробную информацию о тестировании, проведенном на протяжении жизненного цикла разработки программного обеспечения. Элементы в итоговом отчете по тестированию различаются от организации к организации, а также различаются для разных проектов. Информация в отчете об испытаниях основывается на аудитории отчета об испытаниях. Аудитория может быть клиентом, менеджментом, бизнес-аналитиком, разработчиками, членами команды тестирования, членами организации и т. д.\n\n**Отчет о пользовательском приемочном тестировании (User acceptance test report)**\n\nОтчет о пользовательском приемочном тестировании создается во время и после UAT. В нем указываются подробности проведенного пользователем приемочного теста и результат пользовательского приемочного теста. В нем также перечислены дефекты, не учтенные при UAT.\n\nИсточники:\n\n* [Создание понятных отчетов о тестировании](https://habr.com/ru/company/performance\\_lab/blog/207512/)\n* [What Is Incident Report In Software Testing?](https://www.softwaretestingclass.com/what-is-incident-report-in-software-testing/)\n* [Software Testing Artifacts - Test Reports](https://www.softwaretestingclass.com/test-report-artifacts/)\n\nДоп. материал:\n\n* [Как составить отчет о тестировании](https://telegra.ph/test-report-04-15)\n* [48+ SAMPLE Test Report Templates](https://www.sample.net/reports/test-report/)\n* [Отчет по результатам тестирования сайта](https://www.performance-lab.ru/wp-content/themes/pureengineering/images/sitetesting/test\\_report\\_example.pdf)\n* [Отчет о тестировании релиза](https://vk.com/@usetalkrostov-otchet-o-testirovanii-reliza)\n* [Test report templates](https://strongqa.com/qa-portal/testing-docs-templates/test-report)\n* [Test Summary Reports Tutorial: Learn with Example & Template](https://www.guru99.com/how-test-reports-predict-the-success-of-your-testing-project.html)\n","category":"manual","description":"External Test Reports"},{"title":"Критерии приемки","path":"/kriterii-priemki/","content":"\n## Критерии приемки (Acceptance Criteria)\n\n_Критерии приемки (acceptance criteria): Критерии выхода, которым должны соответствовать компонент или система, для того, чтобы быть принятыми пользователем, заказчиком или другим уполномоченным лицом. (IEEE 610)_\n\nКритерии приемки - это условия, которым должен удовлетворять программный продукт, чтобы быть принятым пользователем, заказчиком или, в случае функциональности системного уровня, потребляющей системой. Проще говоря - это список деталей (также известных как требования) о том, как новая функция (feature) программного обеспечения должна работать / выглядеть. Это гарантирует, что:\n\n* Функция разработана хорошо. В противном случае важный или полезный аспект может быть упущен - и никто этого не заметит до самого конца.\n* Это работает так, как было задумано. Если описание расплывчато, разработчикам, возможно, придется сделать предположения о том, как должна работать каждая область. С критериями приемки разработчики точно знают, какой дизайн и функциональность ожидаются.\n* QA знает, чего ожидать во время тестирования. Даже если функция не выглядит сломанной, она может работать не так, как хотели менеджеры по продукту. Если критерии приемки отсутствуют, тестировщики не могут сообщать о подобных проблемах.\n\nХорошие критерии приемки должны быть простыми для понимания, но с достаточной детализацией, чтобы убедиться, что они не слишком расплывчаты. Это не всегда универсальный подход. Но они всегда должны предоставлять достаточно информации для разработчиков, чтобы создать функцию, а для QA - для ее тестирования. Это не значит, что в процессе разработки программного обеспечения не возникнет вопросов. Но в целом функция должна быть понятной.\n\nФормат / макет / шаблон критериев приемки (Acceptance Criteria Format/Layout/Template): существует два основных типа критериев приемки, основанные на сценариях и правилах:\n\n* Критерии приемлемости, основанные на сценариях (Scenario-based acceptance criteria), используют шаблон для подробного описания конкретного поведения / последовательности действий пользователя;\n* Критерии приемлемости на основе правил (Rule-based acceptance criteria) - это скорее простой список того, как функция должна выглядеть / работать;\n\n**Scenario-based acceptance criteria** соответствует формату “Дано/Когда/Тогда” (“Given/When/Then”) (основан на BDD - [behavior driven development](https://en.wikipedia.org/wiki/Behavior-driven\\_development)):\n\n* Given /_какой-то аспект, связанный с поведением пользователя_/\n* When /_пользователь выполняет определенное действие_/\n* Then /_происходит определенный результат_/\n\nМежду ними в случае нескольких условий можно добавлять “И” (“AND”).\n\n**Rule-Based Acceptance Criteria** - это простой список «правил» о том, как функция должна выглядеть / работать:\n\n* Все кнопки должны быть определенного цвета;\n* Кнопка входа должна перенаправлять пользователя в определенный раздел;\n* Кнопка регистрации должна находиться в определенной области;\n* Все кнопки должны быть серыми, если не выполняются определенные требования;\n* и многое другое;\n\nХотя критерии, основанные на правилах, имеют более простой формат, нет причин, по которым они не могут быть длинными и подробными.\n\n**Кто пишет критерии приемки?** Обычно в создании критериев приемки участвуют несколько человек или команд. Тем не менее, это в первую очередь делает product manager (или “product owner”). Разработчики несут ответственность за обеспечение функциональности функции, а QA - за подтверждение ее удобства использования. Но критерии приемки создаются человеком или командой, ответственной за решение, какие новые функции добавить в продукт (независимо от типа приложения или веб-сайта).\n\nБольшая часть Agile включает внесение изменений по мере развития проекта. Так **могут ли критерии приемки измениться в середине спринта?** Ответ: «Это зависит от обстоятельств». Если спринт начался, но разработчики еще не завершили эту функцию, можно изменить требования. Но важно всегда сначала согласовывать с разработчиками и держать других (например, QA) в курсе. Тестировщики могли написать test cases, которые больше не актуальны после изменений. Кроме того, новый объем работы может оказаться слишком большим, чтобы разработчики могли завершить его вовремя.\n\n\\*\\*User Stories vs Acceptance Criteria: \\*\\*пользовательские истории и критерии приемки идут рука об руку. Пользовательская история описывает основную цель новой функции - обзор того, как она поможет пользователям. Критерии приемки перечисляют способы работы функции с технической точки зрения. Обычно в тикетах (например, в Jira или Trello) вверху указывается пользовательская история, за которой следуют критерии приемки\n\n**Definition of Done:** чтобы заявка (или функция) считалась «выполненной», все критерии должны работать. Например, предположим, что пользовательская история была: “Как пользователь, я хочу иметь возможность войти в систему, чтобы получить доступ к панели управления моей учетной записи”. Как уже упоминалось, пользователь может войти в систему, чтобы получить доступ к панели управления своей учетной записи. Но тикет не считался бы «done», если бы он также содержал следующие критерии приемки: “Кнопка входа должна быть бирюзовой”, а фактически кнопка входа была бы, например, желтой. Иногда команда решает запустить функцию даже с незначительными несоответствиями. Таким образом, они могут пометить тикет как выполненный (или создать отдельный для решения оставшихся аспектов), даже если не все критерии работают. Но с точки зрения технического определения, это не «готово», пока не пройдут все критерии приемки.\n\nИсточник: [What is Acceptance Criteria?](https://www.mindfulqa.com/acceptance-criteria/)\n","category":"manual","description":"Критерии приемки"},{"title":"Метрики тестирования","path":"/metriki-testirovaniya/","content":"\n## Метрики тестирования (Software Test Metrics)\n\n_Метрика (metric): Шкала измерений и метод, используемый для измерений (ISO 14598)_\n\n“Вы не можете контролировать то, что не можете измерить” - Том Демакро.\n\nОсновная цель тестирования заключается в предоставлении информации, необходимой для управления рисками. Чтобы контролировать и управлять тестированием, а также предоставлять своевременную информацию заинтересованным сторонам, необходимы эффективные измерения процесса тестирования. Для измерения процесса тестирования нужно определить, какая информация должна быть предоставлена, как ее получить и как она должна быть представлена. Таким образом, для всех действий тестирования необходимо определить и использовать метрики, а также предоставить показатели измерений, как для продуктов, так и для процессов.\n\nМетрики тестирования программного обеспечения подразделяются на два типа:\n\n* **Метрики процесса** (Process metrics): используются в процессе подготовки и выполнения тестирования.\n  *   **Продуктивность подготовки тест-кейсов** (Test Case Preparation Productivity): используется для расчета количества подготовленных тест-кейсов и усилий (Effort), затраченных на их подготовку.\n\n      _Test Case Preparation Productivity = (No of Test Case) / (Effort spent for Test Case Preparation)_\n  *   **Охват тестового дизайна** (Test Design Coverage): процент покрытия тест-кейсами требований.\n\n      _Test Design Coverage = ((Total number of requirements mapped to test cases) / (Total number of requirements)\\*100_\n  *   **Продуктивность выполнения тестов** (Test Execution Productivity): определяет количество тест-кейсов, которые могут быть выполнены в час.\n\n      _Test Execution Productivity = (No of Test cases executed) / (Effort spent for execution of test cases)_\n  *   **Покрытие выполненных тестов** (Test Execution Coverage): предназначено для измерения количества выполненных тест-кейсов по сравнению с количеством запланированных тест-кейсов.\n\n      _Test Execution Coverage = (Total no. of test cases executed / Total no. of test cases planned to execute)\\*100_\n  *   **Успешные тест-кейсы** (Test Cases Passed): для измерения процента пройденных успешно тест-кейсов.\n\n      _Test Cases Pass = (Total no. of test cases passed) / (Total no. of test cases executed) \\* 100_\n  *   **Неуспешные тест-кейсы** (Test Cases Failed): для измерения процента заваленных тест-кейсов.\n\n      _Test Cases Failed = (Total no. of test cases failed) / (Total no. of test cases executed) \\* 100_\n  *   **Заблокированные тест-кейсы** (Test Cases Blocked): для измерения процента блокированных тест-кейсов.\n\n      _Test Cases Blocked = (Total no. of test cases blocked) / (Total no. of test cases executed) \\* 100_\n* **Метрики продукта** (Product metrics):\n  *   **Уровень обнаружения ошибок** (Error Discovery Rate): для определения эффективности тест-кейсов.\n\n      _Error Discovery Rate = (Total number of defects found /Total no. of test cases executed)\\*100_\n  * **Процент выявления дефектов** (Defect Detection Percentage (DDP)): _Количество дефектов, выявленных в фазе тестирования, поделенное на число дефектов, найденных в этой фазе тестирования, а также во всех последующих фазах. См. также ускользнувший дефект. (ISTQB)_\n  *   **Уровень исправления дефектов** (Defect Fix Rate): помогает узнать качество сборки (build) с точки зрения устранения дефектов.\n\n      _Defect Fix Rate = (Total no of Defects reported as fixed - Total no. of defects reopened) / (Total no of Defects reported as fixed + Total no. of new Bugs due to fix)\\*100_\n  *   **Плотность дефектов** (Defect Density): _количество дефектов, обнаруженных в компоненте или системе, поделенное на размер компонента или системы (выраженный в стандартных единицах измерения, например строках кода, числе классов или функций). (ISTQB)_\n\n      _Defect Density = Total no. of defects identified / Actual Size (requirements)_\n  *   **Утечка дефектов** (Defect Leakage): используется для проверки эффективности процесса тестирования перед UAT.\n\n      _Defect Leakage = ((Total no. of defects found in UAT)/(Total no. of defects found before UAT)) \\* 100_\n  *   **Эффективность устранения дефектов** (Defect Removal Efficiency): позволяет сравнивать общую (дефекты, обнаруженные до и после поставки) эффективность устранения дефектов.\n\n      _Defect Removal Efficiency = ((Total no. of defects found pre-delivery) /( (Total no. of defects found pre-delivery )+ (Total no. of defects found post-delivery)))\\* 100_\n\n**Тестовое покрытие (Test Coverage)**\n\nТестовое Покрытие - это одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода. Сложность современного ПО и инфраструктуры сделало невыполнимой задачу проведения тестирования со 100% тестовым покрытием. Поэтому для разработки набора тестов, обеспечивающего более-менее высокий уровень покрытия можно использовать специальные инструменты либо техники тест дизайна.\n\nСуществуют следующие подходы к оценке и измерению тестового покрытия:\n\n* [Покрытие требований (Requirements Coverage)](http://www.protesting.ru/testing/testcoverage.html#requirements) - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix).\n* [Покрытие кода (Code Coverage)](http://www.protesting.ru/testing/testcoverage.html#code) - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей ПО.\n* [Тестовое покрытие на базе анализа потока управления](http://www.protesting.ru/testing/testcoverage.html#flow) - это одна из техник тестирования белого ящика, основанная на определении путей выполнения кода программного модуля и создания выполняемых тест кейсов для покрытия этих путей.&#x20;\n\nРазличия:\\\nМетод покрытия требований сосредоточен на проверке соответствия набора проводимых тестов требованиям к продукту, в то время как анализ покрытия кода - на полноте проверки тестами разработанной части продукта (исходного кода), а анализ потока управления - на прохождении путей в графе или модели выполнения тестируемых функций (Control Flow Graph).\n\nОграничения:\n\n* Метод оценки покрытия кода не выявит нереализованные требования, так как работает не с конечным продуктом, а с существующим исходным кодом.\n* Метод покрытия требований может оставить непроверенными некоторые участки кода, потому что не учитывает конечную реализацию.\n\n_**Альтернативное мнение**_\n\nПокрытие кода - совершенно бесполезная метрика. Не существует «правильного» показателя. Это вопрос-ловушка. У вас может быть проект с близким к 100% покрытием кода, в котором по-прежнему остаются баги и проблемы. В реальности нужно следить за другими метриками - хорошо известными показателям CTM (Codepipes testing Metrics).\n\n![](https://lh5.googleusercontent.com/ycWdGw8XfGW\\_7xun6DdJ2HLdCP5FaAIht4em7L99M4Pu58zUki4bgk6V0o4VjnGCxPcxyZFsXKep5rwyJP-KVQa9daBeK0XdCUgOkSUvBsPJyLOTxnYOHunUBfvIOrgMuUeH7f61)\n\n* **PDWT** (процент разработчиков, пишущих тесты) - вероятно, самый важный показатель. Нет смысла говорить об антипаттернах тестирования ПО, если у вас вообще нет тестов. Все разработчики в команде должны писать тесты. Любую новую функцию можно объявлять сделанной только если она сопровождается одним или несколькими тестами.\n* **PBCNT** (процент багов, приводящих к созданию новых тестов). Каждый баг в продакшне - отличный повод для написания нового теста, проверяющего соответствующее исправление. Любой баг должен появиться в продакшне не более одного раза. Если ваш проект страдает от появления повторных багов даже после их первоначального «исправления», то команда действительно выиграет от использования этой метрики.\n* **PTVB** (процент тестов, которые проверяют поведение, а не реализацию). Тесно связанные тесты пожирают массу времени при рефакторинге основного кода.\n* **PTD** (процент детерминированных тестов от общего числа). Тесты должны завершаться ошибкой только в том случае, если что-то не так с бизнес-кодом. Если тесты периодически ломаются без видимой причины - это огромная проблема.\\\n  \\\n  Если после прочтения о метриках вы по-прежнему настаиваете на установке жесткого показателя для покрытия кода, я дам вам число 20%. Это число должно использоваться как эмпирическое правило, основанное на законе Парето. 20% вашего кода вызывает 80% ваших ошибок\n\nИсточники:\n\n* [ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013](https://docs.cntd.ru/document/1200134996)\n* [Software Test Metrics - Product Metrics & Process Metrics](https://www.softwaretestingmaterial.com/test-metrics/)\n* [Антипаттерны тестирования ПО](https://habr.com/ru/post/358178/)\n\nДоп. материал:\n\n* [What Metrics Should You Be Using?](https://blog.gurock.com/qa-metrics/)\n* [Different Software Quality Metrics used by Expert Test Managers](https://www.softwaretestinggenius.com/different-software-quality-metrics-used-by-expert-test-managers/)\n* [Code Coverage: How to Measure You've Done Enough Testing](https://hackernoon.com/code-coverage-how-to-measure-youve-done-enough-testing)\n* [Understanding time to quality](https://theqalead.com/topics/time-to-quality-concept-explained/)\n* [Метрики в тестировании](https://www.youtube.com/watch?v=OyCnB2LvAtQ\\&t=656s)\n* [Самый полный список метрик тестирования на русском языке](https://habr.com/ru/post/546562/)\n* [Code Coverage Best Practices](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html)\n* [Лекция 4: Оценка оттестированности проекта: метрики и методика интегральной оценки](https://intuit.ru/studies/courses/48/48/lecture/1430)\n* [Тестовое покрытие по Бейзеру // Бесплатный урок OTUS](https://www.youtube.com/watch?v=jqjJ256CZhk)\n* [Оцениваем риски в тестировании с помощью open source-проекта Drill4j](https://www.youtube.com/watch?v=zN-F71rEXh4)\n* [Метрики в тестировании. Матрица трассировки](https://www.youtube.com/watch?v=OyCnB2LvAtQ)\n","category":"manual","description":"Метрики тестирования"},{"title":"Требования","path":"/trebovaniya/","content":"\n## Требования (Requirements)\n\n_Требование (requirement): Условия или возможности, необходимые пользователю для решения определенных задач или достижения определенных целей, которые должны быть достигнуты для выполнения контракта, стандартов, спецификации, или других формальных документов. (IEEE 610)_\n\n_Спецификация (specification): Документ, описывающий (в идеале - исчерпывающе, однозначно и доступно) требования, дизайн, поведение или иные характеристики компонента или системы. Зачастую в спецификацию включаются процедуры контроля исполнения. (ISTQB)_\n\n_Спецификация компонента (component specification): Описание функций компонента в терминах его выходных значений для заданных входных значений при определенных условиях, а также требуемого нефункционального поведения (например, использование ресурсов). (ISTQB)_\n\n_Спецификация проектирования теста (test design specification): Документ, описывающий тестовое условие (элементы покрытия) для элемента тестирования, детализированный подход к тестированию, и идентифицирующий соответствующие тестовые сценарии высокого уровня. (IEEE 829)_\n\n_Спецификация процедуры тестирования (test procedure specification): Документ, описывающий последовательность действий при выполнении теста. Также известен как ручной сценарий тестирования. (IEEE 829)_\n\n_Спецификация теста (test specification): Документ, состоящий из спецификации проектирования теста, спецификации тестовых сценариев и/или спецификации процедуры тестирования._\n\n_Спецификация тестовых сценариев (test case specification): Документ, описывающий комплект тестовых сценариев - цель, входы, тестовые операции, ожидаемые результаты и предусловия выполнения для объекта тестирования. (IEEE 829)_\n\nТребования являются отправной точкой для определения того, что проектная команда будет проектировать, реализовывать и тестировать. Вне зависимости от того, какая модель разработки ПО используется на проекте, чем позже будет обнаружена проблема, тем сложнее и дороже будет ее решение. Если проблема в требованиях будет выяснена на начальной стадии, ее решение может свестись к исправлению пары слов в тексте, в то время как недоработка, вызванная пропущенной проблемой в требованиях и обнаруженная на стадии эксплуатации, может даже полностью уничтожить проект.\n\n**Источники и пути выявления требований**\n\nТребования начинают свою жизнь на стороне заказчика. Их сбор (gathering) и выявление (elicitation) осуществляются с помощью следующих основных техник:\n\n* **Интервью**. Самый универсальный путь выявления требований, заключающийся в общении проектного специалиста (как правило, бизнес-аналитика) и представителя заказчика (или эксперта, пользователя и т.д.). Интервью может проходить в классическом понимании этого слова (беседа в виде «вопрос ответ»), в виде переписки и т.п. Главным здесь является то, что ключевыми фигурами выступают двое - интервьюируемый и интервьюер (хотя это и не исключает наличия «аудитории слушателей», например, в виде лиц, поставленных в копию переписки).\n* **Работа с фокусными группами**. Может выступать как вариант «расширенного интервью», где источником информации является не одно лицо, а группа лиц (как правило, представляющих собой целевую аудиторию, и/или обладающих важной для проекта информацией, и/или уполномоченных принимать важные для проекта решения).\n* **Анкетирование**. Этот вариант выявления требований вызывает много споров, т.к. при неверной реализации может привести к нулевому результату при объемных затратах. В то же время при правильной организации анкетирование позволяет автоматически собрать и обработать огромное количество ответов от огромного количества респондентов. Ключевым фактором успеха является правильное составление анкеты, правильный выбор аудитории и правильное преподнесение анкеты.\n* **Семинары и мозговой штурм**. Семинары позволяют группе людей очень быстро обменяться информацией (и наглядно продемонстрировать те или иные идеи), а также хорошо сочетаются с интервью, анкетированием, прототипированием и моделированием - в том числе для обсуждения результатов и формирования выводов и решений. Мозговой штурм может проводиться и как часть семинара, и как отдельный вид деятельности. Он позволяет за минимальное время сгенерировать большое количество идей, которые в дальнейшем можно не спеша рассмотреть с точки зрения их использования для развития проекта.\n* **Наблюдение**. Может выражаться как в буквальном наблюдении за некими процессами, так и во включении проектного специалиста в эти процессы в качестве участника. С одной стороны, наблюдение позволяет увидеть то, о чём (по совершенно различным соображениям) могут умолчать интервьюируемые, анкетируемые и представители фокусных групп, но с другой - отнимает очень много времени и чаще всего позволяет увидеть лишь часть процессов.\n* **Прототипирование**. Состоит в демонстрации и обсуждении промежуточных версий продукта (например, дизайн страниц сайта может быть сначала представлен в виде картинок, и лишь затем сверстан). Это один из лучших путей поиска единого понимания и уточнения требований, однако он может привести к серьезным дополнительным затратам при отсутствии специальных инструментов (позволяющих быстро создавать прототипы) и слишком раннем применении (когда требования еще не стабильны, и высока вероятность создания прототипа, имеющего мало общего с тем, что хотел заказчик).\n* **Анализ документов**. Хорошо работает тогда, когда эксперты в предметной области (временно) недоступны, а также в предметных областях, имеющих общепринятую устоявшуюся регламентирующую документацию. Также к этой технике относится и просто изучение документов, регламентирующих бизнес-процессы в предметной области заказчика или в конкретной организации, что позволяет приобрести необходимые для лучшего понимания сути проекта знания.\n* **Моделирование процессов и взаимодействий**. Может применяться как к «бизнес-процессам и взаимодействиям» (например: «договор на закупку формируется отделом закупок, визируется бухгалтерией и юридическим отделом…»), так и к «техническим процессам и взаимодействиям» (например: «платежное поручение генерируется модулем “Бухгалтерия”, шифруется модулем “Безопасность” и передаётся на сохранение в модуль “Хранилище”»). Данная техника требует высокой квалификации специалиста по бизнес-анализу, т.к. сопряжена с обработкой большого объема сложной (и часто плохо структурированной) информации.\n* **Самостоятельное описание**. Является не столько техникой выявления требований, сколько техникой их фиксации и формализации. Очень сложно (и даже нельзя!) пытаться самому «придумать требования за заказчика», но в спокойной обстановке можно самостоятельно обработать собранную информацию и аккуратно оформить ее для дальнейшего обсуждения и уточнения.\n\n**Уровни и типы требований**\n\n![](https://lh5.googleusercontent.com/reoIE5sFFhpiNAY1ZgN\\_cFtkQuEF2FFhSQvR1SkW8zk5NKvCFt3L7JNrCSzGhVG0zzLF6hb78h39BvYeEhEecai-E\\_YpycdghBjqvVzRdF4vqlITR1t1gRlETVXKgnYTV1jfJUcE)\n\n* **Бизнес-требования** (business requirements) выражают цель, ради которой разрабатывается продукт (зачем вообще он нужен, какая от него ожидается польза, как заказчик с его помощью будет получать прибыль). Результатом выявления требований на этом уровне является общее видение (vision and scope) - документ, который, как правило, представлен простым текстом и таблицами. Здесь нет детализации поведения системы и иных технических характеристик, но вполне могут быть определены приоритеты решаемых бизнес-задач, риски и т.п. Несколько простых, изолированных от контекста и друг от друга примеров бизнес-требований:\n  * Нужен инструмент, в реальном времени отображающий наиболее выгодный курс покупки и продажи валюты;\n  * Необходимо в два-три раза повысить количество заявок, обрабатываемых одним оператором за смену;\n  * Нужно автоматизировать процесс выписки товарно-транспортных накладных на основе договоров.\n* **Пользовательские требования** (user requirements) описывают задачи, которые пользователь может выполнять с помощью разрабатываемой системы (реакцию системы на действия пользователя, сценарии работы пользователя). Поскольку здесь уже появляется описание поведения системы, требования этого уровня могут быть использованы для оценки объема работ, стоимости проекта, времени разработки и т.д. Пользовательские требования оформляются в виде вариантов использования (use cases), пользовательских историй (user stories), пользовательских сценариев (user scenarios). Несколько простых, изолированных от контекста и друг от друга примеров пользовательских требований:\n  * При первом входе пользователя в систему должно отображаться лицензионное соглашение;\n  * Администратор должен иметь возможность просматривать список всех пользователей, работающих в данный момент в системе;\n  * При первом сохранении новой статьи система должна выдавать запрос на сохранение в виде черновика или публикацию.\n* **Бизнес-правила** (business rules) описывают особенности принятых в предметной области (и/или непосредственно у заказчика) процессов, ограничений и иных правил. Эти правила могут относиться к бизнес-процессам, правилам работы сотрудников, нюансам работы ПО и т.д. Несколько простых, изолированных от контекста и друг от друга примеров бизнес-правил:\n  * Никакой документ, просмотренный посетителями сайта хотя бы один раз, не может быть отредактирован или удален;\n  * Публикация статьи возможна только после утверждения главным редактором;\n  * Подключение к системе извне офиса запрещено в нерабочее время.\n* **Атрибуты качества** (quality attributes) расширяют собой нефункциональные требования и на уровне пользовательских требований могут быть представлены в виде описания ключевых для проекта показателей качества (свойств продукта, не связанных с функциональностью, но являющихся важными для достижения целей создания продукта - производительность, масштабируемость, восстанавливаемость). Атрибутов качества очень много, но для любого проекта реально важными является лишь некоторое их подмножество. Несколько простых, изолированных от контекста и друг от друга примеров атрибутов качества:\n  * Максимальное время готовности системы к выполнению новой команды после отмены предыдущей не может превышать одну секунду;\n  * Внесенные в текст статьи изменения не должны быть утеряны при нарушении соединения между клиентом и сервером;\n  * Приложение должно поддерживать добавление произвольного количества неиероглифических языков интерфейса.\n* **Функциональные требования** (functional requirements) описывают поведение системы, т.е. ее действия (вычисления, преобразования, проверки, обработку и т.д.). В контексте проектирования функциональные требования в основном влияют на дизайн системы. Стоит помнить, что к поведению системы относится не только то, что система должна делать, но и то, что она не должна делать (например: «приложение не должно выгружать из оперативной памяти фоновые документы в течение 30 минут с момента выполнения с ними последней операции»). Несколько простых, изолированных от контекста и друг от друга примеров функциональных требований:\n  * В процессе инсталляции приложение должно проверять остаток свободного места на целевом носителе;\n  * Система должна автоматически выполнять резервное копирование данных ежедневно в указанный момент времени;\n  * Электронный адрес пользователя, вводимый при регистрации, должен быть проверен на соответствие требованиям RFC822.\n* **Нефункциональные требования** (non-functional requirements) описывают свойства системы (удобство использования, безопасность, надежность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения. Здесь приводится более техническое и детальное описание атрибутов качества. В контексте проектирования нефункциональные требования в основном влияют на архитектуру системы. Несколько простых, изолированных от контекста и друг от друга примеров нефункциональных требований:\n  * При одновременной непрерывной работе с системой 1000 пользователей, минимальное время между возникновением сбоев должно быть более или равно 100 часов;\n  * Ни при каких условиях общий объем используемой приложением памяти не может превышать 2 ГБ;\n  * Размер шрифта для любой надписи на экране должен поддерживать настройку в диапазоне от 5 до 15 пунктов.\n\nСледующие требования в общем случае могут быть отнесены к нефункциональным, однако их часто выделяют в отдельные подгруппы (здесь для простоты рассмотрены лишь три таких подгруппы, но их может быть и гораздо больше; как правило, они проистекают из атрибутов качества, но высокая степень детализации позволяет отнести их к уровню требований к продукту).\n\n* **Ограничения** (limitations, constraints) представляют собой факторы, ограничивающие выбор способов и средств (в том числе инструментов) реализации продукта. Несколько простых, изолированных от контекста и друг от друга примеров ограничений:\n  * Все элементы интерфейса должны отображаться без прокрутки при разрешениях экрана от 800x600 до 1920x1080;\n  * Не допускается использование Flash при реализации клиентской части приложения;\n  * Приложение должно сохранять способность реализовывать функции с уровнем важности «критический» при отсутствии у клиента поддержки JavaScript.\n* **Требования к интерфейсам** (external interfaces requirements) описывают особенности взаимодействия разрабатываемой системы с другими системами и операционной средой. Несколько простых, изолированных от контекста и друг от друга примеров требований к интерфейсам:\n  * Обмен данными между клиентской и серверной частями приложения при осуществлении фоновых AJAX-запросов должен быть реализован в формате JSON;\n  * Протоколирование событий должно вестись в журнале событий операционной системы;\n  * Соединение с почтовым сервером должно выполняться согласно RFC3207 («SMTP over TLS»).\n* **Требования к данным** (data requirements) описывают структуры данных (и сами данные), являющиеся неотъемлемой частью разрабатываемой системы. Часто сюда относят описание базы данных и особенностей её использования. Несколько простых, изолированных от контекста и друг от друга примеров требований к данным:\n  * Все данные системы, за исключением пользовательских документов, должны храниться в БД под управлением СУБД MySQL, пользовательские документы должны храниться в БД под управлением СУБД MongoDB;\n  * Информация о кассовых транзакциях за текущий месяц должна храниться в операционной таблице, а по завершении месяца переноситься в архивную;\n  * Для ускорения операций поиска по тексту статей и обзоров должны быть предусмотрены полнотекстовые индексы на соответствующих полях таблиц.\n\n**Свойства качественных требований** (требования к самим требованиям)\n\n* **Завершенность** (completeness). Требование является полным и законченным с точки зрения представления в нем всей необходимой информации, ничто не пропущено по соображениям «это и так всем понятно». Типичные проблемы с завершенностью:\n  * Отсутствуют нефункциональные составляющие требования или ссылки на соответствующие нефункциональные требования (например: «пароли должны храниться в зашифрованном виде» - каков алгоритм шифрования?);\n  * Указана лишь часть некоторого перечисления (например: «экспорт осуществляется в форматы PDF, PNG и т.д.» - что мы должны понимать под «и т.д.»?);\n  * Приведённые ссылки неоднозначны (например: «см. выше» вместо «см. раздел 123.45.b»).\n* **Атомарность, единичность** (atomicity). Требование является атомарным, если его нельзя разбить на отдельные требования без потери завершенности и оно описывает одну и только одну ситуацию. Типичные проблемы с атомарностью:\n  * В одном требовании, фактически, содержится несколько независимых (например: «кнопка “Restart” не должна отображаться при остановленном сервисе, окно “Log” должно вмещать не менее 20-ти записей о последних действиях пользователя» - здесь зачем-то в одном предложении описаны совершенно разные элементы интерфейса в совершенно разных контекстах);\n  * Требование допускает разночтение в силу грамматических особенностей языка (например: «если пользователь подтверждает заказ и редактирует заказ или откладывает заказ, должен выдаваться запрос на оплату» - здесь описаны три разных случая, и это требование стоит разбить на три отдельных во избежание путаницы). Такое нарушение атомарности часто влечёт за собой возникновение противоречивости;\n  * В одном требовании объединено описание нескольких независимых ситуаций (например: «когда пользователь входит в систему, ему должно отображаться приветствие; когда пользователь вошел в систему, должно отображаться имя пользователя; когда пользователь выходит из системы, должно отображаться прощание» - все эти три ситуации заслуживают того, чтобы быть описанными отдельными и куда более детальными требованиями).\n* **Непротиворечивость, последовательность** (consistency). Требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам. Типичные проблемы с непротиворечивостью:\n  * Противоречия внутри одного требования (например: «после успешного входа в систему пользователя, не имеющего права входить в систему…» - тогда как он успешно вошёл в систему, если не имел такого права?);\n  * Противоречия между двумя и более требованиями, между таблицей и текстом, рисунком и текстом, требованием и прототипом и т.д. (например: «712.a Кнопка “Close” всегда должна быть красной» и «36452.x Кнопка “Close” всегда должна быть синей» - так всё же красной или синей?);\n  * Использование неверной терминологии или использование разных терминов для обозначения одного и того же объекта или явления (например: «в случае, если разрешение окна составляет менее 800x600…» - разрешение есть у экрана, у окна есть размер).\n* **Недвусмысленность** (unambiguousness, clearness). Требование должно быть описано без использования жаргона, неочевидных аббревиатур и расплывчатых формулировок, должно допускать только однозначное объективное понимание и быть атомарным в плане невозможности различной трактовки сочетания отдельных фраз. Типичные проблемы с недвусмысленностью:\n  * Использование терминов или фраз, допускающих субъективное толкование (например: «приложение должно поддерживать передачу больших объемов данных» - насколько «больших»?) Вот лишь небольшой перечень слов и выражений, которые можно считать верными признаками двусмысленности: адекватно (adequate), быть способным (be able to), легко (easy), обеспечивать (provide for), как минимум (as a minimum), быть способным (be capable of), эффективно (effectively), своевременно (timely), применимо (as applicable), если возможно (if possible), будет определено позже (to be determined, TBD), по мере необходимости (as appropriate), если это целесообразно (if practical), но не ограничиваясь (but not limited to), быть способно (capability of), иметь возможность (capability to), нормально (normal), минимизировать (minimize), максимизировать (maximize), оптимизировать (optimize), быстро (rapid), удобно (user-friendly), просто (simple), часто (often), обычно (usual), большой (large), гибкий (flexible), устойчивый (robust), по последнему слову техники (state-of-the-art), улучшенный (improved), результативно (efficient). Вот утрированный пример требования, звучащего очень красиво, но совершенно нереализуемого и непонятного: «В случае необходимости оптимизации передачи больших файлов система должна эффективно использовать минимум оперативной памяти, если это возможно»;\n  * Использование неочевидных или двусмысленных аббревиатур без расшифровки (например: «доступ к ФС осуществляется посредством системы прозрачного шифрования» и «ФС предоставляет возможность фиксировать сообщения в их текущем состоянии с хранением истории всех изменений» - ФС здесь обозначает файловую систему? Точно? А не какой-нибудь «Фиксатор Сообщений»?);\n  * Формулировка требований из соображений, что нечто должно быть всем очевидно (например: «Система конвертирует входной файл из формата PDF в выходной файл формата PNG» - и при этом автор считает совершенно очевидным, что имена файлов система получает из командной строки, а многостраничный PDF конвертируется в несколько PNG-файлов, к именам которых добавляется «page-1», «page-2» и т.д.). Эта проблема перекликается с нарушением корректности.\n* **Выполнимость** (feasibility). Требование должно быть технологически выполнимым и реализуемым в рамках бюджета и сроков разработки проекта. Типичные проблемы с выполнимостью:\n  * Так называемое «озолочение» (gold plating) - требования, которые крайне долго и/или дорого реализуются и при этом практически бесполезны для конечных пользователей (например: «настройка параметров для подключения к базе данных должна поддерживать распознавание символов из жестов, полученных с устройств трёхмерного ввода»).\n  * Технически нереализуемые на современном уровне развития технологий требования (например: «анализ договоров должен выполняться с применением искусственного интеллекта, который будет выносить однозначное корректное заключение о степени выгоды от заключения договора»).\n  * В принципе нереализуемые требования (например: «система поиска должна заранее предусматривать все возможные варианты поисковых запросов и кэшировать их результаты»).\n* **Обязательность, нужность** (obligatoriness) и актуальность (up-to-date). Если требование не является обязательным к реализации, оно должно быть просто исключено из набора требований. Если требование нужное, но «не очень важное», для указания этого факта используется указание приоритета (см. «проранжированность по…»). Также исключены (или переработаны) должны быть требования, утратившие актуальность. Типичные проблемы с обязательностью и актуальностью:\n  * Требование было добавлено «на всякий случай», хотя реальной потребности в нём не было и нет;\n  * Требованию выставлены неверные значения приоритета по критериям важности и/или срочности;\n  * Требование устарело, но не было переработано или удалено.\n* **Прослеживаемость** (traceability). Прослеживаемость бывает вертикальной (vertical traceability) и горизонтальной (horizontal traceability). Вертикальная позволяет соотносить между собой требования на различных уровнях требований, горизонтальная позволяет соотносить требование с тест-планом, тест-кейсами, архитектурными решениями и т.д. Для обеспечения прослеживаемости часто используются специальные инструменты по управлению требованиями (requirements management tool) и/или матрицы прослеживаемости (traceability matrix). Типичные проблемы с прослеживаемостью:\n  * Требования не пронумерованы, не структурированы, не имеют оглавления, не имеют работающих перекрестных ссылок;\n  * При разработке требований не были использованы инструменты и техники управления требованиями;\n  * Набор требований неполный, носит обрывочный характер с явными «пробелами».\n* **Модифицируемость** (modifiability). Это свойство характеризует простоту внесения изменений в отдельные требования и в набор требований. Можно говорить о наличии модифицируемости в том случае, если при доработке требований искомую информацию легко найти, а ее изменение не приводит к нарушению иных описанных в этом перечне свойств. Типичные проблемы с модифицируемостью:\n  * Требования неатомарны (см. «атомарность») и непрослеживаемы (см. «прослеживаемость»), а потому их изменение с высокой вероятностью порождает противоречивость (см. «непротиворечивость»);\n  * Требования изначально противоречивы (см. «непротиворечивость»). В такой ситуации внесение изменений (не связанных с устранением противоречивости) только усугубляет ситуацию, увеличивая противоречивость и снижая прослеживаемость;\n  * Требования представлены в неудобной для обработки форме (например, не использованы инструменты управления требованиями, и в итоге команде приходится работать с десятками огромных текстовых документов).\n* **Проранжированность по важности, стабильности, срочности** (ranked for importance, stability, priority). Важность характеризует зависимость успеха проекта от успеха реализации требования. Стабильность характеризует вероятность того, что в обозримом будущем в требование не будет внесено никаких изменений. Срочность определяет распределение во времени усилий проектной команды по реализации того или иного требования. Типичные проблемы с проранжированностью состоят в ее отсутствии или неверной реализации и приводят к следующим последствиям:\n  * Проблемы с проранжированностью по важности повышают риск неверного распределения усилий проектной команды, направления усилий на второстепенные задачи и конечного провала проекта из-за неспособности продукта выполнять ключевые задачи с соблюдением ключевых условий;\n  * Проблемы с проранжированностью по стабильности повышают риск выполнения бессмысленной работы по совершенствованию, реализации и тестированию требований, которые в самое ближайшее время могут претерпеть кардинальные изменения (вплоть до полной утраты актуальности);\n  * Проблемы с проранжированностью по срочности повышают риск нарушения желаемой заказчиком последовательности реализации функциональности и ввода этой функциональности в эксплуатацию.\n* **Корректность** (correctness) **и проверяемость** (verifiability). Фактически эти свойства вытекают из соблюдения всех вышеперечисленных (или можно сказать, что они не выполняются, если нарушено хотя бы одно из вышеперечисленных). В дополнение можно отметить, что проверяемость подразумевает возможность создания объективного тест-кейса (тест-кейсов), однозначно показывающего, что требование реализовано верно и поведение приложения в точности соответствует требованию. К типичным проблемам с корректностью также можно отнести:\n  * опечатки (особенно опасны опечатки в аббревиатурах, превращающие одну осмысленную аббревиатуру в другую также осмысленную, но не имеющую отношения к некоему контексту; такие опечатки крайне сложно заметить);\n  * наличие неаргументированных требований к дизайну и архитектуре;\n  * плохое оформление текста и сопутствующей графической информации, грамматические, пунктуационные и иные ошибки в тексте;\n  * неверный уровень детализации (например, слишком глубокая детализация требования на уровне бизнес-требований или недостаточная детализация на уровне требований к продукту);\n  * требования к пользователю, а не к приложению (например: «пользователь должен быть в состоянии отправить сообщение» - увы, мы не можем влиять на состояние пользователя).\n\n**Источники требований**:\n\n* Федеральное и муниципальное отраслевое законодательство (конституция, законы, распоряжения);\n* Нормативное обеспечение организации (регламенты, положения, уставы, приказы);\n* Текущая организация деятельности объекта автоматизации;\n* Модели деятельности (диаграммы бизнес-процессов);\n* Представления и ожидания потребителей и пользователей системы;\n* Журналы использования существующих программно-аппаратных систем;\n* Конкурирующие программные продукты.\n\n**Виды документов требований**:\n\n* **Спецификация требований к программному обеспечению** (SRS - Software Requirement Specification): представляет собой документ, подготовленный группой системных аналитиков (system analysts), который используется для описания программного обеспечения, которое будет разработано, основной бизнес-цели и функциональности определенного продукта, а также того, как он выполняет свои основные функции. В организациях, которые используют SRS, они обычно очень похожи на то, что описывается в PRD и FSD. SRS - это основа любого проекта, поскольку он состоит из структуры, которой будет следовать каждый член команды. SRS также является основой контракта с заинтересованными сторонами (пользователями / клиентами), который включает в себя все подробности о функциональности будущего продукта и о том, как он должен работать. SRS широко используется разработчиками программного обеспечения в процессе разработки продукта или программы. SRS включает как функциональные, так и нефункциональные требования, а также варианты использования. В идеальном документе SRS учитывается не только то, как программное обеспечение будет взаимодействовать с другим программным обеспечением или когда оно встроено в оборудование, но также потенциальных пользователей и способы их взаимодействия с программным обеспечением. Он также содержит ссылки на таблицы и диаграммы, чтобы получить четкое представление обо всех деталях, связанных с продуктом. Документ SRS помогает членам команды из разных отделов оставаться в единстве и обеспечивать выполнение всех требований. Этот документ также позволяет минимизировать затраты и время на разработку программного обеспечения.;\n* **Спецификация бизнес-требований** (BRS - Business Requirement Specification): BRS - это спецификация бизнес-требований, цель которой - показать, как удовлетворить бизнес-требования на более широком уровне. Документ BRS является одним из наиболее широко распространенных документов со спецификациями. Это очень важно, и BRS обычно создается в самом начале жизненного цикла продукта и описывает основные цели продукта или потребности, которые клиент хочет достичь с помощью определенного программного обеспечения или продукта. Он обычно создается бизнес-аналитиком (business analyst) на основе спецификаций других заинтересованных сторон и после тщательного анализа компании-клиента. Обычно окончательная версия документа проверяется клиентом, чтобы убедиться, что ожидания всех заинтересованных сторон бизнеса верны. BRS включает в себя все требования, запрошенные клиентом. Как правило, он состоит из цели продукта, пользователей, общего объема работ, всех перечисленных функций и возможностей, требований к удобству использования и производительности. В этот тип документа не включены варианты использования, а также диаграммы и таблицы. BRS используется в основном высшим и средним менеджментом, инвесторами в продукты, бизнес-аналитиками;\n* **Спецификация функциональных требований** (FRS - Functional Requirement Specification): документ, в котором описаны все функции, которые должно выполнять программное обеспечение или продукт. Фактически, это пошаговая последовательность всех операций, необходимых для разработки продукта от начала до конца. FRS объясняет подробности того, как определенные программные компоненты будут вести себя во время взаимодействия с пользователем. Этот документ создан квалифицированными разработчиками и инженерами и считается результатом тесного сотрудничества между тестировщиками и разработчиками. Основное отличие от документа SRS заключается в том, что FRS не включает варианты использования. Он также может содержать диаграммы и таблицы, но это не обязательно. Этот документ является наиболее подробным, поскольку в нем подробно объясняется, как программное обеспечение должно функционировать (включая бизнес-аспекты, соответствие требованиям, требования безопасности), поскольку оно также должно удовлетворять всем требованиям, упомянутым в документах SRS и BRS. FRS помогает разработчикам понять, какой продукт они должны создать, а тестировщики программного обеспечения лучше разбираются в различных тестовых примерах и сценариях, в которых ожидается тестирование продукта;\n* **Документ бизнес-требований** (BRD - Business Requirements Document, Business Needs Specification, Business Requirements): BRD фокусируются на определении бизнес задач проекта. BRD определяет одну или несколько бизнес задач стоящих перед пользователями, которые могут быть решены с помощью продукта компании. После этого предлагается решение - обычно это новый продукт или усовершенствование существующего продукта в нужной части. Он также может включать какой-то предварительный бизнес анализ - прогноз прибылей, анализ рынка и конкурентов, а также стратегию продаж и продвижения. Чаще всего он пишется Менеджером по продукту, Менеджером по маркетингу продукта или Бизнес аналитиком. В маленьких компаниях это может быть даже директор или владелец фирмы;\n*   **Документ требований рынка** (MRD - Market Requirements Document): MRD фокусируется на определении требований рынка к предлагаемому новому продукту. Если BRD определяет круг проблем и предлагает вариант их решения - то MRD более подробно описывает детали предлагаемого решения. Он может включать несколько или все нижеприведенные аспекты:\n\n    * Функциональные возможности, необходимые для решения бизнес задач;\n    * Анализ рынка и конкурентов;\n    * Функциональные и нефункциональные требования;\n    * Приоритезацию требований и функциональных возможностей;\n    * Варианты использования;\n\n    Чаще всего он пишется Менеджером по продукту, Менеджером по маркетингу продукта или Бизнес аналитиком совместно с Системным аналитиком. Некоторые организации объединяют MRD и PRD в один документ и называют этот документ MRD. В этом случае MRD будет включать то, что описано в этой части и то, что описано в следующей - и может содержать более 50 страниц;\n* **Документ требований к продукту** (PRD - Product Requirements Document): PRD фокусируется на определении требований к предлагаемому новому продукту. Если MRD фокусируется на требованиях с точки зрения нужд рынка, PRD фокусируется на требованиях с точки зрения самого продукта. Обычно он более детально описывает возможности и функциональные требования и может даже содержать скриншоты и лэйауты пользовательских интерфейсов. В организациях, где MRD не включает детализацию требований и варианты использования, PRD закрывает эту брешь. Обычно он пишется Менеджером по продукту, Бизнес аналитиком или Продуктовым аналитиком;\n* **Функциональная спецификация** (FSD - Functional Specifications Document): FSD детально определяет функциональные требования к продукту с фокусировкой на реализации. FSD может определять продукт последовательно форму за формой и одну функциональную возможность за другой. Это документ, который уже может непосредственно использоваться командой разработчиков для создания продукта. Если MRD и PRD фокусируются на требованиях с точки зрения потребностей рынка и продукта, FSD фокусируется на определении деталей продукта, в форме, которая может быть использована разработчиками. FSD может также включать законченные скриншоты и детальное описание пользовательских интерфейсов (UI). Обычно он пишется Системным аналитиком, Архитектором решения или Главным разработчиком - т.е. автор обычно сам относится к разработчикам;\n* **Спецификация продукта** (PSD - Product Specifications Document): PSD - это наименее популярная аббревиатура, но в тех организациях, которые используют эти документы, они обычно соответствуют по содержанию и объему Функциональной спецификации (Functional Specifications Document FSD) описанный выше;\n* **Спецификация функционального дизайна** (FDS - Functional Design Specification);\n* **Спецификация технического дизайна** (TDS - Technical Design Specification);\n* …\n\nТехники тестирования требований см. в теме “Тестирование документации” в видах тестирования.\n\nИсточники:\n\n* [Святослав Куликов “Тестирование программного обеспечения. Базовый курс”](https://svyatoslav.biz/software\\_testing\\_book/). Глава 2.\n* [Требования к программному обеспечению](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\\_%D0%BA\\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%BC%D1%83\\_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8E)\n* [Important Software Testing Documentation: SRS, FRS and BRS](https://dzone.com/articles/important-software-testing-documentation-srs-frs-a)\n* [BRD, MRD, PRD, FSD и прочие ТБА](https://www.sites.google.com/site/sloutskov/brd-mrd-prd-fsd-%D0%B8-%D0%BF%D1%80%D0%BE%D1%87%D0%B8%D0%B5-%D1%82%D0%B1%D0%B0)\n\nДоп. материал:\n\n* [Критерии качества требований и как им следовать](https://dou.ua/forums/topic/35139/)\n* [IEEE Guide to the Software Engineering Body of Knowledge](https://ieeecs-media.computer.org/media/education/swebok/swebok-v3.pdf). Chapter 1.\n* [Software Requirements Engineering: What, Why, Who, When, and How By Linda Westfall](http://www.westfallteam.com/Papers/The\\_Why\\_What\\_Who\\_When\\_and\\_How\\_Of\\_Software\\_Requirements.pdf)\n* Карл Вигерс «Разработка требований к программному обеспечению»\n* [Святослав Куликов “Тестирование программного обеспечения. Базовый курс”](https://svyatoslav.biz/software\\_testing\\_book/). Раздел 2.2.8. “Типичные ошибки при анализе и тестировании требований”.\n* [Не только функциональные требования](https://www.youtube.com/watch?v=3U7oxrpc7ek)\n* [Нефункциональные требования. Как не упустить качество продукта](https://www.youtube.com/watch?v=IEWlrZcqXCw)\n* [Интервью. Как говорить с людьми про требования](https://www.youtube.com/watch?v=Izw0086q8iM)\n* [«File Converter» Project Requirements SAMPLE](https://drive.google.com/file/d/1MV7IPacZZ77W0YGs6d3UHhCt-8Drpe6r/view)\n* [Системные требования и требования к программному обеспечению](https://intuit.ru/studies/curriculums/15720/courses/174/lecture/4714?page=2)\n* [Ицыксон В.М. ПТППО - Управление требованиями](http://kspt.icc.spbstu.ru/media/files/2010/course/se/requirements-management.pdf)\n* [Почему требования так важны для тестировщика](https://dou.ua/forums/topic/34549/)\n* [Явные и неявные требования](https://www.youtube.com/watch?v=4AYoRhbViwA)\n* [Сколько вопросов задавать по ТЗ](https://okiseleva.blogspot.com/2019/02/blog-post\\_28.html)\n* [Сбор требований по TROPOS](https://studopedia.ru/9\\_168380\\_metodologiya-proektirovaniya-Tropos.html)\n* [Принципы CustDev при сборе требований на разработку](https://www.youtube.com/watch?v=h7tZGDKVvvs)\n\n## Пользовательские истории (User stories)\n\n_Пользовательская история (user story): Высокоуровневое пользовательское или бизнес-требование, обычно использующееся в гибких методологиях разработки программного обеспечения. Обычно состоит из одного или нескольких предложений на разговорном или формальном языке, описывающих функциональность, необходимую пользователю, любые нефункциональные требования и включающих в себя критерии приемки. (ISTQB)_\n\nВ индустрии разработки ПО слово «требование» определяет нашу цель, что именно нужно клиентам и что заставит нашу компанию развивать свой бизнес. Будь то продуктовая компания, которая производит программные продукты, или сервисная компания, которая предлагает услуги в различных областях программного обеспечения, основной базой для всех из них является требование, а успех определяется тем, насколько хорошо эти требования выполняются. Термин «требование» имеет разные названия в разных методологиях проекта. В Waterfall это называется Requirement/Specification Document, в Agile или SCRUM требования документируются в виде «Epic» и «User Story». В модели Waterfall документы с требованиями представляют собой огромные документы на сотни страниц, поскольку весь продукт реализуется за один этап. Но это не относится к Agile / SCRUM, потому что в этих случаях требования предъявляются к небольшим функциям или фичам, поскольку продукт готовится поэтапно.\n\nПользовательская история определяет требования к любой функциональности или фиче, в то время как критерии приемки (Acceptance Criteria) определяют критерии готовности (Definition of done) для пользовательской истории или требования.\n\n![https://www.softwaretestinghelp.com/wp-content/qa/uploads/2018/02/User-Story-and-Acceptance-Criterion.jpg](https://www.softwaretestinghelp.com/wp-content/qa/uploads/2018/02/User-Story-and-Acceptance-Criterion.jpg)\n\n**Пользовательская история** - это требование для любой функциональности или фичи, которое записано в 1-2 строки. Пользовательская история обычно является самым простым из возможных требований и касается одной-единственной функции/фичи.\n\n**Формат**:\n\nКак /_роль пользователя или клиента_/, я хочу /_цель, которую нужно достичь_/, чтобы я мог /_причина цели_/.\n\nНапример, “Как _пользователь WhatsApp_, я хочу, чтобы _значок камеры в поле ввода чата позволял захватывать и отправлять изображения_, чтобы я мог _щелкнуть и поделиться своими фотографиями одновременно со всеми своими друзьями_.”\n\nЭто стандартный формат, но далеко не обязательный или единственно-возможный. Главное  в пользовательской истории -  это ценность, которую пользователь получит от функции, т.е. User Story -  это приём записи требований, который помогает команде разработки понять нужду клиента и после обсуждения выбрать, описать и утвердить то решение, которое удовлетворит эту нужду.\n\n**Job Stories**\n\nВ целом Job Stories - схожая с US техника. Можно назвать их приёмом-субститутом, ведь обычно они не используются вместе и выполняют максимально похожую функцию. Job Stories представляют требование в виде действия, которое выполняет пользователь. Они не описывают саму функцию, а лишь концентрируют внимание команды на потребности. Job Stories концентрируются на психологической части фичи, на эмоциях, тревогах и прочем, что может возникнуть во время использования функции.\n\n“Тело” JS делится на три части:\n\n* Situation: дает контекст обо всей JS, который помогает dev-команде придумать возможное решение;\n* Motivation: описывает невидимую руку, которая ведет юзера к использованию данной функции;\n* Expected Outcome: описывает, что получит юзер после использования функции.\n\nJob Stories могут писаться по двум форматам:\n\n* В одну строку: When X I want to Y so I can Z\" или \"When X, actor is Y so that Z;\n* В три строки:\n  * When X\n  * I want to Y\n  * So I can Z.\n\nПример: When I want to withdraw money from my bank account, I want to know I have enough money in my account to withdraw some now so that I can go out to dinner with my friends.\n\nИсточники:\n\n* [What Is User Story And Acceptance Criteria (Examples)](https://www.softwaretestinghelp.com/user-story-acceptance-criteria/)\n* [Гайд по User Stories](https://habr.com/ru/post/577420/)\n\nДоп. материал:\n\n* [User Stories Full Study: внутри и снаружи](https://www.youtube.com/watch?v=E07TXH\\_QpY0)\n* [10 советов для написания хороших пользовательских историй](https://habr.com/ru/company/otus/blog/546518/)\n* [Гайд по Job Stories в помощь к написанию user stories](https://dkapaev.medium.com/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BF%D0%BE-job-stories-c7d513f72e8f)\n* [Юзер-стори идеальная, а багов 100500? Как мы тестируем документацию](https://habr.com/ru/company/testit-tms/blog/564666/)\n* [Job Stories Offer a Viable Alternative to User Stories](https://www.mountaingoatsoftware.com/blog/job-stories-offer-a-viable-alternative-to-user-stories)\n* [25 sample user stories](https://www.yodiz.com/help/agile-user-stories-and-groomed-product-backlog/)\n* [User Stories](https://www.agilealliance.org/glossary/user-stories/#q=\\~\\(infinite\\~false\\~filters\\~\\(postType\\~\\(\\~'page\\~'post\\~'aa\\_book\\~'aa\\_event\\_session\\~'aa\\_experience\\_report\\~'aa\\_glossary\\~'aa\\_research\\_paper\\~'aa\\_video\\)\\~tags\\~\\(\\~'user\\*20stories\\)\\)\\~searchTerm\\~'\\~sort\\~false\\~sortDirection\\~'asc\\~page\\~1\\))\n* [User stories to acceptance criterias examples](https://i.pinimg.com/originals/35/4c/32/354c320f1bf9722791a7ccdbb40476cd.png)\n* [The User Story Value Hypothesis](https://qablog.practitest.com/the-user-story-value-hypothesis/)\n* [Use case или User story? Хватит выбирать - даешь все и сразу](https://www.youtube.com/watch?v=KNsznqqcUgI)\n","category":"manual","description":"Требования"},{"title":"Тестовый оракул","path":"/testovyj-orakul/","content":"\n## Тестовый оракул (Test oracle)\n\n_Тестовый предсказатель (test oracle): Источник, при помощи которого можно определить ожидаемые результаты для сравнения с реальными результатами, выдаваемыми тестируемой системой. В роли тестового предсказателя могут выступать уже имеющаяся система (для эталонного тестирования), руководство пользователя, профессиональные знания специалиста, однако им не может быть программный код. (ISTQB)_\n\n**Тестовый оракул** - это механизм для определения того, прошел ли тест или нет. Использование оракулов включает сравнение (для заданных входных данных тестового примера) выходных данных тестируемой системы с выходными данными, которые, по определению оракула, должен иметь продукт. Термин «тестовый оракул» впервые был введен в статье Уильяма Э. Хаудена. Дополнительная работа над различными видами оракулов была исследована Элейн Вейкер.\n\n**Категории тестовых оракулов**:\n\nОпределенные (**Specified**): Эти оракулы обычно связаны с формализованными подходами к моделированию программного обеспечения и построению программного кода. Они связаны с formal specification, model-based design, который может использоваться для создания тестовых оракулов, state transition specification, для которой могут быть получены оракулы, чтобы помочь model-based testing and protocol conformance testing, and design by contract, для которого эквивалентный тестовый оракул является утверждением (assertion). Указанные тестовые оракулы имеют ряд проблем. Формальная спецификация основана на абстракции, которая, в свою очередь, может иметь элемент неточности, поскольку все модели не могут зафиксировать все поведение;\n\nПолученные (**Derived**): полученный тестовый оракул различает правильное и неправильное поведение, используя информацию, полученную из артефактов системы. Они могут включать в себя документацию, результаты выполнения системы и характеристики версий тестируемой системы. Regression test suites (or reports) являются примером производного тестового оракула - они построены на предположении, что результат из предыдущей версии системы может быть использован в качестве помощника (оракула) для будущей версии системы. Ранее измеренные характеристики производительности могут быть использованы в качестве оракула для будущих версий системы, например, чтобы задать вопрос о наблюдаемом потенциальном ухудшении производительности. Текстовая документация из предыдущих версий системы может использоваться в качестве основы для определения ожиданий в будущих версиях системы. Псевдо-оракул попадает в категорию полученных тестовых оракулов. Псевдо-оракул, по определению Вейукера, представляет собой отдельно написанную программу, которая может принимать те же входные данные, что и тестируемая программа или система, так что их выходные данные могут быть сопоставлены, чтобы понять, может ли быть проблема для исследования. Частичный оракул - это гибрид указанного тестового оракула и производного тестового оракула. Он определяет важные (но не полные) свойства тестируемой системы. Например, при метаморфическом тестировании (Metamorphic testing) такие свойства, называемые метаморфическими отношениями, используются при нескольких запусках системы.\n\nПримеры:\n\n* формальная спецификация, используемая в качестве входных данных для model-based design and model-based testing;\n* документация, которая не является полной спецификацией продукта, такая как руководство по использованию или установке, или запись характеристик производительности или минимальных требований;\n* оракул согласованности, сравнивающий результаты выполнения одного теста с другим на предмет сходства;\n* псевдо-оракул: вторая программа, которая использует другой алгоритм для вычисления того же математического выражения, что и тестируемый продукт;\n* Specified+derived: во время поиска Google у нас нет полного оракула, чтобы проверить правильность количества возвращенных результатов. Мы можем определить метаморфическое отношение так, что последующий суженный поиск будет давать меньше результатов.\n\nНеявные (**Implicit**): Неявный тестовый оракул полагается на подразумеваемую информацию и предположения. Например, может быть какой-то подразумеваемый вывод из сбоя программы, то есть нежелательное поведение - оракул, чтобы определить, что может быть проблема. Существует несколько способов поиска и тестирования нежелательного поведения, независимо от того, называют ли это отрицательным тестированием, где есть специализированные подмножества, такие как фаззинг. У неявных тестовых оракулов есть ограничения, поскольку они полагаются на подразумеваемые выводы и предположения. Например, сбой программы или процесса может не быть приоритетной проблемой, если система является отказоустойчивой и поэтому работает в форме самовосстановления / самоуправления. Неявные тестовые оракулы могут быть подвержены ложным срабатываниям из-за зависимостей от среды;\n\nЧеловек (**Human**): Если предыдущие категории оракулов не могут быть использованы, то потребуется участие человека. Это можно рассматривать как количественный и качественный подходы. Количественный подход направлен на поиск нужного количества информации, которую нужно собрать о тестируемой системе (например, результатов тестирования), чтобы заинтересованная сторона могла сделать решения о соответствии или выпуске программного обеспечения. Качественный подход направлен на определение репрезентативности и пригодности входных данных тестирования и контекста выходных данных тестируемой системы. Примером может служить использование реалистичных и репрезентативных данных испытаний и понимание результатов (если они реалистичны). При этом можно руководствоваться эвристическими подходами, такими как интуиция, эмпирические правила, вспомогательные контрольные списки и опыт, чтобы помочь адаптировать конкретную комбинацию, выбранную для тестируемой программы / системы.\n\nПримеры:\n\n* Качественный: эвристический оракул предоставляет репрезентативные или приблизительные результаты по классу тестовых входных данных;\n* Количественный: статистический оракул использует вероятностные характеристики, например, с анализом изображений, где определен диапазон достоверности и неопределенности для того, чтобы тестовый оракул решил о совпадении.\n\nИсточники:\n\n* [Test oracle](https://en.wikipedia.org/wiki/Test\\_oracle)\n\nДоп. материал:\n\n* [Оракулы в тестировании](https://telegra.ph/Orakuly-v-testirovanii-10-17)\n* [Oracles from the inside out](https://www.developsense.com/blog/2015/09/oracles-from-the-inside-out/)","category":"manual","description":"Тестовый оракул"},{"title":"Международные стандарты тестовой документации","path":"/mezhdunarodnye-standarty-testovoj-dokumentaczii/","content":"\nСтандарт ANSI/IEEE 829-1983 на Документацию по тестированию программного обеспечения (STD — Software Test Documentation), заново подтвержденный в 1991 году, состоит из следующих разделов:\n\n1. **Введение**\n\nВ разделе Введение объясняется содержание тестов и их общие принципы. \n\n_Например_, если программа управляет оборудованием помещения скорой помощи, именно в этом разделе мы должны объяснить наш общий подход к тестированию моделей, сводящийся к тестированию в условиях данных помещений.\n\n2. **План тестирования**\n\nТестируемые элементы, границы, подход, ресурсы, расписание, персонал.\n\nПлан тестирования объясняет, как следует организовать персонал, программы и оборудование, чтобы выполнить тестирование. \n\n_Например_: «Временной модуль будет тестировать Джо на протяжении недель 30-33; модуль мониторинга сердца будет тестировать Сьюзан на протяжении недель 26-30; интеграцию этих двух модулей будет тестировать Эд на протяжении недель 31-33;... ».\n\n3. **Проект тестирования**\n\nТестируемые элементы, подход, план в подробностях.\n\nПроект тестирования отражает следующий уровень детализации после плана тестирования. Он раскрывает значение соответствующих программных элементов, описывает порядок, в котором их следует тестировать, называет тестовые варианты, которые следует применить. \n\n_Например_: «Джо будет тестировать временной модуль отдельно на протяжении недель 30-33, используя тестовую процедуру 892 и драйвер 8910; Сьюзан будет тестировать модуль мониторинга сердца отдельно на протяжении недель 26-30, используя тестовую процедуру 555 и драйвер 3024; Эд будет тестировать сборку, интегрирующую эти два модуля (сборка 7), используя...».\n\n4. **Тестовые варианты**\n\nНаборы входных данных и событий.\n\n5. **Тестовые процедуры**\n\nШаги настройки и выполнения тестовых вариантов.\n\n6. **Отчет о проведении тестирования элементов**\n\nТестируемый элемент, физическое местоположение результатов, ответст-венный за проведение тестов.\n\n7. **Журнал испытаний**\n\nХронологическая запись, физическое местоположение теста, название теста.\n\n8. **Отчет о происшествиях во время тестирования** \n\nДокументирование любого события, имевшего место во время тестирования, требующего дальнейших расследований.\n\n9. **Итоговый отчет о тестировании**\n\nИтог всего вышеперечисленного.","category":"manual","description":"Международные стандарты тестовой документации"},{"title":"Master Test Plan и тестовые планы для каждого уровня","path":"/master-test-plan-i-testovye-plany-dlya-kazhdogo-urovnya/","content":"\n## План тестирования (Test plan)\n\n_“План тестирования (test plan): Документ, описывающий цели, подходы, ресурсы и график запланированных тестовых активностей. Он определяет объекты тестирования, свойства для тестирования, задания, ответственных за задания, степень независимости каждого тестировщика, тестовое окружение, метод проектирования тестов, определяет используемые критерии входа и критерии выхода и причины их выбора, а также любые риски, требующие планирования на случай чрезвычайных обстоятельств.” (IEEE 829)_\n\nВ то время как стратегия излагает общие принципы или теорию, план детально описывает практические аспекты того, как проект будет протестирован в реальности.\n\nХотя есть рекомендации по составлению тест плана (IEEE 829 ([1](https://www.ecs.csun.edu/\\~rlingard/comp480/TestPlanTemplate.pdf), [2](https://jmpovedar.files.wordpress.com/2014/03/ieee-829.pdf)), [RUP](https://tmguru.ru/wp-content/uploads/2015/01/TestPlanTemplate\\_RUP.pdf)), нет единственно правильного шаблона или формата для написания тест-планов. В обзорных статьях можно встретить и свои варианты:\n\n[Такой](https://theqalead.com/topics/leadership-in-test-test-planning/):\n\n* Перечень планируемых тестовых активностей ([Test Activities](https://theqalead.com/wp-content/uploads/2021/06/Test-activities-infographic-1024x579.png));\n* Тестовая логистика ([Test Logistics](https://theqalead.com/wp-content/uploads/2021/06/Test-logistics-infographic-1024x579.png));\n* Необходимые ресурсы ([Resources](https://theqalead.com/wp-content/uploads/2021/06/Resources-infographic-1024x579.png));\n* Необходимые коммуникации ([Your Support Network](https://theqalead.com/wp-content/uploads/2021/06/Typical-requirements-infographic-1024x579.png));\n* Оценки трудозатрат (Estimates);\n* Зависимости и риски (Dependencies, Risks and Assumptions);\n* Порядок обсуждений и отчетности в процессе работы (Communication, Commitment and Progress Reporting);\n\nИли:\n\n* Какие ресурсы требуются и когда;\n* Когда задачи нужно начинать и заканчивать, и кто их будет выполнять;\n* Навыки, необходимые для выполнения задач;\n* Инструменты и технологии, поддерживающие план;\n* Результаты и когда они будут доставлены;\n* Затраты на усилия и необходимые ресурсы;\n* Процесс продвижения проекта / процесса по стадиям;\n* Риски, угрожающие доставке.\n\nВ какой-то момент можно заметить, что все они предлагают плюс-минус похожую структуру и пункты, а итоговый вариант всё равно будет уникальным для каждого конкретного проекта. Весомая часть литературы по данной теме предполагает работу по водопадной модели разработки и эта информация не так актуальна в наше время. Это не значит, что в гибких методологиях не бывает тест-планов. Даже в Agile необходимо предварительное планирование для структурирования работы, распределения ресурсов и планирования - по крайней мере, на высоком уровне - процесса выпуска на ближайшие месяцы. Но итерация за итерацией, а часто и день за днем, общий план постоянно корректируется с учетом событий и новой информации, которая появляется на свет. Планирование - это непрерывное обучение, а не задача с конечным результатом.\n\nВ гибких методологиях всё чаще говорят о концепции одностраничного тест-плана, а в случае необходимости дополнений и уточнений просто создаются ссылки на внешние страницы/документы. Такой план может быть и в гугл-таблицах, в виде дашборда, mind map, и как вам самим вздумается. Тест-план призван отвечать на те вопросы, ради которых его создают. Порой весомую часть пользы от данной активности можно получить на этапе самого планирования и составления плана, а не от самого документа. Если команда понимает, что никакой практической “боли” этот документ и его создание не решает, на него нет времени, то можно прекрасно обойтись и без его формализации, т.к. в некоей словесной форме он всё равно будет существовать всегда.\n\n_“В зависимости от размеров команды, сложности продукта, количества зависимостей и строгости критериев качества эти вопросы могут быть иными. Если процесс тестирования имеет большое количество зависимостей, например разные команды должны выполнять разные этапы тестирования в строго определенном порядке - это необходимо фиксировать. Без этого ты не только не сможешь планировать работу команд, но и несколько раз выстрелишь себе в ногу, когда команды будут блокировать друг друга из-за того, что заранее не проговорили зависимости. Чем более комплексным является объект тестирования (и как результат само тестирование), тем более подробного описания требует методология тестирования, применяемые подходы и практики - просто за счёт увеличения объема того, что необходимо проверить. Без этого сложно оценивать объемы работ, давать эстимейты и строить планы по релизам. Чем более точно и строго необходимо оценивать уровень качества, тем более детально должны быть описаны критерии прохождения тестирования, ключевые метрики и_ [_quality gate_](https://habr.com/ru/post/542676/)_\\`ы. Потому что без их формализации нельзя будет однозначно оценить результаты тестирования. Люди, находящиеся за пределами команды тестирования (а иногда и команды разработки в целом) хотят понимать, что вообще происходит на этапе тестирования и как обеспечивается качество продукта. Иногда это связано с регуляторикой отрасли, иногда для согласования объемов работы с заказчиком, иногда из-за высокой степени рисков или просто потому, что работа этих людей напрямую зависит от результатов процесса обеспечения качества.“ (с)_ [_Shoo and Endless Agony: What's the plan?_](https://t.me/shooandendlessagony/76)\\_\\_\n\n**Виды тест-планов**:\n\n* **Мастер Тест-План** ([Master Test Plan](https://tryqa.com/what-are-master-test-plans-level-test-plan-examples-when-to-use/)): \\_“Главный план тестирования (master test plan, project test plan): План тестирования, обычно охватывающий несколько уровней тестирования.” (ISTQB). \\_Это может быть как единственный базовый план, так и главный в иерархии нескольких планов, самый статичный и высокоуровневый. Нужен когда:\n  * продукт имеет множество релизов или итераций, между которыми сохраняется общая информация, которую нет смысла повторять;\n  * различные тестовые команды работают над одним продуктом, выполняя различные задачи, которые необходимо объединить в рамках одного документа;\n* **Детальный Тест-план** (Phase Test plan): _“Уровневый план тестирования (level test plan): План тестирования, обычно относящийся к одному уровню тестирования.” (ISTQB)._ Детальный план составляется на каждый релиз/итерацию или для каждой команды в рамках проекта и является динамическим, т.е. может претерпевать изменения по необходимости. Его основная цель - кратко и доходчиво отразить задачи тестирования. Детальных планов может быть несколько для отдельных модулей ПО или команд тестирования. Кроме того, могут быть созданы планы для отдельных уровней тестирования (Level Test Plan) или видов тестирования. В Agile проектах могут быть планы итерационного тестирования ([iteration testing plans](https://tryqa.com/what-is-release-and-iteration-planning-in-agile-methodology/)) для каждой итерации;\n* **План приемочных испытаний** (Acceptance Test Plan, ПСИ):\\*\\* \\*\\*план приемочного тестирования отличают от обычного плана тестирования факторы, которые приводят к принятию бизнес-решения. План приемочного тестирования - это один из жизненно важных документов, который содержит руководство по выполнению приемочного тестирования для конкретного проекта. Пишется на основе бизнес-требований (Business Requirements). Ревью этого плана обычно выполняется by Managers/Business Analysts/Customers.\n\n**Тест план (Test Plan)** — это документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.\nОтвечает на вопросы:\nЧто надо тестировать?\nЧто будете тестировать?\nКак будете тестировать?\nКогда будете тестировать?\nКритерии начала тестирования.\nКритерии окончания тестирования.\n\nОсновные пункты тест плана\nВ стандарте IEEE 829 перечислены пункты, из которых должен (пусть — может) состоять тест-план:\na) Test plan identifier;\nb) Introduction;\nc) Test items;\nd) Features to be tested;\ne) Features not to be tested;\nf) Approach;\ng) Item pass/fail criteria;\nh) Suspension criteria and resumption requirements;\ni) Test deliverables;\nj) Testing tasks;\nk) Environmental needs;\nl) Responsibilities;\nm) Staffing and training needs;\nn) Schedule;\no) Risks and contingencies;\np) Approvals.\n\nИсточники:\n\n* [Leadership in test: test planning](https://theqalead.com/topics/leadership-in-test-test-planning/)\n* [Acceptance Testing Documentation With Real-Time Scenarios](https://www.softwaretestinghelp.com/acceptance-test-plan/)\n\nДоп. материал:\n\n* [The Inquiry Method for Test Planning](https://testing.googleblog.com/2016/06/the-inquiry-method-for-test-planning.html)\n* [Тест-план не для галочки, или 8 вопросов к заказчику на старте проекта](https://dou.ua/lenta/columns/creating-quality-test-plan/)\n* [Blog: What Should A Test Plan Contain?](https://www.developsense.com/blog/2008/12/what-should-test-plan-contain/)\n* [The One Page Test Plan](https://www.ministryoftesting.com/dojo/lessons/the-one-page-test-plan)\n* [TEST PLAN: What is, How to Create (with Example)](https://www.guru99.com/what-everybody-ought-to-know-about-test-planing.html)\n* [Developing a solid yet simple test plan](https://www.softwaretestingnews.co.uk/developing-a-solid-yet-simple-test-plan/)\n* [Тест-план и тест-стратегия: преимущества, состав, советы по ведению](https://dou.ua/forums/topic/35324/?from=fpcol)\n* [Действительно ли вам нужен тест-план?](https://telegra.ph/Dejstvitelno-li-vam-nuzhen-test-plan-11-03)\n* [Что такое тест план и как его написать?](https://testengineer.ru/chto-takoe-test-plan-i-kak-ego-napisat/)\n* [End-to-end, приди и порядок наведи](https://habr.com/ru/company/arcadia/blog/653773/)\n* [Еще одна история о важности Тест Плана](https://serioustester.io/tpost/eeseb021v1-esche-odna-istoriya-o-vazhnosti-test-pla)\n* Примеры: [раз](https://testerchronicles.ru/wp-content/uploads/2018/03/2018-03-12\\_16-33-10.png), [два](https://hsto.org/getpro/habr/upload\\_files/5be/94e/842/5be94e842c3417a918830cc9f5f1b785.png); [Acceptance Test Plan Template](https://www.softwaretestinggenius.com/docs/tplatp.doc)\n","category":"manual","description":"Master Test Plan и тестовые планы для каждого уровня"},{"title":"Понятие Test Case и Test Suite","path":"/ponyatie-test-case-i-test-suite/","content":"\n## Тестовый сценарий (Test scenario)\n\n_Сценарий выполнения (test scenario): См. спецификация процедуры тестирования. (ISTQB)_\n\n_Спецификация процедуры тестирования (test procedure specification): Документ, описывающий последовательность действий при выполнении теста. Также известен как ручной сценарий тестирования. (IEEE 829) См. также спецификация теста_\n\n_Спецификация теста (test specification): Документ, состоящий из спецификации проектирования теста, спецификации тестовых сценариев и/или спецификации процедуры тестирования (ISTQB)_\n\n**Тестовый сценарий** (Test scenario) - последовательность действий над продуктом, которые связаны единым ограниченным бизнес-процессом использования, и сообразных им проверок корректности поведения продукта в ходе этих действий. Иными словами, это последовательность шагов, которые пользователь может предпринять, чтобы использовать ваше программное обеспечение. Сценарии тестирования должны учитывать все возможные способы выполнения задачи (функции) и охватывать как положительные, так и отрицательные тестовые примеры, потому что конечные пользователи могут не обязательно предпринимать шаги, которые вы от них ожидаете. Используя тестовые сценарии, мы оцениваем работу приложения с точки зрения конечного пользователя. Фактически при успешном прохождении всего тестового сценария мы можем сделать заключение о том, что продукт может выполнять ту или иную возложенную на него функцию.\n\n**Как писать сценарии**:\n\n* Тщательно ознакомьтесь с требованиями (Спецификация бизнес-требований (BRS), Спецификация требований к программному обеспечению (SRS), Спецификация функциональных требований (FRS)) тестируемой системы (SUT), use cases, книгами, руководствами и т. д.;\n* Для каждого требования выясните, как пользователь может использовать программное обеспечение всеми возможными способами;\n* Составьте список сценариев тестирования для каждой функции тестируемого приложения (AUT);\n* Создайте матрицу прослеживаемости и свяжите все сценарии с требованиями. Это позволит вам определить, сопоставлены ли все требования с тестовыми сценариями или нет;\n* Отправьте сценарии тестирования руководителю, чтобы он рассмотрел и оценил их. Даже сценарии тестирования дополнительно проверяются всеми заинтересованными сторонами.\n\nНе стоит путать Test scenario с **Test Suite** (набор тестов, тест-свит).\n\n_Набор тестов (test suite): Комплект тестовых наборов для исследуемого компонента или системы, в котором обычно постусловие одного теста используется в качестве предусловия для последующего. (ISTQB)_\n\nTest Suite - это некоторый набор формализованных Test case, объединенных между собой по общему логическому признаку, которые позволяют проверить одну из частей или вариантов сценария. Test Scenario представляет собой некий пользовательский сценарий по тестированию некой функциональности. Что-то, что пользователь может захотеть сделать с вашей системой, и вы хотите это проверить. Сценарий может иметь один или несколько Test Suite.\n\nИсточники:\n\n* [How To Create Test Scenarios With Examples](https://www.softwaretestingmaterial.com/test-scenarios/)\n* [Каких ответов я жду на собеседовании по тестированию](https://habr.com/ru/post/254209/)\n\nДоп. материал:\n\n* [Test Scenarios Registration Form](https://www.softwaretestingmaterial.com/test-scenarios-registration-form/)\n* [Test Scenarios of GMail](https://www.softwaretestingmaterial.com/test-scenarios-of-gmail/)\n* [Шаблон сценария](https://www.softwaretestingmaterial.com/wp-content/uploads/2021/11/Sample-Test-Scenario-Template.xlsx)\n\n## Тест-кейс (Test case)\n\n_Тестовый сценарий (test case): Набор входных значений, предусловий выполнения, ожидаемых результатов и постусловий выполнения, разработанный для определенной цели или тестового условия, таких как выполнения определенного пути программы или же для проверки соответствия определенному требованию. (IEEE 610)_\n\n**Test case** (тест-кейс, тестовый пример/случай) - это артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или ее части. Более строго - формализованное описание одной показательной проверки на соответствие требованиям прямым или косвенным.\n\n**Содержание тест-кейса**:\n\n* Идентификатор набора тестов (**Test Suite ID**): Идентификатор набора тестов, в которых входит этот кейс;\n* Идентификатор тестового кейса (**Test Case ID**): Идентификатор самого кейса;\n* Заголовок кейса (**Test Case Summary**): Краткое и емкое название проводимой проверки;\n* Связанное требование (**Related Requirement**): Идентификатор требования, к которому относится / отслеживается данный тестовый пример;\n* Предварительные условия (**Prerequisites**): Любые предпосылки или предварительные условия, которые должны быть выполнены перед выполнением теста;\n* Шаги выполнения (**Test Script / Procedure**): Шаги выполнения теста;\n* Тестовые данные (**Test Data**): Тестовые данные или ссылки на тестовые данные, которые должны использоваться при проведении теста;\n* Ожидаемый результат (**Expected Result**): результат, который мы ожидаем получить после выполнения шагов теста;\n* Статус пройден или не пройден (**Status**): Другие статусы могут быть «Не выполнено», если тестирование не проводится, и «Заблокировано», если тестирование заблокировано;\n* Заметки (**Remarks**): Любые комментарии к тесту или выполнению теста;\n* Создано (**Created By**): Имя автора тестового примера;\n* Дата создания (**Date of Creation**): Дата создания тестового примера (опционально модификации);\n* Выполнено (**Executed By**): Имя человека, выполнившего тест;\n* Дата выполнения (**Date of Execution**): Дата выполнения теста;\n* Тестовое окружение (**Test Environment**): оборудование / программное обеспечение / сеть, в которых выполнялся тест, т.е. все необходимые сведения об окружении, чтобы можно было воспроизвести полученный результат.\n\nВ иностранной литературе часто делят кейсы на две категории:\n\n* **Высокоуровневый тест-кейс** (high level test case или logical test case) - тест-кейс без конкретных входных данных и ожидаемых результатов. Как правило, ограничивается общими идеями и операциями, схож по своей сути с подробно описанным пунктом чек-листа. Достаточно часто встречается в интеграционном тестировании и системном тестировании, а также на уровне smoke. Может служить отправной точкой для проведения исследовательского тестирования или для создания низкоуровневых тест-кейсов.\n* **Низкоуровневый тест-кейс** (low level test case) - тест-кейс с конкретными входными данными и ожидаемыми результатами. Представляет собой «полностью готовый к выполнению» тест-кейс и вообще является наиболее классическим видом тест-кейсов. Начинающих тестировщиков чаще всего учат писать именно такие тесты, т.к. прописать все данные подробно - намного проще, чем понять, какой информацией можно пренебречь, при этом не снизив ценность тест-кейса.\n\n**Нужно ли вообще писать кейсы?** Ответ тот же, что и для любого документа - если написание кейсов решает определенную задачу и это обоснованно, то писать. Если вы один, не путаетесь в небольшом проекте, пользуетесь чек листами/mind map/.., можете и без TMS/test runs reports наглядно предоставлять актуальные сведения о протестированности/качестве заинтересованным лицам, то не писать.\n\n**Может ли быть несколько ожидаемых результатов?** Может, если это необходимо, но сразу после каждого шага.\n\n**Можно ли объединять позитивные и негативные тест-кейсы?** Позитивные можно, негативные нельзя, поскольку сложно будет понять, что именно влияет на результат.\n\nИсточники:\n\n* [Test Case](https://softwaretestingfundamentals.com/test-case/)\n\nДоп. материал:\n\n* [Тест-кейсы: полная лекция из ШНАТ](https://www.youtube.com/watch?v=0xuOOlhb5SQ)\n* [Составление тест-кейсов](https://www.youtube.com/watch?v=VG8hAQjxAkI)\n* [12 характеристик высокоэффективных тестов](https://software-testing.ru/library/testing/test-analysis/3495-12-traits-of-highly-effective-tests)\n* [Blog: Evaluating Test Cases, Checks, and Tools](https://www.developsense.com/blog/2021/04/evaluating-test-cases-checks-and-tools/)\n* [How to write Test Cases for a Login Page](https://www.softwaretestingmaterial.com/test-scenarios-login-page/)\n* [Как писать тест-кейсы: полное руководство](https://testengineer.ru/kak-pisat-test-kejsy-polnoe-rukovodstvo/)\n* [Основные методики создания тест-кейсов](https://testengineer.ru/osnovnye-metodiki-sozdaniya-test-kejsov/)\n* [Вложил в тест-кейс аттач? Поясни его!](https://okiseleva.blogspot.com/2018/11/blog-post\\_23.html)\n* [Результат в тест-кейсе - один или много?](https://okiseleva.blogspot.com/2020/05/blog-post\\_14.html)\n* [Правила написания предварительных шагов в тест-кейсах](https://okiseleva.blogspot.com/2019/12/blog-post\\_24.html)\n* [Название тест-кейса - как оформлять](https://okiseleva.blogspot.com/2020/12/blog-post\\_17.html)\n* [5 атрибутов хорошего тест-кейса. Правила написания тест-кейсов. Тест-кейсы в TestRail.](https://www.youtube.com/watch?v=S4UyfH\\_QNec)\n* Примеры: [раз](https://drive.google.com/uc?export=download\\&id=0ByI5-ZLwpo25eXFlcU5ZMTJsT28), [два](https://www.softwaretestingmaterial.com/wp-content/uploads/2016/02/Sample-Test-Case-Template-1.png)","category":"manual","description":"Понятие Test Case и Test Suite"},{"title":"Понятие Test Basis, Test Condition и Test Procedure","path":"/ponyatie-test-basis-test-condition-i-test-procedure/","content":"\n## Базис тестирования (Test basis)\n\n_Базис тестирования (test basis): Документ, на основании которого определяются требования к компоненту или системе. Документация, на которой базируются тестовые сценарии. Если правка данного документа может быть осуществлена только в процессе формальной процедуры внесения изменения, то такой базис тестирования называется замороженным базисом тестирования. (ISTQB)_\n\n_Базис тестирования (test basis): Свод знаний, используемых в качестве базы проекта тестирования и контрольных примеров. Примечание - Базис тестирования может иметь форму документов, таких как спецификация требований, спецификация проекта или спецификация модуля, но может также представлять собой недокументированное понимание требуемого поведения. (ГОСТ 56920)_\n\n_Тестовое условие (test condition): Тестируемый аспект компонента или системы, такой как функция, транзакция, возможность, атрибут качества или структурный элемент, идентифицированные как базис тестирования. (ГОСТ 56920)_\n\nБазис тестирования определяется как источник информации или документ, необходимый для написания кейсов, а также как данные для начала анализа тестов. Им может выступать:\n\n* System Requirement Document (SRS);\n* Functional Design Specification;\n* Technical Design Specification;\n* User Manual;\n* Use Cases;\n* Source Code;\n* Business Requirement Document (BRD);\n* ?User story;\n* ?Vision;\n* ?Mockup;\n* ?Prototype.\n\nПо [ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013](https://docs.cntd.ru/document/1200134996) примерами базиса тестирования являются:\n\n* ожидания по формату и содержанию документации, обычно в форме стандартов и/или контрольных списков;\n* ожидания потребителя/пользователя по программной системе, новой или уже существующей, обычно спецификаций требований в письменной форме. Они могут быть представлены как функциональные/нефункциональные описания с употреблением глагола \"должен\", содержащие варианты использования, истории пользователя или другие формы неформально или формально записанные требования. Сюда могут быть включены нормативные требования, которые должны соблюдаться для определенных типов продуктов, например, для критичного к безопасности программного обеспечения для фармацевтической промышленности или для транспортных систем, таких как поезд или самолет;\n* опыт тестера или экспертов в другой предметной области по работе с функциями, необходимыми пользователям, или с историей продукта;\n* ожидания по прямым и/или косвенным интерфейсам между компонентами программной системы и/или по сосуществованию компонентов программной системы, обычно в форме проекта архитектуры в виде схем и/или формального письменного определения протокола;\n* ожидания по реализации компонентов программной системы в коде, обычно в форме детального проекта.\n\nБазис тестирования должен быть четко определен и должным образом структурирован, чтобы можно было легко определить условия тестирования, из которых можно получить тестовые примеры.\n\n_Тестовое условие (test condition): Объект или событие в компоненте или системе, которое должно быть проверено одним или несколькими тестовыми наборами. Например: функция, транзакция, параметр, атрибут качества или структурный элемент. (ISTQB)_\n\nТестовое условие - тестируемый аспект в test basis.\n\nИсточники:\n\n* [Test Basis in Software Testing](https://www.professionalqa.com/test-basis)\n","category":"manual","description":"Понятие Test Basis, Test Condition и Test Procedure"},{"title":"Check-list, как представитель Experience-Based","path":"/check-list-kak-predstavitel-experience-based/","content":"\n## Чек-лист (Check List)\n\nКонтрольный список/лист проверок - это список проверок, которые помогают тестировщику протестировать приложение или отдельные функции. Основная цель чеклиста состоит в том, чтобы вы не забыли проверить всё, что планировали. Классический чеклист состоит из:\n\n* 1-й столбец: заголовки тест-кейсов, структурированные по разделам/функционалу, или любые определенные составителем пункты;\n* 2-й столбец для отметки: пусто (еще не проверялось)/успех/ошибка;\n* 3-й столбец опционально под заметки.\n\nПримеры чек-листов из жизни:\n\n* Список проверок при покупке б/у ноутбука;\n* Список вещей/дел во время сборов в путешествие;\n* Список покупок в магазине.\n\nЧек-лист не обязательно является некоторой заменой тест-кейсов, это более глобальная сущность, в виде которой можно записывать множество планов и предстоящих действий: критерии начала и окончания тестирования, проверки перед началом каждой фазы, действия по их завершении, подспорье при исследовательском тестировании, накидать проверок с mind map функционала продукта, шеринг опыта с коллегами и т.п.\n\n**Разница между тест-кейсом и чек-листом**\n\nСила тест-кейса в том, что в нем все расписано очень детально, и с помощью тест-кейсов тестировать сможет даже человек, который ни разу не видел тестируемое им приложение. Но создание и поддержка кейсов требует времени, сил и является рутиной. Помимо прочего, очевидно, тест-кейс часто подразумевает только один конкретный тест, когда в чек-листе подразумевается целый перечень разных проверок.\n\nСила чек-листа в том, что он простой. Там нет глубокой детализации, это просто памятка. К тому же, он довольно наглядный с точки зрения отчетности. Минус в том, что другому человеку может быть сложно вникнуть в суть проверок без деталей и шагов. Чек-листы стали популярнее с приходом гибких моделей разработки, когда писать детальные кейсы может не быть времени и смысла, т.к. всё меняется слишком быстро, к тому же команда может быть небольшой и расписывать кейсы просто не для кого.\n\n**Traceability matrix** — Матрица соответствия требований — это двумерная таблица, содержащая соответсвие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки.\nМатрица соответсвия требований используется QA-инженерами для валидации покрытия продукта тестами. МСТ является неотъемлемой частью тест-плана.\n\n\n\n**Чек-лист (check list)** — это документ, описывающий что должно быть протестировано. При этом чек-лист может быть абсолютно разного уровня детализации. На сколько детальным будет чек-лист зависит от требований к отчетности, уровня знания продукта сотрудниками и сложности продукта.\nКак правило, чек-лист содержит только действия (шаги), без ожидаемого результата. Чек-лист менее формализован чем тестовый сценарий. Его уместно использовать тогда, когда тестовые сценарии будут избыточны. Также чек-лист ассоциируются с гибкими подходами в тестировании.\n\n\n**Traceability matrix** — Матрица соответствия требований — это двумерная таблица, содержащая соответсвие функциональных требований (functional requirements) продукта и подготовленных тестовых сценариев (test cases). В заголовках колонок таблицы расположены требования, а в заголовках строк — тестовые сценарии. На пересечении — отметка, означающая, что требование текущей колонки покрыто тестовым сценарием текущей строки.\nМатрица соответсвия требований используется QA-инженерами для валидации покрытия продукта тестами. МСТ является неотъемлемой частью тест-плана.\n\nДоп. материал:\n\n* [Чек-листы: полная лекция](https://www.youtube.com/watch?v=UOhg7moss9U)\n* [Составление чек-листов](https://www.youtube.com/watch?v=b3E5SbU1rEM)\n* [Cheat-sheet](https://tmguru.ru/baza-znanij/upravlenie-testami/cheat-sheet/)\n* Примеры: [раз](https://strongqa.com/qa-portal/testing-docs-templates/checklist)\n","category":"manual","description":"Check-list, как представитель Experience-Based"},{"title":"Summary Report","path":"/summary-report/","content":"\n**Итоговый отчет о тестировании (test summary report)**\n\n_Итоговый отчет о тестировании (test summary report): Документ, подводящий итог задачам и результатам тестирования, также содержащий оценку соответствующих объектов тестирования относительно критериев выхода. (IEEE 829)_\n\nСводный отчет о тестировании содержит подробную информацию о тестировании, проведенном на протяжении жизненного цикла разработки программного обеспечения. Элементы в итоговом отчете по тестированию различаются от организации к организации, а также различаются для разных проектов. Информация в отчете об испытаниях основывается на аудитории отчета об испытаниях. Аудитория может быть клиентом, менеджментом, бизнес-аналитиком, разработчиками, членами команды тестирования, членами организации и т. д.\n","category":"manual","description":"Summary Report"},{"title":"Bug Report","path":"/bug-report/","content":"\n## Баг-репорт (Defect/bug report)\n\n_Отчет о дефекте (defect report): Документ, содержащий отчет о любом недостатке в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию. (IEEE 829)_\n\n«Смысл написания отчета о проблеме (отчета об ошибке) состоит в том, чтобы исправить ошибки» - Джем Канер. Если тестировщик неправильно сообщает об ошибке, то программист, скорее всего, отклонит эту ошибку, заявив, что она невоспроизводима. Или потратит кучу лишнего времени на то, чтобы сделать вашу работу за вас. Едва ли такой тестировщик будет выгоден бизнесу, приятен коллегам и долго задержится на своем месте.\n\nГлавное при написании отчета - он должен быть сразу и однозначно понят читающим, а дефект однозначно воспроизведен по указанным шагам в указанном окружении.\n\n**Основные поля баг-репорта**:\n\n* Уникальный идентификатор (**ID**);\n* Описание (**Summary**): краткое, емкое и понятное описание ошибки;\n* Окружение (**Environment**): ссылка на билд/коммит/версия ПО и всего окружения;\n* Шаги воспроизведения (**Steps to reproduce**): полный перечень шагов для воспроизведения;\n* Ожидаемый результат (**Expected result**): какой результат должен был быть без ошибки;\n* Фактический результат (**Actual result**): какой результат получился на самом деле;\n* Вложения (**Attachments**): логи, скриншоты, видео - всё что необходимо для понимания ошибки.\n\n**Дополнительные**:\n\n* Предварительные условия (Prerequisites);\n* Тестовые данные (Test Data);\n* Серьезность дефекта (Defect Severity);\n* Комментарии (Remarks);\n* Проект (Project);\n* Продукт (Product);\n* Версия релиза (Release Version);\n* Модуль (Module);\n* Обнаружено в версии (Detected Build Version);\n* Вероятность возникновения дефекта (Defect Probability);\n* Приоритет дефекта (Defect Priority);\n* Автор отчета (Reported By);\n* Назначено на (Assigned To);\n* Статус (Status);\n* Fixed Build Version.\n\nВ случаях использования TMS поля будут настроены лидом/менеджером и в зависимости от размеров проекта могут быть пункты вроде milestone, epic, feature и т.п.\n\nПомимо прочего, баг-репорты могут создаваться не только тестировщиками, но и любыми членами команды, приходить от пользователей или техподдержки. Во втором случае необходимо будет воспроизвести ошибку, составить баг-репорт по всем правилам или дополнить присланный, затем провести ретроспективу на тему того, как ошибка попала в прод и как этого избежать в будущем.\n\n**Несколько ключевых моментов, которые следует учитывать при написании отчета об ошибке:**&#x20;\n\n* В одном отчете один баг;\n* Воспроизведите его 2-3 раза;\n* Убедитесь, что используете актуальную версию ПО и окружения;\n* Проверьте по поиску багтрекинговой системы наличие отчета о таком же дефекте;\n* Локализуйте ошибку, чтобы выяснить ее первопричину;\n* Напишите подробные шаги и полное окружение для воспроизведения ошибки;\n* Напишите хорошее summary дефекта по формуле “Что? Где? При каких условиях?” (3 Ws, WWW - What? Where? When?);\n* Следите за словами в процессе написания сообщения об ошибке, они не должны обвинять, оскорблять людей, содержать какую-либо точку зрения по поводу произошедшего. В общем, только факты по делу;\n* Проиллюстрируйте проблему с помощью правильных скриншотов, видео и логов;\n* Перед отправкой перепроверьте ваш отчет об ошибке. А потом еще раз;\n\nИсточники:\n\n* [How To Write Good Bug Report](https://www.softwaretestingmaterial.com/write-good-bug-report/)\n\nДоп. материал:\n\n* [Defect Probability](https://softwaretestingfundamentals.com/defect-probability/)\n* [Как правильно писать отчеты о дефектах на английском языке](https://www.youtube.com/watch?v=UEY5hGNPSvA)\n* [Не пишите в баге «Ввести 6,9»!](https://okiseleva.blogspot.com/2016/06/69.html)\n* [Воспроизводится ли баг по твоим шагам? Проверь!](https://okiseleva.blogspot.com/2019/07/blog-post\\_28.html)\n* [Нужна авторизация? Дай данные](https://okiseleva.blogspot.com/2019/09/blog-post\\_2.html)\n* [Эмоций в баге быть не должно!](https://okiseleva.blogspot.com/2019/01/blog-post\\_13.html)\n* [4 типичные ошибки оформления бага новичком](https://okiseleva.blogspot.com/2018/09/4.html)\n* [Шаблон бага](http://okiseleva.blogspot.com/2015/05/blog-post\\_25.html)\n* [Как воспроизвести баг](https://www.youtube.com/watch?v=1NLd5cvaBAI)\n* [О записи багов, или Найди кота](https://habr.com/ru/company/developersoft/blog/456132/)\n\n\n## Отчет о дефекте\n\n### Отчет о дефекте / Баг Репорт (Bug Report)\n\nДокументирование возникновения, характера и состояния дефекта. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%82%D1%87%D0%B5%D1%82%20%D0%BE%20%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82%D0%B5)]  \nВключает описание ситуации или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.\n\n### Состав баг репорта\n\n| Поле                             | Описание                                                                                                   |\n| -------------                    | --------------- | \n| Заголовок (Summary)              | Короткое описание проблемы, явно указывающее на причину и тип ошибочной ситуации.                          |\n| Проект (Project)                 | Название тестируемого проекта                                                                              |\n| Компонент приложения (Component) | Название части или функции тестируемого продукта                                                           |\n| Номер версии (Version)           | Версия на которой была найдена ошибка                                                                      |\n| Критичность (Severity)           | Наиболее распространена пятиуровневая система градации серьезности дефекта: <br>• S1 Блокирующий (Blocker) <br>• S2 Критический (Critical) <br>• S3 Значительный (Major) <br>• S4 Незначительный (Minor) <br>• S5 Тривиальный (Trivial)                    |\n| Приоритет (Priority)             | Приоритет дефекта: <br>• P1 Высокий (High) <br>• P2 Средний (Medium) <br>• P3 Низкий (Low)                 |\n| Статус (Status)                  | _Статус бага._ <br>Зависит от используемой процедуры и жизненного цикла бага. Например: <br>• Новый <br>• Открыт <br>• Закрыт                                                                                                                             |\n| Автор (Author)                   | Создатель баг репорта                                                                                      |\n| Назначен на (Assigned To)        | Имя сотрудника, назначенного на решение проблемы                                                           |\n| Описание (Description)           | _Окружение (Environment):_ <br>Информация об окружении, на котором был найден баг.<br>_Операционная Система, Service Pack;_<br>для WEB тестирования — _имя и версия браузера и т.д._<hr>_Шаги воспроизведения (Steps to Reproduce):_<br>Шаги, по которым можно легко воспроизвести ситуацию, приведшую к ошибке.<hr>_Фактический Результат (Actual Result):_<br>Результат, полученный после прохождения шагов к воспроизведению.<hr>_Ожидаемый результат (Expected Result):_<br>Ожидаемый правильный результат                                                  |\n| Дополнения                       | _Прикрепленный файл (Attachment):_<br>Файл с логами, скриншот или любой другой документ, который может помочь прояснить причину ошибки или указать на способ решения проблемы                                                                                 |\n\n## Дополнительные ссылки\n\n### Как написать хороший баг репорт\n\nhttps://www.softwaretestinghelp.com/how-to-write-good-bug-report/\n\nhttps://testlio.com/blog/the-ideal-bug-report/\n\n https://testit.software/blog/post/kak-pravilno-oformit-bag-report","category":"manual","description":"Bug Report"},{"title":"Requirements Tracebility Matrix","path":"/requirements-tracebility-matrix/","content":"\n## Матрица трассируемости (RTM - Requirement Traceability Matrix)\n\n_Трассируемость (traceability): Способность идентифицировать связанные объекты в документации и программном обеспечении, например, требования со связанными с ними тестами. (ISTQB)_\n\n_Матрица трассируемости (traceability matrix): Двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)_\n\n![https://hsto.org/r/w1560/webt/5n/tw/4h/5ntw4hujujk0cmsxs6hchfajtoo.jpeg](https://hsto.org/r/w1560/webt/5n/tw/4h/5ntw4hujujk0cmsxs6hchfajtoo.jpeg)\n\nВ тестировании многое можно представить в виде удобной и наглядной матрицы (таблицы): Requirement Traceability Matrix, Test matrix, Compliance Matrix, Risk Matrix, RACI Matrix и т.д.\n\n**Матрица трассируемости** (Requirement Traceability Matrix AKA Traceability Matrix or Cross Reference Matrix) используется для документирования связей между требованиями и тест-кейсами по этим требованиям и наглядного отображения трассируемости в виде простой таблицы.\n\nМатрица трассируемости может служить одновременно в качестве матрицы покрытия. Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.\n\n**Виды трассируемости**:\n\n* _Вертикальная трассируемость (vertical traceability): Отслеживание требований через уровни разработки к компонентам. (ISTQB)_\n* _Горизонтальная трассируемость (horizontal traceability): Трассировка требований к уровню тестирования по отношению к уровням документации (например, план тестирования, спецификация проектирования теста, спецификация тестовых сценариев и спецификация процедуры тестирования или автоматизированный сценарий тестирования). (ISTQB)_\n\nДругой источник:\n\n* Прямая трассируемость (Forward Traceability): гарантирует, что проект продвигается в желаемом направлении и что каждое требование тщательно проверяется;\n* Обратная трассируемость (Backward Traceability): гарантирует, что текущий разрабатываемый продукт находится на правильном пути. Это также помогает определить, что дополнительные неуказанные функции не добавляются и, таким образом, это не влияет на объем проекта;\n* Двунаправленная трассируемость (Bi-Directional Traceability = Forward + Backward): содержит ссылки от тестовых примеров к требованиям и наоборот. Это гарантирует, что все тестовые примеры можно отследить до требований, и каждое указанное требование содержит точные и действительные тестовые примеры для них.\n\nRTM актуальна на всех этапах программного проекта. Давайте разберемся с этим через водопадную модель SDLC:\n\n* RTM начинается вместе с началом фазы сбора требований (Requirements Gathering phase);\n* продолжается через управление требованиями (Requirements Management);\n* проектирование (Design);\n* разработку (Development);\n* тестирование (Testing);\n* внедрение (Implementation);\n* и поддержку (Support).\n\nПри прохождении всех этих этапов трассируемость требований поддерживается с помощью этого документа. После того, как требования были внесены в таблицу, детали дизайна для этих требований будут сопоставлены с требованиями. На основе этих деталей проекта будет производиться разработка программного обеспечения / модуля. Детали репозитория кода из SVN, TFS, Bitbucket, Github будут сопоставлены. Теперь вы знаете, где находится дизайн и код каждого требования. Это трассируемость. Отслеживайте каждое требование от начала до его конечного результата по мере его использования пользователем приложения! На этапе поддержки RTM будет чрезвычайно полезен для понимания и решения проблем, пройдя через все соответствующие детали функции / требования. Улучшение функции стало бы возможным благодаря отслеживанию и пониманию логики, дизайна и кода. С точки зрения владения RTM, RTM принадлежит менеджерам проекта или бизнес-аналитикам. В организациях CMMi команда TQM также будет проверять это как стандартный результат в проектах программного обеспечения.\n\n\\*Когда на основе требований к продукту составляются тест-сценарии и выполняется тестирование, это называется Requirement based testing.\n\nИсточники:\n\n* [How To Create Requirements Traceability Matrix (RTM): Example And Sample Template](https://www.softwaretestinghelp.com/requirements-traceability-matrix/)\n* [What is the difference between Test matrix and Traceability matrix?](https://www.quora.com/What-is-difference-between-Test-matrix-and-Traceability-matrix)\n\nДоп. материал:\n\n* [Матрица трассабилити](https://habr.com/ru/company/simbirsoft/blog/412677/)\n* [Reinventing the QA process](https://blog.picnic.nl/reinventing-the-qa-process-25854fee51f3)\n* [Traceability Matrix как инфраструктура общения QA и AQA спец-ов через призму Test Pyramid и ROI 2.0](https://www.youtube.com/watch?v=Vurf7G1JgG8)\n","category":"manual","description":"Requirements Tracebility Matrix"},{"title":"Ресурсы. Тест дизайн","path":"/resursy-test-dizajn/","content":"\nhttps://www.youtube.com/watch?v=LcTymHYm1MM\n\nhttps://www.youtube.com/watch?v=SO3o43A4jVw\n\nhttps://www.youtube.com/watch?v=yzOiGpLA0Jc\n\nhttps://www.youtube.com/watch?v=hBl5pV2xnQg\n\nhttps://www.youtube.com/watch?v=Bqmuw3ZJ75g\n\nhttps://www.youtube.com/watch?v=EGtUFuZmaQ8","category":"manual","description":"Ресурсы. Тест дизайн"},{"title":"Ethernet, WI-FI, IP, MAC, Маска подсети, VLAN","path":"/ethernet-wi-fi-ip-mac-maska-podseti-vlan/","content":"\nВсе компьютеры соединены между собой в сеть, соединены неким образом кабелями или по wi-fi и как-то между собой взаимодействуют. \n\n## Хост\nКогда компьютер находится в сети он называется хостом. **Хост** - единица в сети, это любой уствройство в сети которое имеет интерфейс. \n\n## Сетевой итерфейс\n**Итнерфейс** - способ управления чем-то, **сетевой интерфейс** - это сетевая карта в компьютере. \n\nКоманда ipconfig, ifconfig(MacOS, Linux) - посмотреть сетевые интерфейсы. \nИнтерфейсов может быть несколько, но если его не будет то он не будет хостом, тк у него не будет сети. \n\n## Hostname\nHostname - имя хоста в сети, как он называется. \n\nwww.google.com\n\nwww - имя хоста  \ngoogle.com - домен\n\n## IP адрес\nКомпьютеры не понимают по именам. Но понимают адреса - IP address. \n\n**IP адрес** - это идентификатор интерфейса. IP адрес - это 4 числа через точку (.), от 0 до 255. \n\nПочему не больше 255?\n\nУ нас под адрес выделяется пространство и оно занимает 32 бита. Поэтому больше чем 4 числа, каждое по 8 бит и от 0 до 255, мы туда поместить не можем. \n\nПример IP адреса: 192.168.1.76\n\n## Маска подсети \nЛюбая сеть имеет размер, он задается **маской (сетевая маска)**. Маска задает размер сети.\n\nКогда мы говорим, что у нас IP адрес 192.168.1.0 с маской 255.255.255.0 - это значит в диапазоне моей сети все адреса будут от 192.168.1.0 до 192.168.1.255.\n\nЕсли в маске идет число 255 это значит, что дальше менять это число нельзя, а там где 0 может быть любое число. Чтобы расширять сеть маска корректируется с конца.\n\n192.168 обычно роутер работает в диапазоне начинающемся с этих цифр.\n\nЕсть несколько диапазонов сетей которые имеют особое значение:\n- 192.168.0.0/16\n- 10.0.0.0/8\n- 172.15.0.0/16\n- 127.0.0.0/8 - 127.0.0.1/32- диапазон который используется только один адрес\n\nВ маске каждая часть 255 - это 8 бит, получается 255.255.255.255 = 8+8+8+8 = 32.\nПоэтому для сокращения пишут просто количество бит которое можно добавить.\n\n## Диапазон сети\nДиапазон сети - это размер сети, внутри которой компьютеры будут видеть друг друга, компьютеры за пределами сети видеть компьютеры внутри сети не будут.\n\n127.0.0.1/32 - адрес нашего компьютера, и другие компьютеры по этому адресу увидят только свой компьютер, а не наш.\n\nИнтернет - это совокупность сетей, которые соединены между собой и работают. 0.0.0.0/0 - весь интернет.\n\nРоутер (маршрутизатор, getway) - устройство у которого есть больше одного интерфейса и они находятся в разных сетях и роутер соединяет одну подсеть с другой подсетью и благодаря этому мы можем взаимодействовать.\n\n**VLAN порт** - это второй интерфейс роутера - порт к которому подключен провайдер и на VLAN будет другая подсеть.\n\n192.168.0.0/16 - локальные сети.\n\n## NAT\nNAT - ретрансляция адресов.\nКогда мы обращаемся в сеть, мы обращаемся через VLAN и наш ip меняется.\n\n**Проброска порта** - это когда то что приходит на адрес VLAN можно пробросить к локальному адресу. Чтобы наш компьютер стал доступен из вне.\n\n**Толстый клиент** - 1С бухгалтерия, компьютерные онлайн игры;\n\n**Тонкий клиент** - браузерные приложения;\n\n## MAC\nMAC - физический адрес, назначается утсройству заводом изготовителем.\n\nИспользуется при первичной адресации, чтобы вас можно было найти в сети при первичном обращении.\n\n## DHCP\nDHCP протсокл динамических хостов, протокол к котрому обращается клиент и он выдает настройки: ip адрес, маску, шлюз, DNS.\nDHCP выдает настройки в аренду.\n\n## DNS\nDNS, Domain Name System - серверное приложение, которое хранит таблицу, в которой записано доменное имя и его ip адрес и слушает запросы от пользователей и выдает ip адрес запрашиваемого сайта.\n\n## Протокол\nПротокол - набор правил, описание того, как работают между собой клиент и сервер.\n\nПротоколы и порты по умолчанию:\n- DHCP \n- DNS :53\n- HTTP :80\n- FTP :21\n- POP3 :110\n- UDP/TCP\n\n## Порт\nКогда серверное прилодение работает оно занимает опрелеленный порт.\n\nПорт - это число от 1- 65535. IP адрес можно сравнить с домом, а порт - это квартира.\n\nОдин порт может использовать только одно приложение. Если нужно несколько приложений нужно добавить еще один порт.\n","category":"nets","description":"Ethernet, WI-FI, IP, MAC, Маска подсети, VLAN"},{"title":"Модель OSI vs стек протоколов TCP/IP","path":"/model-osi-vs-stek-protokolov-tcp-ip/","content":"\n## Модель OSI\nМодель OSI - это описание уровней и какие протоколы используются на этих уровнях.\n\n### Уровни\n\n- Прикладной: HTTP, FTP, POP3\n- Представления: JPG, ASCII\n- Сеансовый: RPC, PAP\n- Транспортный: TCP, UDP\n- Сетевой: IP(IPv4, IPv6)\n- Канальный: Ethernet, 802.22\n- Физический: радиоканал или витая пара\n\n### Разница между TCP и UDP\n\n\n**UDP** - транспортный протокол без подтверждения доставки;  \nТак как нам не всегда нужно подтверждение доставки и не важна точность данных, например, разговор по скайпу, прослушивание музыки.\n\n**TCP** - транспортный протокол с подтверждением доставки;  \nНапример, открытие страницы в интернет -  если что то не дойдет, то поедет верстка, отправка письма - если что то потеряется, то будет потерян смысл пиисьма, отправка файла и т.д.\n\nЕсли смотреть на процесс открытия web-страницы в интернете то это будет выглядеть так:  \n\nесли смотреть с **физического уровня**, то  мы подключены к интернету по витой паре или радиоканалу(wi-fi);\n\nесли с **канального уровня**, то у wi-fi есть стандарт 802.11g 802.11ab мы подкючаемся по нему;\n\nс точки зрения **сетевого уровня**, у нас ip адресация - откуда и куда нужно отправить информацию;\n\nс точки зрения **транспортного уровня**, http работает по TCP, проверка целостности данных;\n\n**сеансовый уровень** не используется;\n\nс точки зрения **представления** мы отправили наш запрос в виде текста (ASCII - текст);\n\nс точки зрения **прикладного уровня**, мы используем HTTP;\n\n## Модель TCP/IP\n\nTCP/IP - название стека протоколов\n\n- Прикладной: HTTP, FTP, POP3\n- Транспортный: TCP, UDP\n- Сетевой: IP(IPv4, IPv6)\n- Сетевого доступа: Ethernet, 802.22 + радиоканал или витая пара\n\n\nЧек-лист API тестов\nКорректность структуры данных\nPOST запросы\nЗаполнены все поля валидными данными\nЗаполнены только обязательные поля\nЗаполнены не все обязательные поля\nНе заполнено ни одно поле\nВалидация данных в полях (корректные и некорректные данные)\nПустой JSON\nДата создания объекта\nGET запросы\nПустой список (если возможно)\nЗаполненный список\nПагинация в списке (limit, offset)\nПолучение списка с ограничением на количество записей\nПолучение списка начиная с указанного номера\nВ случае передачи параметров с некорректным значением возвращается 400 с описанием ошибки в теле ответа\nПри отрицательном offset список пользователей возвращается начиная с первой позиции\nПри несуществующем offset возвращается пустой список пользователей\nСортировка списка\nЗапрос данных по валидному ID, проверка возвращения корректных данных\nЗапрос данных по несуществующему ID, но в валидном формате\nЗапрос данных по невалидному ID\nPUT запросы\nОбновление с корректными данными\nОбновление по несуществующему ID\nОбновление по невалидному ID\nВалидация полей (корректные и некорректные данные)\nЧастичное обновление (в JSON присутствуют не все поля)\nDELETE запросы\nУдаление существующего объекта\nУдаление уже удаленного объекта\nУдаление по несуществующему ID\nУдаление по невалидному ID\nУдаление и повторное добавление такой же сущности (если есть уникальные поля)\nПроверка статусов ответов\nПроверка всех возможных ошибок\nОстальные специфичные проверки в случае сложной логики","category":"nets","description":"Модель OSI vs стек протоколов TCP/IP"},{"title":"Микросервисная архитектура","path":"/mikroservisnaya-arhitektura/","content":"\n## Микросервисная архитектура\n\n### Особенности\n\n- дает простоту и независисмость деплоймента;\nМы можем деплоить каждый микросервис отдельно.\nНапример, если есть изменения в микросервисе А, то мы деплоим только его и нам не нужно передеплаивать UI или другие микросервисы;\n\n- каждый микросервис имеет одну свою собственную, как правило простую функцию;\nи как правило, поддерживается одной командой, иногда даже из 1-2 человек;\n\n- отсутсвие иерархической структуры;\nмикросервис может комуницировать с БД или с другим микросервисом, нет какой то четкой структуры.\n\n- микросервисы взаимодействуют друг с другом напрямую;\n\n### Преимущества\n\n- микросервисы взаимодействуют по очень легковесным сетевым протоколам, как правило это REST;\n\n- мы можем в пределах одного приложения использовать какие угодно технологии и языки программирования;\nнапример, один микросервис на java, а другой на nodejs и это отлично работает;\n\n- простота масштабирования микросервисной архитектуры;\n\n### Проблемы для автоматизации тестирования\n\n- каждый микросервис имеет собственную ценность для заказчика \nесли монолитное приложение мы тестируем и используем все целиком, то в тут каждый микросервис имеет свою ценность;\nи не обязательно его использовать с тем UI клиентом, который был написан изначально, клиент может захотеть использовать другой клиент, мобильный клиент или переписать UI;\nнам важно, чтобы микросервис сам по себе выполнял те функции, которые на него возложены;\n\n- проблема мертвого кода\nкогда есть микросервисы и один микросервис мы больше не используем, его заменили на другой микросервис\nпри этом если automation framework остается монолитным то возникает проблема что есть автотесты которые существую но при этом они уже не нужны.\n\n- нужно также тестировать взаимодействие между микросервисами\n\n### Архитектура для автотестирования\n- тесты на java\n- конфигурация spring\n- билд через Maven\n- BDD - Cucumber\n- взаимодействие с UI - Selenium(Selenide)\n- взаимодействие с BackEnd - RestAssured\n- хранилице тестов - Google Cloud Platform\n- управление контейнерами - Kubernetes\n- для запуска тестов - Selenoid\n- для отчетности - Report Portal, Allure\n\n**Unit тесты** пишутся разработчиками.\n\n**Integrartion тестирование** - разбито  на 2 слоя: слой клиента, который работает как аналог UI, отправляет запросы и принимает ответы\nи уровень тестов, где происходят проверки.\n\n**UI тестирование** - имеет 3 слоя: уровень страниц (pages), уровень шагов (steps), уровень тестов (tests)\n\nДалее UI тесты подключаются к Selenoid - это браузеры, которые запускаются в докер контейнерах и оркестрируются Kubernetes' ом.\nЧтобы включить ui тесты в pipeline. \n\nUI тесты и BackEnd тесты не взаимодействуют между собой, поэтому чтобы создать тестовые данные, например пользователя который будет логиниться в приложение, это нужно будет делать через UI, что не совсем удобно.\n\nДля решения этой проблемы мы подключаем клиентскую часть Backend тестов через dependency в Мавен проект UI тестов, для того чтобы создать тестовые данные или ускорить работу UI тестов(например для быстрого логина в приложение).\n\nДля проверки взаимодействия микросервисов, мы подключаем клиентскую часть backEnd тестов для микросервиса 1 к клиентской часть backend тестов микросервиса 2 и проверяем.\n\nДля предоставления результатов используется Allure репорт, он используется для внутренних нужд.\n\nДля кастомера используется Report Pirtal, где отображаются результаты со всех уровенй тестирования.\n\n#### Selenoid\n\n- доступен сразу из коробки\n\n- есть 2 решения:\n  1. деплоится на виртуальную машину\n  2. деплоится в kubernetes кластер\nесли есть cloud платформа то можно бытсро с помощью seleonoid поднять браузер в cloud'е\n\n- браузеры стартуют очень быстро (~30сек)\n\n- надежность\nбраузеры сами закрываются ничего не зависает\n\n- запись видео\n\n## Docker\n\nDocker container - экземпляр Docker Image который содержит три атрибута:\n- docker image\n- среда запуска\n- стандартный набор инструкций\n\n### Преимущества\n\n- приложения портируемые и стандартно упакованные\nзапустить можно везде где есть docker engine\n- деплоймент простой и повторяемый \n- поддержка микросервисной архитектуры\nкаждый микросервис запакован, изолирован и запускается отдельно\n\n### Tools for containers orchestration\n\n- kubernetes - самый распространненый инструмент\n- docker swarm - нативный tool\n- rancher\n- mesos\n\n#### Источник информации:\n1. ❗[Automation testing solution for micro service architecture](https://www.youtube.com/watch?v=0QVlMsObhuQ)","category":"testops","description":"Микросервисная архитектура"},{"title":"Docker","path":"/docker/","content":"\nDocker - это средство упаковки (в контейнеры), доставки и запуска (запуск осуществляется одним и тем же образом, единый интерфейс) приложения.\nДокер - это история про виртуализацию, но не ту какую вам предоставляют виртуальные машины, которые разворачивают полноценную ОС внутри вашей. Главная задача Докера запустить приложение. \n\n## Базовые понятия\n\nDocker image - это сборка, говтовое к запуску приложение, но еще не запущеное.\n\nDocker container -  работающее приложение, созданное на базе имеджа.\n\nНа основе одного образа можно создать много одинаковых контейнеров.\nНапример, нужно 10 реплик одного сервиса.\n\nДля контейнера образ является read only системой, он не может его изменить.\n\nImage - слоеный пирог, напрмиер image Ubuntu и возьмем его за базу и поставим туда Nginx и поставим туда mongo и поставим питон.\n\nРеестр имеджей - он находится локально там хранятся те images которые создали именно вы.  \nТакже есть docker hub - там реестр всех имеджей, которые поддерживаются создателями докера но так же и те которые создавали другие люди.\n\n## Посмотреть images\n\n```\ndocker images\n```\n\n## Посмотреть запущенные контейнеры\n\n```\ndocker ps\n```\n\n-a - посмотреть в том числ остановленные контейнеры\n-a -q - отобразить только id контейнера\n\n## Создаем свой докер образ\n\n```\ndocker build -t hello-world .\n```\n\ndocker build - команда для создания образа\n-t - тег, название образа\n. - путь к текущей директории (где находится приложение)\n\nТакже нужно указать как именно нужно упаковать приложение, для этого создается Dockerfile.\n\nВ Dockerfile нужно описать шаги для упаковки нашего приложения.\n\n```docker\nFROM python:3.6 \n\nRUN mkdir -p /usr/src/app/\nWORKDIR /usr/src/app/\n\nCOPY . /usr/src/app/\n\nCMD [\"python\", \"app.py\"]\n```\n\n- FROM - базовый образ, через :(двоеточие) указывается тег\n- RUN - указывает что нужно выполнить указанную команду\n- WORKDIR - начальный каталог в который нужно перейти\n- COPY - копирует содержимое из источника в целевую папкув контейнере\n- CMD - указывает какие команды нужно выполнить когда мы запустим контейнер, запускает команды через shell \n- ENTRYPOINT - аналог CMD, но команды выполняются без shell оболочки\n\n## Запуск контейнера\n\n- запуск контейнера  \ndocker run <имя образа>\n```\ndocker run hello-world\n```\n\nКонтейнер работает до тех пор пока работает приложение.\n\n- задаем имя контейнера при запуске  \ndocker run **--name** <имя контейнера> <имя образа>\n```\ndocker run --name hello hello-world\n```\n\n- запуск контейнера в фоне, чтобы можно было работать с консолью  \ndocker run --name <имя контейнера> **-d** <имя образа>\n```\ndocker run --name hello -d hello-world\n```\n\n- запуск контейнера с автоудалением после остановки  \ndocker run --name <имя контейнера> -d **--rm** <имя образа>\n```\ndocker run --name hello -d --rm hello-world\n```\n\n## Удалить контейнер\n\nНапример те которые уже отработали\n\n- удалить один контейнер\ndocker rm <id контейнера>\ndocker rm <имя контейнера>\n```\ndocker rm 1e0c7cd00041\n```\n\n- удалить все контейнеры\ndocker rm $(docker ps -qa) \n\n## Остановить контейнер\n\n- docker stop <id контейнера>\n- docker stop <имя контейнера>\n\n## Проброска портов\n\nКонтейнер собирается в полностью изолированном окружении и если явно не пробросить порты то приложение будет не видно.\n\nЧтобы пробросить порт нужно в Dockerfile указать EXPOSE 8080 тем самым мы указываем что мы можем этот порт пробросить.\n\nЧтобы выполнить проброску нужно при запуске контейнера указать флаг -p и через двоеточие 2 порта (1- порт нашей машины, 2 - порт в контейнере)\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 hello-world\n```\n\n## Переменные окружения\nМожно указать в Dockerfile\n\nENV <название переменной> <значение>\n\nно иногда переменные нужно менять поэтому можно указывать переменные при запуске контейнера\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 -e <имя переменной>=<значение> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -e TZ=Europe/Moscow hello-world\n```\n\n## Работа с внешними данными\n\n1. монтируем папку\nделается это при запуске контейнера через параметр -v\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 -v <папка на хостовой машине(абсолютный путь)>:<папка в контейнере(абсолютный путь)> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -v ...:... hello-world\n```\n\n2. docker volume\n\nпосмотреть какие volume доступны\n\n```\ndocker volume ls\n```\n\nчтобы создать volume\n\n```\ndocker volume create <имя>\n```\n\nтеперь при запуске можно указать \n\ndocker run --name <имя контейнера> --rm -v <имя volume>:<папка в контейнере(абсолютный путь)> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -v ...:... hello-world\n```\n\n## Удалить image\n\ndocker rmi <имя image>\n\n## Получить список images id \n\ndocker images -q\n\n## Удалить все images\n\ndocker rmi $(docker images -q)\n\n## Многосервисная архитектура \n\nДля каждого сервиса имеется свой Dockerfile. \nЕсли через docker run выполнять настройке переменных когда есть много сервисов это не совсем удобно.\n\nДля этого используется docker-compose - надстройка над докером.\n\nДля его использования нужно создать docker-compose.yaml\n\n\nуказываем версию, volumes и описываем настройки каждого сервиса\n\n**Настройки сервиса:**\n\nbuild: указываем откуда взять Dockerfile либо image: mongo:latest если нужно взять готовый образ\n\nvolumes: \n  - <имя volume>:<абсолютный путь к папке в контейнере>\n\nports: - проброска портов\n  - 8080:8080 \n\nrestart: always - если вдруг машина перезагрузится то докер сам перезапустит контейнеры\n\nenvironment: - перечисляем переменные окружения\n- TZ=Europe/Moscow\n\n## Создаем ssh ключ\n\nпереходим из домашнего каталога в .ssh и запускаем ssh-keygen, затем выводим на экран публичный ключ\n\n```\ncd .ssh\nssh-keygen -t rsa\n# задаем имя, например vscale\ncat vscale.pub | pbcopy\n```\n\nсоздаем в папке .ssh файл config\n```\nvim config\n```\n\nУказываем в config настройки\n\nhost <имя хоста пожеланию>\n  hostname <шз адрес сервера>\n  user root\n  IdentityFile ~/.ssh/vscale\n\nСозряняем и выполняем команду \nssh vs\n\n## Устанавливаем docker на сервере\n\n```\nsudo apt update\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-app-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\"\nsudo apt install docker-ce\n```\n\n## Устанавливаем docker-compose на сервере\n\n```\nsudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s` -`uname -m` -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n```\n\n## Запуск docker-compose\ndocker-compose up -d\n\n-d - чтобы контейнеры в фоне работали\n\n## Остановить docker-compose\ndocker-compose down -d\n\n## Работа с docker hub\n\nСоздать свой репозиторий можно с сайта hub.docker.com нажав Create Repository  \nлибо просто запушив свои первый image\n\nнужно в имя образа вставить идентификатор пользователя и через / имя репозитория\n\n```\ndocker build -t artemproject/statisticmanager .\ndocker login\ndocker push artemproject/statisticmanager\n```\n\n## Запуск postgres в docker\nЧтобы запустить postgres в docker нужно:\n\n1. Сделать pull image\n\n```docker\ndocker pull postgress\n```\n\n2. Запустить инстанс докера\n\n```docker\ndocker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres\n```\n\n--name - имя контейнера на локальной машине\nPOSTGRES_PASSWORD= - здесь указывается пароль\n-d (detach) необходимо указывать для того чтобы терминал оставвался терминалом локального компьютера, а не терминалом БД\npostgres - название контейнера который мы будем запускать\n-p 5432:5432 - проброс портов, порт внутри контейнера будет соответсвовать порту нашего компьютера\n\n3. Проверяем запущенные контейнеры\n\n```docker\ndocker ps -a\n```\n\nДля работы с БД нужно подключить Postgress JDBC - `'org.postgresql:postgresql:42.3.6'`\nи часть фреймворка Spring для работы с БД - `'org.springframework:spring-jdbc:5.3.20'`\n\nсистема виртуализации для запуска приложения в ихолированной среде.\n\nSELECT departamens.name FROM departamens LEFT JOIN users ON users.departament_id = departamens.id WHERE users.departament_id IS NULL;\n\n\n\n\n","category":"testops","description":"Docker"},{"title":"Kubernetes","path":"/kubernetes/","content":"\n## Kubernetes\nKubernetes - открытая платформа созданная для автомтаического деплоя, масштабирования и оперирования контейнерами приложений.\n\nПортативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами которая облегчает как декларативную настройку так и автоматизацию.\n\nKubernetes состоит из нод. Как правило рекомендуют использовать не менее 3х нод для Kubernetes. \nMaster Node и 2 Work Nodes. \n\n**Master Node** - отвечает за поддержание желаемого состояния для вашего кластера.\nС Master Node взаимодействует kubectl - интерфейс командной строки, который позволяет через командную строку управлять Kubernetes кластером.\n\nС другой стороны у нас есть пользователь, который через интернет обращается к нашему приложению через Work Node и через kube-proxy ходит непосредственно на pod'ы.Основные фундаментальные концепции Kubernetes -  это pod и node, а также kublet, kube-proxy, etcd.\n\n**Nodes(узлы)** - это виртуальные либо физические машины в Kubernetes кластере на которых будут запускаться контейнеры.\nНода содержит kublet, Docker, kube-proxy. Также нода может содержать 1 или несколько под.\n\n**Pod** - минимальный юнит в Kubernetes с которым можно взаимодействовать, абстрактный объект Kubernetes представляющий группу из одного или нескольких контейнеров приложения (например Docker).\n\nПоды можно создавать, деплоить и удалять. Одна пода - один процесс в кластере. \nПод содержит: Docker container, storage resources, уникальный IP. \n\n**Cluster** - совокупность мастер-сервисов и нод.\n\n**Namespace** - это способ разделения ресурсов кластера между несколькими пользователями.\nНапример, namespace команд, проектов и тд.\n\nЧтобы зайти в кластер и начать запускать команды нужно установить kubectl.\n\nkubectl - это инструмент командной строки kubernetes, который позволяет запускать команды для кластеров Kubernetes. Вы можете использовать kubectl для развертывания приложений проверки и управлени ресурсов кластера а также просмотра логов\n\n### Жизненный цикл Pod\n\n- Pending - ожидание, под ждет ресурсов. Под был принят кластером но один или несколько контейнеров еще не были запущены и нужно подождать.\n- Running - запуск, созданы контейнеры необходимые для пода и запуска непосредственно на этой ноде. Под привязан к узлу и все контейнеры созданы.\n- ContainerCreating - собираются контейнеры.\n- Succeeded/Completed - успешный запуск, все контейнеры созданы, работают, нода запущена.\n- CreateContainerConfigError - ошибка конфигурации.\n- Failed - неуспешный запуск, запуск зафейлился приходит response != 1\n- CrashLoopBackOff - под уходит в бесконечный цикл. Под был запущен крашнулся перезапустился и заново крашнулся (установлено значение restartPolicy: Always) нужно изучить логи.\n- Terminating -  трафик не идет на под, под тушится после его удаления\n\nЧтобы работало автодоплнение нужно выполнить команду:\n\n```\nsource <(kubectl completion bash)\n```\n\nДалее нужно получить доступ к кластеру:\n\n- Получить список всех неймспейсов\n```\nkubectl get namespaces\n```\n\n- получить список всех подов во всех неймспейсах\n```\nkubectl get pods --all-namespaces\n```\n\n- получить список всех подов во всех неймспейсах там где есть название ssr с подробным выводом логов\n```\nkubectl get pods --all-namespaces -o wide |grep ssr\n```\n\n- получить список подов в определенном неймспейсе\n```\nkubectl get pods -n core-team\n```\n\n```\nkubectl get pods -n core-team|grep besida-madmax\n```\n\nПосле того как вышел список подов мы можем увидеть статусы в которых они находятся:\n\n- Обзор запущенного пода\n```\nkubectl -n core-team describe pod besida-trunk-ua-685d5d4f-hpdw2\n```\n\n- Вывести логи пода \n```\nkubectl -n core-team logs besida-trunk-ua-685d5d4f-hpdw2\n```\n\nотображает логи на лету\n```\nkubectl -n core-team logs -f besida-trunk-ua-685d5d4f-hpdw2\n```\n\n### Controllers\n\nУправляется Controller Manager'ом. \n\nВиды контроллеров:\n- ReplicaSets - проверяет что необходимое количество pod запущено все время. Если pods стало меньше (например одна изпод закрешилась), то replicaSet создаст новую. ReplicaSets существует не самостоятельно а в рамках Deployment.\n\n- Deployments - предоставляет декларативное описание для апдейта ReplicaSet и Pod. В ранних версиях Kubernetes вместо ReplicaSet и Deployment использовался Replication Controller. Но это нарушало принцип single responsibilities и в дальнейшем он был разделен и облегчилась задача rollback'a - если во время деплоймента что то пошло не так то в текущих условиях легко откатиться назад и востановить работоспособность приложения.  \n\n- DeamonSets - проверяет что на каждой ноде запущен экземпляр конкретной поды. Если ноды добавляются в кластер или удаляются из кластера то DeamonSet добавить или удалить поды на этой ноде. Удаление DeamonSet означает удаление всех под из кластера.\n\n- Jobs - это процесс верхнего уровня для пода. Используется когда нужно запустить pod для выполнения какой то задачи один раз или по расписанию. Типичный пример - cron job.\n\n- Services - позволяет сетевое взаимодействие между деплойментами. Необходимы, когда нужно, чтобы поды из разных деплойментов взаимодействовали между собой. \n\nНапример: FrontEnd Pod взаимодействует с BackEnd Pods через Backend Service.\n\n### Виды сервисов:\nInternal - ip-адрес доступен только внутри кластера. \n\nExternal - эндпоинт доступен по ip адресу ноды(такой сервис называют NodePod). \n\nLoad Balancer - открывает приложение в интернет через лоад балансер (обычно используется когда кубернетис кластер развернут в облаке (GCP, AWS, Azure).\n\n\n### Labels\n\nПара ключ/значение, может быть присоединена к таким объектам как поды, сервисы и доплойменты. Используются пользователями Кубернетис для идентификации аттрибутов для объектов. Уникальны в пределах объекта. \n\nПример: \"environment\": \"dev\", \"environment\": \"qa\", \"environment\": \"prod\"\n\nLabels как правило используются не одни а с selectors.\n\n### Selectors\n\n- equality-based: '=' и '!='\n- Set-based: 'IN', 'NOTIN' и 'EXISTS'\n\nLabels и Selectors обычно используются в kubectl командах для получения списков объектов и их фильтрации. НапримерЖ получение списка под на QA env.\n\n### Namespaces\n\nКонцепция неймспейсов позволяет реализовать множество виртуальных кластеров внутри одного физического кластера. Это полезно, когда есть необходимость разделять ресурсы физического кластера между командами и контролировать доступ к ресурсам.\n\n### Kublet\n\n- Запущен на каждой work-ноде\n- Коммуницирует с API сервером, который запущен на Master Node\n- Запускает контейнеры для под через docker engine\n- Подключает и запускает диски и сикреты для под\n- Запускает хелсчеки для проверки статусов под/нод и сообщает статус API серверу\n\n### Kube-proxy\n\n- Запущен на каждой work-ноде\n- Рефлицирует сетевой трафик для сервисов (NodePort и LoadBalancer)\nконфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.\n\n\n### Режимы Kube-proxy\n\n- User space mode (наиболее широко используемый)\n- Iptables mode\n- Ipvs mode (alpha version)\n\n### etcd\nРаспределённое и высоконадёжное хранилище данных в формате \"ключ-значение\", которое используется как основное хранилище всех данных кластера в Kubernetes.\n\n### kube-scheduler\nКомпонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.\n\n\n## Команды Kubernetes\n\n- получить список подов\n```\nkubectl get pods\n```\n\n- получить список сервисов\n```\nkubectl get services\n```\n\n- получить список деплойментов\n```\nkubectl get deployments\n```\n\n- поднимаем selenium-hub\n```\nkubectl create -f selenium-hub-deployment.yaml\n```\n\n- поднимаем selenium-hub-svc\n```\nkubectl create -f selenium-hub-svc.yaml\n```\n\n- поднимаем selenium-node\n```\nkubectl create -f selenium-node-chrome-deployment.yaml\n```\n\n\n\n\n## CI/CD microservices\n\nCI - Continious Integration это когда разработчики интегрируют свои код в общий репозиторий на постоянной основе и постоянно проходят некий quality gate который показывает что их код синтегрировался корректно. \n\nCD - Continious Delivery это когда артефакт который мы собрали в рамках Continious Integration и начинаем поставлять его на разные окружения.\nContinious De[loyment это когда мы в процессе Continious Delivery не ждем ручного апрува а автоматом через энвайронменты проводим и выкатываем на продакшен.\n\nКак этого достичь:\n1. Докеризация микросервисов\nнужно получить артефакт который будет неизменным - нужно быть уверенным что тот артефакт который мы собрали в таком же виде дойдет до продакшена\n2. Мы можем присваивать артефакту теги и тем самым продвигать его на следущую стадию\n3. Мы не завязываемся на технический стек\n4. Это прощает деплоймент, управление окружением, конфигурацию и т.д.\n5. Эфективное использование ресурсов\n\nУ нас есть контейнер - запущенный процесс который представляет наш микросервис и image - immutable артефакт который мы собрали в рамках  CI и выложили его в registry - реестр images, где хранятся наши артефакты.\n\n## Версионирование\n\nСемантическое версионирование - \nглавная версия отвечает за то какие знаковые изменения были сделаны в микросервисе(то что мы не поломали API), если мы не имеем обратной совместимости то увеличиваем эту версию либо по большим релизом и с каждым релизом увеличиваем;\nминорная версия - либо начинаем каждый раз с нуля в рамках каждого нового большошо релиза либо если девелопим интерациями то используют номер интерации, тогда можно быстро востановить когда эта версия была выпущена.\nпатч версия - для хот фиксов \nкомит хештег как суффикс и дата как дополнительный суффикс\n\n## CI pipeline\n\nРазработчик делает комит в гит репозиторий на CI делается: build code, run unit tests, build image, push image(пушится в реестр контейнеров). На выходе мы получаем кодовые артифакты, результаты тестов, image контейнер.\n\nQuality Gates:\n- unit tests\n- integration tests\n- static code analysis\n- api tests\n- contract tests\n- security checks\n\nЧтобы поставить полностью всю систему нужно знать версии всех микросервисов.\n\nЗдесь нужно учитывать совместимость - это когда мы взяли набор микросервисов подняли провели тесты и после этого мы говорим что этот набор сервисов совместим \n\nПоэтому нужно сохранять нобор версий этих сервисов как отдельный артефакт \nЭтот артефакт можно положить в систему контроля версий(например гит)\nДальше в Continious Delivery будет участвовать этот набор. и дальше можно промоутить этот артефакт между разными окружениями. Если мы добавим зависимость на какую то версию postgress или elastic то мы получим полную совместимсоть\n\nЭто делается с помощью property файла и прописываем версии.\nМожно использовать helm.\n\n**Пример:**\n\nУ нас есть 3 сервиса с соответсвущими версиями и мы их собрали в compatible set. \n\nИ тут появляется доработка в одном из сервисов и появляется его новая версия и это новый кандидат мы хотим его продвинуть. \n\nМы собираем новый set с этим кандидатом и пытаемся его запустить и билд падает(возможно оказалась проблема в несовместимости например с ui частью).\n\nИ появилась необходимость сделать исправление в другом микросервисе, разработчики делают исправление, получают новую версию и хотят ее задеплоить. И тут вступает фактор, что нужно подхватывать всех новых кандидатов, потому что если бы подхватили только последний кандидат, он могбы упасть так как ожидает исправлений, которые появились в первом сервисе.\n\nЕсли билд проходит успешно, то мы делаем совместимый между собой set и сохраняем его в сисетму контроля версий.\n\nЕсли билд падает, то артифакт невидим и нет возможность такой билд куда-то задеплоить просто так, не пройдя тест на совместимость. \n\nПосле того как артефакт появился в системе контроля версий, то либо jenkins джоба это проверяет, либо оператор в Kubernetes переодически мониторит что появляется и говорит что надо это деплоить - вручную или по расписанию. \n\nFlux CD мониторит появление новых images в гите и говорит что можно их задеплоить.\n\n## Выполняем деплой на окружение\n\nДля этого мы создаем Jenkins джобу или github actions которая показывает нам список окружений который нам доступен: dev, qa, stage, prod либо оставляем создаем новое окружение. Также показываются для выбора не отдельные микросервисы а показыватся сеты. Еще нужно указать TTL(Time To Live) окружение будет автоматически очищаться по истечению времени. \n\nНо если будет много окружений - это займет все ресурс и для решения этой проблемы нужен Kubernetes.\n\nКак ускорить создание окружения в Kubernetes:\n- каждое окружение уходит в отдельый namespace \n- конфигурируем минимальные лимиты и scale фактор \n- выносим основные внешние ресурсы (DB, Elastcsearch, Redis, Kafka)\n- используем готовые images с данными\n- сконфигурируем все тулы \n- асинхронное удаление окружение\n- задаем TTL\n\n\nzhuk.__\n\n","category":"testops","description":"Kubernetes"},{"title":"Linux","path":"/linux/","content":"\n## Terminal: основы\n\n- pwd  - вывести текущую директорию (print working directory)\n\n- ls - вывести содержимое директории (list directory content)\n    - ls --all --human-readable -l путь\n    - ls -a -h -l путь\n    - ls -ahl путь ls -lah путь\n\n-a, --all — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.\n\n-h, --human-readable — добавлять к каждому размеру файла букву размера, например, M для двоичных мегабайт (`мебибайт').\n\n-l, --format=long, --format=verbose — в дополнении к имени каждого файла, выводятся тип файла, права доступа к файлу, количество ссылок на файл, имя владельца, имя группы, размер файла в байтах и временной штамп (время последней модификации файла, если не задано другое). Для файлов с временем больше чем 6 месяцев назад или больше, чем 1 час в будущее, временной штамп содержит год вместо времени дня.\n\n- man команда - справка о команде (для выхода: Q)\n- clear - очистить экран терминала\n- exit - закрыть терминал\n\n### Специальные символы:\n- . текущая директория\n- .. директория на уровень выше\n- ~ домашняя директория\n- \\* любое количество любых символов\n- ? ровно один любой символ\n\n\n- mkdir путь_до_директории - создать директорию\n- mkdir -p путь_до_директории - создать директорию и ее “родителей”\n- touch путь_до_файла - создать файл\n- cd путь_до_директории - войти в директорию\n- rm путь_до_файла - удалить файл\n- rm -r путь_до_директории -  удалить директорию\n- rm -rf путь_до_директории - удалить директорию (без вопросов)\n- сp путь_до_файла1 путь_до_файла2 - скопировать файл1 в файл2\n- cp -r путь_до_дир1 путь_до_дир2 - скопировать дир1 в дир2\n- mv путь1 путь2 - переместить директорию или файл\n\n## Запуск исполняемых файлов\n- Ctrl + C - прервать выполнение\n- Ctrl + Z - приостановить выполнение\n    - fg продолжить (foreground)\n    - bg продолжить в фоновом режиме (background)\n- program & - запустить выполнение программы сразу в фоновом режиме\n\n- ./имя_программы - запустить выполнение программы из текущей директории\n- /полный/путь/имя_программы\n\n- chmod +x имя_программы - сделать программу исполняемой\n\n## Ввод/вывод\n- cat файл - вывести содержимое файла на экран\n- less файл - открыть файл на чтение\n    - q – выход; \n    - / – поиск;\n    - g – в начало; \n    - G – в конец\n- nano файл - редактировать файл\n    - Ctrl + X – выход\n\n- Программа < файл - брать stdin из файла\n\n- Программа > файл - выводить stdout в файл\n- Программа >> файл - аналогично, но с дозаписью в файл\n\n- Программа 2> файл - выводить stderr в файл\n- Программа 2>> файл - аналогично, но с дозаписью в файл\n\n- Прогр1 | Прогр2 | … | ПрогрN - передать stdout Прогр1 в качестве stdin для Прогр2, далее stdout Прогр2 в качестве stdin для Прогр3 и т.д.\n\n## Скачивание файлов из интернета\n- wget ссылка - скачать файл по ссылке и сохранить в текущей директории\n- wget -P путь_до_директории ссылка - скачать файл по ссылке и сохранить в директории заданной путем\n- wget -O путь_до_файла ссылка - скачать файл по ссылке и сохранить под указанным именем\n\n- wget -c ссылка - докачать файл по ссылке в случае обрыва связи\n- wget --spider ссылка - проверить доступность файла по ссылке\n- wget -i текстовый_файл - скачать несколько файлов по ссылкам из текстового файла\n\n- wget -r -l глубина ссылка - рекурсивное скачивание файлов по ссылке на указанную глубину(по умолчанию глубина 5)\n- wget -r -A тип,тип,...,тип ссылка - рекурсивное скачивание файлов только определенного типа (типов)\n\n## Работа с архивами\n\n### Распаковка архивов\n- unzip архив.zip - распаковать содержимое архива.zip\n- gunzip архив.gz - распаковать содержимое архива.gz, файл архив.gz удалить\n\n### Создание архивов\n- zip архив.zip файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.zip\n- gzip файл - запаковать файл в файл.gz, исходный файл удалить\n- tar -cvf архив.tar файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar (без сжатия)\n- gzip архив.tar - запаковать архив.tar в архив.tar.gz, исходный архив.tar удалить\n- tar -zcvf архив.tar.gz файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar.gz (c сжатием при помощи gzip)\n\n### Распаковка архивов\n- tar -xvf архив.tar - распаковать архив.tar\n- tar -xzvf архив.tar.gz - распаковать архив.tar.gz (с использованием gunzip)\n\nЕще один архиватор:\n- bzip2 файл\n- bunzip2 файл.bz2\n- tar -cjvf архив.tar.bz2 файл1 файл2 ...\n- tar -xjvf архив.tar.bz2\n\n### Сжатие/распаковка без удаления\n- gzip -c файл > файл.gz\n- gunzip -c файл.gz > файл\n- bzip2 -c файл > файл.bz2\n- bunzip2 -c файл.bz2 > файл\n\n## Работа на сервере\n\nДля входа на сервер, нужно знать:\n1) адрес сервера,\n2) логин и пароль.\n\n### Команда входа\nssh логин@адрес_сервера -p порт\n\nна клиенте хранится закрытый ключ ~/.ssh/id_rsa, ~/.ssh/id_rsa.pub  \nна сервере открытый ключ ~/.ssh/authorized_keys\n\n### Создание ключа\n- ssh-keygen - создание ключа\n- ssh-add - сообщить системе о ключе\n- cat ~/.ssh/id_rsa.pub - просмотр публичного ключа:\n- nano ~/.ssh/authorised_keys - редактирование авторизованных ключей (на сервере)\n\n### Копирование файлов\n- scp -P порт логин@адрес_сервера:путь1 путь2 - с сервера (путь1) на клиента (путь2)\n- scp -P порт путь1 логин@адрес_сервера:путь2 - с клиента (путь1) на сервер (путь2)\n\n### Установка, удаление и обновление программ\n\n- sudo apt-get install программа - Установка программ через терминал\n- sudo apt-get remove программа - Удаление программ через терминал:\n- sudo apt-get update - Обновление ссылок на пакеты:\n- sudo apt-get upgrade - Обновление установленных пакетов:\n- sudo apt-get install --only-upgrade программа - Обновление отдельной программы:\n\n### контроль запускаемых программ\n- jobs - посмотреть запущенные программы\n- fg %<номер> - продолжить программу с этим номером\n- bg %<номер> - продолжить программу с этим номером в фоновом режиме \n- ps - посмотреть ваши процессы\n- top - отслеживать процессы в реальном времени\n- top -u <имя пользователя> - отслеживать процессы этого пользователя \n- kill <номер процесса> - завершить процесс с этим номером\n- kill -9 <номер процесса> - “убить” процесс с этим номером\n\n### Многопточные приложения\n- free -g - информация об оперативной памяти\n- nproc - количество ядер процессора\n- lscpu - детальная информация о процессоре\n- bowtie2-build - запуск построения индекса генома\n    - bowtie2-build <геном> <индекс>\n        - bowtie2-build ref.fasta index\n- bowtie2 - запуск выравнивателя bowtie\n    - bowtie2 -x <индекс> -U <риды>\n        - bowtie2 -x index -U reads.fastq\n    - bowtie2 -x <индекс> -U <риды> -p <количество потоков>\n        - bowtie2 -x index -U reads.fastq -p 4\n\n### Менеджер терминалов\n- Ctrl + Shift + T - открыть новую вкладку в терминале\n- Alt + <цифра> - перейти в указанную вкладку\n- Ctrl + Shift + W - закрыть текущую вкладку\n- tmux - запустить tmux\n- Ctrl + B - перейти в режим команд\n- Ctrl + B и C (зажать Ctrl+B, отпустить, затем нажать С) - создать новую вкладку\n- Ctrl + B и <цифра> - перейти в указанную вкладку\n- Ctrl + B и N / Ctrl + B и P - перейти в следующую / предыдущую вкладку\n- Ctrl + B и X (или exit) - закрыть вкладку\n- Ctrl + B и D - временно выйти из tmux\n- tmux attach / tmux a - вернуться в tmux\n- tmux list-sessions - посмотреть список запущенных tmux’ов\n- Ctrl + B и PgUp - перейти в режим просмотра истории\n- PgUp, PgDown, стрелки - перемещать курсор по истории\n- Esc, Ctrl + C - выйти из режима просмотра истории\n\n## Редактор Vim\n### Вход\nvim\nvim файл\nvim файл1 файл2 файл3 ...\n\n### Главные команды\n:q - выход\n:help - справка\nvimtutor - очень хороший автотуториал!\n\n### Режимы работы\n1. normal\n- Режим по умолчанию\n- Любая клавиша воспринимается как команда\n- «Сложные» команды начинаются с ‘:’\n\n2. insert\n- Режим ввода текста — все, что вы\nнажимаете, вставляется (заменяется).\n- Выход через `<Esc>`, `<Ctrl+c>`\n\n3. visual\n- Режим выделения\n\n### Перемещение\n- По символам:\n    - Стрелочки\n    - h,j,k,l\n- По словам:\n    - w, W — в начало следующего слова\n    - e, E — в конец\n    - b, B — в начало предыдущего\n\n- Еще крупнее:\n0,^,$ — начало строки, первый непробельный символ, конец строки\n- Совсем крупно:\n - gg — начало файла\n - G — конец\n - :21 `<Enter>` — перейти к строке 21\n - `<Ctrl+D>`, `<Ctrl+U>` — вниз/вверх на N строчек, где N обычно пол-экрана\n\n### Удаление\n- По символам:\n    - x — символ под курсором\n    - X — символ до курсора\n- Сразу много: d [<кол-во>] <ход>\n    - dе — удалить до конца текущего слова\n    - d$ — удалить до конца строки\n    - d5w — удалить пять слов\n- Специальная команда\n    - dd — удалить строку (или, например, d10d)\n\n### Создание\ni — войти в insertion mode\na — сдвинуть курсор вправо и войти в insertion mode\nI = ^i\nA = $a\no — вставить пустую строку снизу и редактировать ее\nO — то же, но строка сверху\n\n### Копирование\ny <кол-во> <ход> — скопировать\nyy — скопировать строку\n\n### Вставить\np — вставить после\nP — вставить перед\n\n### Поиск и замена\n#### Поиск\n- /<текст> — искать <текст> вперед\n- ?<текст> — назад\n- n — следующее вхождение, \n- N — предыдущее\n\n#### Замена\n- :%s/<что ищем>/<на что меняем>/<флаги>\n- флаги: \n    - g – много замен в строке, \n    - с – подтверждение\n\n### Полезные команды\n#### Отмена/возврат\n- u — отменить последнее действие\n- `<Ctrl+r>` — вернуть отмененное действие\n\n#### Сохранение работы\n- :w — сохранить изменения\n- :wq — сохранить и выйти\n- :q! — выйти без сохранения\n- :w `<файл>` — сохранить изменения в `<файл>`\n\n## Программирование на bash\n- оболочка (shell) – интерпретатор команд\n- sh (Bourne shell) – стандарт и доступна почти в любом дистрибутиве (1977)\n- bash (Bourne again shell) – усовершенствованная и модернизированная вариация sh (1989)\n- csh, tcsh, zsh, ...\n\n### Создаем программу\nvim my_first_script.sh\n```\n#!/bin/bash\necho \"Hello, world!\"\n```\n\n### Запускаем программу\nchmod +x my_first_script.sh  \n./my_first_script.sh\n\n### Переменные\nПеременная (variable) - именованная область памяти\n\n**имя (name):**\n- буквы, цифры, _;\n- не может начинаться с цифры.\n\n**значение (value):**\n- числа;\n- строки (если есть пробелы, то в кавычках);\n- отдельные символы.\n\n### Запись (перезапись) значения\n<имя>=<значение>\n```\npath=~/Docs\n```\n\n### Чтение\n$<имя> или ${<имя>}\n```\npath2=$path/file1.txt # path2=~/Docs/file1.txt\necho “Path is $path2” # Path is ~/Docs/file1.txt\necho “Path is ${path}2” # Path is ~/Docs2\n```\n\n### Аргументы\n#### Передача аргументов скрипту:\n./script.sh arg1 arg2 arg3 ...\n\n#### Обработка внутри скрипта:\n$1 первый аргумент  \n$2 второй аргумент  \n...\n\n\\$0 имя скрипта  \n$# количество аргументов\n\n```\nvar=”Первый аргумент равен $1”\necho ”Всего было передано $# аргументов”\n```\n\n### Ветвление: основы\n\n#### Синтаксис:\n```\nif [[ условие ]]\nthen\n    # действия, если условие истинно\nfi\n```\n\n\n#### Условия (строки):\n- -z <строка> # строка пуста\n- -n <строка> # строка не пуста\n- <стр1> == <стр2> # строки равны\n- <стр1> != <стр2> # строки не равны\n\nПример:\n```\nif [[ -z $1 ]]\nthen\n echo “Первый аргумент пустой!”\nfi\n```\n```\nif [[ $var1 == $var2 ]]\nthen\n echo “Переменные равны!”\nfi\n```\n\n#### Условия [числа (строки)]:\n\n<число/строка> операция <число/строка>\n\n- -eq == # равно\n- -ne != # не равно\n- -lt < # меньше\n- -le # меньше или равно\n- -gt > # больше\n- -ge # больше или равно\n\nоперации вида “-хх” – только для чисел!  \nоперации-знаки – только для строк!  \n\n#### Условия (файлы):\n- -e <путь> # путь существует\n- -f <путь> # это файл\n- -d <путь> # это директория\n- -s <путь> # размер файла больше 0\n- -x <путь> # файл исполняемый\n\n#### Условия (логические):\n- ! # отрицание логического выражения\n- && # логическое «И»\n- || # логическое «ИЛИ»\n\n### Ветвление: альтернативы\n#### Синтаксис:\n```\nif [[ условие ]]\nthen\n    # действия, если условие истинно\nеlse\n    # действия, если условие ложно\nfi\n```\n\n```\nif [[ условие1 ]]\nthen\n    # действия, если условие1 истинно\nelif [[ условие2 ]]\nthen\n    # действия, если условие1 ложно,\n    # но условие2 истинно\nеlse\n    # действия, если оба условия ложны\nfi\n```\n\n```\ncase переменная in\nзнач1)\n    # действия, если переменная==знач1\n    ;;\nзнач2)\n    # действия, если переменная==знач2\n    ;;\n*)\n    # действия, если переменная\n    # не равна ни одному из вариантов\nesac\n```\n\n### Циклы\n#### Синтаксис:\n```\nfor переменная in список_значений\ndo\n    # действия, каждый раз переменная\n    # принимает следующее значение\n    # из списка\ndone\n```\n\n```\nfor переменная in список_значений\ndo\n    # действия, каждый раз переменная\n    # принимает следующее значение\n    # из списка\ndone\n```\n\nbreak прервать выполнение  \nсontinue перейти на след. значение\n\n\n```\nwhile [[ условие ]]\ndo\n    # действия, пока условие истинно\ndone\n```\n\n- read переменная - записать введенное пользователем значение в переменную\n\n\n### Арифметика\n#### Синтаксис:\nlet “переменная = выражение”\n\nПример:\n```\nlet “c = 1 + 1”\nlet “c = a + b”\n```\n \n#### Операции:\n- +, -, /, * стандартные\n- % остаток от деления\n- ** возведение в степень\n\n#### Cокращение:\nlet “a=a+b” эквивалентно let “a+=b”\n\n### Внешние программы\n#### Синтаксис:\nпеременная=`программа`\n\nПример:\n```\na=`echo “test”`\nfiles=`ls ~`\n```\n\n#### Код возврата:\n- 0 корректное завершение\n- не 0 в процессе работы были ошибки\n\n#### Узнать код:\n$?\n\n#### Выйти с кодом:\nexit код\n\nПример:\n```\ntouch file.txt\necho $?\n```\n\n\nПроверка кода возврата:\n```\nif `программа`\nthen\n    # действия, если код 0\nеlse\n    # действия, если код не 0\nfi\n```\n\n### Функции\n#### Задаем функцию:\n```\nимя_функции ()\n{\n    # действия\n} \n```\n\n#### Используем функцию:\n...\nимя_функции\n...\n\n#### Функции с параметрами:\n```\nимя_функции ()\n{\n    # действия с $1, $2, … , $#\n}\n```\n\n#### Используем функцию:\n...\nимя_функции аргумент1 аргумент2 ...\n...\n\n#### Переменные:\n```\nимя_функции ()\n{\n    var_global=1\n    local var_local=1\n}\n```\n\n#### Используем:\nимя_функции\n```\necho $var_global # выведет 1\n```\n```\necho $var_local # ничего не выведет\n```\n\n#### Компактная запись:\n```\nимя_функции () { действ1; действ2; }\n```\n\n#### Актуально и в других конструкциях:\n```\nif [[ $var==”test ”]]; then\n...\nfor i in 1 2 3 4 5; do\n...\n```\n\n## Продвинутый поиск и редактирование\n- find -iname “<имя файла>” не учитывать регистр\n- find -path “<путь>” найти указанный путь\n- find -size <размер> выводить файлы указанного размера \n- find -maxdepth <число> искать не больше чем на заданное число уровней вниз\n- find -mindepth <число> искать начиная с заданного числа уровней вниз\n\n### Поиск строк по регулярному выражению\n- grep -l “<строка>” <файл> список файлов с этой строкой\n- grep -L “<строка>” <файл> список файлов, где этой строки нет\n- grep -n “<строка>” <файл> выводить номер строки в файле\n- grep -m <число> “<строка>” <файл> не искать дальше после заданного числа вхождений\n- grep -A <число> “<строка>” <файл> выводить это число строк после вхождения\n- grep -B <число> “<строка>” <файл> выводить это число строк до вхождения\n- grep -C <число> “<строка>” <файл> выводить это число строк вокруг вхождения\n- grep -E “<шаблон>” <файл> найти указанный шаблон в файле\n- grep -E “<шаблон>” <файл> найти указанный шаблон в файле\n- grep -E “^go” <файл> найти строки, начинающиеся с “go”\n- grep -E “go$” <файл> найти строки, оканчивающиеся на “go”\n- grep -E “c[au]t” <файл> найти все слова, содержащие cut и cat\n- grep -E “ [a-z]ight ” <файл> слова из 5 букв, кончающиеся на “ight”\n- grep -E “ [a-z]*ight ” <файл> слова из 4 и более букв, кончающиеся на “ight” \n- grep -E “ [a-z]+ight ” <файл> слова из 5 и более букв, кончающиеся на “ight”\n- grep -E “ [a-z]?ight ” <файл> слова из 4-5 букв, кончающиеся на “ight”\n- grep -E “ [a-zA-Z]*ight ” <файл> слова, кончающиеся на “ight” (разрешены большие буквы)\n\n- cat <файл> | sed ‘инструкция’\n- sed ‘инструкция’ <файл> - потоковый редактор: читает строчки из stdin (или из файла), обрабатывает их по инструкции и пишет в stdout\n\n### Если хотим писать в файл\n- \\> <файл> обычное перенаправление\n- -i, --in-place перезаписать входной файл\n- sed ‘s/John/Nick/g’ old.txt > new.txt заменить все John на Nick\n- sed -r ‘s/J[a-z]*n/Nick/g’ old.txt > new.txt заменить все слова, которые начинаются на J и кончаются на n на Nick\n- sed -n ‘2,4p’ file.txt вывести строки с 2 по 4\n- sed ‘2,4d’ file.txt вывести все строки кроме 2-4\n- sed -n ‘/[0-9]\\{2\\}/p’ file.txt вывести строки с 2 цифрами подряд\n- sed '2,/[Rr]ight/d' file.txt вывести все строки кроме со 2 до строки содержащей “right” (с большой или маленькой буквы)\n\n## Права доступа\n\n- users - узнать кто сейчас в системе\n\n- less /etc/passwd  \n    syslog&#58;x&#58;100:103::...  \n    bi&#58;x&#58;1000:1000:bi,,,...(UID >= 1000) - узнать какие вообще есть пользователи\n\n- groups <имя_пользователя> - узнать группы пользователя\n\n- ls -l <путь> - узнать права доступа\n```\nls -l <путь>\ndrwxrwxr-x 2 user group ... dir\n-rw-rw-r-- 1 user group ... file\n```\n \n- r (100, 4) – Read\n- w (010, 2) – Write\n- x (001, 1) – eXecute\n\n### Права у файлов\nr – просмотр содержимого  \nw – редактирование  \nx – запуск  \n\n### Права у директорий\nr – просмотр содержимого  \nw – создание/удаление файлов/поддиректорий  \nx – 1) вход в директорию  \n    2) просмотр inode файлов/поддиректорий\n \n### Изменить права доступа\n- chmod [ugoa][+-][rwx] <путь>\n```\nchmod ug+rw file.txt\n```\n- chmod [octal code] <путь>\n```\nchmod 777 file.txt\n```\n\n### Изменить обладателя\n- chown new_user:new_group <путь>\n```\nchown zoidberg file.txt\n```\n```\nchown :futurama file.txt\n```\n\n### Cуперпользователь\nroot (группа root)\n\n### Сделать от имени root:\n- sudo <действие>\n```\nsudo mkdir dir\n```\n```\nsudo chmod -r dir\n```\n\n### Посчитать что-то в файле:\n- wc [что-считаем] <путь>\n```\nwc -l file.txt\n```\n```\nwc -w file.txt\n```\n```\nwc -c file.txt\n```\n\n### Сравнить файлы/директории\n- diff [-q -r] <путь1> <путь2>\n```\ndiff file1.txt file2.txt | less\n```\n```\ndiff -qr dir1/ dir2/\n```\n\n### Узнать сколько места занимаем на диске\n- du [--max-depth <глубина> -h] <путь>\n```\ndu -h ~/\n```\n```\ndu –-max-depth 1 -h .\n```\n```\ndf [-h]\n```\n\n### узнать сколько места занято/свободно\n- во всей системе\n\nВывести часть файла:  \nhead [-n <количество строк>] <путь>  \ntail [-n <количество строк>] <путь>  \n```\nhead -n 10 file.txt\n```\n```\ntail -n 50 file.txt | less\n```\n\n### Работа с файлами/директориями\nможно использовать {имя1,имя2,...}  \nmkdir ./{dir1,dir2,dir3}  \ntouch ~/{file1,file2}.txt\n\n### Вывод с сортировкой:\n- ls --sort=[вид сортировки] -l <путь>\n```\nls –-sort=size -l ~/\n```\n```\nls –-sort=time -l .\n```\n\n### Перенаправление в один файл\n- &> или &>>\n```\nprogram &>> both.txt\n```\n\n### Перенаправление одного потока в другой\n- 2>&1 stderr в stdout\n- 1>&2 stdout в stderr\n\n### Перенаправление в никуда и из ниоткуда:\n- /dev/null\n```\nprogram 2>/dev/null\n```\n```\ncat /dev/null > file.txt\n```","category":"testops","description":"Linux"},{"title":"Общие вопросы TestOps","path":"/obshhie-voprosy-test-ops/","content":"\n## Какие есть виды индексов? Когда и зачем использовать?\nИндекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.\n\nВ общем виде, индекс в базах данных — это файл с последовательностью пар ключей и указателей. Идея использования индексов пришла от того, что современные базы данных слишком массивны и не помещаются в основную память. Мы обычно делим данные на блоки и размещаем данные в памяти поблочно. Однако поиск записи в БД может занять много времени. С другой стороны, файл индексов или блок индексов намного меньше блока данных и может поместиться в буфере основной памяти, что увеличивает скорость поиска записи.\n\nРазрежённый индекс (англ. sparse index) характеризуется тем, что каждый ключ ассоциируется с определённым указателем на блок в сортированном файле данных.\n\nПлотный индекс (англ. dense index) в свою очередь отличается тем, что каждый ключ ассоциируется с определённым указателем на запись в сортированном файле данных.\n\nВ кластерных индексах с дублированными ключами разрежённый индекс указывает на наименьший ключ в каждом блоке, в то время как плотный индекс указывает на первую запись с указанным ключом.\n\n## Можно ли вывести список баз данных/таблиц через CLI\n\nВ Postgress\n\n```\n-l или \\list\n```\n\nВ MySQL\n\n```sql\nSHOW DATABASES;\n```\n\n## Транзакции,команды для транзакций\nТранзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну операцию «всё или ничего». Промежуточные состояния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно завершить транзакцию, ни один из результатов этих действий не сохранится в базе данных.\n\nТранзакцией называется последовательность операций над данными имеющая начало и конец\n\nТранзакция это последовательное выполнение операций чтения и записи. Окончанием транзакции может быть либо сохранение изменений (фиксация, commit) либо отмена изменений (откат, rollback). Применительно к БД транзакция это нескольких запросов, которые трактуются как единый запрос.\n\nТранзакции должны удовлетворять свойствам ACID\n\nАтомарность. Транзакция либо выполняется полностью либо не выполняется вовсе.\n\nСогласованность. При завершении транзакции не должны быть нарушены ограничения накладываемые на данные (например constraints в БД). Согласованность подразумевает, что система будет переведена из одного корректного состояния в другое корректное.\n\nИзолированность. Параллельно выполняемые транзакции не должны влиять друг на друга, например менять данные которые использует другая транзакция. Результат выполнения параллельных транзакций должен быть таким, как если бы транзакции выполнялись последовательно.\n\nУстойчивость. После фиксации изменения не должны быть утеряны.\n\n```sql\nBEGIN;\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nSAVEPOINT my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\n-- ошибочное действие... забыть его и использовать счёт Уолли\nROLLBACK TO my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Wally';\nCOMMIT;\n```\n\n## Что такое индекс и что такое ключ\nКлюч представляет собой комбинацию полей, данные в которых однозначно определяют каждую запись в таблице. Простой ключ состоит из одного поля, а составной (сложный) из нескольких полей. Поля, по которым построен ключ, называют ключевыми. \n\nИндекс, как и ключ, представляет собой своеобразное оглавление таблицы, просмотр которого выполняется перед обращением к ее записям. Таким образом, использование индекса повышает скорость доступа к данным в таблице за счет того, что доступ выполняется не последовательным, а индексно-последовательным методом.\n\n## Deployment strategies\n\n### Rolling (постепенный, «накатываемый» деплой)\n\nЭто стандартная стратегия развертывания в Kubernetes. Она постепенно, один за другим, заменяет pod'ы со старой версией приложения на pod'ы с новой версией — без простоя кластера.\n\n### Recreate (повторное создание)\n\nВ этом простейшем типе развертывания старые pod'ы убиваются все разом и заменяются новыми\n\n### Blue/Green (сине-зеленые развертывания)\n\nСтратегия сине-зеленого развертывания (иногда ее ещё называют red/black, т.е. красно-чёрной) предусматривает одновременное развертывание старой (зеленой) и новой (синей) версий приложения. После размещения обеих версий обычные пользователи получают доступ к зеленой, в то время как синяя доступна для QA-команды для автоматизации тестов через отдельный сервис или прямой проброс портов\n\n### Canary (канареечные развертывания)\n\nКанареечные выкаты похожи на сине-зеленые, но лучше управляются и используют прогрессивный поэтапный подход. К этому типу относятся несколько различных стратегий, включая «скрытые» запуски и А/В-тестирование.\n\nЭта стратегия применяется, когда необходимо испытать некую новую функциональность, как правило, в бэкенде приложения. Суть подхода в том, чтобы создать два практически одинаковых сервера: один обслуживает почти всех пользователей, а другой, с новыми функциями, обслуживает лишь небольшую подгруппу пользователей, после чего результаты их работы сравниваются. Если все проходит без ошибок, новая версия постепенно выкатывается на всю инфраструктуру.\n\n### Dark (скрытые) или А/В-развертывания\n\nСкрытое развертывание — еще одна вариация канареечной стратегии (с ней, кстати, Flagger тоже может работать). Разница между скрытым и канареечным развертыванием состоит в том, что скрытые развертывания имеют дело с фронтендом, а не с бэкендом, как канареечные.\n\nДругое название этих развертываний — А/В-тестирование. Вместо того, чтобы открыть доступ к новой функции всем пользователям, ее предлагают лишь ограниченной их части. Обычно эти пользователи не знают, что выступают тестерами-первопроходцами (отсюда и термин «скрытое развертывание»).\n\n### Flagger и A/B-развертывания\n\nПомимо маршрутизации с учётом весов, Flagger также может направлять на канареечный сервер трафик в зависимости от параметров HTTP. При А/В-тестировании можно использовать заголовки HTTP или файлы cookie для перенаправления определенного сегмента пользователей. Это особенно эффективно в случае frontend-приложений, требующих привязки сессии к серверу (session affinity). Дополнительную информацию можно найти в документации Flagger.\n\n## Что такое контроллер?\nКонтроллер - это что-либо в вашем кластере, которое отслеживает хотя бы один другой тип ресурса Kubernetes. Контроллеры могут быть пассивными или активными. Активный контроллер сам выполнит необходимые действия; пассивы будут передавать изменения другим компонентам или серверу API кластера.\n\n## Что такое операторы?\nОператор - это специализированная форма контроллера. Операторы реализуют модель контроллера, что означает, что они переводят кластер в определенное состояние, но у них также есть дополнительные характеристики. Первоначально этот термин был придуман CoreOS, но теперь получил более широкое распространение в Kubernetes.\n\nОператоры адаптированы к конкретным приложениям. Они добавляют расширения Kubernetes API через пользовательские определения ресурсов, создавая новые типы объектов, используемых приложением, которым они управляют.\n\n## Права к файлу 755\nУ файла установлены права 755. \n\nПервая цифра — 7, это значит, что хозяин имеет на файл все права: чтение, запись и запуск (7 — 111). \n\nВторая цифра — 5, пользователи из одной с хозяином группы имеют возможность читать и запускать файл, но не могут в него писать (5 — 101). \n\nАналогично и все остальные — третья цифра тоже пятерка.\n\n## Какое максимальное количество docker layers возможно\n127\n\n## Что такое многоэтапный build\n\nмного-этапные (multi-stage builds) сборки позволяют значительно упростить процесс и описать его внутри Dockerfile. Каждая инструкция FROM может использовать индивидуальный базовый образ и каждая из них начинает новую стадию сборки docker образа. Но основное преимущество, что вы можете копировать необходимые артефакты из одной стадии в другую. В результате все вышеперечисленные шаги могут быть описаны вот так\nDockerfile:\n\n```docker\nFROM golang:latest as build\nCOPY . .\nRUN go build ./src/main.go\n\nFROM alpine:latest as production\nCOPY --from=build /go/main .\nCMD [\"./main\"]\n```\n\n## DinD (Docker in docker)\n\nDocker предоставляется в виде самодостаточного образа через тег docker:dind на Docker Hub.\n\nЗапустив этот образ, вы получите функционирующую установку демона Docker внутри вашего нового контейнера.\n\nОн будет работать независимо от демона вашего хоста, который запускает контейнер dind, поэтому docker ps внутри контейнера даст результаты, отличные от docker ps на вашем хосте.\n\n```\ndocker run -d --privileged --name docker \\\n    -e DOCKER_TLS_CERTDIR=/certs \\\n    -v docker-certs-ca:/certs/ca \\\n    -v docker-certs-client:/certs/client \\\n    docker:dind\n```\n\nИспользование Docker-in-Docker таким образом связано с одним большим предостережением: необходимо использовать привилегированный режим.\n\nЭто ограничение действует, даже если вы используете контейнеры без рутов.\n\nПривилегированный режим активируется флагом –privileged в команде, показанной выше.\n\nИспользование привилегированного режима дает контейнеру полный доступ к вашей хост-системе.\n\nЭто необходимо в сценарии Docker-in-Docker, чтобы ваш внутренний Docker мог создавать новые контейнеры.\n\nОднако в некоторых средах это может быть неприемлемым риском для безопасности.\n\nСуществуют и другие проблемы с dind.\n\nВ некоторых системах могут возникать конфликты с модулями безопасности Linux Security Modules (LSM), такими как AppArmor и SELinux.\n\nЭто происходит, когда внутренний Docker применяет политики LSM, которые внешний демон не может предугадать.\n\nЕще одна проблема связана с файловыми системами контейнеров.\n\nВнешний демон будет работать поверх обычной файловой системы вашего хоста, например ext4.\n\n## Переменная PATH\nДля того, чтобы посмотреть содержимое переменной PATH в Linux, выполните в терминале команду:\n\necho $PATH\n\nДля того, чтобы добавить новый путь к переменной PATH, можно воспользоваться командой export. Например, давайте добавим к значению переменной PATH папку/opt/local/bin. Для того, чтобы не перезаписать имеющееся значение переменной PATH новым, нужно именно добавить (дописать) это новое значение к уже имеющемуся, не забыв о разделителе-двоеточии:\n\nexport PATH=$PATH:/opt/local/bin\n\n## Команды для копирования и переименования файла\n- cp\n- mv\n\n## Команда env\n\nКоманда env позволяет модифицировать список переменных окружения перед исполнением пользовательской команды. В некоторых командных оболочках она является встроенной, в некоторых — внешней командой.\n\nБазовый синтаксис команды выглядит следующим образом:\n\n```\n$ env [параметры] [ИМЯ=ЗНАЧЕНИЕ] ... [команда]\n```\n\nПри вызове env без каких-либо параметров будет выведен список всех переменных окружения. \nИсполнение команды с измененными значениями переменных окружения\nДля изменения значения произвольной переменной окружения перед запуском команды достаточно указать имя этой переменной и ее значение после символа равенства. Например, для вывода времени по Гринвичу достаточно изменить значение переменной окружения TZ:\n\n```\n$ env TZ=GMT date\nСр июл 26 17:50:30 GMT 2017\n```\n\nИсполнение команды лишь с заданными переменными окружения\nДля исполнения команды с несколькими пользовательскими переменными окружения следует воспользоваться параметром -i и вручную задать значения необходимых переменных:\n```\n$ env -i PWD=/root env\nPWD=/root\n```\n\nDELETE vs TRUNCATE\n\n## Партиционирование \nПартиционирование – это метод разделения больших (исходя из количества записей, а не столбцов) таблиц на много маленьких. И желательно, чтобы это происходило прозрачным для приложения способом.\n\nкогда таблица готова, я могу создать партиции, что означает – наследованные таблицы:\n\ncreate table users_1 () inherits (users);\n\n* Deadlock\n* Задачка на LEFT JOIN примерно как в собесе выше\n\nЧто такое CI/CD\n* Инструменты (Jenkins, Gitlab CI ...)\n* Green / Blue deploy\n* Канареечный релиз\n* Балансировщик\n\n## В чем отличие контейнеризации от виртуализации\nВиртуализация - эмулируется аппаратное окружение и может быть запущен широкий спектр гостевых операционных систем,\nКонтейнеризация - может быть запущен экземпляр операционной системы только с тем же ядром, что и у хостовой операционной системы \nотсутствуют дополнительные ресурсные накладные расходы на эмуляцию виртуального оборудования и запуск полноценного экземпляра операционной системы","category":"testops","description":"Общие вопросы TestOps"},{"title":"Ресурсы. CI","path":"/resursy-ci/","content":"\n## Ресурсы. CI\n\nhttps://www.youtube.com/watch?v=RmziIx1D_Lo\n\nhttps://www.youtube.com/watch?v=jX9K5MqTNYM\n\nhttps://www.youtube.com/watch?v=XwQ65qaoPzw\n\nhttps://www.youtube.com/watch?v=hgi7AEEr2B0\n\nhttps://www.youtube.com/watch?v=Xos_J-byz3E\n\nhttps://www.youtube.com/watch?v=rg2PK0jECeM\n\nhttps://www.youtube.com/watch?v=1AJS74luWyI\n\nhttps://www.youtube.com/watch?v=oxbbnDpghCM\n\nhttps://www.youtube.com/watch?v=PeA1QLDxaFQ\n\nhttps://www.youtube.com/watch?v=xERPGjUVSCc\n\nhttps://www.youtube.com/watch?v=Iam2NlTukFQ\n\nhttps://www.youtube.com/watch?v=dxGGZQiuD6Q","category":"testops","description":"Ресурсы. CI"},{"title":"Ресурсы. Kubernetes, Docker, Selenoid","path":"/resursy-kubernetes-docker-selenoid/","content":"\n## Docker\n\nhttps://www.youtube.com/watch?v=0OIgiYVRDiI\n\nhttps://www.youtube.com/watch?v=LeA2_GJ1e70\n\nhttps://www.youtube.com/watch?v=QF4ZF857m44\n\n## Kubernetes\n\nhttps://www.youtube.com/watch?v=_-NRlfur9gE\n\nhttps://youtu.be/Hv1LjlTD3Dk\n\nhttps://www.youtube.com/watch?v=HsWsFuuOjKM\n\nhttps://www.youtube.com/watch?v=fVhpWxqBm2I\n\nhttps://www.youtube.com/watch?v=yPU7sYMGIgM\n\nhttps://www.youtube.com/watch?v=VqLW2TLJM3E\n\nhttps://www.youtube.com/watch?v=EnhwnuJRSXY\n\nhttps://www.youtube.com/watch?v=Mw_rEH2pElw&list=PL8D2P0ruohOBSA_CDqJLflJ8FLJNe26K-\n\n\n## Selenoid. How to.\n\nhttps://www.youtube.com/watch?v=0z3FFTCdYDY&t\n\nhttps://www.youtube.com/watch?v=L01F3i_ZZpA\n\nhttps://www.youtube.com/watch?v=zxMPrUOO48w&t=1242s\n\nhttps://www.youtube.com/watch?v=wAKcBinMn6o&t=1575s\n\nhttps://www.youtube.com/watch?v=Ig24ZJtRI-Y\n\n---\n\nhttps://www.youtube.com/watch?v=w-VXxYa8EJY\n\nhttps://youtu.be/hNBMavE_70Q\n","category":"testops","description":"Ресурсы. Kubernetes, Docker, Selenoid"},{"title":"Понимание DOM модели","path":"/ponimanie-dom-modeli/","content":"\nDOM — это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML-кода, полученного им от сервера. Иными словами, это представление HTML-документа в виде дерева тегов.\n\nБраузер запрашивает у сервера веб-страницу и получает в ответ ее исходный HTML-код. Браузеру такой код сначала нужно разобрать на элементы. В процессе разбора он строит на основе HTML-кода DOM-дерево. После этого браузер отрисовывает страницу, используя созданное им DOM-дерево, а не исходный HTML-документ.\n\nТакое дерево нужно для правильного отображения сайта и внесения изменений на страницах с помощью JavaScript. JavaScript — это «живой» язык, он может изменять страницу в реальном времени уже после того, как она «пришла» с сервера в браузер. Этим JavaScript принципиально отличается от PHP, который компилирует страницу и только потом посылает в браузер уже готовый HTML-код.\n\n![Схема отображения страницы в браузере](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image6-1.png)\n\nДля чтения и изменения DOM браузеры предоставляют DOM API (программный интерфейс). DOM API — это набор различных объектов, которые разработчик использует для чтения и изменения DOM с помощью JavaScript.\n\n### Из чего состоит HTML-код страницы\nСтраница на HTML состоит из тегов, вложенных в друг друга. Самый общий тег — это HTML. В него вкладываются два дочерних тега head и body.\n\nТег head используется для подключения информации, которая не будет отображаться непосредственно на странице, но будет использоваться для подключения важных файлов. Тут бывает, например, подключение одного или нескольких CSS-файлов, подключенные шрифты, название сайта, язык, кодировка, скрипты, которые должны выполняться в первую очередь, иконка сайта или базовый фон.\n\nВ body находится значимое содержимое. Обычно в body выделяют три части: шапка сайта, основное содержимое и подвал. В шапке обычно содержится верхнее меню сайта, за это отвечает тег header. Для содержимого нет определенного тега, но обычно используется section. Для подвала используется footer, там обычно содержатся контактная информация, ссылки на ключевые страницы сайта и копирайт. Теги header и footer должны быть единственными на странице, а section может бесконечно повторяться.\n\n## Как строится DOM-дерево\nДля описания структуры DOM потребуются термины: корневой, родительские и дочерние элементы. Корневой элемент находится в основании всей структуры и не имеет родительского элемента. Дочерние элементы не просто находятся внутри родительских, но и наследуют различные свойства от них. На картинке ниже изображено DOM-дерево.\n\n![DOM-дерево](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image4-1.png)\n\nКорневой элемент здесь html — без него страница не будет скомпилирована. Он не имеет родительского (вышестоящего) элемента, но имеет два наследника или дочерних элемента — head и body.\n\nПо отношению друг к другу элементы head и body являются сиблингами (братьями и сестрами). В каждый из них можно вложить еще много дочерних элементов. Например, в head обычно находятся link, meta, script или title.\n\nВсе эти теги не являются уникальными, и в одном документе может быть по несколько экземпляров каждого из них.\n\nВ body могут находиться разнообразные элементы. Например, в родительском body — дочерний элемент header, в элементе header — дочерний элемент section, в родительском section — дочерний div, в div — элемент h3, и наконец, в h3 — элемент span. В этом случае span не имеет дочерних элементов, но их можно добавить в любой момент.\n\nМожно описать это так:\n\n![Графическое представление элементов HTML-страницы](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image5-1.png)\n\nА если бы система была бы более разветвленная и с большим количеством вложений — так:\n\n![Графическое представление элементов HTML-страницы](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image1-2.png)\n\nНа схеме изображено довольно большое DOM-дерево, и его сложно воспринимать из-за его размера. Для удобства часто используется система многоуровневых списков. Например, предыдущее дерево можно преобразовать в такой список:\n![Представление элементов HTML-страницы в виде списка](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image2-2.png)\n\nЕсли преобразовать дерево на предыдущем рисунке в код, то получится так:\n\n```js\n<html>\n  <head>\n    <link>\n    <link>\n    <link>\n    <meta>\n    <meta>\n    <title></title>\n  </head>\n  <body>\n    <header>\n      <div>\n        <h3></h3>\n      </div>\n      <div>\n        <h4>\n          <span></span>\n        </h4>\n      </div>\n      <div>\n        <p></p>\n      </div>\n      <div>\n        <img>\n      </div>\n    </header>\n    <section>\n      <div>\n        <h3></h3>\n        <p>\n          <span></span>\n        </p>\n      </div>\n      <div>\n        <p>\n          <span></span>\n        </p>\n        <img>\n        <p></p>\n        <div>\n          <img>\n          <iframe></iframe>\n        </div>\n      </div>\n    </section>\n    <footer>\n      <div>\n        <img>\n        <p></p>\n      </div>\n      <div>\n        <h6></h6>\n      </div>\n    </footer>\n  </body>\n</html>\n```\n\nКак видно из кода, некоторые теги должны закрываться, а некоторые — нет.\n\nЭту схему важно понимать, чтобы разобраться с темой наследования свойств. Элементы могут наследовать не все, но многие свойства своих родителей — например, цвет, шрифт, видимость и т.д.\n\nТаким образом, чтобы задать стиль шрифта на всей странице, потребуется не прописывать цвет для каждого элемента, а задать его только для body. А чтобы изменить наследуемое свойство у дочернего элемента, нужно прописать только ему новые свойства. Наследование удобно для создания единообразной страницы.\n\n### Зачем нужно знать, как строится DOM-дерево?\nБольшинство действий при работе с DOM сводится к поиску нужных элементов. Не понимая, как строится DOM-дерево, и не зная, каковы связи между узлами, найти нужный элемент будет сложно.\n\n### Как просмотреть DOM-дерево?\nВ любом браузере есть инструменты, с помощью которых можно отобразить DOM-дерево. Если выбрать какой-либо объект в структуре, он будет подсвечен на странице. При этом для него будут выведены свойства CSS, которые работают сейчас, и те, которые не задействованы.\n\nЧтобы посмотреть DOM в браузере, нужно зайти в инструменты разработчика. В большинстве браузеров для этого надо нажать на F12 — тогда откроется дополнительная панель с вкладками и зонами.\n\n![Просмотр DOM-дерева в браузере](https://blog.skillfactory.ru/wp-content/uploads/2021/09/image3-2.png)\n\nНа изображении выше во вкладке Elements представлена структура DOM в виде многоуровневого вложенного списка. Каждый элемент можно открыть и посмотреть, что у него внутри, его расположение на странице и размеры этого элемента со всеми отступами.\n\nТакже там находятся другие инструменты — например консоль, где выводится информация об ошибках и куда можно ввести необходимые данные, например для отладки (исправления ошибок в коде).\n\nПанель ресурсов отображает подключенные ресурсы — это шрифты, изображения, JavaScript- и CSS-файлы.\n\n\nПо Web могут спросить что-то типа такого: «Что происходит, когда пользователь набирает в браузере адрес сайта?». Можно раскрыть, как браузер начинает искать сервер, как отправляет запрос к DNS-серверам, как попакетно устанавливается соединение с сервером, процесс обработки запросов и так далее.\n\nКроме того, могут спросить про коды состояний HTTP (Informational/Success/Redirection/Client Error/Server Error) и методы HTTP (GET/POST/PUT/DELETE).\n\nкак функционирует веб-приложение: понимать устройство HTTP-протокола, разбираться в связке HTML/CSS/JS.","category":"web","description":"Понимание DOM модели"},{"title":"Какие веб-элементы бывают","path":"/kakie-veb-elementy-byvayut/","content":"\nЭлемент HTML — это основная структурная единица веб-страницы, написанная на языке HTML. Данный элемент вы можете увидеть в исходном коде для всех веб-страниц после задания типа документа на первой строке на странице. DOCTYPE определяет, какую версию (X) HTML эта страница использует. Элементы страницы находятся между открывающим тегом `<HTML>` и закрывающим `</HTML>`. Элемент `<html>` называется корневым элементом\n\n**Основные элементы**\n\n### Гиперссылки\n`<a href=\"filename\" target=\"_self\">название ссылки</a>`\nАтрибут href задаёт значение адреса документа, на который указывает ссылка.\n\n### Якорь\nТот же элемент используется для создания так называемых «якорей» (anchor), которые могут потом использоваться в гиперссылках, направленных на какой-то определённый элемент страницы. \n\n### Текстовые блоки\n`<H1> … </H1>, <H2> … </H2>, … ,<H6> … </H6>` — заголовки 1, 2, … 6 уровня. Используются для выделения частей текста (заголовок 1 — самый крупный, 6 — самый мелкий).\n`<P>` — новый абзац. Можно в конце абзаца поставить </P>, но это не обязательно.\n`<BR>` — новая строка. Этот тег не закрывается (то есть не существует тега </BR>)\n`<HR>` — горизонтальная линия\n`<BLOCKQUOTE> … </BLOCKQUOTE>`  — цитата. Обычно текст сдвигается вправо.\n`<PRE> … </PRE>`  — режим preview (preformatted text). Пробельные символы остаются там, где они есть в оригинальном документе (в других тегах игнорируются). Внутри могут обрабатываться внутристроковые теги кроме img, object, big, small, sup и sub.\n`<DIV> … </DIV>`  — блок (обычно используется для применения стилей CSS)\n`<SPAN> … </SPAN>`  — строка (обычно используется для применения стилей CSS)\n\n### Форматирование текста\n`<EM> … </EM>`  — логическое ударение (обычно отображается курсивным шрифтом)\n`<STRONG> … </STRONG>`  — усиленное логическое ударение (обычно отображается жирным шрифтом)\n`<I> … </I>`  — выделение текста курсивом\n`<B> … </B>` — выделение текста жирным шрифтом\n`<U> … </U>`  — подчёркивание текста\n`<S> … </S>` (или `<STRIKE> … </STRIKE>` )— зачёркивание текста\n`<BIG> … </BIG>`  — увеличение шрифта\n`<SMALL> … </SMALL>`  — уменьшение шрифта\n`<BLINK> … </BLINK>`  — мигающий текст. Внимание! Этот тег не работает в браузере Internet Explorer версий 5 и ниже без применения JavaScript\n`<MARQUEE> … </MARQUEE>`  — сдвигающийся по экрану текст.\n`<SUB> … </SUB>`  — подстрочный текст. Например, H<SUB>2</SUB>O создаст текст H2O.\n`<SUP> … </SUP>`  — надстрочный текст. Например, E=mc<SUP>2</SUP> создаст текст E=mc2.\n`<FONT параметры> … </FONT>`  — задание параметров шрифта. \n\n### Списки\n\n`<UL><LI>` - неупорядоченный список\n`<OL><LI>` - упорядоченный список\n`<DL><DT><DD>` - список определений\n\n### Объекты\nEMBED — вставка различных объектов: не-HTML документов и media-файлов\nAPPLET — вставка Java-апплетов\nSCRIPT — вставка скриптов.\nIMG — вставка изображения. Этот тег не закрывается.\n\n### Карта изображений\n`<MAP><AREA></MAP>` — создание карты изображений позволяющей хранить в одном изображении несколько ссылок.\n\n### Таблицы\nTABLE — создание таблицы. Параметры тега:\nCAPTION — заголовок таблицы (этот тег необязателен)\nTR — строка таблицы\nTH — заголовок столбца таблицы (этот тег необязателен)\nTD — ячейка таблицы\n\n### Формы\nСоздание форм в HTML является довольно сложным делом. Здесь приводятся только названия основных тегов.\n\nFORM — создание формы\nINPUT — элемент ввода (может иметь разные функции — от ввода текста до отправки формы)\nTEXTAREA — текстовая область (многострочное поле для ввода текста)\nSELECT — список (обычно в виде выпадающего меню)\nOPTION — пункт списка\n","category":"web","description":"Какие веб-элементы бывают"},{"title":"UI/UX и Pixel Perfect","path":"/ui-ux-i-pixel-perfect/","content":"\nhttps://bugza.info/testirovanie-ui-i-verstki/\n\n## UI тестирование\n\nUI (user interface — пользовательский интерфейс) — является точкой взаимодействия человека и продукта. Дизайн кнопок, полей ввода и т.д. — это место, где пользователь взаимодействует с системой. Таким образом, Вы можете сравнить UI с рулем, педалями и приборной панелью автомобиля. Они используются для управления автомобилем так же, как приложение использует UI (пользовательский интерфейс) для управления системой. Короче говоря, дизайн пользовательского интерфейса (UI) — это дизайн точек взаимодействия, через которые пользователь может взаимодействовать с системой.\n\nТестирование интерфейса пользователя осуществляется вместе со следующими видами тестирования (UI):\n- Тестирование на соответствие стандартам графических интерфейсов.\n- Тестирование с различными разрешениями экрана.\n- Тестирование кроссбраузерности или совместимости с разными интернет браузерами и их версиями.\n- Тестирование локализованных версий: точность перевода (мультиязычность, мультивалютность), проверка длины названий элементов интерфейса и т.д..\n- Тестирование графического интерфейса пользователя на целевых устройствах (смартфоны, кпп, планшеты).\n\n### Основные элементы графического интерфейса:\n- Окно (окно браузера, диалоговое окно, модальное окно, плавающее окно).\n- Меню (главное, всплывающее, контекстное, системное).\n- Виджеты/элементы управления/контролы (аккордеон, кнопка, радио-кнопка, чек-бокс, значок (иконка), список, панель инструментов, дерево, полоса прокрутки, ползунок, строка состояния, тултип (подсказка) и др.).\n- Вкладка.\n\nЭлементы взаимодействия: курсор мыши, текстовый курсор, поинтер (“ладошка”), курсор перетаскивания и др.\n\n### Основные проверки при тестировании UI:\n- Расположение, размер, цвет, ширина, длина элементов; возможность ввода букв или цифр.\n- Реализуется ли функционал приложения с помощью графических элементов.\n- размещение всех сообщений об ошибках, уведомленией (а также шрифт, цвет, размер, расположение и орфография текста).\n- Читабелен ли использованный шрифт.\n- Переходит ли курсор из текстового в поинтер при наведении на активные элементы, выделяются ли выбранные элементы.\n- Выравнивание текста и форм.\n- Качество изображений.\n- Проверить расположение и отображение всех элементов при различных разрешениях экрана, а также при изменении размера окна браузера (проверить, появляется ли скролл).\n- Проверить текст на орфографические, пунктуационные ошибки.\n- Появляются ли тултипы (если есть необходимость).\n- Унификация дизайна (цвета, шрифты, текст сообщений, названия кнопок и т.д.).\n\n## Тестирование Pixel Perfect \nПроверка точного (пиксель в пикcель) соответствия сверстанного HTML-шаблона оригиналу (PSD-макету). Другими словами, если наложить “картинку” сверстанного HTML-шаблона на картинку оригинального PSD-макета, то обе картинки должны совпадать. Совместиться должны все элементы картинок: текст, изображения, графические элементы.\n\n## UX тестирование\n\nПри проектировке качественного UI уделяется внимание не только внешнему виду интерфейса, но и его логической структуре, чтобы пользователь мог без лишних усилий, быстро и легко взаимодействовать с ним и добиваться необходимого результата. Но, чтобы четко понимать, как создать качественный пользовательский интерфейс для конкретного продукта, необходимо изучать поведение, эмоции и реакцию пользователей при взаимодействии с данным продуктом, проводить тестирование, собирать данные. Человек, взаимодействуя с какой-либо системой, испытывает ощущения и реагирует определенным образом в процессе ее использования. Это называется опытом взаимодействия, или UX.\n\nUser Experience (пользовательский опыт)— ощущение, испытываемое пользователем во время использования цифрового продукта, в то время как User interface — это инструмент, позволяющий осуществлять интеракцию «пользователь — веб-ресурс». UX — это то, что чувствует и запоминает пользователь в результате использования программы, приложения или сайта. UX учитывается при разработке UI, создании информационной архитектуры, юзабилити тестировании. Определив целевую аудиторию и характеристики основного пользователя можно составить список требований к проекту.\n\nДля простоты усвоения разницы между 2 этими понятиями рассмотрим наглядный пример: предположим, мы едим сэндвич с сыром. Ощущения, получаемые во время поедания сэндвича, это и есть пользовательский опыт. Ингредиенты, составляющие наш воображаемый бутерброд (хлеб, майонез, сыр, сливочное масло и т. д.), могут считаться частью пользовательского интерфейса.\n\nОщущение, что мы получаем, когда едим бутерброд, можно считать UX, а ингредиенты сэндвича ассоциируются с UI\n\nСэндвич, сделанный из белого хлеба и сыра и майонеза с высоким содержанием жиров, на вкус почти также хорош, как бутерброд, состоящий из цельнозернового хлеба, низкокалорийного майонеза и нежирного сыра. Однако люди, стремящиеся к здоровому образу жизни, отвергнут первый сэндвич в пользу второго.\n\nИтак, у нас есть хороший интерфейс в обоих случаях, но мы не провели пользовательское исследование (а это неотъемлемая часть UX), мы не знаем соотношения пользователей, которые будут/не будут использовать наш продукт, в результате чего мы теряем весомую часть целевой аудитории.\n\nПроцесс проектирования UX включает в себя исследование поведенческих паттернов и психологических реакций пользователей, разработку информационной архитектуры, дизайн взаимодействия (interaction design), дизайн пользовательского интерфейса, интерактивное прототипирование макета (interactive prototyping) и тестирование юзабилити (usability testing).\n\nДизайнеры пользовательского интерфейса должны обладать навыками в области визуального дизайна, иконографики и типографики, однако в перечень их служебных обязанностей не обязательно входит проведение пользовательских исследований или построение информационной архитектуры веб-ресурса.\n\nА вот дизайнеры пользовательского опыта должны дополнительно еще и разбираться в исследованиях целевого рынка, information architecture и дизайне взаимодействий (что автоматически подразумевает базовое знание поведенческой психологии) и т. д.\n\n### Тестирование удобства пользования (Usability Testing)\nЮзабилити (usability) - дословно с английского означает: возможность использования или полезность. Юзабилити — это больше мера дружелюбности сайта или интерфейса программы, поскольку оно помогает сделать сайт понятным и естественным для пользователя.\n\nТестирование удобства пользования (Usability Testing) — это метод тестирования, направленный на установление степени удобства использования, обучаемости, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий.\n\n### Этапы тестирования удобства использования пользовательского интерфейса:\n\n1. Исследовательское — проводится после формулирования требований и спецификаций к системе, а также после разработки прототипа интерфейса. Основная цель на этом этапе — выяснить, позволяет ли он с достаточной степенью эффективности решать задачи пользователя.\n\n2. Оценочное — проводится после разработки низкоуровневых требований и детализированного прототипа пользовательского интерфейса. Оценочное тестирование углубляет исследовательское и имеет ту же цель. На данном этапе уже проводятся количественные измерения характеристик пользовательского интерфейса: измеряются количество обращений к системе помощи по отношению к количеству совершенных операций, количество ошибочных операций, время устранения последствий ошибочных операций и т.п.\n\n3. Валидационное — проводится ближе к этапу завершения разработки. На этом этапе проводится анализ соответствия интерфейса программной системы стандартам, регламентирующим вопросы удобства интерфейса, проводится общее тестирование всех компонентов пользовательского интерфейса (с точки зрения конечного пользователя). Под компонентами интерфейса здесь понимается как его программная реализация, так и система помощи и руководство пользователя. Также на данном этапе проверяется отсутствие дефектов удобства использования интерфейса, выявленных на предыдущих этапах.\n\n4. Сравнительное — данный вид тестирования может проводиться на любом этапе разработки интерфейса. В ходе сравнительного тестирования сравниваются два или более вариантов реализации пользовательского интерфейса.\n\nИз этого следует, что UI-тестирование, предполагает под собой тестирование на основании требований к внешнему виду пользовательского интерфейса и формам взаимодействия с пользователем. \n\nНа какие требования стоит обращать внимание при UI-тестировании:\n- Требования к размещению элементов управления на экранных формах.\n- Требования к содержанию и оформлению выводимых сообщений.\n- Требования к форматам ввода.\n- Требования к реакции системы на ввод пользователя.\n- Требования к времени отклика на команды пользователя.\n\nВажно обращать внимание на:\n- Простоту использования сайта или интерфейса.\n- Эффективность использования.\n- Запоминаемость.\n- Ошибки, их количество и серьезность.\n- Удовлетворение пользователя (субъективное).\n\nТестирование пользовательского интерфейса (UI) – тестирование, выполняемое путем взаимодействия с системой через графический интерфейс пользователя.\n\nGUI тестирование включает:\n- навигация;\n- цвета, графика, оформление;\n- содержание выводимой информации;\n- поведение курсора и горячие клавиши;\n- отображение различного количества данных (нет данных, минимальное и максимальное количество);\n- изменение размеров окна или разрешения экрана.\n\n\nТестирование удобства использования (Usability Testing) – тестирование с целью определения степени понятности, легкости в изучении и использовании, привлекательности программного продукта для пользователя при условии использования в заданных условиях эксплуатации:\n- визуальное оформление;\n- навигация;\n- логичность.\n\nCompatibility testing (тестирование совместимости) – процесс тестирования для определения возможности взаимодействия программного продукта, проверка работоспособности приложения в различных средах (браузеры и их версии, операционные системы, их типы, версии и разрядность)\n\nВиды тестов:\n- Кросс-браузерное тестирование (различные браузеры или версии браузеров).\n- Кросс-платформенное тестирование (различные операционные системы или версии операционных систем).\n\n\ntodo  добавить инструменты UI, UX и Pixel Perfect тестирования\n","category":"web","description":"UI/UX и Pixel Perfect"},{"title":"Работа с Dev Tool","path":"/rabota-s-dev-tool/","content":"\nhttps://www.youtube.com/watch?v=58_AqypXjG4\n\nhttps://www.youtube.com/watch?v=C8Z-N0y6Sqo ","category":"web","description":"Работа с Dev Tool"},{"title":"Тестирование верстки, JS ошибок","path":"/testirovanie-verstki-js-oshibok/","content":"\nhttps://quality-lab.ru/blog/layout-testing/\n\nhttps://vc.ru/dev/199130-kak-my-testiruem-frontend-html-verstku-chek-list\n\nhttps://habr.com/ru/post/114256/\n\nhttps://qna.habr.com/q/373556\n\nhttps://www.youtube.com/watch?v=GfPmWGU0vI0\n\nhttps://www.youtube.com/watch?v=vfOEGw-n7mA","category":"web","description":"Тестирование верстки, JS ошибок"},{"path":"/title/","content":""},{"path":"/title/","content":""},{"path":"/title/","content":""},{"path":"/title/","content":""},{"path":"/title/","content":""},{"path":"/title/","content":""},{"title":"Инфраструктура проекта автотестирования","path":"/infrastruktura-proekta-avtotestirovaniya/","content":"\n## Общая схема инфраструктуры\n\nИнфраструктура проекта по автоматизации тестирования состоит из следующих компонентов:\n\n- Selenium WebDriver\n- Язык программирования\n- Сборщик, менеджер зависимостей\n- Тестовый фреймворк\n\n## Инфраструктура для Java\n\n- Selenium WebDriver - chromedriver\n- Язык программирования - Java\n- Сборщик - Gradle\n- Менеджер зависимостей - Maven Central\n- Тестовый фреймворк - JUnit\n\n","category":"automation","description":"Инфраструктура проекта автотестирования"},{"title":"Понятие автоматизированного тестирования","path":"/ponyatie-avtomatizirovannogo-testirovaniya/","content":"\n## Что такое автоматизированное тестирование?\nАвтоматизированное тестирование (Automation Testing, Test Automation) — техника тестирования, в которой для выполнения тест кейсов используются специальные программы. Это отличает ее от ручного тестирования, в котором тест кейсы выполняются вручную тестировщиком.\n\nПрограммы для автоматизации сравнивают полученные результаты с актуальными и генерируют подробные тест-репорты.\n\nРазработка продукта циклична и итерационна — и на каждой итерации, как правило, требуется выполнение одного и того же набора тестов. С помощью инструментов автоматизированного тестирования можно записывать наборы тестов (test suites) и выполнять, когда это необходимо. Как только набор тестов автоматизирован, участие человека в выполнении тестов практически не требуется. Это делает автоматизированное тестирование эффективной техникой. Цель автоматизации — уменьшить количество тестов, которые нужно выполнять вручную.\n\n## Зачем нужно автоматизированное тестирование?\nАвтоматизированное тестирование — лучший способ улучшить эффективность, покрытие продукта тестами, уменьшить время на тестирование. \n\nПреимущества автоматизированного тестирования:\n\n- Автоматизированное тестирование увеличивает скорость тестирования\n- Автоматизированное тестирование не требует участия человека для выполнения тестов. Отсутсвует влияние человеческого фактора.\n- Средства автоматизации способны выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов. \n- Средства автоматизации способны собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.\n- Ручное тестирование всех возможных сценариев использования требует много времени (и, следовательно, денег)\n- Автоматизированные тесты могут быть запущены в любое время (днем, ночью, в выходные и праздники)\n- Многократное ручное тестирование одной и той же функциональности скучно\n\nНедостатки автоматизированного тестирования:\n\n- Необходимость наличия высококвалифицированного персонала в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, ко- дом и т.д.).\n- Разработка и сопровождение как самих автоматизированных тест-кейсов, так и всей необ- ходимой инфраструктуры занимает очень много времени.\n- Автоматизация требует более тщательного планирования и управления рисками,т.к. в противном случае проекту может быть нанесён серьёзный ущерб&\n- Коммерческие средства автоматизации стоят ощутимо дорого, а имеющиеся бесплатные аналоги не всегда позволяют эффективно решать поставленные задачи. \n- Средств атоматизации крайне много, что усложняет проблему выбора того или иного средства, затрудняет планирование и определение стратегии тестирования, может повлечь за собой дополнительные временные и финансовые затраты, а также необходимость обучения персонала или найма соответствующих специалистов.\n\n## Что автоматизировать в первую очередь?\n\nДля максимальной эффективности, для определения сценариев, подходящих под автоматизацию, пользуйтесь следующими критериями:\n\n- Критически важная бизнес-функциональность\n- Тест кейсы, которые нужно выполнять много раз\n- Тест кейсы, которые сложно воспроизвести вручную\n- Тест кейсы, воспроизведение которых занимает много времени\n\nСледующие критерии не подходят для автоматизации:\n\n- Новые тест кейсы, которые еще не были выполнены вручную\n- Тест кейсы для функциональности, требования к которой часто меняются\n- Тест кейсы, которые выполняются редко\n\n## Процесс автоматизированного тестирования\n\nШаг 1: Выбор инструмента для автоматизации\nШаг 2: Определение функциональности, которую нужно автоматизировать\nШаг 3: Планирование, тест дизайн и разработка тестов\nШаг 4: Выполнение тестов\nШаг 5: Поддержка написанных тестов\n\n### Определение функциональности, которую нужно автоматизировать\n\nОбласть для автоматизации может быть определена по следующим критериям:\n\n- Функциональность, которая важна для бизнеса\n- Сценарии, для тестирования которых нужны большие объемы входных данных\n- Функциональность, использующаяся в нескольких частях приложения\n- Целесообразность с технической точки зрения\n- Сложность написания тест кейсов\n- Возможность использования одних и тех же тест кейсов для кроссбраузерного тестирования\n- Планирование, тест дизайн и разработка\n\nСценарии, обычно подходящие для автоматизации:\n\nТесты, которые повторяются во всех билдах\nТесты, в которых легко могут возникать ошибки тестировщиков\nТесты с большими объемами данных\nЧасто используемые функции с большими рисками\nТесты, забирающие много ручного времени\nТесты, задействующие много разных программных/аппаратных конфигураций\n\nДалее пять вещей, которые нужно оценить до того как приступать к автоматизации.\n\n1. Автоматизируй Smoke-тесты.\nТакие тесты позволяют удостовериться, что приложение в целом работоспособно, и их желательно делать при каждом изменении функциональности, и после каждого билда. Smoke-тесты должны интегрироваться в CI/CD-процессы — это позволяет выловить критические ошибки. Smoke-тестами проверяют основные части приложения/сайта, они должны оставаться работоспособными в любых условиях; гарантируется, что билд достаточно стабилен, значит можно продвигаться дальше в пайплайне.\n\nАвтоматизация Smoke-тестирования помогает:\n\nОперативно найти критические баги, и сделать это очень рано в пайплайне. Главная страница/экран не открывается; у клиент не получается залогиниться или сделать себе аккаунт; платежные системы не подключаются и т.п.\nБыстрее идет устранение новых или “регрессионных” дефектов. Smoke-тесты сами по себе “дают широкое покрытие, но малую глубину” этого покрытия. Получается много тестовых кейсов без необходимости “глубокого погружения” тестировщиков в проект. Убедились, что самые важные части работоспособны — и идем дальше, к менее важным компонентам.\nАвтоматизация Smoke-тестов позволяет экономить время за счет уменьшения большого количества ручной работы. Включение автотестов в CI/CD позволяет проводить smoke-тестирование еще на этапе сборки билда. \n2. Автоматизируй тесты, которые пишутся всегда, и которые пишутся в начале каждого этапа\nТогда получаются стабильные тест-сьюты. К примеру, тестирование создания аккаунта должно делаться до того как юзер может логиниться и видеть свое клиентское окно, проводить платежи и т.п.\n\nСоздание автоматического “регрессионного” тестового набора (сьюта) позволяет:\n\nДелать тесты, оперативно находящие баги, возникающие из правок в коде. Правки могут быть новыми функциями, или “фиксами” прошлых багов. \nТестовый набор, как уже было сказано, получается с повышенной стабильностью и надежностью. Регрессионное тестирование обычно касается существующей функциональности, то есть функции уже тестированы неоднократно. Это повышает стабильность сьютов, экономится время ручных тестировщиков, когда не знаешь, реально “падают” тесты или они нестабильные.\nЭкономится время: можно сосредоточиться на ручном тестировании (особенно граничных значений).\n3. Автоматизируй “большие тесты” — с большим массивом данных\n“Большие тесты” — это может быть ввод больших массивов данных, тестирование форм, или тесты предполагающие многократный ручной ввод самых разных данных. Их-то и надо автоматизировать. Если речь идет о формах, автоматизация позволяет быстро протестировать комбинации данных в форме, например ситуации когда пропущены поля, данные неполные, и т.п. Тут полезно DDT-тестирование, позволяющее модифицировать только данные, а не весь скрипт. Это то что называется “реюзабельный” и эффективный подход.\n\n4. Автоматизируй тесты с множественными конфигурациями\nЕсли в проекте множество ОС и целый “парк браузеров”, будет сложная конфигурация.\n\nРучная конфигурация всего этого “парка” — утомительная вещь, и для экономии времени такое тестирование стараются автоматизировать. Тесты запускают в разных окружениях, меняя лишь переменную среды достаточно удобным образом. \n\nЖелательно также почитать что-то о параллельном тестировании, которое также экономит время. Можно применять специальные “тулзы” типа CircleCI — прописывают ОС/браузер/окружение, в которых будут выполняться параллельные тесты. \n\n5. Автоматизируй тесты производительности\nТакие тесты проводятся для устранения отказов приложения, улучшения пресловутого User Experience, и, разумеется, контроля производительности приложения. Проверяется, как приложение ведет себя под серьезной нагрузкой; находят ее проблемные точки; контролируют то что называется “плавность” приложения, время реакции на действия, стабильность, степень задействования аппаратных ресурсов девайса, и способность безболезненно реагировать на резкий рост нагрузки. \n\nАвтоматизация тестирования производительности — это когда генерируются тысячи условных “пользователей”, и проверяют, как реагирует приложение. \n\nКак часто будут выполняться написанные тесты?\nСамый важный вопрос. Автоматизировать тест-кейс имеет смысл в том случае, если он будет выполняться постоянно. Обязательно учитывайте частоту использования при составлении плана по автоматизации.\n\nДля какой функциональности разрабатываются автотесты?\nНекоторые части приложения имеют большее значение/влияние, чем другие. Очень важно, чтобы критическая функциональность была покрыта тестами в первую очередь — баги в таких местах будут стоить очень дорого. Здесь автоматизация однозначно себя окупит.\n\nПланируется ли запускать тест с разными наборами данных?\nРучное выполнение тест-кейсов с разными наборами входных данных — тяжелая работа. С помощью автотестов можно освободить время ручных тестировщиков и минимизировать шансы багов на продакшене.\n\nТест будет выполняться в регрессионном или smoke-тестировании?\nРегрессионное и smoke-тестирование выполняются очень часто. Это тест-сьюты, которые тестируют приложение “вширь” — т.е. тестируют корректность работы всего базового функционала. Регрессионные тесты интегрируются в процесс сборки приложения и выполняются во время каждого билда. Их автоматизация поможет улучшить качество продукта.\n\nПросто ли написать автотест с помощью ваших инструментов?\nНужно проводить анализ возможности (сложности) разработки конкретного тест-сьюта с помощью используемого инструмента автоматизации. Например, попытка автоматизировать тестирование запросов к SAP — не лучшая трата вашего времени, если инструмент не поддерживает такое тестирование. Использование другого инструмента для одной конкретной задачи тоже не лучшее решение. Такие места дешевле всего тестировать вручную.\n\nКак часто будет меняться/дорабатываться функциональность, которую планируется покрывать?\nВажный вопрос. В случае, если часть приложения будет часто меняться, дорабатываться, переписываться с нуля и т.п. — писать автотетсы для нее рано. Каждый раз после изменения функционала тесты нужно будет обновлять/переписывать заново.\n\nПоэтому узнайте о планах разработчиков на ближайшее время — если функциональность планируют менять, отложите написание автотестов до лучших времен.\n\nЭто негативный тест?\nПисать негативные автотесты — не лучшее решение.\n\nСмогут ли написанные тесты выполняться параллельно?\nЕсли процесс автоматизации хорошо выстроен, можно сэкономить много времени, запуская тесты параллельно. Параллельное выполнение очень важно для получение максимальной отдачи от автоматизации. Поэтому тесты, которые в конечном итоге смогут быть выполнены только в определенном последовательном порядке — не лучшие кандидаты на автоматизацию. Это не значит, что их не нужно автоматизировать вообще. Просто на данном этапе лучше поискать что-то более подходящее.\n\nНе пишутся ли тесты только ради отчетов?\nСовременные инструменты для автоматизации дают возможность генерировать классные отчеты о результатах тестирования. Однако, отчеты не являются целью автоматизации. Для улучшения качества нужно разбирать каждый упавший тест — определять, почему он упал и что нужно исправить. Написанные тесты нужно постоянно поддерживать в актуальном состоянии. Все это нужно держать в уме, когда вы собираетесь писать автотест для какой-либо функциональности. Автоматизация гораздо больше, чем красивые отчеты.\n\nНа этом этапе создается тест стратегия и тест-план, которые содержат следующие детали:\n\n- Выбранный инструмент автоматизации\n- Фреймворк с описанием его особенностей\n- Описание функциональности, тестирование которой будет автоматизировано\n- Подготовка стендов для выполнения тестов\n- Расписание выполнения автотестов\n- Результаты автоматизированного тестирования\n\n### Выполнение тестов\n\nВо время этой стадии происходит выполнение автотестов. После выполнения генерируется подробный тест репорт.\n\nВыполнение тестов может быть запущено как из инструмента автоматизации напрямую, так и с помощью системы управления тестированием (Test Management Tool), который запустит инструмент автоматизации.\n\n### Поддержка написанных тестов\n\nНа стадии поддержки происходит изменение существующих тестов (в случае планируемого изменения функциональности) или добавление новых тестов.\n\n## Советы по использованию инструментов автоматизации\n\n- Функциональность, подходящая для автоматизации, должна быть определена до начала разработки проекта.\n- Инструмент для автоматизации должен быть выбран исходя из требований конкретного продукта, а не из популярности.\n- Придерживайтесь стандартов написания кода, когда разрабатываете автотесты. Вот некоторые из них:\n    - Придерживайтесь гайдлайнов при написании кода\n    - Оставлйте комментарии\n    - Обрабатывайте ошибки — при разработке думайте о том, как отработает ваша система в случае некорректного поведения приложения.\n- Собирайте метрики, чтобы определить эффективность автоматизированного тестирования. Вот некоторые из них:\n    - Процент найденных багов\n    - Время, затраченное на выполнение автотестов для каждого релиза\n\n## Типы автоматизированного тестирования\n\n|Случай/задача | В чём проблема автоматизации|\n|---|---|\n|Регрессионное тестирование|Необходимость выполнять вручную тесты, количество которых неуклонно растёт с каждым билдом, но вся суть которых сводится к проверке того факта, что ранее работавшая функциональность продолжает работать корректно.|\n|Инсталляционное тестирование и настройка тестового окружения.|Множество часто повторяющихся рутинных операций по проверке работы инсталлятора, размещения файлов в файловой системе, содержимого конфигурационных файлов, реестра и т. д. Подготовка прило- жения в заданной среде и с заданными настройками для проведения основного тестирования.|\n|Конфигурационное тестирование и тестирование совместимости.|Выполнение одних и тех же тест-кейсов на большом множестве входных данных, под разными платформами и в разных условиях. Классический пример: есть файл настроек, в нём сто параметров, каждый может принимать сто значений: существует 100100 вариантов конфигурационного файла — все их нужно проверить.|\n|Использование комбинаторных техник тестирования (в т.ч. доменного тестирования).|Генерация комбинаций значений и многократное выполнение тест-кейсов с использованием этих сгенерированных комбинаций в качестве входных данных.|\n|Модульное тестирование.|Проверка корректности работы атомарных участков кода и элементарных взаимодействий таких участков кода — практически невыполнимая для человека задача при условии, что нужно выполнить тысячи таких проверок и нигде не ошибиться.|\n|Интеграционное тестирование.|Глубокая проверка взаимодействия компонентов в ситуации, когда человеку почти нечего наблюдать, т. к. все представляющие интерес и подвергаемые тестированию процессы проходят на уровнях более глубоких, чем пользовательский интерфейс.|\n|Тестирование безопасности.|Необходимость проверки прав доступа, паролей по умолчанию, открытых портов, уязвимостей текущих версий ПО и т. д., т. е. быстрое выполнения очень большого количества проверок, в процессе которого нельзя что-то пропустить, забыть или «не так понять».|\n|Тестирование производительности.|Создание нагрузки с интенсивностью и точностью, недоступной человеку. Сбор с высокой скоростью большого набора параметров работы приложения. Анализ большого объёма данных из журналов работы системы автоматизации.\n|Дымовой тест для крупных систем.|Выполнение при получении каждого билда большого количества достаточно простых для автоматизации тест-кейсов.|\n|Приложения (или их части) без графического интерфейса.|Проверка консольных приложений на больших наборах значений параметров командной строки (и их комбинаций). Проверка приложений и их компонентов, вообще не предназначенных для взаимодействия с человеком (веб-сервисы, серверы, библиотеки и т. д.)|\n|Длительные, рутинные, утомительные для человека и/или требующие повышенного внимания операции.|Проверки, требующие сравнения больших объёмов данных, высокой точности вычислений, обработки большого количества размещённых по всему дереву каталогов файлов, ощутимо большого времени выполнения и т.д. Особенно, когда такие проверки повторяются очень часто.|\n|Проверка «внутренней функциональности» веб-приложений (ссылок, доступности страниц и т. д.)|Автоматизация предельно рутинных действий (например, проверить все 30’000+ ссылок на предмет того, что все они ведут на реально существующие страницы). Автоматизация здесь упрощается в силу стандартности задачи — существует много готовых решений.|\n|Стандартная, однотипная для многих проектов функциональность.|Даже высокая сложность при первичной автоматизации в таком слу- чае окупится за счёт простоты многократного использования полу- ченных решений в разных проектах.|\n|«Технические задачи».|Проверки корректности протоколирования, работы с базами данных, корректности поиска, файловых операций, корректности форматов и содержимого генерируемых документов и т. д.|\n ","category":"automation","description":"Понятие автоматизированного тестирования"},{"title":"Сортировки. Быстрая, слиянием и поразрядная","path":"/sortirovki-bystraya-sliyaniem-i-porazryadnaya/","content":"\n## Быстрая сортировка. Quick sort","description":"Сортировки. Быстрая, слиянием и поразрядная"},{"title":"Линейный поиск","path":"/linejnyj-poisk/","content":"\n## Классические задачи линейного поиска\n\nЛинейный поиск - способ поиска, когда перебираются все элементы.\n\nСложность линейного поиска - линейная, т.е. $O(N)$.\n\nОбычно ищут \"подходящий\" элемент или \"наиболее подходящий элемент\".\n\n### Задача 1. Найти первое вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию.\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (ans == -1 && seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 2. Найти последнее вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию (без проверки что текущая позиция равна -1).\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 3. Найти максимальное число в последовательности.\nДана последовательность чисел длиной N (N>0). Найти максимальное число в последовательности.\n\nРешение:\n\nСначала положим в ответ нулевой элемент последовательности (он точно существует, тк N>0), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент.\n\n```java\npublic static int findMax(int[] seq) {\n    int ans = seq[0];\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i] > ans) {\n            ans = seq[i];\n        }\n    }\n\n    return ans;\n}\n```\n\nЕсли условие допускает пустую последовательность то этот случай нужно обрабатывать отдельно через if.\n\nСтроки сравниваются по символьно и когда символы начинают отличаться можно сказать какая строка меньше или больше. Если строки длинные то сравнение будет идти долго, время равно длине строки. \n\nЛексикографический порядок - это сравнение с учетом регистра.\nАлфавитный порядок - это сравннеие, как в словаре, без учета регистра.\n\nРешение задачи не подойдет для строк, так как будет постоянно перезаписываться значение ans, а для строк это требует больше времени, строки могут быть длинные.\n\nНужно запоминать не значение, а индекс максимального элемента. \n\n```java\npublic static String findMax(String[] seq) {\n    int ans = 0;\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i].compareTo(seq[ans]) == 0) {\n            ans = i;\n        }\n    }\n\n    return seq[ans];\n}\n```\n\n### Задача 4. Найти максимальное число в последовательности и второе по величине число.\nДана последовательность чисел длиной N (N>1). \nНайти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число).\n\nРешение:\n\nЗаведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого макисмума, а меньшее - для второго. Пройдем по всей последовательности. Если очередное число больше первого максимума, то запишем во второй макисмум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй макисмум.\n\n```java\npublic static int[] findMax2(int[] seq) {\n        int max1, max2;\n        if (seq[0] > seq[1]) {\n            max1 = seq[0];\n            max2 = seq[1];\n        } else {\n            max1 = seq[1];\n            max2 = seq[0];\n        }\n        for (int i = 2; i < seq.length; i++) {\n            if (seq[i] > max1) {\n                max2 = max1;\n                max1 = seq[i];\n            } else if (seq[i] > max2) {\n                max2 = seq[i];\n            }\n        }\n        return new int[]{max1, max2};\n    }\n```\n\n### Задача 5. Найти минимальное четное число в последовательности.\nДана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого не существует.\n\nРешение:\n\nВ переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.\n\nУниверсальный способ для решения это завести boolean переменную с признаком встречали ли мы четное число или нет. Изначально она равна fasle, а как встретили четное число делаем ее true.\n\n```java\npublic static int findMinEven(int[] seq) {\n    int ans = 0;\n    boolean isFound = false;\n\n    for (int i = 0; i < seq.length; i++) {\n        int now = seq[i];\n        if (now % 2 == 0 && (!isFound || now < ans)) {\n            ans = now;\n            isFound = true;\n        }\n    }\n    return ans;\n}\n```\n\n## Два прохода\n\n### Задача 6. Вывести все самые короткие слова через пробел.\n\nДана последовательность слов. Вывести все самые короткие слова через пробел.\n\nЕсли решать задачу за один проход, то есть сохранять количество символов в строке и саму строку и при нахождении еще более меньшей обновлять ее, это будет медленно и будет лишняя память заниматься. Так как мы будем накапливать слова, и хороше если добавление слова будет занимать $O(1)$, но может быть и больше, если копировать сами объекты. В Java лучше использовать для этих целей StringBuilder или StringBuffer.\n\n```java\npublic static String shortWords(String[] words) {\n    int minLength = words[0].length();\n    for (String word : words) {\n        if (word.length() < minLength) {\n            minLength = word.length();\n        }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (String word : words) {\n        if (word.length() == minLength) {\n            ans.append(word).append(\" \");\n        }\n    }\n\n    return ans.toString();\n}\n```\n\n### Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.\n\nИгра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окруженный морем. Над островом прошел сильный дождь, который затопил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень.\n\nПо ландшафту острова определить, скоолько блоков воды осталось после дождя в низинах острова.\n\n**_Решение:_**\n\nПосле того как вода нальется наш остров примет форму ступенек. Давайте найдем самый высокий столбик(вершину) и до этой вершины будут ступеньки на подъем, вся вода будет сливаться влево от вершины, а все что справа от вершины будет утекать вправо. \n\nРазделим задачу на две задачи по вершине острова и решим сначала для левой а потом по аналогии для правой.\n\nБудем идти и запоминать максимальную высоту столбика который нам встретился, если следующий столбик меньше то добавляем разность высот между этими столбиками которая зальется водой, если же произошло обновление максимума, то количество воды не добавляем.\n\n```java\npublic static int isleFlood(int[] h) {\n    int maxPos = 0;\n    for (int i = 0; i < h.length; i++) {\n        if (h[i] > h[maxPos]) {\n            maxPos = i;\n        }\n    }\n\n    int ans = 0;\n    int nowMax = 0;\n    for (int i = 0; i < maxPos; i++) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n\n    nowMax = 0;\n    for (int i = h.length - 1; i > maxPos; i--) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n    return ans;\n}\n```\n\n## Задача с собеседования\n\n### Задача 8 - RLE\n\nДана строка (возможно пустая), состоящая из букв A-Z: AAAABBBCCХYZDDDВEEEFFFAAAAAABBBBBBBBBBBBBBBBBB}\nНужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3F3A6B18. И сгенерирует ошибку если на вход пришла невалидная строка.\n\nЕсли символ встречался один раз, он остается без изменений; Если символ повторяется более 1 раза, к нему добавляется количество повторений.\n\n\nПопробуем упростить задачу и написать сначала функцию которая выдаст в ответе строку ABCXYZDEFAB.  \nКладем изначально в переменную значение первого символа, далее проходим по всей строки и проверяем если символ не соответсвует предыдущему то добавляем предыдущий символ и обновляем его. В конце добавляем оставшийся последний символ.\n\n```java\npublic static String easyPeasy(String s){\n    StringBuilder ans = new StringBuilder();\n    char lastCh = s.charAt(0);\n    for (int i = 1; i < s.length(); i++) {\n        if(s.charAt(i) != lastCh){\n            ans.append(lastCh);\n            lastCh = s.charAt(i);\n        }\n    }\n    ans.append(lastCh);\n\n    return ans.toString();\n}\n```\n\nДля полноценного выполнения задачи чтобы посчитать сколько раз символ подряд встретился в строке нужно добавить разность между последней позицией текщего повторяющегося символа и позицией последнего отличающегося символа. Добавим анонимную функцию для вычисления.\n\n```java\npublic static String rle(String s) {\n    StringBuilder ans = new StringBuilder();\n    int lastPos = 0;\n    char lastCh = s.charAt(0);\n\n    BiFunction<StringBuilder, Integer, StringBuilder> pack =\n            (str, cnt) -> {\n                if (cnt > 1) {\n                    return str.append(cnt);\n                }\n                return str;\n            };\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) != lastCh) {\n            ans.append(lastCh);\n            pack.apply(ans, i - lastPos);\n            lastCh = s.charAt(i);\n            lastPos = i;\n        }\n    }\n\n    ans.append(lastCh);\n    pack.apply(ans, s.length() - lastPos);\n\n    return ans.toString();\n}\n```\n## Вопросы\n\n1. _**Алгоритмы линейного поиска это про алгоритмы Рабина Карпа?**_\nАлгоритм Рабина Карпа - это алгоритм поиска подстроки в строке и его с большой натяжкой можно назвать алгоритмом линейного поиска. Это довольно умный алгоритм.\n\n2. **_Волнует ли вопрос оптимизации в алгоритме линейного поиска?_**\nДа, волнует, но бывают такие последовательности которые не обладают никаким свойством и задачи поиска максимума или поиска значения в последовательности про которую ничего не известно, никак быстрее не сделать мы так или иначе должны посмотреть каждое значение. ","description":"Линейный поиск"},{"title":"Сложность, тестирование, особые случаи","path":"/slozhnost-testirovanie-osobye-sluchai/","content":"\n## Сложность\n\nДля тренировки нужно написать 10000 строк кода.\nДля этого можно использовать сайты leetcode.com, codeforces.com\n\n**Сложность алгоритма** - это порядок количества действий, которые выполняет алгоритм.\n\nЕсли сложность $O(N)$ - это значит, что скорость алгоритма зависит напрямую от количества данных и такую сложность называют **линейной**. \nНапример, обычный цикл от $1$ до $N$.\n\nЕсли в программе два вложенных цикла, каждый от $1$ до $N$, тогда сложность составит $O(N^2)$.\n\n$O$ никак не зависит от константы.  \n$100*N = O(N), 2*N=O(N)$. Здесь 2 и 100 - константы, не зависящие от размера входных данных.  Константы не так сильно влияют на скорость алгоритма при больших параметрах.\n\nНапример, алгоритм, который работает за $O(100*N)$ будет работать лучше, чем $O(1*N^2)$, поэтому константа не так принципиальна.\n\nТ.е. если в алгоритме выполняется цикл, то не важно сколько действий выполняется внутри цикла, важно сколько вхождений выполнится.\n\n$O$(O-большое) означает, что наш алгоритм работает не более, чем за столько действий сколько указано в скобках, например $O(N) = 10 * N$ - означает что найдется такое число, в нашем случае 10, что наш алгоритм гарантировано совершит не больше, чем 10 * N  действий. Чем асимптотическая сложность ниже, тем лучше, тем быстрее решается.\n\nСравнение алгоритмов по асимптотической сложности имеет смысл проводить только для больших значений параметров, пока он маленький там может произойти, что угодно :). \n\nЕще существует **\"пространственная сложность\"** - количество использованной памяти, сколькдополнительной памяти потребляет наш алгоритм.\nПамяти алгортим не может потребить больше чем он потратил времяБ потому что чтобы что то положить в ячейку памяти это тоже элементарная операция. \nНо иногда алгоритмы отличаются и по дополнительной памяти которую они употребляют. \n\n### Задача №1. Условие.\nДана строка в кодировке UTF-8.  \nНайти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.\n\n### Задача №1. Решение 1.\n\nПереберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n--- \n\nЗаводим внешние переменные для максимального количества повторений и для значения символа. \n\nВнешний цикл сначала выбирает первый символ и далее проходит по строке и ищет сколько раз этот символ в ней встречается, запоминаем значение символа и количество повторений и сохраняем их во внешнюю переменную. \n\nЗатем переходим ко второму символу и также проверяем сколько раз он встретился, если количество его повторений больше, чем во внешней переменной, то обновляем значения для максимального количества повторений и для значения символа во внешних переменных и так далее до конца строки.\n\n**_Сложность алгоритма: _**$O(N^2)$, тк 2 вложенных цикла.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    int ansCount = 0;\n    char ans = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char nowChar = s.charAt(i);\n        int nowCount = 0;\n\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == nowChar) {\n                nowCount += 1;\n            }\n        }\n\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = nowChar;\n        }\n    }\n    return ans;\n}\n```\n\nНо есть более эффективное решение. \n\n### Задача №1. Решение 2.\n\nПереберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n---\n\nПолучаем список уникальных букв через Set. \n\nПроходим по нему в цикле и для каждой из букв запускаем цикл, который подсчитывает количество повторений для этой буквы. \n\nЗаписываем в счетчик и возвращаем искомый символ.\n\n**_Сложность алгоритма: _**$O(N*K)$, где K - количество уникальных букв, цикл по ним чтобы узнать, сколько каждая из них встречалась раз, N - общее количество букв, цикл по N, чтобы найти количество повторений для каждой из уникальных букв.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    Set<Character> str = s.chars().mapToObj(e -> (char) e).collect(Collectors.toSet());\n\n    char ans = 0;\n    int ansCount = 0;\n\n    for (Character now : str) {\n        int nowCount = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == now) {\n                nowCount += 1;\n            }\n        }\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = now;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача №1. Решение 3.\n\nЗаведем словарь, где ключом является символ, а значением - сколько раз он встретился. \n\nПроходим в цикле по всем символам строки и если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Далее для текущего символа в словаре прибавляем к элементу словаря с ключом, совпадающим с этим символом единицу. \n\nПосле выполнения прохода по всем символам, запускаем цикл прохода по ключам словаря и сравниваем значение по ключу с текущим максимальным повторением, если значение больше то переписываем символ в ответе и макимальное количество повторений.\n\n**_Сложность алгоритма: _**$O(N + K) = O(N)$, N - количество проходов пока формировали словарь, K - количество прохода только по (уникальным) ключам. Но так как K обычно меньше N то можно сказать что алгоритм выполняется за $O(N)$.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    char ans = 0;\n    int ansCount = 0;\n    Map<Character, Integer> dict = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char now = s.charAt(i);\n        if (!dict.containsKey(now)) {\n            dict.put(now, 0);\n        }\n        dict.put(now, dict.get(now) + 1);\n    }\n\n    for (Character key : dict.keySet()) {\n        if (dict.get(key) > ansCount) {\n            ansCount = dict.get(key);\n            ans = key;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Сравниваем затраченное время и память (дополнительную)\n\n|Решение|Время|Память|\n|---|---|---|\n|#1 Проход по строке для каждого символа|$O(N^2)$|$O(N)$ - так как храним только саму строку|\n|#2 Проход по строке для каждого символа в множестве|$O(N*K)$|$O(N+K) = O(N)$ - храним строку и множество ($K$)|\n|#3 Использование словаря|$O(N)$|$O(K)$ - храним только словарь из K элементов|\n\n## Особые случаи\n\n### Сумма последовательности\n\nВ данном алгоритме не обязательно делать проверку на пустую строку так как и без этой проверки у нас выведется ноль.\n\n```java\npublic static int sequenceSum(String s) {\n    int[] sequence = s.chars().toArray();\n    int sequenceSum = 0;\n    for (int i = 0; i < sequence.length; i++) {\n        sequenceSum += sequence[i];\n    }\n    \n    return sequenceSum;\n}\n```\n\n### Максимум последовательности\n\nВ этом алгоритме мы не можем задать начальное значение нулем, тк в массиве могут быть еще и отрицательные значения, поэтому необходимо добавить ночальную проверку на пустую строку и при выполнении алгоритма стартовому значению присвоить первое значение в массиве.\n\n```java\npublic static double sequenceMax(String s) {\n    int[] sequence = s.chars().toArray();\n    if (sequence.length == 0) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        int sequenceMax = sequence[0];\n        for (int i = 0; i < sequence.length; i++) {\n            if (sequence[i] > sequenceMax) {\n                sequenceMax = sequence[i];\n            }\n        }\n        return sequenceMax;\n    }\n}\n```\n\n## Тестирование\n\nПри тестировании алгоритма нужно проверить:\n\n- тесты из условия (если есть)\n- общие случаи\n- особые случаи (все числа отрицательные, пустая последовательность)\n\nТесты для алгоритма на поиск максимума последовательности:\n\n- 1 3 2 - общий случай (максимум в середине)\n- 1 2 3, 3 2 1 - максимум по краям \n- 1 1 1 - все элементы одинаковы\n- 1 - один элемент\n- _ - пустая последовательность\n- -2 -1 -3 - все числа отрицательные\n\n### Советы по составлению тестов\n\n- Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу;\n- Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить;\n- Проверь последовательность из одного элемента и пустую последовательность;\n- \"Краевые эффекты\" - проверь что программа работает корректно в начале и конце последовательности сделай тесты чтоы ответ находился на первом и на последнем месте последовательности;\n- Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else;\n- Подбери тесты чтобы не было ни одного входа в цикл;\n- Один тест - одна возможная ошибка;\n\n## Вопросы\n\n1. **_Что приоритетней оптимизация по памяти или по времени исполнения?_**\n\nЧаще всего по времени исполнения, а если есть несколько алгориитмов с одинаковым временем то уже по памяти.\nНо бывают редкие задачи, где память играет решающее значение.\n\n2. **_Почему в решение №3 мы использовали Set но не считали его асимптотическую сложность?_**\n\nДобавление в Set происходит за $O(1)$ времени. Объяснение будет в следующих лекциях.\n\n3. **_Как проверить алгоритм, если не знаешь где может быть ошибка?_**\n\n    1. пишем самый простой базовый алгоритм для решения задачи\n    2. пишем генератор маленьких массивов из случайных чисел\n    3. запускаем цикл и сравниваем ответ нашего алгоритма с ответом примитивного алгоритма","description":"Сложность, тестирование, особые случаи"},{"title":"Множества","path":"/mnozhestva/","content":"\n## Как устроено множество\n\nМножество - это математическая структура, где каждый элемент либо есть, либо его нету.\n\nЧто должно уметь делать множество:\n\n- добавлять элемент\n- проверять наличие элемента\n- удалять элемент\n\n### Как реализовать множество\n\n- Придумаем какую-нибудь функцию которая сопоставляет каждому элементу какое-либо небольшое число\n- Вычислим функцию от элемента\n- Положим элемент в список с номером, равным значению фуекции\n\nСпособ 1: Завести массив где в ячейку с индексом равным числу которое мы кладем класть boolean переменную true что такое число есть. При удалении менять на false. Но тогда если множество будет большим это будет есть большое количество памяти а если таких множеств несколько то съест еще больше.\n\nСпособ 2: Чтобы поместить большое количество элементов в сравнительно небольшой массив нужно сопоставить каждому элементу какое-либо небольшое число. Для этого сформируем соответсвующую функцию. \n\n### Пример функции добавления для чисел\n\n- Функция - последняя цифра числа $X (F(X) = X \\% 10)$. \nФункция которая переводит большие числа в маленькие  - хеш функция.\n- Вычислим функцию от элемента.\n- Положим элемент в список с номером, равным значению функции.\n\nНапример, наша функция преобразует число 137 -> 7 и  17 -> 7. Такая ситуация называется **коллизией**.\nЕсли мы будем класть в ячейку true/false то когда мы получим число 137 мы положим в ячейку с номером 7 флаг true и когда нас запросят узнать есть ли в множестве число 17 мы скажем что да а это неверно.\n\nОдним из решений этой проблемы - класть в ячейку не флаг а само число. Но в таком виде множество не может одновременно хранить в себе значения и 137 и 17 и т.д. \n\nРешением стало - завести список для всех чисел которые имеют одинаковый хеш. \n\nЕсли у нас множество длины N и внем лежит K элементов, то мы можем перебрать все элементов за N + K. Мы будем идти по всем спискам пока список пустой мы его пропускаем, а как только обнаруживаем непустой список у нас запускается внутренний цикл проходит по всем элементам и их возвращает.\n\nЕсли мы решим напечатать значения Set'a, то оно выводся в произвольном порядке (в порядке возрастания значения хеш функции).\n\nДля того чтобы удалить элемент мы сначала находим значение хеш функции находим ячейку с этим знаением и в найденном списке находим нужный элемент. \nУдаление-1: мы перемещаем элементы  на 1 позицию влево, начиная с позиции того элемента который хотим удалить и последний элемент удаляем. \nУдаление-2: копируем последний элемент на место элемента который удаляем и удаляем самый последний это возможно когда не важен порядок элементов.\nУдаление элемента происходит $O(1)$ а его поиск за $O(K/N)$.\n\n```java\npublic class MySet {\n\n    int setSize = 10;\n    int[][] mySet = new int[setSize][];\n\n\n    public void add(int x) {\n        int[] xSet = mySet[x % 10];\n        if (xSet == null) {\n            mySet[x % 10] = new int[]{x};\n        } else {\n            mySet[x % 10] = ArrayUtils.add(xSet, x);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"MySet{\" +\n                \"setSize=\" + setSize +\n                \", mySet=\" + Arrays.toString(mySet) +\n                '}';\n    }\n\n    public boolean find(int x) {\n        for (int now : mySet[x % 10]) {\n            if (now == x) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void delete(int x) {\n        int[] xList = mySet[x % 10];\n        for (int i = 0; i < xList.length; i++) {\n            int now = xList[i];\n            if (now == x) {\n                xList[i] = xList[xList.length - 1];\n                mySet[x % 10] = ArrayUtils.remove(xList, xList.length - 1);\n                return;\n            }\n        }\n    }\n}\n```\n\nМультимножество - такое множество в которое элемент входит несколько раз.\nЧтобы такого не допускать в методе добавления элемента стоит добавить проверку что такого элемента еще нет.\n\n$F(X) = X \\% setSize$ - хеш функция\n\n$MySet$ - хеш таблица\n\nСовпадение значений хеш-функции для разных параметров - коллизия.\n\n### Что можно эффективно хранить в множестве\n\n- Эффективно можно хранить только неизменяемые объекты.\n- Для неизменяемых объектов можно посчитать значение хеш-функции при их создании\n- Хеш функция должна давать равномерное распределение\n\n## Амортизированная сложность\n\nСлишком большой размер - ест много памяти $O(N)$\n\nСлишком маленький размер - большой коэфициент заполнения и медленный поиск и удаление $O(K/N)$\n\nХочется иметь разумный баланс, например, коэфициент заполнения не больше единицы (т.е. $K<=N$)\nТогда все операции в среднем будут занимать $O(1)$\n\nРешение проблемы: Когда таблица наполнится - увеличим ее размер вдвое и перестроим. Нужно пересчитать хеш каждого элемента в зависимости от нового размера и переместить элементы в соответсвующую ячейку.\n\nАмортизированная сложность - это среднее время выполнения опреации (условно).\n\nУ нас амортизированная сложность операции $O(1)$ - всего было N операций и суммарно на это ушло $O(N)$.\n\nВ худшем случае отдельная операция выполняется за $O(N)$ - может не подходить для систем реального времени.\n\n## Примеры задач\n\n### Задача 1. \nПереберем число А за $O(N)$. Переберем число B за $O(N)$. Если их сумма равна X, то вернем эту пару.\n\nРешение 1 (неправильное)\n\nНеправильное, так как не учитывает, что числа должны быть разные.\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int a : nums) {\n        for (int b : nums) {\n            if (a + b == sum) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\nРешение (исправленное)\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == sum) {\n                return new int[]{nums[i], nums[j]};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\n### Задача 2\nДан словарь из N слов, длина каждого не превосходит K. \nВ записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущеной буквой) в словарь.\n\n","description":"Множества"},{"title":"Словари и сортировка подсчётом","path":"/slovari-i-sortirovka-podschyotom/","content":"\n## Сортировка подсчетом\n\nПусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K. Все эти числа довольно маленькие. Например, школьные оценки от 1 до 5.\n\nОбычная сортировка(например, из классических быстрая, слиянием, пирамидальная) займет $O(N logN)$.\nНо мы не будем пользоваться классической сортировкой, если значения довольно не большие.\n\nБудем считать количество вхождений каждого числа, а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.\n\nИнтервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.\n\nРешение\n\nСоздаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. \nКогда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. \n\nЗатем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.\nДля языков, у которых нумерация массива начинается с нуля, рекомендуется не экономить эту ячейку памяти, а включить нулевую ячейку, чтобы не напутать с индексами.\n\nМы потратим $O(K)$ времени и $O(K)$ памяти, где К количество возможных значений.\n\n$O(K)$ памяти - тк нам нужно завести массив из К элементов.\n\n$O(K)$ времени - тк на создание массива тоже тратится время, пропорционально его длине. Если не на выделение памяти, то на заполнение нулями точно потратится.\n\n$O(N)$ времени - мы за один проход заполним этот массив, тк каждая операция это прибавление единицы и она занимает $O(1)$ времени. И поскольку чисел N, в сумме это займет $O(N)$.\n\nВ итоге на построение массива уходит $O(N+K)$ времени и $O(K)$ дополнительной памяти.\nТоже самое с выводом: мы пройдемся по всем возможным значениям - это цикл до К и в сумме мы совершим N действий на вывод. То есть на вывод мы тоже потратим $O(N+K)$ времени.\n\nЕсли бы мы не делали нулевой элемент в массиве этобы уменьшило количество занимаемой памяти но затруднило и усложнило вычисление, тк пришлось бы постоянно отнимать дополнительное число.\n\nНо если нужно отсортировать числа далекие от нуля, то этот интервал лучше перенести.\n\n```java\npublic static void countSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt(); // сложность O(N)\n    int min = Arrays.stream(arr).min().getAsInt(); // сложность O(N)\n\n    int k = max - min + 1;\n    int[] array = new int[k];\n    Arrays.fill(array, 0);\n\n    for (int i = 0; i < arr.length; i++) {\n        array[arr[i] - min] += 1;\n    }\n\n    int nowPos = 0;\n    for (int i = 0; i < array.length; i++) {\n        for (int j = 0; j < array[i]; j++) {\n            arr[nowPos] = i + min;\n            nowPos += 1;\n        }\n    }\n}\n```\n\n### Задача 1\n\nДано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.\n\nПосчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10. \nРазложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. \n\nЦиклом while проходим по каждой цифре пока после деления не останется 0. Такой способ возможен только если число без ведущих нулей. Это как раз наш случай.\nРаскладываем цифры в массив от 0 до 9, в соответсвии со значением индекса. Пришла цифра 9 увеличиваем на один значение в ячейке с индексом 9 и тд.\nДелаем это для обоих чисел и сравним эти массивы по элементно. Достаточно найти всего одно несовпадение.\n\nСортировка подсчетом уместна, когда разница между максимальным и минимальным значением небольшая и числа с одним и тем же значением встречаются достаточно часто, тогда N > K и сложность сортировки фактически стала $O(N)$.\nЕсли это не так, то точная оценка $O(N+K)$, но в случаях когда K большое, а N маленькое, сортировка подсчетом не лучший выбор.\nМожно вычислить конкретное значение K и сравнить с $N logN$.\n\n```java\npublic static boolean isDigitPerMutation(int x, int y) {\n    int[] digitsX = countDigits(x);\n    int[] digitsY = countDigits(y);\n    for (int i = 0; i < 10; i++) {\n        if (digitsX[i] != digitsY[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static int[] countDigits(int num) {\n    int[] digitCount = new int[10];\n    Arrays.fill(digitCount, 0);\n\n    while (num > 0) {\n        int lastDigit = num % 10;\n        digitCount[lastDigit] += 1;\n        num /= 10;\n    }\n    return digitCount;\n}\n```\n\n\n## Словари\n\nБолее универсальный алгоритм, но в некоторых случаях может работать хуже чем сортировка подсчетом.\n\nСловарь - он как множество, но к каждому ключу приписано значение.\nВ словаре есть пара ключ - значение (key, value). И все что происходит в множестве (подсчет хеша, раскладываение и тд), оно проходит только по ключу.\n\nКлюч должен быть неизменяемым объектом, чтобы у него эффективно хеш вычислялся, а значение может быть каким угодно, от него хеш ни в какой момент не считается, оно просто болтается рядом с ключом.\n \nИскать по значению в словаре нельзя.\n\nСложность поиска в словарях $O(1)$. НО константа большая. Тк может происходить расширение словаря, может считаться хеш функция и тд. Работает это медленее, чем доступ по индексу, как это происходит в сортировке подсчетом.\n\nКонстанта в сложности словарей заметно больше, чем у массивов, поэтому где можно - лучше использовать сортировку подсчетом (если начения лежат довольно плотно (разность между максимальным и минимальным не велика) и значения встречаются по несколько раз).\n\nСортировку подсчетом использовать неразумно, если данные разреженные(редкие вхождения, например числа до миллиарда).\n\n### Задача 1\n\nНа шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) \nОпределите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.\n\n$1<= N <= 10^9, 0<=M<=2*10^5$.\n\nРешение\n\nДля каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.\n\nЧтобы оценить время работы программы мы можем посмотреть на входные данные, значение N может достигать $10^9$ или $1 000 000 000$ - 1 миллиард операций. Даже на языке C, при наличии не примитивных операций, это может быть достаточно долго, для других языков тем более.\nПоэтому нужно ориентироваться на значение M, оно может достигать $2*10^5$ или $200 000$ - 200 тысяч оперций.\n\n> Ладья бьет другую ладью, если они стоят на одной вертикали или горизонтали.\n\n> Ферзь бьет другого ферзя, если они стоят на одной вертикали или горизонтали или на одной диагонмали(диагональ слева направо /, диагональ справа налево \\\\).\n\nОбратим внимание, что если на одной линии стоит 3 ладьи то они образуют 2 пары которые бьют друг друга.\nЕсли на одной линии 4 ладьи, то они образуют 3 пары и т.д.\nПолучается что пар ладей на 1 меньше, чем количество ладей на одной линии.\n\nОтталкиваясь от этого нужно завести 2 словаря для вертикали и горизонтали в которой будем подсчитывать количество ладей на соответсвующей линии.\n\n```java\npublic static int countBeatingRooks(int[][] rookcoords) {\n    Map rooksInRow = new HashMap<Integer, Integer>();\n    Map rooksInCol = new HashMap<Integer, Integer>();\n    for (int i = 0; i < rookcoords.length; i++) {\n        addRook(rooksInRow, rookcoords[i][0]);\n        addRook(rooksInCol, rookcoords[i][1]);\n    }\n    return countPairs(rooksInCol) + countPairs(rooksInRow);\n}\n\npublic static void addRook(Map<Integer, Integer> rowOrCol, int key) {\n    if (!rowOrCol.containsKey(key)) {\n        rowOrCol.put(key, 0);\n    }\n    rowOrCol.put(key, rowOrCol.get(key) + 1);\n}\n\npublic static int countPairs(Map<Integer, Integer> rowOrCol) {\n    int pairs = 0;\n    for (Integer key : rowOrCol.keySet()) {\n        pairs += rowOrCol.get(key) - 1;\n    }\n    return pairs;\n}\n```\n\nСложность данного решения составит $O(M)$. N - никак не участвует в оценке сложности.\nЕсли нужно будет посчитать ферзей, то нужно завести 2 словаря для диагоналей, в которых в качестве ключа для диагонали из нижнего левого угала в правй верхний (/) будет сумма между координатами (row + col или x+y),\nа для диагонали из левого верхнего угла в нижний правый угол (\\\\) будет разность между координатами (row - col или x-y).\n\n### Задача 2\n\nДана строка S.\nВыведите гистограмму как в примере (коды символов отсортированы)\n\nS = Hello, world!\n```\n      #\n      ##\n##########\n !,Hdelorw\n```\n\nПосчитать для каждой буквы сколько раз она встречается и вывести таким образом, как в примере.\n\nРешение\n\nДля каждого символа в словаре посчитаем, сколько раз он встречался. Найдем самый частый символ и переберем количество от этого числа до 1. Пройдем по всем отсортированным ключам и если количество больше счетчика - выведем #.\n\n1. Заводим словарь. Так как когда мы работаем с текстом, алфавит может быть очень большой, могут какие-нибудь иероглифы или эмоджи или еще какие либо символы использоваться. Если явно не сказано что только латинские буквы то лучше использовать словарь.\n2. Проходим по символам и добавляем в словарь по ключу со значением символа сколько раз он встречается.\n3. Отсортировать ключи и вывести нужным образом символы #.\n\nДля того чтобы вывести символы # по условию задачи, нужно найти максимальное значение(n), когда встречается один и тот же символ и для каждого символа в цикле пройтись от 1 до n и если значение меньше того что вышло в цикле то ставим пробел иначе ставим #. \n\n```java\npublic static void printChart(String s) {\n    Map<Character, Integer> symCount = new HashMap();\n    int maxSymCount = 0;\n    char[] charArray = s.toCharArray();\n    for (int i = 0; i < charArray.length; i++) {\n        char sym = charArray[i];\n        if (!symCount.containsKey(sym)) {\n            symCount.put(sym, 0);\n        }\n        symCount.put(sym, symCount.get(sym) + 1);\n        if (symCount.get(sym) > maxSymCount) {\n            maxSymCount = symCount.get(sym);\n        }\n    }\n    List<Character> sortedUniqSyms = symCount\n            .keySet()\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n    for (int i = maxSymCount; i > 0; i--) {\n        for (Character sym : sortedUniqSyms) {\n            if (symCount.get(sym) >= i) {\n                System.out.print('#');\n            } else {\n                System.out.print(' ');\n            }\n        }\n        System.out.println();\n    }\n\n    String str = sortedUniqSyms.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n    System.out.println(str);\n}\n```\n\nЭтот алгоритм не самый эффективный, во-первый вместо вызова функции print луше класть символы в массив и потом выводить строку через join, во-вторых в худшем случае этот алгоритм может работать за $O(N^2)$ или $O((N/2)^2)$\n\n\n## Задел под оптимизацию\n\nПреждевременная оптимизация страшный грех :). Так как иногда нужно сделать быстро  и нет времени на реализацию эффективных алгоритмов. В этом случае лучше сделать таким образом чтобы если вдруг придется решать проблему со скоростью было примерно понятно как это сделать при теущей реализации.\n\n### Всегда ли асмиптотически лучшее решение лучше?\n\n>  Например есть 2 алгоритма: \n- линейный - $1000 * N$ - $O(N)$ \n- алгоритм $2 * NlogN$ - $O(NlogN)$\n\nНа первый взгляд первый алгоритм лучше, но константа отличается в 500 раз.\nДля уточнения разделим обе части на N.\n\n> $2 * logN$ или $1000$\n\nТеперь делим на 2.\n\n> $logN$ или $500$\n\nТеперь то какой алгоримт лучше будет зависить от N.\n\nПри $N>2^{500}$ решение за $O(N)$ лучше, чем решение за $O(NlogN)$, но $2^{500}$ это $3*10^{150}$, что примерно в  $10^{70}$ раз больше количества атомов во вселенной. И вряд ли наш алгоритм будут запускать для таких чисел.\n\n> В реальности разница констант в 500 раз все же случается редко.\n\n### Некоторые другие критерии качества алгоритма\n\n- Потребление памяти - часто бывает, что есть 2 алгоритма с одной асимтотической сложностью, но разным потреблением памяти. Но чаще все равно выбирается время с хорошей асимтотикой.\n\n- Время на реализацию - если нужно писать какой то хороший алгорим но очень долго. То тут может не быть нужного оличества времени.\n\n- Сложность поддержки - как легко алгоритм будет поддерживать\n\n- Возможность распараллеливания - возможно ли будет алгортим разложить на несколько серверов если увеличится нагрузка.\n\n- Необходимая квалификация сотрудника - насколько легко найти человека который сможет поддерживать и разобраться в написанном вами алгоритме.\n\n- Стоимость оборудования - мы можем посидеть потратить время или купить более дорогое железо которое будет быстрее выполнять не самый эффективный алгоритм.\n\n### Задача 3\n\nСгруппировать слова по общим буквам.\n\n> ```Sample Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]```\n\n> ```Sample Output: [\"ate\", \"eat\", \"tea\"], [\"nat\", \"tan\"], [\"bat\"]```\n\n\nОтсортируем в каждом слове буквы и это будет выступать в роли ключа, а значением будет список слов.\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        char[] sortedWord = word.toCharArray();\n        Arrays.sort(sortedWord);\n        String srtWord = new String(sortedWord);\n        if (!groups.containsKey(srtWord)) {\n            groups.put(srtWord, new ArrayList<Character>());\n        }\n        groups.get(srtWord).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String sortedWord : groups.keySet()) {\n        ans.add(groups.get(sortedWord));\n    }\n\n    return ans;\n}\n```\n\nВдруг слово будет длинное (N)? Сортировка займет $O(NlogN)$. Количество различных букв в слове $K{\\leq}N$, можем посчитать количество каждой за $O(N)$ и отсортировать за $O(KlogK)$ с помощью сортировки подсчетом, теоретически \n\n#### Задел под оптимизацию\nНо так как в данный момент все успешно работает и нет времени на переделывание, то можно вынести шаги с сортировкой в отдельный метод.\n\n> Будет тормозить - посмотрим на профилировщике где, и если долго считается ключ - легко поправим на что-то более эффективное.\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Arrays.sort(sortedWord);\n    return new String(sortedWord);\n}\n```\n\n#### Оптимизация\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Map<Character, Integer> symCnt = new HashMap();\n    for (char sym : sortedWord) {\n        if (!symCnt.containsKey(sym)) {\n            symCnt.put(sym, 0);\n        }\n        symCnt.put(sym, symCnt.get(sym) + 1);\n    }\n    ArrayList<String> lst = new ArrayList<>();\n\n    for (char sym : symCnt.keySet().stream().sorted().collect(Collectors.toList())) {\n        lst.add(Character.toString(sym));\n        lst.add(symCnt.get(sym).toString());\n    }\n    return lst.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n}\n```\n\nВ худших случаях этот алгоритм будет работать быстрее, но в среднем будет тормозить.\nИ в некоторых случаях этот алгоритм можно сломать :)\n\n#### Сомнительная оптимизация (?)\n\nНо человек может не выделить часть под оптимизацию в отдельную функцию а вставить код прямо в основной алгоритм.\nКак минимум такой код будет тяжело читать. И вносить изменения, если придется.\n\n\n## Вопросы для проработки\n\n1. Как сджойнить массив символов в строку?\n```java\nlst.stream().map(String::valueOf).collect(Collectors.joining());\n```\n\n2. Как отсортировать массив?\n```java\nsymCnt.keySet().stream().sorted().collect(Collectors.toList())\n```\n\nhttps://www.youtube.com/embed/Nb5mW1yWVSs?si=IN4XvqnlTrMeJ7SK","description":"Словари и сортировка подсчётом"},{"title":"Префиксные суммы и два указателя","path":"/prefiksnye-summy-i-dva-ukazatelya/","content":"\n## Префиксные суммы\n\nОдин из вариантов, когда нужно использовать алгоритм префиксные суммы, это определение чему равна сумма элементов на полуинтервале [L, R) или отрезке. \n\n> Пусть у нас есть массив `nums` из `N` чисел и необходимо ответить на запрос \"Чему равна сумма элементов на полуинтервале [L, R)?\"\n\nЧтобы решить эту задачу нужно совершить предподсчет, некоторые предварительные действия с помощью которых мы потом сможем быстро отвечать на запрос.\n\nЭти действия имеют смысл только если запросов много. Если не много то лучше просто пробежаться и посчитать.\n\n> Подсчитаем массив `prefixsum` длиной `N+1`, где `prefixsum[k]` будет хранить сумму всех чисел из `nums` с индексами от `0` до `k-1`.\n\nСоздадим массив префиксных сумм. Длина у него будет больше чем у исходного массива.\nИ к-тый элемент этого массива будет равняться сумме всех чисел исходного массива с индексами от `0` до `k-1`.\nТакой массив легко посчитать за O(N^2). Но можно и еще быстрее.\n\n### Построение массива префиксных сумм\n\nДля построения массива префиксных сумм не обязательно каждый раз складывать все значения по индексам. Достаточно взять предыдущую префиксную сумму и прибавить к ней очередное значение.\n\nO(N): prefixsum[i] = prefixsum[i-1] + nums[i-1]\n\n|Индекс|0|1|2|3|4|5|6|\n|---|---|---|---|---|---|---|---|\n|nums|5|3|8|1|4|6|\n|prefixsum|0|5|8|16|17|21|27|\n\nПри составлении префиксного массива нужно помнить 2 вещи:\n\n1. Массив префиксных сумм должен быть на 1 больше, чем исходный!\n2. Переполнение. Целые числа могут переполнить допустимое значение. При сложении 2х int значений, при переполнении получается не верный результат. Если складывать long + int то значение будет приведено к типу long\n\n### Ответ на запрос суммы на полуинтервале\n\n> Ответ за O(1): sum(L, R) = prefixsum[R] - prefixsum[L]\n\n> Найдем sum(2, 5) = prefixsum[5] - prefixsum[2] = 21 - 8 = 13\n\nПочему мы ищем полуинтервал?\nЧтобы избежать проблемы запросов прижатых к левому краю.\nЕсли мы будем искать значение от 0 до 3, как для полуинтервала, то все будет корректно. А если считать как для отрезка то чтобы взять значение прижатое к левому краю нам пришлось бы выйти за пределы массива и взять элементс индексом -1.\n\n### Реализация RSQ(Range Summ Query) через префиксные суммы\n\n```java\npublic static long[] makePrefixSum(int[] nums) {\n      long[] prefixsum = new long[nums.length + 1];\n      for (int i = 1; i < nums.length + 1; i++) {\n          prefixsum[i] = prefixsum[i - 1] + nums[i - 1];\n      }\n      return prefixsum;\n  }\n\n  public static long rsq(long[] prefixsum, int l, int r) {\n      return prefixsum[r] - prefixsum[l];\n  }\n  ```\n\nПример задачи:\n\nПусть на сайт заходят люди и для каждого человека записано, когда он зашел. Нужно посчитать сколько людей у нас было на сайте с L дня по R.Получится массив где в каждом элементе будет храниться число человек посетивших сайт в этот день. И далее с помощью алгоритма префиксных сумм можно ответить на целевой вопрос.\n\n\n### Задача 1\n\n> Дана последовательность чисел длиной N и M запросов\n\nЗапросы: Сколько нулей на полуинтервале [l, R)\n\n#### Решение за O(NM)\n\n> Для каждого запроса переберем все числа от L до R (не включительно) и считаем количество нулей. В худшем случае каждый запрос за `O(N)`. Так как всего запросов M то общая сложность решения `O(NM)`.\n\n\n```java\npublic static int countZeroes(int[] nums, int l, int r) {\n    int cnt = 0;\n    for (int i = l; i < r; i++) {\n        if(nums[i] == 0){\n            cnt+=1;\n        }\n    }\n    return cnt;\n}\n```\n\n#### Решение за O(N+M)\nПопробуем применить метод префиксных сумм. Вместо префиксных сумм будем считать количество нулей на префиксе.\n\n> Для каждого префикса посчитаем количество нулей на нем (prefixZeroes). Тогда ответ на запрос на полуинтервале [L, R): prefixZeroes[R] - prefixZeroes[L].\n\n||0|1|2|3|4|5|6|7|\n|---|---|---|---|---|---|---|---|---|\n|nums|1|0|1|1|0|0|1|\n|prefixZeroes|0|0|1|1|1|2|3|3|\n\n```java\npublic static long[] makePrefixZeroes(int[] nums) {\n    long[] prefixsum = new long[nums.length + 1];\n    for (int i = 1; i < nums.length + 1; i++) {\n        if(nums[i-1] == 0){\n            prefixsum[i] = prefixsum[i - 1] + 1;\n        }else{\n            prefixsum[i] = prefixsum[i - 1];\n        }\n    }\n    return prefixsum;\n}\n\npublic static long countZeroes(long[] prefixZeroes, int l, int r) {\n    return prefixZeroes[r] - prefixZeroes[l];\n}\n```\n\nПолучается сложность O(N+M). O(N) уйден на построение тк у нас N элементов. И на каждый из M запросов мы отвечаем за O(1).\n\n\n### Задача 2\n\n>Дана последовательность чисел длиной N.\nНеобходимо найти количество отрезков с нулевой суммой.\n\n#### Решение за $O(N^3)$\n\n> Переберем начало и конец отрезка и просто просуммируем все его элементы.\n\nПеребираем левую и правую границу отрезка и перебираем цифры которые находятся между ними.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length + 1; j++) {\n            int rangeSum = 0;\n            for (int k = i; k < j; k++) {\n                rangeSum += nums[k];\n            }\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N^2)$\n\n> Переберем начало и будем двигать конец, сумируя элементы.\n\nФиксируем значение слева и затем двигая от этой точки указатель правого края высчитываем сумму.\nНам не нужно каждый раз заново высчитывать всю сумму.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int rangeSum = 0;\n        for (int j = i; j < nums.length; j++) {\n            rangeSum += nums[j];\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N)$\n\nНасчитаем префиксные суммы. Одинаковые префиксные суммы означают, что сумма на отрезке с началом и концом в позициях, на которых достигаются одинаковые префиксные суммы, будет равна нулю.\n\n1. Проходим по массиву и считаем префиксые суммы, при подсчете в словаре увеличиваем количество точек в этой сумме на 1.\n2. Проходим по словарю и для каждой суммы высчитываем количество пар сочетаний по комбинаторной формуле, где k = 2 так как ищем пару\n\n${C_{n}^{k}} = \\frac{n!}{k!(n-k)!} = \\frac{n \\times (n -1) \\times (n - 2)!} {2! \\times (n - 2)!} = \\frac{n \\times (n - 1)} {2}$\n\n```java\npublic static Map<Integer, Integer> countPrefixSums(int[] nums) {\n    Map<Integer, Integer> prefixSumByValue = new HashMap<>();\n    {\n        prefixSumByValue.put(0, 1);\n    }\n    int nowSum = 0;\n    for (int now : nums) {\n        nowSum += now;\n        if (!prefixSumByValue.containsKey(nowSum)) {\n            prefixSumByValue.put(nowSum, 0);\n        }\n        prefixSumByValue.put(nowSum, prefixSumByValue.get(nowSum) + 1);\n    }\n    return prefixSumByValue;\n}\n\npublic static int countZeroSumRanges(Map<Integer, Integer> prefixSumByValue) {\n    int cntRanges = 0;\n    for (Integer nowSum : prefixSumByValue.keySet()) {\n        int cntSum = prefixSumByValue.get(nowSum);\n        cntRanges += cntSum * (cntSum - 1) / 2;\n    }\n\n    return cntRanges;\n}\n```\n\n## Два указателя\n\n### Задача 1\n\n> Дана отсортированная последовательность чисел длиной N и число K. \nНеобходимо найти количество пар чисел A, B, таких что B - A > K.\n\n#### Решение за $O(N^2)$\n\nПереберем все пары чисел и для каждой проверим условие.\n\nВо вложенном цикле можно идти не каждый раз сначала перебирая цифры, а дигаясь вправо от левой границы.\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    for (int i = 0; i < sortedNums.length; i++) {\n        for (int j = i; j < sortedNums.length; j++) {\n            if (sortedNums[j] - sortedNums[i] > k) {\n                cntPairs += 1;\n            }\n        }\n    }\n    return cntPairs;\n}\n```\n#### Решение за $O(N)$\n\nВозьмем наименьшее число и найдем для него первое подходящее большее. Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, а указатель первого подходящего большего будем двигать начиная с той позиции, где он находится сейчас\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    int last = 0;\n    for (int first = 0; first < sortedNums.length; first++) {\n\n        while (last < sortedNums.length && sortedNums[last] - sortedNums[first] <= k) {\n            last += 1;\n        }\n        cntPairs += sortedNums.length - last;\n    }\n    return cntPairs;\n}\n```\n\n### Задача 2\n\n> Игрок в футбол обладает одной числовой характеристикой - профессионализмом. Команда называется сплоченной, если профессионализм любого игрока не превосходит сумарный профессионализм любых других двух игроков из команды. Команда может состоять из любого количества игроков. Дана отсортированная последовательность чисел длиной N - профессионализм игроков.\n\nНеобходимо найти максимальный суммарный профессионализм сплоченной команды.\n\n```java\npublic static int bestTeamSum(int[] players) {\n    int bestSum = 0;\n    int nowSum = 0;\n    int last = 0;\n    for (int first = 0; first < players.length; first++) {\n\n        while (last < players.length && (last == first || players[last] + players[first] >= players[last]) {\n            nowSum += players[last];\n            last += 1;\n        }\n        bestSum = bestSum >= nowSum ? bestSum : nowSum;\n        nowSum -= players[first];\n    }\n    return bestSum;\n}\n```\n\n### Задача 3\n\nДаны две отсортированные последовательности чисел (длиной N и M соответсвенно) \n\nНеобходимо слить их в одну отсортированную последовательность.\n\nРешение\n\n\nДве последовательности могуть быть не обязательно одинаковые по длине, могут быть одинаковые числа.\n\nИдея решения: делаем указатель на текущий элемент первой и во второй последовательности и просто выводим то что меньше по текущему указателю. Например, из чисел из 1 и 3 меньше 1 - 1 записали в ответ и указатель двинули в той последовательности из которой мы взяли очередное число и так далее. Если одна из последовательностей заканчивается мы просто выписываем весь оставшийся хвост текущей последовательности.\n\n#### Неидеальная реализация\n\nПоставим два указателя на начало каждой из последовательностей. Выберем тот, который указывает на меньшее число, запишем это число в результат и сдвинем указатель\n\n\n\n","description":"Префиксные суммы и два указателя"},{"title":"Бинарный поиск","path":"/binarnyj-poisk/","content":"","description":"Бинарный поиск"},{"title":"Сортировка событий","path":"/sortirovka-sobytij/","content":"","description":"Сортировка событий"},{"title":"Деревья","path":"/derevya/","content":"","description":"Деревья"},{"title":"Алгоритмы (курс Яндекс)","path":"/algoritmy-kurs-yandeks/","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","category":"java","description":"Курс на платформе Яндекс по алгоритмам"},{"title":"Java Core","path":"/java-core/","content":"\nJava Core\n\n## Что такое программа\n\nЛюбая программа это набор инструкций, которые выполняет процессор или его микропрограмма. Эти инструкции называются машинным кодом. \nОни показывают процессору откуда взять данные, что с ними сделать и куда поожить результат. Hello world на машинном языке выглядел бы как набор цифр и букв, набор инструкций зависит от реализации конкретного процессора и унифицируется на уровне операционных систем(созданием виртуального процесора с универсальным набором инструкций). \n\n\n## Появление и развитие языка программирования\n\n1. Чтобы было проще запоминать машинные коды для каждого кода придумали мнемоники. Так появился язык Asembler и код стал немного понятнее. \n\n2. Затем появились языки высокого уровня которые оперируют простыми словами, а специальные программы - компеляторы и интерпретаторы приводили их в машинный код. \n\n3. Следующим этапом развития стало компиляция языка программирования не напрямую в машинный код, а сначала в промежуточный байт-код, по этому пути пошли разработчики java и dotNet'a. \n\n- Разработчики Java создали концепцию JVM - java virtual machine - виртуальная машина, которая может исполнять bytecode скомпелированный из java кода. Создав реализацию такой виртуальной машины для разных платформ, мы получили возможность писать на джаве для любой платформы. \n\n- Разработчики из дотнета пошли другим путем и создали clr - common language runtime если разработчики джава были сосредоточены только на языке джава, то clr был создан для возможности писать на разных языках в пределах одного решения но при этом все ставки делались только на windows. \n\nВ настоящее время обе команды пересмотрели свою концепцию: в jvm появилась поддержка в том числе и других языков, а для дот нета почвилась платформа Mono которая позволяет запускать C# практически на любом устройстве. \n\n## Что такое JVM?\n\nJVM состоит из:\n- Class Loader, загружающего файлы с байт кодом в память;\n- виртуальная память, куда все это загружается;\n- движок, который исполняет и оптимизирует код;\n- дополнительные интерфейсы и библиотеки для работы с нативным кодом (кодом написанном на c/c++/assembler'e).\n\n### Class Loader\n\nРазличают 3 вида:\n- bootstrap - загружает все стандартные классы Java, т.е. все которые содержатся в пакетах java.lang, java.net и т.д.;\n- extension - загружает классы из дополнительных библиотек, которые стаятся вместе с jdk и jre;\n- application - загружает классы из  classpath папок, которые может настроить сам разработчик.\n\n### JVM Memory - виртуальная память\n\n- Method Area, metaspace - здесь хранятся все статичные структуры и сам код, эта область является частью Heap(кучи)\n- Heap - большая область памяти в которой хранятся все создаваемые объекты, она выделяется сразу при запуске и делится между всеми основными потоками. Здесь обычно происходят основные утечки память и здесь же работает garbage collector(уборщик мусора). GC - собирает информацию о данных которые больше не используются и пытается их удалить.\n- Stack - более емкая область памяти, которая создается при создании потока, у каждого потока свой стек. Стек устроен по принципу первый вошел последний вышел(FILO). Для каждого вызываемого метода в стеке создается frame, набор именнованных параметров которые хранит переменные созданные в этом методе, промежуточные результаты и итоговый результат который возвращается через return. После выполнения метода его фрейм извлекается из стека и происходит переход к фрейму метода который был положен в стек перед ним, те тот метод который вызывал данный метод. \n- PC Registers - содержат указатели на внутренние инструкции самой java.\n- Native Method Stack - стек для нативных методов.\n\n### Движок\n\n- JIT - just-in-time компилятор - оптимизирует уже скомпелированный байт код \n- Интерпретатор который исполняет скомпелированный байт код\n\n\n### JRE\n\nJVM + java библиотеки\n\n### JDK\n\nJRE + инструменты разработчика + компилятор\n\n","category":"java","description":"Java Core"},{"title":"Глава 1. Введение в объекты","path":"/glava-1-vvedenie-v-obekty/","content":"\n## Развитие абстракции\n\nВсе языки программирования построены на <u>**абстракции**</u>.\n\nРазличают тип и качество абстракции. Под словом \"Тип\" имеется ввиду ответ на вопрос \"Что конкретно мы абстрагируем?\"\n\nЯзык ассемблера - есть небольшая абстракция от компьютера, на базе которого он работает.\n\n\"Командные\" языки, созданные вслед за ним, такие как Fortran, BASIC и C представляют собой абстракции следующего уровня, но по-прежнему заставляли мыслить в контектсте структуры компьютера, а не решаемой задачи.\n\n### Моделирование машины\nНужно устанавливать связь между моделью машины(в \"пространстве решения\" - место, где реализуется решение, н-р компьютер) и моделью задачи(н-р прикладная область). В результате затрачиваются дополнительные усилия и появляются программы, которые трудно писать и тяжело поддерживать.\n\n### Моделирование решаемой задачи\n\n#### Моделирование окружающего мира\nЯзыки, подобные LISP и APL, имели особый подход к моделированию окружающего мира (\"Все задачи решаются списками\" или \"Алгоритмы решают все\") \n\n#### Проблемы как цепочки решений \nPROLOG трактует все проблемы как цепочки решений. \n\n#### Cистемs ограничений и манипуляциb с графическими конструкциями\nСуществовали языки для программирования, основанного на системе ограничений и специальные языки, в которых программирование осуществлялось посредством манипуляций с графическими конструкциями(областьприменения оказалась слишком узкой).\n\nКадый из подходов хорош, но не позволяет выйти из области решаемых задач. Использование их вне их сферы становится затруднительно.\n\n#### Объектный подход\nОбъектный подход предоставляет средства для представления задачи в ее пространстве. Имеет общий характер и не накладывает ограничений на тип решаемой проблемы. \n\nЭлементы пространства задачи и их представления в пространстве решения называются \"объектами\".\n\nПрограмма может адаптироваться к специфике задачи посредством создания новых типов объектов. Т.о. ООП описывает задачу в контексте самой задачи. \n\nСвязь с компьютером однако сохранилась т.к. каждый объект похож на компьютер - у него есть состояние и операции, которые он позвояет проводить, что сочетается с реальным миром - <i>**\"реальность, данная нам в объектах\"**</i>, обладающих характеристиками и поведением.\n\n### Характеристики академического подхода к ООП\n\n- Всё является объектом;<br>\n<i>Объект - это усовершенствованная переменная, он хранит данные, но к нему можно \"обращаться с запросами\", приказывая выполнить операции над собой. Любой компонент решаемой задачи может быть представлен в виде объекта.</i>\n\n- Программа - это набор объектов, указывающих друг другу, что делать, посредством сообщений;<br>\n<i>Чтобы обратиться с запросом, вы \"посылаете сообщение\". Сообщение - это запрос на вызов метода, принадлежащего определенному объекту.</i>\n\n- Каждый объект имеет собственную \"память\", состоящую из других объектов;<br>\n<i>Новый объект создается  путем встраивания в него уже существующих объектов, скрывая общую сложность за простотой отдельных объектов.</i>\n\n- У каждого объекта есть тип;<br>\n<i>Каждый объект является экземпляром класса, \"класс\" - синоним слова \"тип\". Отличие классов друг от друга - ответ на вопрос \"Какие сообщения можно объекту посылать?\"</i> \n\n- Все объекты определенного типа могут получать одинаковые сообщения;<br>\n<i>Объект типа \"круг\" также является объектом типа \"фигура\" и справедливо что \"круг\" также  может принимать сообщения для типа \"фигура\".</i>\n\n\n#### Описание объекта (Буч)\n<i>**Объект обладает состоянием, поведением и индивидуальностью.**</i>\n Объект может иметь внутренние данные(состояние объекта), методы(определяют поведение) и каждый объект можно уникальным образом отличить от другого объекта(н-р уникальным адресом в памяти)\n\n## Объект обладает интерфейсом\n\nПонятие типа можно сравнить с понятием Аристотеля о \"классе рыб и классе птиц\".\n\nКонцепция, что все объекты будучи уникальными являются частью класса объектов со сходными характеристиками и поведением, использована в <u>первом</u> объектно-ориентированном языке <i>Simula-67</i>, с введением слова class, которое вводило новый тип в прорамму.\n\n\n\n\n\n\n","description":"Глава 1. Введение в объекты"},{"title":"Глава 10. Внутренние классы","path":"/glava-10-vnutrennie-klassy/","content":"\n## Внутренние классы\n\nКласс, размещенный в определении другого класса называется внутренним(inner class).\n\nКак правило внешний класс содержит ссылку на внутренний класс.\n\nЕсли нужно создать объект внутреннего класса где-нибудь за пределами внешнего класса или в статическом методе, нужно будет указать тип этого объекта следующим образом: ИмяВнешнегоКласса.ИмяВнутреннегоКласса.\n\nВнутренний класс может обращаться к членам внешнего класса и ему доступны все элементы внешнего класса.\n\nВнутренний класс хранит ссылку на внешний класс, поэтому существование внутреннего класса невозможно без внешнего если он не является статическим.\n\nЕсли нужно получить ссылку на внешний класс то указывается имя класс и .this.\n\nЕсли нужно создать объект внутреннего класса из внешнего, например в статическом методе или за пределом внешнего класса то используется объект внешнего класса и .new\n\nЗакрытый внутренний класс позволяет разработчику класса полностью запретить использование определенных типов и скрыть детали реализации класса.\n\nВнутренние классы могут создаваться в методах и даже произвольных областях действия. Для этого есть 2 причины:\n1. Нужно создавать и возвращать ссылки на некоторый интерфейс\n2. Нужно решить сложную задачу и нужно создать класс, который будет задействован в его решении, но при этом сделать его недоступным для посторонних.\n\nВнутренний класс может быть:\n\n1. Класс, определенный в методе - локальный внутренний класс. К нему невозможно обратиться за пределами метода, в котором он определяется;\n2. Класс, определенный в области действия внутри метода - например вложен в область действия команды if. Внутренний класс не доступен за пределами действия в которой он определяется;\n3. Анонимный класс, реализованный в интерфейсе;\nЕсли вы определяете анонимный внутренний класс и хотите использовать внутри него объект передаваемый в аргументе, то необходимо чтобы аргумент был обозначен как final иначе компилятор выдаст ошибку.\n4. Анонимный класс, расширяющий класс с конструктором, который не является конструктором по умолчанию. В название класса передаются нужные аргументы и задается определение класса;\n5. Анонимный класс, выполняющий инициализацию поля;\n6. Анонимный класс, выполняющий конструирование с использованием инициализации экземпляра (анонимные внутренние классы не могут иметь конструкторов)\n\nВ отличие от обычного класса анонимные внутренние классы могут либо расширять класс, либо реализовать интерфейс но не оба действия сразу.\n\nПаттерн «Фабричный метод»\n\nВложенные классы\n\nЕсли связь между объектом внутреннего класса и объектом внешнего класса не нужна, внутренний класс можно сделать статическим (объявить его как static). Такой класс называют вложенным.\n\nВложенный класс:\n1. Для создания его объекта не нужен объект внешнего класса\n2. Нельзя обращаться к членам не-статического объекта внешнего класса из объекта вложенного класса.\n\nСтатические поля и методы внутреннего класса определяются только на уровне внешнего класса. Вложенные классы таких ограничений не имеют. Уточнить!!!\n\nВложенный класс может быть частью интерфейса. Даже без специальных обозначений любой класс помещенный в интерфейс считается public и static. Это может быть удобно при здании общего кода, который должен использоваться со всеми реализациями интерфейса.\n\nНеважно насколько глубоко вложен класс он будет иметь доступ ко всем полям и методам всех внешних классов.\n\n\nПричина для использования внутренних классов:\nКаждый внутренний класс способен наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовано в ситуациях, где внешний класс уже наследует реализацию.\n\nТаким образом, внутренний класс выступает как «довесок» множественного наследования.\n\nДля наследованная от внутреннего класса должна быть ссылка на внешний класс поэтому используется следующий синтаксис:\nextends ИмяВнешнегоКласса.ИмяВнутреннего класса\nи в конструктор нужно передать ссылку на внешний класс и определить его как \nСсылкаНаВнешнийКласс.super();\n\nПереопределение внутреннего класса не имеет никакого эффекта. Внутренние класс совершенно отдельные составляющие, с независимым пространством имен, но можно явно унаследовать от внутреннего класса.\n\nЛокальный внутренний класс не имеет модификатора доступа, но имеет доступ к членам внешнего класса и final переменным.\nУ локального внутренний класса может быть свой конструктор.\n\nАнонимный внутренний класс не может содержать конструктора только инициализатор экземпляра.\n\nЕдинственный довод в пользу локального внутреннего класс перед анонимным внутренним классом есть необходимость в именованном конструкторе и/или перегруженных конструкторах и  возможность создавать более чем один объект такого класса.\n\n\n\n#философия_java","description":"Глава 10. Внутренние классы"},{"title":"Глава 15. Обобщенные типы","path":"/glava-15-obobshhennye-tipy/","content":"\nОдин из механизмов обобщения в ООП основан на полиморфизме.\nНапример, имеется метод, который принимает в аргументе объект базового класса, после чего его можно использовать для любых классов производных от базового.\n\nЭтот принцип действует и для классов. \nОграничение можно выставить по типу базового класса, интерфейса или указать некий \"условный тип\".\n\n<i>**Обобщения(generics)**</i> реализуют концепцию параметризованных типов, позволяющих создавать компоненты(контейнеры), которые удобно использовать с разными типами.\n\nПод темином \"обобщение\" следует понимать \"применимость к большой группе классов\".\n\n## Простые обобщения\n\nОдна из причин использования обобщений - это классы контейнеры. Контейнер - это хранилище для объектов.\n\nПример класса-контейнера с использованием \"условного\" типа для хранения. На это указывает параметр-тип в угловых скобках после имени класса.\n\n```java\npublic class Holder3<T> {\n    private T a;\n\n    public Holder3(T a) {\n        this.a = a;\n    }\n\n    public void set(T a) {\n        this.a = a;\n    }\n\n    public T get() {\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Holder3<Automobile> h3 =\n                new Holder3<Automobile>(new Automobile());\n        Automobile a = h3.get();\n    }\n}\n\nclass Automobile {\n}\n```\n\n## Библиотека кортежей\n\nПри вызове метода иногда возникает необходимость вернуть несколько объектов. Команда return позволяет вернуть только один объект, но задачу можно решить созданием объекта, содержащего несколько возвращаемых объектов. Можно писать специальный класс при необходимости, но обобщения позволяют решить задачу сразу на все случаи. \n\nГруппа объектов, завернутых в один объект, называется <i>**кортежем**</i>. Кортеж может иметь произвольную длину и все объекты могут относиться к разным типам. Получатель может читать элементы, но не может добавлять новые (концепция \"объект передачи данных\").\n\n\n```java\npublic class TwoTuple<A, B> {\n    public final A first;\n    public final B second;\n\n    public TwoTuple(A first, B second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n```\n\n```java\npublic class ThreeTuple<A, B, C> extends TwoTuple<A, B> {\n\n    public final C third;\n\n    public ThreeTuple(A first, B second, C third) {\n        super(first, second);\n        this.third = third;\n    }\n}\n```\n\nПоля first, second, third объявляются public и final, что позволяет не добавлять get и set методы, тк получить значение можно просто обратившись к переменной, тк она public, а изменить нельзя, тк она final. Данная форма оказывается короче чем добавление геттеров и сеттеров.\nДля того чтобы изменить элементы кортежа лучше будет просто создать новый объект. Для оздания кортежа с большим количеством элементов, можно применить наследование.\n\n## Класс стека\n\nПри каждом вызове `push()` новый узел `Node<T>` создается и связывается с предыдущим узлом `Node<T>`. При вызове `pop()` всегда возвращается `top.item`, после чего текущий узел `Node<T>` удаляется и происходит переход к следующему узлу; но при достижении сторожа(значение `null`, признак пустого стека) перемещение не выполняется.\n\n```java\npublic class LinkedStack<T> {\n\n  private static class Node<U> {\n    U item;\n    Node<U> next;\n    Node() { item = null; next = null; }\n    Node(U item, Node<U> next) {\n      this.item = item;\n      this.next = next;\n    }\n    boolean end() { return item == null && next == null; }\n  }\n\n  private Node<T> top = new Node<T>(); // End sentinel\n\n  public void push(T item) {\n    top = new Node<T>(item, top);\n  }\t\n\n  public T pop() {\n    T result = top.item;\n    if(!top.end())\n      top = top.next;\n    return result;\n  }\n\n  public static void main(String[] args) {\n    LinkedStack<String> lss = new LinkedStack<String>();\n    for(String s : \"Phasers on stun!\".split(\" \"))\n      lss.push(s);\n    String s;\n    while((s = lss.pop()) != null)\n      System.out.println(s);\n  }\n\n}\n```\n\n## RandomList\n\n```java\npublic class RandomList<T> {\n  private ArrayList<T> storage = new ArrayList<T>();\n  private Random rand = new Random(47);\n  public void add(T item) { storage.add(item); }\n  public T select() {\n    return storage.get(rand.nextInt(storage.size()));\n  }\n  public static void main(String[] args) {\n    RandomList<String> rs = new RandomList<String>();\n    for(String s: (\"The quick brown fox jumped over \" +\n        \"the lazy brown dog\").split(\" \"))\n      rs.add(s);\n    for(int i = 0; i < 11; i++)\n      System.out.print(rs.select() + \" \");\n  }\n}\n```\n\n## Обобщенные интерфейсы\n\nС интерфейсами обобщения работают почти также, как с классами. Рассмотрим интерфейс для создания генератора. От него требуется возвращать следущий элемент передаваемого типа. Для этого добавляется метод `next()`.\n\n```java\npublic interface Generator<T> { T next(); }\n```\n\nПродемонстрируем реализацию интерфейса Generator.\n\n```java\npublic class Coffee {\n\n    private static long counter = 0;\n    private final long id = counter++;\n\n    public String toString() {\n        return this.getClass().getSimpleName() + \" \" + id;\n    }\n}\n\nclass Latte extends Coffee {\n}\n\nclass Mocha extends Coffee{\n}\n\nclass Americano extends Coffee {\n}\n```\n\n```java\npublic class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee> {\n\n    // Реализация генератора\n\n    private Class[] types = {Americano.class, Mocha.class, Latte.class};\n\n    private Random rand = new Random(47);\n\n    @Override\n    public Coffee next() {\n        try {\n            return (Coffee) types[rand.nextInt(types.length)].getDeclaredConstructor().newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Реализация итератора\n    private int size = 0;\n\n    public CoffeeGenerator(int size) {\n        this.size = size;\n    }\n\n    public CoffeeGenerator() {\n    }\n\n    class CoffeeIterator implements Iterator<Coffee> {\n\n        int count = size;\n\n        @Override\n        public boolean hasNext() {\n            return count > 0;\n        }\n\n        @Override\n        public Coffee next() {\n            count--;\n            return CoffeeGenerator.this.next();\n        }\n    }\n\n    @Override\n    public Iterator<Coffee> iterator() {\n        return new CoffeeIterator();\n    }\n\n\n    public static void main(String[] args) {\n        CoffeeGenerator generator = new CoffeeGenerator();\n        for (int i = 0; i < 5; i++) {\n            System.out.println(generator.next());\n        }\n        System.out.println();\n        for (Coffee c : new CoffeeGenerator(5)) {\n            System.out.println(c);\n        }\n    }\n    \n}\n```\n\nПример генератора для генерации чисел Фибоначчи.\n\nВариант с рекурсией:\n```java\npublic class FibonacciGenerator implements Generator<Integer> {\n\n    private static int counter = 0;\n\n    @Override\n    public Integer next() {\n        return fib(counter++);\n    }\n\n    public Integer fib(int n) {\n        if (n < 2) return 1;\n        return fib(n - 2) + fib(n - 1);\n    }\n\n    public static void main(String[] args) {\n        FibonacciGenerator generator = new FibonacciGenerator();\n        for (int i = 0; i < 10; i++) {\n           System.out.println(generator.next());\n        }\n    }\n}\n```\n\nВариант без рекурсии\n```java\npublic class FibonacciGenerator implements Generator<Integer> {\n\n    private int first = 0;\n    private int second = 1;\n\n    private static int counter = 0;\n\n    @Override\n    public Integer next() {\n        if (counter < 1) {\n            counter++;\n            return 1;\n        } else {\n            int result = first + second;\n            first = second;\n            second = result;\n            counter++;\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        FibonacciGenerator generator = new FibonacciGenerator();\n        for (int i = 0; i < 10; i++) {\n            System.out.println(generator.next());\n        }\n    }\n}\n```\n\nСоздание итератора для вывода числе Фибоначчи с помощью паттерна Адаптер:\n\n```java\npublic class IterableFibonacci extends FibonacciGenerator implements Iterable<Integer> {\n\n    private int count;\n\n    public IterableFibonacci(int count) {\n        this.count = count;\n    }\n\n    class FibonacciIterator implements Iterator<Integer> {\n\n\n        @Override\n        public boolean hasNext() {\n            return count > 0;\n        }\n\n        @Override\n        public Integer next() {\n            count--;\n            return IterableFibonacci.this.next();\n        }\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new FibonacciIterator();\n    }\n\n    public static void main(String[] args) {\n        for (Integer n : new IterableFibonacci(5)) {\n            System.out.println(n);\n        }\n    }\n}\n```\n\n## Обобщенные методы\n\nПараметризация возможна не только для классов но и для методов.\nКак правило, применять обощенные методы следует там, где только возможно.\n\nЧтобы определить обобщенный метод, следует поместить список параметров-типов перед возвращаемым значением:\n\n```java\npublic <T> void f(T x) {\n    System.out.println(x.getClass().getName());\n}\n```\n\n## Использование автоматического определения аргументов-типов\n\nКлассическое обявление объектов параметризованных классов может быть громоздким для этого можно сделать специальную бибилиотеку для обозначения основных параметризованных классов.\n\n```java\npublic class New {\n  public static <K,V> Map<K,V> map() {\n    return new HashMap<K,V>();\n  }\n  public static <T> List<T> list() {\n    return new ArrayList<T>();\n  }\n  public static <T> LinkedList<T> lList() {\n    return new LinkedList<T>();\n  }\n  public static <T> Set<T> set() {\n    return new HashSet<T>();\n  }\t\n  public static <T> Queue<T> queue() {\n    return new LinkedList<T>();\n  }\n  // Examples:\n  public static void main(String[] args) {\n    Map<String, List<String>> sls = New.map();\n    List<String> ls = New.list();\n    LinkedList<String> lls = New.lList();\n    Set<String> ss = New.set();\n    Queue<String> qs = New.queue();\n  }\n}\n```\n\nОднако, такое присвоение работает только при объявлении переменной при попытке использовать на прямую в методе, компилятор не вычисляет тип и будет возникать ошибка.\n\nНо если использовать специальный синтаксис с помощью которого можно задать тип, метод выполнится успешно.\n\nВ Java 13 работают оба варианта.\n\n```java\npublic class LimitsOfInference {\n  static void f(Map<Person, List<? extends Pet>> petPeople) {}\n  public static void main(String[] args) {\n    // f(New.map()); // Does not compile\n    f(New.<Person, List<Pet>>map());\n  }\n}\n```\n\n## Списки аргументов переменной длины и обобщенные методы\n\nОбобщенные методы можно использовать со списками переменной длины.\n\n```java\npublic class GenericVarargs {\n  public static <T> List<T> makeList(T... args) {\n    List<T> result = new ArrayList<T>();\n    for(T item : args)\n      result.add(item);\n    return result;\n  }\n  public static void main(String[] args) {\n    List<String> ls = makeList(\"A\");\n    System.out.println(ls);\n    ls = makeList(\"A\", \"B\", \"C\");\n    System.out.println(ls);\n    ls = makeList(\"ABCDEFFHIJKLMNOPQRSTUVWXYZ\".split(\"\"));\n    System.out.println(ls);\n  }\n}\n```\n\n","description":"Глава 15. Обобщенные типы"},{"title":"Глава 5. Инициализация и завершение","path":"/glava-5-iniczializacziya-i-zavershenie/","content":"\n\n","description":"Глава 5. Инициализация и завершение"},{"title":"CREATE, DROP, DELETE, UPDATE, INSERT, ALTER","path":"/create-drop-delete-update-insert-alter/","content":"\n## Состав таблицы\n\n1. Дать таблице имя, пусть она будет называться book, вот некоторые правила для выбора имен таблиц:\n- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;\n- имя должно быть уникальным в пределах базы данных.\n\nТакже рекомендуется:\n- чтобы имя было существительным в единственном числе;\n- имя должно быть понятным и соответствовать тому объекту, который оно описывает;\n- имя должно быть как можно короче, максимум до 10 символов.\n\n2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять.\n\nПравила по выбору имени поля информационного объекта:\n- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;\n- имя поля должно быть уникальным в пределах таблицы.\n\nРекомендации по выбору имени поля информационного объекта:\n- имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;\n- имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.\n\n3. Включить ключевое поле id, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.\n\nРекомендации по именованию  ключевых полей:\n- имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id.\n\n## Основные типы данных SQL\n\n- INT, INTEGER  \n_Описание:_ Целое число, могут принимать значения от -2 147 483 648 до 2 147 483 647  \t\n_Пример:_ -567 1205\n\n- DECIMAL, NUMERIC  \n_Описание:_ Вещественное число, в скобках указывается максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой.\nМожно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне -10^38+1 до 10^38-1.\nDECIMAL(4,1) NUMERIC(6,3)  \n_Пример:_ 34.6 -3.294\n\n- DATE  \n_Описание:_ Дата в формате ГГГГ-ММ-ДД \n26 июля 2020 года\n3 января 2021 года  \n_Пример:_ 2020-07-26 2021-01-03\n\n- VARCHAR  \n_Описание:_ Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле VARCHAR(10)(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному количеству символов в строке)  \n_Пример:_ пример описание\n\nРекомендации по выбору типов данных для полей таблицы.\n- Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип VARCHAR(25).\n- Для описания ключевого поля используйте описание INT PRIMARY KEY AUTO_INCREMENT. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).\n\n## Создание таблицы\n\nДля создания таблицы используется SQL-запрос. \n\n```sql\nCREATE TABLE genre(\n    genre_id INT PRIMARY KEY AUTO_INCREMENT, \n    name_genre VARCHAR(30)\n);\n```\n\nРекомендации по записи SQL запроса\n- Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово). \n- Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.\n- Имена таблиц и полей - строчными (маленькими) буквами.\nSQL-запрос можно писать на нескольких строках.\n- В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).\n\n## Вставка записи в таблицу\n\nВ таблицу, состоящую из двух столбцов добавим новую строку, при этом в поле1 заносится значение1,  в поле2 - значение2.\n\n```sql\nINSERT INTO таблица(поле1, поле2) \nVALUES (значение1, значение2);\n```\n\nПри составлении списка полей и списка значений необходимо учитывать следующее:\n- количество полей и количество значений в списках должны совпадать;\n- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;\n- типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция - недопустима);\n- новые значения нельзя добавлять в поля, описанные как PRIMARY KEY AUTO_INCREMENT;\n- рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (NULL).","category":"testops","description":"CREATE, DROP, DELETE, UPDATE, INSERT, ALTER"},{"title":"Базовые запросы с использованием LIKE, BETWEEN, ORDER BY, ALIASES, IN, TOP-LIMIT, DISTINCT","path":"/bazovye-zaprosy-s-ispolzovaniem-like-between-order-by-aliases-in-top-limit-distinct/","content":"\n## Выборка всех данных из таблицы\n\nДля того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры:\n\nключевое слово SELECT; \nсимвол « *» ; \nключевое слово FROM; \nимя таблицы.\n\n```sql\nSELECT * FROM book;\n```\n\n## Выборка отдельных столбцов\n\nДля того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: \n\nключевое слово SELECT ; \nсписок столбцов таблицы через запятую; \nключевое слово FROM ; \nимя таблицы.\n\n```sql\nSELECT title, amount FROM book;\n```\n\n## AS - Выборка новых столбцов и присвоение им новых имен\n\nДля того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые имена используется SQL запрос следующей структуры: \n\nключевое слово SELECT ; \nимя столбца;\nключевое слово AS ; \nновое название столбца (можно русскими буквами), но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, Количество_книг ; \nзапятая; \nимя столбца; \n.... \nключевое слово FROM ; \nимя таблицы.\n\nРезультатом является таблица, в которую включены все данные из указанных после SELECT столбцов исходной таблицы. Каждому столбцу присваивается новое имя, заданное после AS, или столбец получает имя столбца исходной таблицы, если AS отсутствует.\n\n```sql\nSELECT title AS Название, amount \nFROM book;\n```\n\n## Выборка данных, вычисляемые столбцы, математические функции\n\nС помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора SELECT указывается выражение и задается имя.\n\nВыражение может включать имена столбцов, константы, знаки операций, встроенные функции.\n\nРезультатом является таблица, в которую включены все данные из указанных после SELECT столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.\n\n```sql\nSELECT title, author, price, amount, \n     price * amount AS total \nFROM book;\n```\n\nВ SQL реализовано множество  математических функций для работы с числовыми данными. В таблице приведены некоторые из них.\n\n|Функция|\tОписание|\tПример|\n|---|---|---|\n|CEILING(x)|\tвозвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)|CEILING(4.2)=5 CEILING(-5.8)=-5|\n|ROUND(x, k)|округляет значение x до k знаков после запятой, если k не указано – x округляется до целого|ROUND(4.361)=4 ROUND(5.86592,1)=5.9|\n|FLOOR(x)|возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)|FLOOR(4.2)=4 FLOOR(-5.8)=-6|\n|POWER(x, y)|возведение x в степень y|POWER(3,4)=81.0|\n|SQRT(x)|квадратный корень из x|SQRT(4)=2.0 SQRT(2)=1.41...|\n|DEGREES(x)|конвертирует значение x из радиан в градусы\t|DEGREES(3) = 171.8...|\n|RADIANS(x)|конвертирует значение x из градусов в радианы|\tRADIANS(180)=3.14...|\n|ABS(x)\t|модуль числа x\t|ABS(-1) = 1 ABS(1) = 1|\n|PI()\t|pi = 3.1415926...\t ||\n\nСуществуют разные способы округления чисел. В SQL реализовано математическое округление. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5,6,7,8 или 9.\n\n```sql\nSELECT title, \n    price, \n    ROUND((price*18/100)/(1+18/100),2) AS tax, \n    ROUND(price/(1+18/100),2) AS price_tax \nFROM book;\n```\n\n## Выборка данных, вычисляемые столбцы, логические функции\n\nВ SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF:\n\n```IF(логическое_выражение, выражение_1, выражение_2)```\nФункция вычисляет `логическое_выражение`, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.\n\nДопускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `IF`.\n\n```sql\nSELECT title, amount, price, \n    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale\nFROM book;\n```\n\n```sql\nSELECT title, amount, price,\n    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,\n    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка\nFROM book;\n```\n\n## Выборка данных по условию\n\nС помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово WHERE и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.\n\nЛогическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.\n\n```sql\nSELECT title, price \nFROM book\nWHERE price < 600;\n```\n\n## Выборка данных, логические операции\n\nЛогическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.\n\nПриоритеты операций:\n1. круглые скобки\n2. умножение  (*),  деление (/)\n3. сложение  (+), вычитание (-)\n4. операторы сравнения (=, >, <, >=, <=, <>)\n5. NOT\n6. AND\n7. OR\n\n```sql\nSELECT title, author, price \nFROM book\nWHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;\n```\n\nВ данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  author = 'Есенин С.А.' and price > 600, а потом уже выражение через or. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше 600.\n\n## Операторы BETWEEN, IN - выборка данных\n\nЛогическое выражение после ключевого слова WHERE может включать операторы  BETWEEN и IN. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.\n\n### Оператор BETWEEN\nОператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.\n\n```sql\nSELECT title, amount \nFROM book\nWHERE amount BETWEEN 5 AND 14;\n```\n\n### Оператор  IN\nОператор  IN  позволяет выбрать данные, соответствующие значениям из списка.\n\n```sql\nSELECT title, price \nFROM book\nWHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');\n```\n\n## Оператор ORDER BY - выборка данных с сортировкой\n\nПри выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию). \n\nСтолбцы после ключевого слова ORDER BY можно задавать:\n- названием столбца;\n- номером столбца;\n- именем столбца (указанным после AS).\n\n```sql\nSELECT title, author, price\nFROM book\nORDER BY title;\n```\n\n## Оператор LIKE - выборка данных\nОператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.\n\n|Символ-шаблон|\tОписание|\tПример|\n|---|----|---|\n|%\t|Любая строка, содержащая ноль или более символов|\tSELECT * FROM book WHERE author LIKE '%М.%' - выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»|\n|_ (подчеркивание)|\tЛюбой одиночный символ|\tSELECT * FROM book WHERE title LIKE 'Поэм_' - выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.|\n\n\n| Шаблон | Описание |\n| --- | --- |\n| 'Б%' | значение, начинающееся с буквы «Б». |\n| \"_ _ _ _ _\" | значение, состоящее ровно из 5 букв |\n| \"_ _ _ _ _ _%\" | значение  длиннее 5 символов |\n| title LIKE \"\\_% и \\_%\" _(отбирает слово И внутри названия)_ <br><br> OR title LIKE \"и \\_%\" _(отбирает слово И в начале названия)_ <br><br> OR title LIKE \"\\_% и\" _(отбирает слово И в конце названия)_ <br><br> OR title LIKE \"и\" | Значение которое содержит букву \"и\" как отдельное слово, если считать, что слова отделяются друг от друга пробелами и не содержат знаков препинания. |\n|\"% %\" | значение состоит ровно из одного слова|\n|\"_% %\" | значение состоит из двух и более слов |\n\n## Оператор DISTINCT - Выбор уникальных элементов столбца\n\nЧтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.\n\n```sql\nSELECT DISTINCT author\nFROM book;\n```\n\n## Оператор GROUP BY - Выбор уникальных элементов столбца\n\nОператор GROUP BY группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после GROUP BY .\n\nС помощью GROUP BY можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании DISTINCT.\n\n```sql\nSELECT  author\nFROM book\nGROUP BY author;\n```\n\n## Групповые функции SUM и COUNT - Выборка данных\n\nПри группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.\n\n```sql\nSELECT author, sum(amount), count(amount)\nFROM book\nGROUP BY author;\n```\n\n1. В таблице book определяются строки, в которых в столбце author одинаковые значения\n2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это author)\n3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция SUM(), а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае amount)\n4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция COUNT(), в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает COUNT(), если в группе есть пустые значения)\n\nФункцию COUNT() можно применять к любому столбцу, в том числе можно использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения Null, то\n- COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;\n- COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.\n\n## Групповые функции MIN, MAX и AVG\n\nК групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.\n\n```sql\nSELECT author, MIN(price) AS min_price\nFROM book\nGROUP BY author;\n```\n\n## Выборка данных c вычислением, групповые функции\n\nВ качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.\n\n```sql\nSELECT author, SUM(price * amount) AS Стоимость\nFROM book\nGROUP BY author;\n```\n\n```\n+------------------+-----------+\n| author           | Стоимость |\n+------------------+-----------+\n| Булгаков М.А.    | 4715.47   |\n| Достоевский Ф.М. | 11802.03  |\n| Есенин С.А.      | 9750.00   |\n+------------------+-----------+\n```\n\n```sql\nSELECT author, ROUND(AVG(price),2) AS Средняя_цена\nFROM book\nGROUP BY author;\n```\n\n## Вычисления по таблице целиком\n\nГрупповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.\n\n```sql\nSELECT SUM(amount) AS Количество\nFROM book;\n```\n\n## Выборка данных по условию, групповые функции\nВ запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.\n\n```sql\nSELECT author,\n    MIN(price) AS Минимальная_цена, \n    MAX(price) AS Максимальная_цена\nFROM book\nGROUP BY author\nHAVING SUM(price * amount) > 5000; \n```\n\nТакже в запросах с группировкой можно сортировать данные.\n\n```sql\nSELECT author,\n    MIN(price) AS Минимальная_цена, \n    MAX(price) AS Максимальная_цена\nFROM book\nGROUP BY author\nHAVING SUM(price * amount) > 5000 \nORDER BY Минимальная_цена DESC;\n```\n\nWHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:\n\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY\n","category":"testops","description":"Базовые запросы с использованием LIKE, BETWEEN, ORDER BY, ALIASES, IN, TOP-LIMIT, DISTINCT"},{"title":"Объединение таблиц(вложенные запросы, джойны","path":"/obedinenie-tablicz-vlozhennye-zaprosy-dzhojny/","content":"\nВложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:\n\nсравнения выражения с результатом вложенного запроса;\nопределения того, включено ли выражение в результаты вложенного запроса;\nпроверки того, выбирает ли запрос определенные строки.\nВложенный запрос имеет следующие компоненты:\n\nключевое слово SELECT  после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент) ;\nключевое слово FROM и имя таблицы, из которой выбираются данные;\nнеобязательное предложение WHERE;\nнеобязательное предложение GROUP BY:\nнеобязательное предложение HAVING.\n Вложенные запросы  могут включаться в WHERE или HAVING так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):\n\nWHERE | HAVING выражение оператор_сравнения (вложенный запрос);\nWHERE | HAVING выражение, включающее вложенный запрос;\nWHERE | HAVING выражение [NOT] IN (вложенный запрос);\nWHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос).\nТакже вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT\n\nВложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.\n\n```sql\nSELECT title, author, price, amount\nFROM book\nWHERE price = (\n         SELECT MIN(price) \n         FROM book\n      );\n```\nВложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.\n\n```sql\nSELECT title, author, amount \nFROM book\nWHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;\n```\n\nВложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором IN.\n\n```WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)```\n\nОператор IN определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после WHERE получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE author IN (\n        SELECT author \n        FROM book \n        GROUP BY author \n        HAVING SUM(amount) >= 12\n      );\n```\n```sql\nSELECT author, title, amount\nFROM book\nWHERE author IN (\n        SELECT amount \n        FROM book \n        GROUP BY amount \n        HAVING COUNT(amount) = 1\n);\n```\n\n## Вложенный запрос, операторы ANY и ALL\nВложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).\n\nОператоры ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.\n\nПри использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY:\n\namount > ANY (10, 12) эквивалентно amount > 10\n\namount < ANY (10, 12) эквивалентно amount < 12\n\namount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)\n\namount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12\n\nПри использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:\n\namount > ALL (10, 12) эквивалентно amount > 12\n\namount < ALL (10, 12) эквивалентно amount < 10\n\namount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)\namount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12\n\nВажно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.\n\nВывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE amount < ALL (\n        SELECT AVG(amount) \n        FROM book \n        GROUP BY author \n      );\n```\n\nВывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE amount < ANY (\n        SELECT AVG(amount) \n        FROM book \n        GROUP BY author \n      );\n```\n\n## Вложенный запрос после SELECT\nВложенный запрос может располагаться после ключевого слова SELECT. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.\n\nПример\n\nВывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.\n\nЗапрос:\n```sql\nSELECT title, author, amount, \n    (\n     SELECT AVG(amount) \n     FROM book\n    ) AS Среднее_количество \nFROM book\nWHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;\n```\n\n```\n+-----------------------+------------------+--------+--------------------+\n| title                 | author           | amount | Среднее_количество |\n+-----------------------+------------------+--------+--------------------+\n| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |\n| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |\n| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |\n+-----------------------+------------------+--------+--------------------+\n```\n\n","category":"testops","description":"Объединение таблиц(вложенные запросы, джойны"},{"title":"Профессионально работаем с IntelliJ IDEA","path":"/professionalno-rabotaem-s-intelli-j-idea/","content":"\n## Основы\n\n_Alt + 1(Win), ⌘ + 1(MacOs)_ - отобразить/скрыть вид проекта слева\n\n_Alt + Insert(Win), ⌘ + N(MacOs)_  \n_(клик в левом меню)_ - открывает диалог создания нового файла\n\n_Alt + Insert(Win), ⌘ + N(MacOs)_  \n_(клик в основной области окна)_ - открывает окно генерации методов разных типов (@Test, @SetUp, @TearDown)\n\n_Ctrl + P(Win), ⌘ + P(MacOS)_ - открывет подсказку параметров текущего метода\n\n_Alt + Enter(Win), Option + Enter(MacOs)_  \n_Alt + Shift + V(Win), Option + ⌘ + V(MacOs)_  - формирует из выражения новую переменную\n\n_⌘ + Shift + I(MacOs)_ - сбилдить gradle проект\n\n### Postfix\n\n_после выражения дописать .var_ - формирует из выражения новую переменную\n_после числа дописать .for_ - формирует циклы от 0 до заданного числа\n\n### Справочная информация по работе в IDE\n\n_Shift + Shift_ - поиск по командам, файлам и всему остальному в проекте\n\n_Help + Keyboard Shortcuts PDF_ - загружает PDF файл со всеми сочетаниями клавиш\n\n_Плагин Key Promoter Х_ - подсказывает какие shortcuts нужно выбирать при совершении действий мышью\n\n_Ctrl + Alt + O(Win), Option + ⌘ + N(MacOs)_ - перемещает значение переменной непосредственно в метод\n\n_Option + Enter (на запускаемом методе), F9_ - выполнить запуск кода\n\n_Ctrl + F11(Win), Option + F3(MacOs)_ - добавить файл в закладки\n\n_View - Tool Windows - TODO_ - открывается окно посмотра добавленных todo комментариев.  \nЗдесь можно настроить фильтр поиска todo содержащие определенный текст, и добавить им соответсвующее выделение\n\nВ момент дебага можно внести изменения в код и чтобы он применился на лету нужно запустить билд приложения и продолжить выполнение.\n\n\n## Git/VSC\n\n### Редактирование коммита\n\nВ окне `Git/VSC` вкладка `Log` - можно нажать на коммит и изменить сообщение\n\n### Объединение коммитов\n\n1. Выбираем в вверхнем меню `Git` - `Rebase`, \n2. Выбираем текущую ветку из удаленного репозитория и выбираем опцию `--interactive`\n3. Нажимаем Rebase\n4. Откроется окно, в нем также можно выбрать и переименовать комит (`Reword`). \n5. Выделяем коммиты, которые хотим объединить и вверху выбираем `Fixup` и нажимаем `Start Rebasing`.\n\n### Отмена коммита\n\nНа вкладке Log нажимаем ПКМ на коммит до которого хотим откатиться и выбираем `Reset Current Branch to Here...`.  \nВыбираем опцию `Hard` - все коммиты выше выбранного будут удалены без сохранения.\n\nЕсли коммит был запушен то отменить его лучше через `Revert commit`, будет создан комит отменяющий выполненные изменения.\n\n\n_Ctrl + Q(Win), F1(MacOS)_ - показывает короткую документацию по текущему методу/переменной.\n\n_Ctrl + B(Win), ⌘ + B(MacOs)_ - переход к объявлению кода/либо поиск мест где данные код используется.\n\n_Ctrl + E(Win), ⌘ + E(MacOs)_ - открывается окно с недавними файлами которые были ранее открыты.\n\n_Ctrl + Alt + ⇨(Win), ⌘ + Option + ⇨(MacOs)_ - позволяет перемещаться по истории в том числе между открытыми ранее файлами выставляя курсор в том месте, где он ранее был при работе в этих файлах.\n\n_Ctrl + shift + E(Win), ⌘ + Shift + E(MacOs)_ - показывает последние участки кода с которыми была работа.\n\nДля работы с рандомными файлами которые возможно даже не относятся к текущему проекту можно пользоваться разделом `Scratches and Console`. Он находится слева в окне с деревом проекта в самом низу.\nЭти файлы будут доступны в любых проектах. Можно сохранять разные шаблоны, шпаргалки и т.д.\n\n## Библиотека JsonPath\n\n_Alt + Enter(Win), Option + Enter(MacOs)_ - при нажатии на значении строковой переменной позволяет выбрать `Inject language or reference` после чего можно выбрать язык, чтобы содержимое строки отформатировалось и подсветилось в соотвествии с синтаксисом выбранного языка, например JSON. При повторном вызове команды, можно выбрать `Edit JSON Fragment` и в открывшемся окне отредактировать выбранный JSON или вставить большой фрагмент.\n\n### Прочитать данные из JSON\n\n```java\nString json = \"{\\\"name\\\": 10}\";\nJsonPath.read(json, \"$..name\")\n```\n\nПри нажатии `Option + Enter`(MacOs) на команде `\"$..name\"` выбираем `Evaluate JSONPath Expression`\nОткрывается окно в котором можно инспектировать json.\n\nЕсли json код находится в отдельном файле, то открыв этот файл и выбрав `Edit` - `Find` - `Evaluate JSONPath Expression`, можно инспектировать текущий json не копируя его содержимое.\n\n_Find By XPath_ - Аналогичный инструмент для XML. \n\n### Регулярные выражения\n\nПри нажатии `Option + Enter`(MacOs) на строке с регулярным выражением можно выбрать `Check RegExp` и выполнить проверку регулярного выражения\n\n## Плагины\n\n### Docker \n\nМожно установить из MarketPlace.\n\nОткрываем Tool окно `Services` (Alt + 8, ⌘ + 8) \n\nНажимаем на `+` - Docker Connection \nМожно смотреть разную информацию. Удалять, смотреть контейнеры.\n\n## Работа с БД (Ultimate Edition)\n\n- Вкладка Database - + - Data Source (выбираем тип БД) PostgreSQL.\n- Указываем Credentials - Test Connection.\n- Вкладка Schemas, обновить выбираем схему и отмечаем public.\n- После этого IDE подключается к БД и можно увидеть всю структуру БД.\nИ выполнять SQL запросы нажимая Cntl + Enter(Win), ⌘ + Enter(MacOs)\n\nЧтобы SQL распознавался в строковой переменной и была возможность автодополнения перед переменной в строке выше нужно добавить комментарий\n\n```java\n// language=SQL\n```\n\nЧтобы нужные колонки одтягивались из нашей БД нужно настроить диалект.\nНажимаем `Option + Enter`(MacOs) на SQL строке, выбираем `Change dialect to...`.\nВ диалоговом окне выбираем `Project SQL Dialect` нашу БД, например `PostgreSQL` и нажимаем `ОК`.\n\nПрямо в IDE можно менять данные в БД.\n\n## Selenium UI Testing (Ultimate Edition)\n\nПозволяет сформировать стартовый проект с подключенными нужными зависимостями (Allure, Selenide и т.д.)\nПодсвечивает и подсказывает в формировании селекторов(XPath, Css и т.д.)\nЕсть автодополнение разных атрибутов и Css свойств.\nTools - Generate Selenium PageObject - открыается браузер, в котором можно перейти на страницу для которой создается Page Object; при нажатии на элементы их можно быстро добавить в текущую страницу.\n\nТакже страницу можно: \n  - сохранить в scratches \n  - нажать иконку копировать и при вставке в дерево проекта будет создан файл с названием класса и содержимым копируемой страницы.\n\nЕсть интеграция с Selenoid: \nпри открытии файла browsers.json в верхней части окна можно выбрать ссылку Launch и запустить selenoid node в docker'e\n\nЕсть интеграция с Allure:\n  - при добавлении аннотации @Issue, @TmsLink можно будет проваливаться непосредственно в задачу, на которую ссылается данный тест.  \n  Для этого нужно тобы путь к проекту был настроен либо в allure.properties либо в настройках IDE: `Preferences` - `Version Control` - `Issue Navigation`,\n  `+` - `Add Pattern`\n\n## Работа с Web Services (Ultimate Edition)\n\nМожно генерировать и исполнять запросы с помощью специального языка http для этого создается файл с соответсвующим разрешением (.http)  \nМожет подсказывать параметры, заголовки и т.д.  \nМожно писать тест на языке javascript и выполнять их прямо из таких файлов.\n\n```javaScript\nGET https://httpbin.org/status/200\n\n> {%\nclient.test(\"Request executed succesfully\", function() {\n  client.assert(responce.status == 200, \"Response status is not 200\");\n});\n%}\n```\n\nПри написании Rest тестов например через библиотеку RestAssured IDE может подсказывать все url, которые есть в вашем проекте или в OpenApi спецификациях.\n\nЧтобы добавить спецификацию идем внизу во вкладку Endpoints, через шестиренку выбираем `Configure OpenApi Sources...` через + выбираем Swagger Hub, ищем конфигурацию и нажимаем `Add Selected`.  \nПосле этого в автодополнении появятся нужные url.  \nЕсли открыть swagger.yaml, то через иконку можно в соседнем открыть swagger ui в котором также можно делать отладку и отправлять запросы.\n\n## Плагины\n\n### Test Management (Ultimate Edition)\n\nНужно установить соответсвующий плагин и в настройках IDE - Preferences - Tools - Tms указать путь к ссиетме управления тестами TestRail.\n\nТогда в соседнем окне появятся тест кейсы, тест раны, тест планы, которые будут синхронизироваться.\n\nМожно скопировать нужный тест кейс и вставить в код автотестов, в результате будет сгененрирован тестовый метод с комментариями шагов, которые нужно автоматизировать.\n\nТакже эти кейсы можно фильтровать по каким-либо параметрам или например, автоматизирован тест или нет.\n\nТакже этот плагин позволяет хранить кейсы как код (test cases as a code). Они сохраняются в виде .md файлов в папочке specs, их можно обновлять и эти изменения будут отражаться в дереве кейсов справа. Их также можно фильтровать по параметрам, хранить в VSC. \nЕсть специальный формат, который позволяет добавлять статусы, assignee и т.д.\n\n### Test Data\n\nПлагин позволяет генерировать данные.\nЧерез `Option + Enter`(MacOs) в строковой переменной можно выбрать тип данных, который нужно сгененрировать.\n\n\nhttps://www.youtube.com/watch?v=_rj7dx6c5R8","category":"automation","description":"Профессионально работаем с IntelliJ IDEA"},{"title":"Как установить OpenJDK на Mac OS","path":"/kak-ustanovit-open-jdk-na-mac-os/","content":"\n\n## Скачиваем JDK \n\nЧтобы скачать пакет Open JDK нужно:\n\n1. Зайти на сайт [jdk.java.net](https://jdk.java.net/)\n2. Перейти по ссылке с нужной версией Java, последняя стабильная версия Java находится в пункте Ready for use\n3. В разделе Build выбираем ссылку на архив с пакетом. Для Mac OS - это macOS / x64\ttar.gz (sha256)\n\n## Извлекаем архив\n\n1. Переходим в папку в которую будем производить установку и создаем в ней папку для хранения jdk[^Here is the footnote]\n\n```bash{outputLines: 2}\ncd /Library/Java/JavaVirtualMachines/\n```\n\n2. Копируем в созданую папку скаченный архив\n\n```bash{outputLines: 2}\nuser@TestAutomation.Space:/usr$ sudo mv ~/Downloads/openjdk-..._bin.tar.gz /Library/Java/JavaVirtualMachines/\n[sudo] пароль для user: \n```\n\n3. И распаковываем tar-архив\n\n```bash{outputLines: 2}\nsudo tar zxvf /usr/java/openjdk-..._bin.tar.gz\n[sudo] пароль для user: \n```\n\n## Настраиваем переменные окружения PATH и JAVA_HOME\n\n1. Открыть на редактирование файл `.profile`\n\n```bash\nnano ~/.bash_profile\n```\n\n2. В конец добавляем строчки\n\n```bash\nJAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk.../Contents/Home\"\nexport JAVA_HOME\n\nPATH=${JAVA_HOME}/bin:${PATH}\nexport PATH\n```\n\n3. Нажимаем `Ctrl+X` и соглашаемся с сохранением изменений, нажав на `Y`\n4. Выполняем команду для инициализации изменени и проверяем что переменная среды выводится верно\n\n```bash\nsource ~/.bash_profile\nenv\necho $JAVA_HOME\necho $PATH\n```\n\n4. Теперь нужно перезапустить консоль и проверить версию Java\n\n```bash\njava -version\n```","category":"automation","description":"Чтобы писать автотесты на языке Java потребуется установить пакет Oracle JDK или Open JDK. В этой статье мы расскажем в чем между ними различия, что лучше устанавливать, а также пройдемся по шагам для установки и настройке рабочей среды."},{"title":"Gradle","path":"/gradle/","content":"\nGradle - это фреймворк который отвечает за структуру, зависимости, плагины вашего проекта для того чтобы управлять этапами сборки этого проекта: компиляция, запуск тестов, публикация. \n\nНаписан на Java  и запускается на JVM. \n\nДля реализации и описания процесса сборки в Gradle реализовано 2 DSL языка на Groovy и на Kotlin.\nОба этих языка предоставляют примерно одинаковый API для работы со сборкой и имеют 2 интерфейса, которые эту сборку описывают.\n\n`project` - описывает как и из чего собрать проект;  \n`settings.gradle` - описывает дополнительные метаданные и список дочерних проектов, если это мультимодульный проект;\n\n## `project`\n\n### task\nПредставляет собой набор задач, который вам нужно выполнить для сборки приложения; эти задачи можно писать самим или добавлять через плагины.\n\n### plugin\nПлагин - это реализация методов интерфейса project, которые могут реализовывать работу с зависимостями, добавлять нужные таски и почти полностью менять, то как работает процесс сборки.\n\n### dependencies\nМожно указать необходимые зависимости для работы вашего приложения. Gradle реализует только логику управления зависимостями а сам репозиторий можно выбрать, настроив это в build скрипте. Это может быть например maven репозиторий.\n\nТип Task в Gradle это по сути класс, который состоит из действия, которое выполняет класс или нескольких действий, входных и выходных данных.\n\nКаждая из этих состовляющих кастомизируема и необязательна. Например, существуют LifeCycle таски, которые сами ничего не делают, но объединяют несколько других тасок.\n\nЗа счет такого разделения Gradle реализует **_инкрементальную_** сборку: перед выполнением таски Gradle проверяет есть ли изменения входных данных и повлияют ли эти изменеия на выходные данные. Если нет, то Gradle просто пропустит таск с надписью **UP TO DATE**, таким образом оптимизируется процесс сборки, чтобы каждый раз не собирать неизменяемые модули, а собирать только то, что изменилось, но эту логику также можно отключить.\n\nЧтобы обеспечить нужный порядок выполнения тасок Gradle строит ориентированный ациклический граф (**DAG, Directed Acyclic Graph**). \n\nГраф - это набор объектов(в нашем случае тасок), обладающих парными связями (каждая таска связана с одной или несколькими(двумя) тасками). \n\nТаски - вершины, связи между ними - ребра. \n\nТо что граф ориентированный значит, что у ребер есть направление (порядок исполнения тасок), то что он ациклический означает, что в нем нет направленных циклов, нельзя из одной точки прийти в нее же, но это не мешает из разных точек прийти в одну. \n\n**Граф для сборки Java приложения**\n\n```mermaid\ngraph TD;\n      build-->check;\n      build-->assemble;\n      check-->test;\n      assemble-->jar;\n      jar-->classes;\n      classes-->compileJava;\n      classes-->processResources;\n```\n\n## Сборка Java приложения\nПроцесс сборки делится на 3 тапа: инициализация, конфигурация и исполнение. \n\n### Инициализация\nВ процессе инициализации Gradle ищет `settings.gradle` файл, из которого определяет это одиночный или мультимодульный проект. После этого он создает instance одного или нескольких проектов. \n\n### Конфигурация\nДалее в процессе конфигурации, gradle для каждого проекта ищет build.gradle скрипт и выполняет все указанные там конфигурационные действия в контексте текущего проекта: подключает плагины, скачивает зависимости, выполняет код находящийся в конфигурационном блоке, создавая объекты сборки. \n\nВо время фазы конфигурации gradle исполняет конфигурационные скрипты всех проектов если это мультимодульный проект, даже если вы собираете только один из модулей. Так что если логика не относится ко всему мультимодульному проекту, лучше ее помещать в конкретные таски. \n\n### Исполнение\nПо сути в процессе конфигурации он строит тот самый граф из тасок и в процессе выполнения, исполняет те таски, которые мы указали.\n\n\nИннициализация Gradle проекта выполняется командой gradle init.\n\n```\n$ gradle init\n```\n\nДалее нужно ответить на несколько вопросов и дождаться окончания инициализации.\nПосле этого в проекте будут созданы файлы: \n- gradlew(исполняющий файл для Linux подобных систем), gradlew.bat(исполняющий файл для Windows);\n- папка gradle, в которой папка wrapper;  \nКак раз этот wrapper и запускает скрипты. Gradle использует wrapper, чтобы можно было однозначно понять версию Gradle, которая будет использоваться для сборки.  \nWrapper сам скачает эту версию Graddle, если на машине он не установлен. Поменять версию и откуда его скачивать можно в файле gradle/gradle-wrapper.properties\n- build.gradle, settings.gradle\n\nВ **settings.gradle** указано только имя проекта, для мультимодульных проектов также здесь указывается список модулей. \n\nВ **build.gradle** имеются следущие секции:\n\n- секция plugins  \nЗдесь размещается обычно плагин id: 'java', который используется для сборки java проектов;  \nЕще существует плагин java-library, он используется если вы хотите поставлять ваше приложение как библиотеку.\n\n```groovy\nplugins {\n    id 'java'\n}\n```\n\n- секция repositories  \nЗдесь можно задать url репозитория из которого будут скачиваться зависимости. Для стандартного Maven репозитория есть алиас mavenCentral().\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n```\n\nТакже в build.gradle, как и в Maven содержатся group, version, description, java.sourceCompatibility, но в отличие от Maven их указывать не обязательно Gradle сможет сам сгенерировать эти данные.\nПосле компиляции нам доступны таски.\n\n- секция dependencies  \n\nЕсть несколько типов зависимостей:\n- implementation - зависимость доступна и в main и в test директориях\n- testImplementation - зависимость доступна только в test директории\n- testAnnitationProcessor - зависимость, которая генерирует код в рантайме на основе аннотаций\n\n```groovy\ndependencies {\n    implementation 'com.codeborne:selenide:6.6.3'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.24'\n}\n```\n\nЧтобы после билда запустились тесты, нужно указать каким движком нужно запустить тесты.\n\n```groovy\ntest {\n    useJUnitPlatform()\n}\n```\n\nКогда зависимость требует какой то сложной конфигурацией она зачастую реализуется плагином. Тогда достаточно подключить плагин и не нужно добавлять несколько зависимостей.\n\nВместо testAnnotationProcessor которую мы прописывали для lombok можно добавить плагин.\n\n```groovy\nplugins {\n    id 'io.freefair.lombok' version'5.3.0'\n}\n```\n\n## Custom task\n\nДля добавления своей таски используется коллекция tasks и новые таски в нее добавляются с помощью методы register. В метод register нужно передать название таски(по этому названию мы в последствии сможем обращаться к этой таске)\nвторой параметр опционален, в него можно передать тип таски можно использовать стандартный тип Test который был добавлен Java плагином. \n\n### Таска для запуска тестов из определенной директории\nОтфильтровать тесты которые будут запускаться можно с помощью блока filter в нем есть метод includeTestsMatching.\nНа вход этому методу можно передать wildcard - часть пути до наших тестов со звездочкой.  \n\n```\nsrc\n├── main\n    ├── java\n        ├── simple\n            ├── automation\n├── test\n    ├── java\n        ├── rest\n        ├── utils\n        ├── web\n            ├── findby\n            ├── simple\n```\n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n```\n\n### Указываем платформу для запуска тестов из Custom Tasks \n\nЧтобы не прописывать в каждой таске, что она должна запускаться с помощью Junit можно выполнить одну настройку для всех тасок с типом test. \nДля этого на контейнере tasks используем метод withType, который выберет все таски с типом Test, и внутри конфигурационного блока используем useJUnitPlatform().\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n}\n```\n\n### Зауск тестов из Custom Task\nВыполняем запуск тестов webtests командой:\n\n```\n$ ./gradlew webtests\n```\n\n### Добавляем еще одну custom таску\nАналогично можно настроить запуск для rest тестов:\n\n```groovy\ntasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n```\n\n### Добавляем зависимость одной таски от другой\nБывает что rest тесты могут использоваться при выполнении web тестов и зачастую бывает удобно прогонять web тесты только если прошли rest тесты.\nДля этого в Gradle есть метод dependsOn с аргументом в виде названия таска, от которой зависит текущая таска. \n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n    dependsOn 'resttests'\n}\n```\n\nСоответсвенно, при запуске web тестов будут также запущены rest тесты и они выполнятся только если rest тесты пройдут. \n\n### Запуск независимых тасок в одном скоупе\nНо если у нас rest и web тесты работают независимо как разные модули или части системы, мы можем создать еще один таск regress, который будет запускать и те и другие тесты. Используем тот же метод dependsOn но уаазываем и web и rest тесты.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n}\n```\n\nНо в таком виде запуска мы не знаем в каком порядке запустятся эти таски. \n\n### Настраиваем порядок запуска тасок\nЕсли мы хотим определить порядок, например, чтобы web тесты запускались после rest тестов, мы можем использовать метод mustRunAfter или shouldRunAfter(является менее строгим и не запускает тесты если из-за зависимости образуется петля).\nЧтобы найти ранее созданный таск используем метод getByName и из него запускаем mustRunAfter с аргументом ввиде названия таски после которой нужно запускать.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n    \n    tasks.getByName('webtests').mustRunAfter('resttests')\n}\n```\n\nЛибо при создании таска можно сохранить ее в переменную и тогда можно использовать эти переменные для вызова mustRunAfter.\n```groovy\ndef webtests = tasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n\ndef resttests = tasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n\n    webtests.mustRunAfter(resttests)\n}\n```\n\n### Запуск тестов из директории main\nЕсли по какой то причине тесты оказались не в папке test, а в папке main, то по умолчанию Gradle найти там тесты не может. Поэтому для того чтобы указать нестандартное место исходников можно использовать блок sourceSets.\n\n1. Добавляем новый sourceSet\n\nДля создания нового сета, просто пишем имя сета и скобку, внутри добавляем блок java чтобы указать свойства которые были добавлены java плагином, compileClasspath и runtimeClasspath, добавляем через += чтобы не затирать текущие значения. \nДобавляем туда путь к папке main - main.output. Чтобы указать где взять исходники используем свойство srcDir. \n\n```groovy\nsourceSets {\n    maintests {\n        java {\n            compileClasspath += main.output\n            runtimeClasspath += main.output\n        }\n        srcDir = file(\"src/main/java/simple/automation\")\n    }\n}\n```\n\n2. Настраиваем зависимости для добавленного sourceSet\n\nТакже нам нужны зависимости из блока dependencies, по умолчанию они в блок sourceSet не попадают.\nДля этого используется блок configurations, в нем указываем имя нашего sourceSet и без пробела пишем Implementation или RuntimeOnly. \nДалее с помощью метода extendsFrom можем указать, что зависимости нужно брать стандартные из testImplementation и testRuntimeOnly.\n\n\n```groovy\nconfigurations{\n    maintestsImplementation.extendsFrom(testImplementation)\n    maintestsRuntimeOnly.extendsFrom(testRuntimeOnly)\n}\n```\n\n3. Добавляем таск для запуска тестов, используя sourceSet\n\nСоздаем таск для запуска псевдотестов и указываем, что нужно использовать наш кастомный sourceSet.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n}\n```\n\n4. Добавляем фильтрацию по тегам JUnit\n\nТеперь нужно отфильтровать псевдотесты чтобы запускались только они. Сделать как в предыдущих тасках мы не можем потому что по имени package simple.automation будут запущены также и web тесты.\nНо можно использовать фильтрацию по тегам Junit. Для этого вызываем метод useJUnitPlatform, но к нему добавляем конфигурационный блок includeTags и тег методов или классов которые хотите запустить.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n\n    useJUnitPlatform{\n        includeTags \"pseudo\"\n    }\n}\n```\n\n### Запуск тестов с логированием\nЧтобы добавить уровень логирования INFO при запуске gradlew нужно добавить ключ -i.\nТаком образом мы увидим сообщения которые выводятся в консоль из тестов.\n\n```\n$ ./gradlew -i pseudotests\n```\n\n### Отключаем инкрементальный билд при запуске\nНо сразу мы можем их не увидеть из-за инкрементального билда.\nТак как между запусками исходники тестов не поменялись Gradle просто не запустит их.\nЧтобы они запустились перед таской с тестами запустим также таску clean. Это актуально для запуска тестов из контекста main.\nЕсли запускаются тесты из директории test то нужно использовать таску cleanTest.\n\n```\n$ ./gradlew -i clean pseudotests\n```\n\n### Отключаем инкрементальный билд глобально при настройке таски\nЧтобы каждый раз не вызывать clean таску можно установить значение upToDateWhen в знасение false для всех тасок с типом Test.\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n    outputs.upToDateWhen {false}\n}\n```\n\nЕсли запускаетя несколько независимых тасок с тестами, то Gradle по умолчанию останавливает выполнение на первом упавшем тесте. \nМожно настроить чтобы он все равно переходил к следущей задаче даже если упала предыдущая.\nДля этого можно при запуске добавить ключ --continue\n\n```\n$ ./gradlew --continue resttests webtests\n```\n\n### Отключаем стандартную таску test при билде\n\nДля этого нужно в блоке test присвоить свойству enabled значение false\n\n```groovy\ntest {\n    enabled = false\n}\n``` \n\n### Порядок выполнения build скрипта \n\n### Как добавить кастомные экшены к таскам\n\nСоздаем еще одну таску, но не указываем тип. В этом случае у таски будет тип DefaultTask и к ней не будет привязано никаких экшенов.\nВыводить текст в консоль можно стандартной командой println, но для реального логирования лучше использовать нормальные логгеры.\nДобавим вывод текста в блок конфигурирования таски, а также перед таской и после нее.\nЧтобы добавить кастомные экшены в таску можно использовать блок doFirst - это действие которое будет выполнено перед стандартными экшенами.\nВ нашем случае таких экшенов нет а для тасок с типом Test таким стандартным экшеном был запуск тестов.\nЕще мы можем использовать блок doLast - запускает кастомные экшены после стандартных. И doFirst и doLast можно использовать несколько раз, тогда они будут исполняться в указанном порядке. \n\nПосле запуска по тексту в консоли мы видим порядок выполнения.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\").configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\nРезультат выполнения:\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 637ms\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nСначала вполняется код конфигурации, затем код конфигурации самой таски (код внутри таски вне блоков doFirst и doLast), \nа уже дальше выполняются экшены сначала doFirst, потом doLast в порядке в котором они указаны в скрипте.\n\n> Стоит иметь ввиду если бы у нас был многомодульный проект, то сначала вполнился бы код конфигурации из всех build скриптов всех модулей.\n\nТип таски это прсто класс. Можно создать свой тип. \nДля этого используется метод с аннотацией @TaskAction, при этом класс должен наследоваться от DefaultTask.\n\n```groovy\nclass CustomTask extends DefaultTask{\n    @TaskAction\n    def customAction(){\n        println \"from custom action\"\n    }\n}\n```\n\nТеперь можно указать наш кастомный тип при регистрации таски. И теперь между doFirst и doLast экшенами выполнился наш кастомный экшен.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom custom action\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nТаск может состоять из input, actions, output. Добавим input в наш тип. Это можно сделать с помощью переменной с аннотацией @Input.\nПрисвоим ей дефолтное значение и будем использовать в нашем экшене. Теперь стандартный экшен использует значение из input'а \nи мы можем этот input переопределить в конфигурации самой таски. \n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    input = \"overrided\"\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n\n\nclass CustomTask extends DefaultTask{\n    @Input\n    String input = \"default\"\n\n    @TaskAction\n    def customAction(){\n        println \"from custom action with $input\"\n    }\n}\n```\n\nПосле прогона тестов в build/test-results складывается отчет JUnit о прогоне тестов.\nТакже есть тип таски zip позволяет что-нибудь заархивировать.\n\nИмя итогового архива задается через переменную archiveFileName, с помощью distinationDirectory указываем куда будет сложен этот архив и через\nметод from указываем какую именно папку заархивировать. Чтобы указать несколько папок используйте несколько строяек from. \n\nТаска чтобы заархивировать отчет:\n\n```groovy\ntasks.register(\"zipReport\", Zip).configure{\n    archiveFileName = 'report.zip'\n    distinationDirectory = file(\"$buildDir/reports\")\n    from \"$buildDir/reports/tests\"\n}\n```\n\nТакже потом его нужно куда нибудь скопировать. ддля этого есть тип таски Copy. В ней указываем через from откуда взять файл(также можно указать несколько from),\nа в into указываем куда скопировать. \n\n```groovy\ntasks.register('copyReport', Copy).configure{\n    from file(\"$buildDir/reports/report.zip\")\n    into file(\"out\")\n}\n```\n\nЕще одна полезная таска это jar - позволяет заархивировать приложение в jar файл. \nУ него в блоке manifest в свойстве attributes можно задать атрибут Main-Class который указыывает класс в котром наодится исполняемый метод main \nа в блоке from откуда взять скомпилированные классы \n\nJar собирается в папку build/libs и его можно запустить через команду java -jar \n\n```groovy\njar {\n    manifest {\n        attributes \"Main-Class\": \"simple.automation.Main\"\n    }\n    from {\n        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n}\n```\n\n## TODO\n\nhttps://www.youtube.com/watch?v=WOBok2u-SL8\n\nhttps://www.youtube.com/watch?v=NZJTYPLb0iE","category":"automation","description":"Gradle"},{"title":"Maven","path":"/maven/","content":"\nВсе pom.xml переопределяют super pom который идет в поставке maven\nЭто позвояет писать компактный xml.\nPom.xml содержит\n- описание проекта(название, версия, ссылки на исходные коды, CI, лицензия, разработчики и т.п.)\n- список зависимостей\n- список плагинов и их конфигурации описывает то что нужно сделать\n- профили - возможность выполнять некоторые действия при определенных обстоятельствах\n\n## Название проекта и параметры\n\n```xml\n<properties>\n    <jetty.port>9990</jetty.port>\n    <jetty.version>9.1.9.v20131115</jetty.version>\n\n    <compiler.version>1.7</compiler.version>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n</properties>\n\n<group.id>ru.yandex.qatools.allure</group.id>\n<artifactId>allure-core</artifactId>\n<version>1.4.4-SNAPSHOT</version>\n\n<packaging>pom</packaging>\n\n<name>Allure Core</name>\n```\n\n## Список модулей\n\n```xml\n<modules>\n    <module>allure-model</module>\n    <module>allure-commons</module>\n    <module>allure-java-annotations</module>\n</modules>\n```\n\n## Информация о проекте\n\n```xml\n<issueManagement>\n    <system>GitHub Issues</system>\n    <url>https://github.com/allure-framework/allure-core/issues</url>\n</issueManagement>\n<ciManagement>\n    <system>TeamCity</system>\n    <url>https://teamcity.qatools.ru</url>\n</ciManagement>\n<developers>\n    <developer>\n        <id>eroshenkoam</id>\n        <name>Artem Eroshenko</name>\n        <email>eroshenko@yandex-team.ru</email>\n        <organization>Yandex</organization>\n    </developer>\n</developers>\n```\n\n## Описание сборки проекта (плагины)\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.0</version>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\n## Зависимости\n\n```xml\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-model</artifactId>\n    <version>${project.version}</version>\n</dependency>\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-commons</artifactId>\n    <version>${project.version}</version>\n</dependency>\n```\n\n## Именование директорий\n\nsrc/ - все исходные коды  \nsrc/main - всё, что касается продукта  \nsrc/test - всё, что касается тестов\n\nsrc/main/java - Java-код продукта  \nsrc/main/resources - ресурсы продукта  \nsrc/main/webapp - файлы веб-приложений продукта (стили, Javascript и т.п.)\n\nsrc/test/java - Java-код тестов  \nsrc/test/resources - ресурсы тестов  \nsrc/test/webapp - файлы веб-приложений тестов\n\n## Жизненные циклы\n\nClean - очищает проект перед сборкой  \nDefault - собирает проект  \nSite - создает сайт проекта со ссылками на зависимости, CI, тикетную систему и т.п.\n\n## Сборка проекта. Команда mvn.\n\n```\n$ mvn clean test\n```\n\nValidate - проверить правильность проекта  \nCompile - скомпилировать исходники  \nTest - скомпилировать и выполнить тесты  \nPackage - упаковать скомпилированный код и исходники в jar, war архив  \nVerify - проверить, что код правильно упакован  \nInstall - установить пакеты в локальный репозиторий  \nDeploy - выгрузить пакеты в удаленный репозиторий  \n\n### Управление зависимостями\n\nНужно добавить блок, описывающий зависимость, в секцию `<dependencies>` и `<dependencyManagement>`\n\nБлок зависимости включает: \n- groupId - идентификатор который описывает группу проектов одного разработчика\n- artifactId - уникальное название проекта\n- version - номер версии\n- scope - на какой стадии сборки используется данная зависисмость\n    Scope может быть: \n    - compile - зависимость нужна на этапе компиляции\n    - test - зависимость не нужна чтобы собрать продукт, но нужна чтобы выполнить тесты\n    - runtime - зависимость не нужна для сборки и тестирования продукта, но нужна при его запуске\n    - provided - зависимость нужна для запуска, но при этом она поставляется кем то еще\n    - system - тоже самое что provided, но с указанием пути; мы можем указать, где на файловой системе лежит данная библиотека\n\n```xml\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n    <version>1.7.7</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n## Версии пакетов. Релизы и снепшоты\n\nСнепшот - промежуточная версия пакета, используемая в разработке: 1.0-SNAPSHOT(снимок текущей версии), чтобы делиться с другими разработчиками. Может быть бесконечно много снепшотов с одной и той же версией\n\nРелиз - стабильная версия пакета, предназначенная для использования другими проектами: 1.0. Релиз всегда один.\n\nПорядок версий: 1.0-SNAPSHOT, 1.0, 1.1-SNAPSHOT, 1.1, 1.2-SNAPSHOT и т.д.\nСначала мы делаем снепшоты, потом делаем релиз и т.д.\n\n## Конфликт зависимостей. Дерево зависимостей\n\nБывает такая ситуация, когда в проекте используется зависимость, в которой есть зависимость, которая также есть в нашем проекте. И одна зависимость будет перекрывать другую.\n\n```\npom.xml\n├── Log4j-1.2.13\n├── commons-logging-1.1\n    ├── Log4j-1.2.12\n    ├── Servlet-2.3\n```\n\nДля разрешения конфликтов зависимостей нужно построить дерево зависимостей.\nДля построения дерева зависимостей используется команда:\n\n```\n$ mvn dependency:tree\n```\n\n## Исключение зависимостей\n\nДля решения конфликта зависимостей иногда нужно исключить какую то зависимость. Для этого используется exclusions:\n\n```xml\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-report-builder</artifactId>\n    <version>2.0</version>\n    <exclusions>\n        <exclusion>\n            <groupId>ru.yandex.qatools.allure</groupId>\n            <artifactId>allure-model</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n\n### Необязательные зависимости\n\nТакая зависимость не будет скачиваться в проектах, зависящих от данного\nДля того, чтобы пометить необязательную зависимость используется секция optional:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.11</version>\n    <scope>test</scope>\n    <optional>true</optional>\n</dependency>\n```\n\n## Плагины. Настройка билда\n\nИзменение процесса билда - это изменение настроек отдельных плагинов в секции build/plugins.\n\n### Maven Compiler Plugin\n\nКомпилирует java код продукта и его тестов. \nОсновная настройка - версия компилятора.\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\n### Maven Source Plugin\n\nУпаковывает исходные коды проекта чтобы поделиться с другими участниками разработки.\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-source-plugin</artifactId>\n    <version>2.2.1</version>\n    <executions>\n        <execution>\n            <goals>\n                <goal>jar</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n### Maven Dependency Plugin\n\nРазрешение зависимостей, построение дерева зависимостей;\nКопирование, распаковка и другие операции с зависимостями;\n\n### Maven Jar Plugin \n\nУпаковывает файлы в jar-архив;\nМожно сделать испольняемый jar файл и указать класс, который будет запускаться при запуске jar файла.\n\n### Maven Assembly Plugin\n\nСборка дистрибутивов продукта (например, zip-архив c jar, bash скриптами и README)\nНапример, вы хотите собрать свой продукт, а потом взять еще какие то файлы и все это вместе упаковать в архив. \nИ этот плагин требует создание специального файла Assembly.xml в котором будет описываться что он собственно должен делать.\n\n### Maven Release Plugin\n\nАвтоматизирует вырсионирование, выкладку релизов.\n\nДобавляются цели release:prepare и release:perform. Они увеличивают номер версии в pom.xml и отправляет в систему контроля версий.\n\nНастройка:\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-release-plugin</artifactId>\n    <configuration>\n        <autoVersionSubmodules>true</autoVersionSubmodules>\n    </configuration>\n</plugin>\n```\n\n### Maven Surefire Plugin \n\nВыполнение тестов Junit или TestNG\n\n### Maven Site Plugin\n\nПервоначальное назначение - сгенерировать сайт поекта\nОсновное применение - генерация отчетов\n\nНастройка:\n\n```xml\n<reporting>\n    <excludeDefaults>true</excludeDefaults>\n    <plugins>\n        <plugin>\n            <groupId>ru.yandex.qatools.allure</groupId>\n            <artifactId>allure-maven-plugin</artifactId>\n            <version>${allure.version}</version>\n        </plugin>\n    </plugins>\n</reporting>\n```\n\n## Служебные файлы и каталоги\n\nПапка ~/.m2 - локальный репозиторий артефактов.  \nФайлы ~/.m2/settings.xml и /etc/maven/settings/xml, ~/.mavemrc и /etc/mavenrc - конфигурация Maven, можно менять поведение Maven по умолчанию\n\n## Профили. Settings.xml\n\nПрофиль - способ изменить настройки билда, не изменяя pom.xml. Мы можем определить как будет собираться проект при определнных условиях например если выставлена какая то переменная, включить дополнительный тесты и т.п..\n\nПрофиль хранится в pom.xml или в settings.xml(могут указываться пароли так как он не распространяется вместе с продуктом) в секции profiles\n\nИспользование профиля:\n\n```\n$ mvn clean test -P myProfile\n```\n\n```xml\n<profiles>\n    <profile>\n        <id>integration-tests</id>\n        <activation>\n            <activateByDefault>true</activateByDefault>\n        </activation>\n        <modules>\n            <module>allure-e2e</module>\n        </modules>\n    </profile>\n</profiles>\n```\n\n## Центральные репозитории артефактов\n\nУдаленный сервер, все разработчики на который могут отправлять свои разработки, а другие могут их забирать.\nОсновным таким сервером является: Maven Central Repository (http://maven.org)\n\nВ папке репозитория хранится: сами пакеты, которые приходят от разработчиков, их контрольная сумма, некоторая служебная информация в xml и цифровые подписи.\n\n- maven-metadata.xml(служебная информация)\n- jar, javadoc.jar, source.jar, jar.asc (пакеты)\n- jar.md5, javadoc.jar.md5, source.jar.md5, jar.asc.md5 (контрольная сумма)\n- jar.sha1, javadoc.jar.sha1, source.jar.sha1, jar.asc.sha1 (цифровые подписи)\n\nСуществует несколько специализироованных веб-приложений, которые выполняют функцию центральных репозиториев: Sonatype Nexus и Artifactory.\n\n## Локальный репозиторий артефактов \n\nПапка на файловой системе, которая скачивает все зависимости и файлы с центрального репозитория и кеширует у себя и это позвояет ускорять выполнение билдов.\n\nВ папке репозитоория хранятся: файлы pom.xml для каждого проекта, jar файлы, файлы с документацией и исходниками и их контрольные суммы.\n- pom\n- jar\n- javadoc.jar\n- source.jar\n- pom.sha1, jar.sha1, javadoc.jar.sha1, source.jar.sha1\n\n## Архетипы\n\nВозможность создавать шаблоны проектов. Такой возмодности не было в Ant.\nАрхетип - готовый шаблон.\n\nСоздание проекта по шаблону выполняется командой:\n\n```\n$ mvn archetype:generate\n```\n\n## TODO\n\nhttps://www.youtube.com/watch?v=R422m8VTevA","category":"automation","description":"Maven"},{"title":"Как создать новый Gradle проект","path":"/kak-sozdat-novyj-gradle-proekt/","content":"Для создания нового проекта с модулем Gradle нужно выполнить следущие шаги:\n\n## Создаем новый проект в Idea или открываем уже созданный\n- Если вы только что установили Inteliji Idea и у вас ещё нет созданных проектов, то после запуска Idea предложит создать новый проект, поэтому выбираем Create New Project.\n![Добавляем новый проект](/images/add_new_project_step1.1.png)\n\n- Если вы находитесь в уже созданном проекте то выбираем в верхнем меню File - New - Module...\n![Добавляем новый проект](/images/add_new_project_step1.2.png)\n\n## Выбираем модуль Gradle\nВыбираем модуль Gradle, библиотека Java. Нажимаем Next.\n![Добавляем новый проект](/images/add_new_project_step2.png)\n\n## Указываем GroupId и ArtifactId\nУказываем индетификаторы GroupId и ArtifactId. Нажимаем Finish.\n![Добавляем новый проект](/images/add_new_project_step3.png)\n\nДалее в нашем проекте формируются 2 файла: settings.gradle и build.gradle.\nВ файле build.gradle видим следущее содержание\n\n```groovy\nplugins {\n    id 'java'\n}\n\ngroup 'ru.qa'\nversion '1.0-SNAPSHOT'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    testCompile group: 'junit', name: 'junit', version: '4.12'\n}\n```\n## Подключаем библиотеку Selenium\n\n### Переходим в цетральный репозиторий Maven\nПерехом по url: [search.maven.org](http://search.maven.org)\n\n### Ищем библиотеку Selenium\nВводим в поисковую строку запрос java-selenium и выбираем библиотеку\n![Ищем библиотеку Selenium в репозитории Maven Central](/images/search_maven_central_selenium_lib.png)\n\n### Выбираем последнюю версию библиотеки и копируем строку для подключения для сборщика Gradle\n\n![Копируем строку для подключения Selenium для сборщика Gradle](/images/selenium_gradle_implementation_command.png)\n\n```groovy\ndependencies {\n    testImplementation group: 'junit', name: 'junit', version: '4.12'\n    testImplementation 'org.seleniumhq.selenium:selenium-java:4.0.0-alpha-5'\n}\n```\n\n## Указываем путь к Chrome Driver и запускаем первый тест\n\n### Скачиваем дитрибутив Chrome Driver\n\n1. Переходим по url [chromedriver.chromium.org/downloads](https://chromedriver.chromium.org/downloads)\n2. Выбираем ссылку для дистрибутива последней версии\n3. Скачиваем версию для вашей ОС\n4. Извлекаем дистрибутив из архива и помещаем его в папку нашего проекта: src/test/resources\n\n### Указываем путь к Chrome Driver и запускаем первый тест\n\nДля проверки на нужо будет создать файл с простым тестом и запустить его.\nСоздаем src/test/java/FirstTest.java\n\n```java\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport static org.openqa.selenium.support.ui.ExpectedConditions.titleIs;\n\npublic class FirstTest {\n\n    private WebDriver driver;\n    private WebDriverWait wait;\n\n    @Before\n    public void start(){\n        System.setProperty(\"webdriver.chrome.driver\",\"./src/test/resources/chromedriver\");\n        driver = new ChromeDriver();\n        wait = new WebDriverWait(driver, 10);\n    }\n\n    @Test\n    public void myFirstTest(){\n        driver.get(\"http://www.google.com/\");\n        driver.findElement(By.name(\"q\")).sendKeys(\"webdriver\");\n        driver.findElement(By.name(\"btnK\")).click();\n        wait.until(titleIs(\"webdriver - Поиск в Google\"));\n    }\n\n    @After\n    public void stop(){\n        driver.quit();\n        driver = null;\n    }\n}\n```\n\n","category":"automation","description":"Создаем новый проект для автотестов на языке Java."},{"title":"Как установить Gradle на Mac OS","path":"/kak-ustanovit-gradle-na-mac-os/","content":"\n## Скачиваем бинарный дистрибутив\n\nНеобходимо перейти на url: [gradle.org/releases/](https://gradle.org/releases/) и скачивать дистрибутив для последней версии Gradle.\n\n## Извлекаем архив\n\n```bash\ncd /Library/\nmkdir /Gradle/\nunzip gradle-6.3-bin.zip\n```\n\n## Настраиваем переменные окружения\n\n1. Открыть на редактирование файл `.profile`\n\n```bash\nnano ~/.profile\n```\n\n2. В конец добавляем строчки\n\n```bash\nexport GRADLE_HOME=/Library/Gradle/gradle-6.3\nexport PATH=$PATH:$GRADLE_HOME/bin\n```\n\n3. Нажимаем `Ctrl+X` и соглашаемся с сохранением изменений, нажав на `Y`\n4. Выполняем команду для инициализации изменений и проверяем что переменная среды выводится верно\n\n```bash\nsource ~/.profile\necho $JAVA_HOME\necho $PATH\n```\n\n4. Теперь нужно перезапустить консоль и проверить версию Java\n\n```bash\njava -version\n```\n","category":"automation","description":"Устанавливаем Gradle локально на ПК с MacOS"},{"title":"Система сборки. Ant, Maven, Gradle","path":"/sistema-sborki-ant-maven-gradle/","content":"\n## Что такое система сборки\n\nСистема сборки – это программное обеспечение, обеспечивающее автоматизацию сборки проекта. Конфигурационный файл для системы сборки описывается в текстовом виде. Как следствие, быстрее можно начать проект, за счет того, что что все типовые задачи заключаются в копировании уже готовых сниппетов. Это гораздо быстрее, более гибко, мобильно, и, главное, читаемо, чем вводить то же самое например, через UI диалоги IDE. Ну и в промышленных проектах это более удобно.\n\n\nИнструменты сборки могут делать\n- компиляцию кода - поддерживают определенный компилятор или несколько\n- запуск тестов и определение покрытия\n- статический анализ\n- сборка архивов с бинарными файлами, исходными кодами, документацией\n- построение отчетов\n- скачивание и обеспечение доступа нужных зависимостей\n\nПольза от инструмента сборки\n- Уменьшение числа рутинных ошибок\n- уменьшение времени сборки проекта\n- можно хранить историю сборок и анализировать ошибки\n- уменьшение затрат на разработку и улучшение качества\n\n## Нет автоматизации сборки\n\nИзначально, когда не было систем сборки, то было неудобно было работать с большим числом файлов, была платформозависимость, не поддерживалась условная логика. \n\n```java\n$ javac MyClass.java\n```\n\n## Shell скрипт\n\nС таким подходом можно большие проекты легко собирать можно использовать условную логику можно разделить сборку на стадии:\nclean.sh, compile.sh, test.sh\n\nНо все также такой способ остается платформозависимым и нет единого подхода к описанию сборки.\n```sh\nif test ! -e .nuget; then\n    mkdir .nuget\n    cp $cachedir/nuget.exe .nuget/nuget.exe\nfi\n```\n\n## Make (1977 год)\n\nТакая утилита появилась под Unix. Make использует специальный формат для описания билда и называется Make-file.\nТипичный Make-file содержит название стадий, зависимость стадий. Но основное содержание это такие же команды операционной системы. \nКоманды выполняются запуском make + название стадии: make install, make noopt и т.д.\n\n```sh\nnoopt:\n    $(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n    $(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nsrc/help.h:\n    @../utils/generate-command-help.rb > help.h\n\ninstall: all\n    @mkdir -p $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n```\n\nПреимущества:\n- определяет единый формат сборки\n\nНедостатки:\n- платформозависимый так как внутри также находятся команды операционной системы\n- в makefile используется табуляция и она не видна в текстовых файлах если в такой файл вставить пробел то такой файл становится неправильным и make не может с ним работать\n- нет поддержки нюансов определенного языка: задач, параметров, плагинов)\nmake работает для любого языка\n\n## Apache Ant (2000 год)\n\nПервый инструмент сборки разработанный на java и для java. Имеет конфигурационный файл формата build.xml.\n\nСодержит описание названий стадий, зависимости стадий и могут содержать java - специфичные вещи. Например, как собирать java  код (javac), classpath и т.д.\n\n```java\n<target name=\"compile\" depends=\"init\" description=\"Compile the source\">\n    <javac srcdir=\"${src.main}\" destdir=\"${build.compile}\" classpathref=\"lib.path.id\" includeantruntime=\"true\"/>\n</target>\n\n<target name=\"test-compile\" depends=\"compile\" description=\"Compile tests source\">\n    <javac srcdir=\"${src.test}\" destdir=\"${build.test-compile}\" classpathref=\"lib.path.id\" includeantruntime=\"true\">\n        <classpath>\n            <pathelement location=\"${build.compile}\"/>\n        </classpath>\n    </javac>\n</target>\n```\n\nЗапускается командой:\n```\n$ ant clean compile\n```\n\nПреимущества:\n- поддержка java-специфичных задач\n- переносима между платформами\n- это первая сисетма которая позвоила писать под нее расширения плагины\n- позволяет запускать параметризованные билды\nможно хранить в отдельной секции некоторые параметры; например, версии используемых библиотек и потом замена версии будет означать просто замену библиотеки у вас в билде\n\nНедостатки:\n- нет конвенций версионирования кода\nможно версионировать продукт, как заблагорасудится\n- нет конвенций по расположению кода\nоткрыв проект на ant'e вы можете ожидать, что код будет где угодно;\nобычно их кладут в одну и туже папку, но это не гарантируется;\n- нет автоматического управления зависимостями (их кладут в lib/)\nесли у вас используется какая-нибудь библиотека, то она будет лежать прямо в проекте в папке lib в виде jar файлов, а в большом проекте таких файлов библиотек будет много\n- произвольный набор целей(нет жизненного цикла)\nцели можно называть как угодно и приходится разбираться какая цель что делает\n- императивный стиль описания билда\nбилд состоит из последовательности действий, которые нужно выполнить чтобы собрать проект\nэто плохо\n- ant не поддерживает junit 4\n\n## Apache Ivy (2004 год)\nЭта библиотека решает проблему Ant - авоматическое управление зависимостями. Конфигурационный файл имеет формат ivy.xml. Написан на Java.\n\n```xml\n<ivy-module version=\"1.0\">\n    <info organisation=\"ru.yandex.qatools.allure\" module=\"allure-testng-ant\"/>\n    <dependencies>\n        <dependency org=\"ru.yandex.qatools.allure\" name=\"allure-testng-adaptor\" rev=\"1.4.0\"/>\n        <dependency org=\"org.aspectj\" name=\"aspectjweaver\" rev=\"1.7.4\"/>\n    </dependencies>\n</ivy-module>\n```\n\nМожно в конфигурационном файле указать название зависимости: организация, имя, версия и все библиотеки скачаются с интернета.\n\n## Apache Maven (2004 год)\nИмеет конфигурационный файл pom.xml (Project Object Model). Написан на Java.\n\nЗапускается подобно Ant'у командой:\n```\n$ mvn clean compile\n```\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.0</version>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\nПреимущества:\n- Конвенции по расположению кода, тестов, ресурсов\nмы точно знаем где и в какой директории лежат исходные коды, тесты и т.д.\n- четкий жизненый цикл: цели предопределены\nесть цель для компиляции тестирования отчетов а можно и свои цели создавать\n- имеет четкий способ чтобы поделиться кодом с другими - удаленные репозитории зависимостей\nэто сервера на который закачиваются готовые пакеты с скомпилированным кодом, с исходными кодами, документацией и другие участники разработки могут их оттуда забрать\n- понятный механизм хранения зависимостей - локальный репозиторий\nэто каталог у вас на файловой системе в который сохраняются копии скомпилированных бинарных файлов, документации и т.д. - копия удаленного репозитория\n- правила версионирования кода\nМавен вводит понятия релизов и snapshot'ов и как версии должны меняться одна от другой\n- поддерживает многомодульные проекты\nможно разбивать большой проект на небольшие кусочки/модули которые могут собираться по отдельности и распространяться, передаваться версионироваться по отдельности\n- описывает подход декларативно \nговорит не в какой последовательности мы должны выполнить шаги а то что мы хотим получить на выходе\n- модульная структура(поддержка плагинов)\nдаже простые действия делают плагины: есть плагин для компиляции, плагин для тестирования и т.д.\n\n## Gradle (2009 год)\nНаписан на Groovy. Использует в качестве файлов конфигурации файлы использующие DSL(Domain Specific Language) на Groovy. \nФайл называется build.gradle. Команда для запуска аналогична Ant, Maven:\n\n```\n$ gradle clean compile\n```\nВозможности Gradle:\n- поддерживает основные воможности Maven;\n- инкрементальная компиляция\nумеет собирать только те исходные коды которые изменились\n- использует теже удаленные репозитории как и мавен\n- эмулирует жизненный цикл мавена, но можно задавать и свои цели\n- поддерживает плагины, но они не совместимы с Maven \n","category":"automation","description":"Система сборки. Ant, Maven, Gradle"},{"title":"JUnit 5","path":"/j-unit-5/","content":"\nМожно определять тестовые методы без модификатора.\n\n```java\n@Test\nvoid someTest(){\n    assertTrue(true);\n}\n```\n\n## Build tool support\n\n```groovy\ntest {\n    useJUnitPlatform {\n        includeTags 'fast', 'smoke'\n        excludeTags 'slow', 'ci'\n\n        include 'org/foo/**'\n        exclude 'org/boo/**'\n    }\n}\n```\n\nhttps://www.youtube.com/watch?v=RAOAcq97KZM\n\nhttps://www.youtube.com/watch?v=w1ey2zjf3-s\n\nhttps://www.youtube.com/watch?v=DAszLeWMsqU\n\nhttps://www.youtube.com/watch?v=751gMXH-lEE\n\nhttps://www.youtube.com/watch?v=r-8EGXMFJaw\n\nhttps://www.youtube.com/watch?v=ZIkIUCyJBGU\n\nhttps://www.youtube.com/watch?v=3pOjh6O7-cg\n\nhttps://www.youtube.com/watch?v=W1INR0I3FCo&list=PLnh8EajVFTl5AqvBosxUefReW4nC35P0x","category":"automation","description":"JUnit 5"},{"title":"JUnit vs TestNG","path":"/j-unit-vs-test-ng/","content":"\n## Добавление метаинформации\n\n### Обозначение тестового метода \n\n- TestNG\n\n```java\n@Test\npublic void regularTest(){\n\n}\n```\n\n- JUnit\n\n> Все импорты без \\*, потому что * в импортах, это не очень хорошо. \nНапример, при review человеку сложно понять, что именно пришло из заимпорченного класса.\n\nВ аннотацию Test не добавляется ничего, там нет дополнительных опций.\n\n```java\n@Test\npublic void regularTest(){\n\n}\n```\n\n### Добавление описания к тесту\n\n- TestNG\n\n```java\n@Test(description = \"Test description\")\npublic void displayNameTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@DisplayName(\"Test description\")\npublic void displayNameTest(){\n\n}\n```\n\n### Способ игнорировать тесты\n\n- TestNG\n\n```java\n@Test(enabled = false)\npublic void ignoredTest(){\n\n}\n```\n\n- JUnit\n\nБудет выброшен exception с указанным описанием. В описание также можно указать номер задачи на исправление.\n\n```java\n@Test\n@Disabled(\"Bad test!!! AE-1\")\npublic void ignoredTest(){\n\n}\n```\n\n### Запуск тестов по группам\n\n> в группу можно добавлять номер issue и тогда можно запускать проверку по задаче\n\n- TestNG\n\n```java\n@Test(groups = {\"web\", \"critical\"})\npublic void taggedTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@Tags({@Tag(\"web\"), @Tag(\"criticla\")})\npublic void taggedTest(){\n\n}\n```\n\n### Тест будет падать, если он идет дольше указанного времени\n\n- TestNG\n\n```java\n@Test(timeOut = 2)\npublic void timeoutTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@Timeout(value = 2, unit = TimeUnit.MINUTES)\npublic void timeoutTest(){\n\n}\n```\n\n### Тест запускается несколько раз\n\n- создавать нагрузку :))\n- запуск теста с рандомными данными, при каждом запуске используются новые данные\n\n- TestNG\n\n```java\n@Test(invocationCount = 10)\npublic void repeatedTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@RepeatedTest(10)\npublic void repeatedTest(){\n\n}\n```\n\n### Custom Annotations (JUnit)\n\nМожно создать свою аннотацию для которой задать поределенные параметры и этой аннотацией обозначать нужные тесты.\n\n> Можно изначально добавить свою аннотацию и использовать ее везде, тк в случае добаления каких то опции всем тестам достаточно будет добавить их только для одной кастомной аннотации.\n\n```java\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\npublic class AnnotationsCustomTest{\n\n    @FastTest\n    public void customTagTest(){\n    }\n    \n    @Test\n    @Tag((\"fast\"))\n    @Target({ElementType.TYPE, ElementType.METHOD})\n    @Retention(RetentionPolicy.RUNTIME)\n    public @interface FastTest{\n    }\n}\n```\n\n## Параметризованные тесты \n\n- TestNG\n\n```java\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\nimport org.testng.util.Strings;\n\nimport static org.testng.Assert.assertEquals;\n\npublic class ParamsTest {\n    @DataProvider(name = \"test1\")\n    public static Object[][] primeNumbers(){\n        return new Object[][]{\n            {null, true},\n            {\"\", true},\n            {\" \", true},\n            {\"not blank\", false} \n        };\n    }\n\n    @Test(dataProvider = \"test1\")\n    public void testBlankString(String input, boolean expected){\n        essertEquals(expected, Strings.isNullOrEmpty(input));\n    }\n}\n```\n\n- JUnit\n\nАналог TestNG\n\n```java\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.junit.platform.commons.util.StringUtils;\n\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ParamsTest {\n\n    private static Stream<Arguments> blankStringParameters() {\n        return Stream.of(\n                Arguments.of(null, true),\n                Arguments.of(\"\", true),\n                Arguments.of(\" \", true),\n                Arguments.of(\"not blank\", false)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"blankStringParameters\")\n    void testBlankString(String input, boolean expected) {\n        assertEquals(expected, StringUtils.isBlank(input));\n    }\n}\n```\n\nи есть другой способ\n\n```java\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.junit.jupiter.params.provider.NullAndEmptySource;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport org.junit.platform.commons.util.StringUtils;\n\nimport java.time.Month;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ParamsTest {\n\n    @ParameterizedTest\n    @NullAndEmptySource\n    @ValueSource(strings = {\" \", \"\\t\", \"\\n\"})\n    void isBlank_ShouldReturnTrueForAllTypesOfBlankStrings(String input){\n        assertTrue(StringUtils.isBlank(input));\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = Month.class,  names = {\"APRIL\", \"JUNE\", \"JULY\"})\n    void someMonths_Are30DaysLong(Month month) {\n        final boolean isALeapYear = false;\n        assertEquals(30, month.length(isALeapYear));\n    }\n    \n    @ParameterizedTest\n    @CsvSource({\"test,TEST\", \"tEst,TEST\", \"Java,JAVA\"})\n    void toUpperCase_ShouldGenerateTheExpectedUppercaseValue(String input, String expected){\n        String actualValue = input.toUpperCase();\n        assertEquals(expected, actualValue);\n    }\n}\n```\n\n## Параметризация через класс\n\n- TestNg\n\n```java\n@Test(dataProvider = \"user\",\n    dataProviderClass = UserDataProvider.class)\npublic void register(User user){\n    assert user.getName().equals(\"Ivan\"); \n}\n```\n\nЛибо через IAnnotationTransformer;\n\n- JUnit\n\n```java\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.api.extension.ParameterResolver;\n\npublic class UserParameterResolver implements ParameterResolver {\n\n\n    @Override\n    public boolean supportsParameter(ParameterContext parameterContext, \n                                     ExtensionContext extensionContext) {\n        return parameterContext.getParameter().getType().equals(User.class);\n    }\n\n    @Override\n    public Object resolveParameter(ParameterContext parameterContext,\n                                   ExtensionContext extensionContext) {\n        return new User(\"Ivan\");\n    }\n}\n```\n\n```java\n\n@ExtendWith(UserParameterResolver.class)\nclass Parametrized{\n    \n    @Test\n    void canRegister(User user){\n        \n    }\n}\n```\n\n## Проверка exception\n\nПроверить, что тест выбрасывает Exception(негативный сценарий);\n\n- TestNG\n\n```java\n@Test(expectedEceptions = ArithmeticException.class)\npublic void divisionWithException(){\n    int i = 1/0;\n}\n```\n\n- JUnit\n\nМетод assertThrows кроме проверки также возвращает сам exception и можно далее с ним делать какие нибудь другие проверки.\n\n```java\n@Test\nvoid exceptionTest(){\n    final Object nullable = null;\n    final NullPointerException exeption =  assertThrows(\n                NullPointerException.class,\n                () -> nullable.toString(),\n                \"Expected toString() to throw, but it didn't\");\n}\n```\n\n## Before/After методы\n\n- TestNG\n\nИмеются аннотации: BeforeSuite, BeforeClass, BeforeTest, BeforeGroup, BeforeMethod, AfterClass, AfterTest, afterGroup, AfterMethod, AfterSuite.\n\n- JUnit \n\nАннотации: BeforeAll, BeforeEach, AfterEach, AfterAll.\n\n## Зависимые тесты и порядок запуска тестов\n\ndependsOnGroups - зависимость от прохождения тестов определенной группы, \ndependsOnMethod - зависимость от определенного тестового метода\n\n```java\n@Test(dependsOnGroups = \"ololo\")\npublic void firstTest(){\n\n}\n\n@Test(dependsOnMethod = \"firstTest\")\npublic void secondTest(){\n\n}\n```\n\n- JUnit\n\nЗапрещает делать зависимые тесты.\n\nМожно задавать порядок тестов:\n\n```java\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class OrderedTest {\n    \n    @Test\n    @Order(1)\n    void firstTest(){}\n    \n    @Test\n    @Order(2)\n    void secondTest(){}\n}\n```\n\nМожно указываеть зависимость от определенных параметров:\n\n```java\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\nimport org.junit.jupiter.api.condition.*;\n\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class ConditionalTest {\n\n    @Test\n    @EnabledOnOs(OS.MAC)\n    void onlyOnMacOS(){}\n\n    @Test\n    @EnabledForJreRange(min = JRE.JAVA_9)\n    void fromJava9toCurrentJavaFeatureNumber(){}\n    \n    @Test\n    @EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\")\n    void onlyOn64BitArchitectures(){}\n}\n```\n\n## Слушатели (Listeners)\n\n- TestNG\n\nМожно создать свой класс Listener который имплементит заданные интерфейсы, например, ISuiteListener\nи задавать выполнение определенной логика до, после теста и т.д. не используя специальные аннотации.\n\n- JUnit\n\nИспользуются Extensions. Все Extensions имплементируют класс Extension можно в него перейти и посмотреть все что его имплементит, чтобы найти нужный.\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\npublic class ExtensionsTest {\n\n    @Test\n    @ExtendWith(ResourceExtension.class)\n    public void extensionTest(){\n        \n    }\n    \n    public static class ResourceExtension implements BeforeEachCallback, AfterEachCallback{\n        @Override\n        public void beforeEach(ExtensionContext context) throws Exception{\n            System.out.println(\"Starting database...\");\n        }\n        \n        @Override\n        public void afterEach(ExtensionContext context) throws Exception{\n            System.out.println(\"Stopping database...\");\n        }\n    }\n}\n```\n\n## Параллельные тесты\n\n- TestNG\n\nМожно задать в xml параметр parallel = \"methods|tests|classes|instances\" и thread-count=\"5\". \n\n- JUnit \n\nМожно воспользоваться опцией Gradle. Можно распараллелить тесты по агентам. ???\n\n## Soft Assertions\n\n- TestNG\n\n```java\nprivate SoftAssert softAssert = new SoftAssert();\n\n@Test\npublic void testForSoftAssertionsFailure(){\n    softAssert.assertTrue(false);\n    softAssert.assertEquals(1, 2);\n    softAssert.assertAll();\n}\n```\n\n- JUnit\n\nИспользуется метод assertAll;\n\n```java\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SoftAssertionsTest {\n    \n    @Test\n    void testWithSoftAssert(){\n        assertAll(\n                () -> assertTrue(false),\n                () -> assertEquals(1, 2)\n        );\n    }\n}\n```\n\n## Источник информации \n\n❗ [#6 Recheck, Karate, JetBrains Academy. Сравнение TestNG и JUnit 5](https://www.youtube.com/watch?v=_sN6JpVpQ-c)\n\n❗ [TestNG vs JUnit 5 battle (Sergey Pirogov, Ukraine)](https://www.youtube.com/watch?v=vRmVZV0fjK8)","category":"automation","description":"JUnit vs TestNG"},{"title":"Selenium & Selenide","path":"/selenium-and-selenide/","content":"\n\n✅ [QA Fest: Selenide для профи - Андрей Солнцев. QA Fest 2019](https://youtu.be/be_cTwayRQc)\n\n❌ [Simple Automation: Автоматизация для QA: Selenide](https://youtu.be/xknQcm6H87M)\n\n❌ [Hillel IT School: Selenide: tips and tricks](https://youtu.be/5WxlKf_EFII)\n\n❌ [Heisenbug: Алексей Виноградов — Selenide Брандашмыг — интерактивное путешествие по дорогам библиотеки](https://youtu.be/3J6mX98TSjk)\n\n❌ [Heisenbug: Алексей Виноградов, Андрей Солнцев – Selenide Puzzlers](https://youtu.be/y-ZyxTWHH08)\n\n❌ [comaqa: Selenide 2019 - Quo vadis? Новинки и малоизвестные функции библиотеки. Алексей Виноградов](https://youtu.be/U5lpTH-FwqE)\n\n❌ [Somov Studio: Применение Cucumber & Selenide в автоматизации тестирования](https://youtu.be/s33NCtGiVFM)\n\n❌ [DEVCLUB.EU: 2017.12.29 Андрей Солнцев - Selenide Puzzlers](https://youtu.be/LQSrhmzXpHM)\n\n❌ [comaqa:Selenide (Selenium WebDriver + Java): используем listener-ы, Андрей Стахиевич](https://youtu.be/yQa47hx53Zc)\n\n## Как начать проект автоматизации с Selenide\n\nhttps://www.youtube.com/watch?v=1aq4gYflEho\n\nhttps://www.youtube.com/watch?v=pbvJ8rmh7Ws\n\nhttps://www.youtube.com/watch?v=h254Tccxgq4\n\nhttps://www.youtube.com/watch?v=WETyt87o_R4","category":"automation","description":"Selenium & Selenide"},{"title":"Selenium API","path":"/selenium-api/","content":"\n## Подключение зависимости\n\n```\n// https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java\nimplementation 'org.seleniumhq.selenium:selenium-java:4.2.2'\n```\n\n## Загрузка драйвера через WebDriverManager\n\n1. Нужно импортировать библиотеку\n\n```\nimplementation 'io.github.bonigarcia:webdrivermanager:5.2.0'\n```\n\n2. Перед запуском теста вызвать \n\n- для Chrome\n\n```\nWebDriverManager.chromedriver().setup();\n```\n\n## Открыть и закрыть браузер\n\n- Chrome\n```java\nChromeOptions options = new ChromeOptions();\ndriver = new ChromeDriver(options);\n\ndriver.quit();\n```\n\n- Microsoft Edge\n```java\nEdgeOptions options = new EdgeOptions();\ndriver = new EdgeDriver(options);\n\ndriver.quit();\n```\n\n- Firefox\n```java\nFirefoxOptions options = new FirefoxOptions();\ndriver = new FirefoxDriver(options);\n\ndriver.quit();\n```\n\n- Internet Explorer\n\nРекомендуется использовать 32-bit версию драйвера.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\ndriver = new InternetExplorerDriver(options);\n\ndriver.quit();\n```\n\nMicrosoft Edge можно использовать в режиме совместимости с IE с помощью драйвера IE.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.attachToEdgeChrome();\noptions.withEdgeExecutablePath(\"/path/to/edge/browser\");\n  \ndriver = new InternetExplorerDriver(options);\n  \ndriver.quit();\n```\n\n- Opera\n\nПоскольку драйвер Opera не поддерживает синтаксис w3c, а основан на Chromium, рекомендуется управлять браузером Opera с помощью chromedriver.\n\n```java\nChromeOptions options = new ChromeOptions();\noptions.setBinary(\"/path/to/opera/browser\");\n  \ndriver = new ChromeDriver(options);\n  \ndriver.quit();\n```\n\n- Safari\n\nЧтобы включить автоматизацию в Safari, выполните следующую команду из терминала:\n\n```\nsafaridriver --enable\n```\n\n```java\nSafariOptions options = new SafariOptions();\ndriver = new SafariDriver(options);\n  \ndriver.quit();\n```\n\n## Начало работы\n\n### Старт сессии\n```java\ndriver = new ChromeDriver();\n```\n\n### Переход на страницу\n```java\ndriver.get(\"https://google.com\");\n```\n\n### Получить заголовок страницы\n```java\nString title = driver.getTitle();\n```\n\n### Ожидания \n```java\ndriver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));\n```\n\n### Поиск элементов \n```java\nWebElement searchBox = driver.findElement(By.name(\"q\"));\nWebElement searchButton = driver.findElement(By.name(\"btnK\"));\n```\n\n### Действия на странице\n```java\nsearchBox.sendKeys(\"Selenium\");\nsearchButton.click();\n```\n\n### Запрос информации об элементе\n```java\nString value = searchBox.getAttribute(\"value\");\n```\n\n## Capabilities\n\n#### browserName\nЗадает имя браузера который нужно запустить\n#### browserVersion\nЗадает версию браузера. Можно не указывать.\n#### pageLoadStrategy\nПри переходе на новую страницу через URL, по умолчанию Selenium ждет пока страница будет загружена, выполняется проверка через js: `document.readyStatus` должен равняться `complete`. Однако для некоторых случаев, например для одностраничных сайтов, не имеет смысла ждать пока загрузится вся страница, так как элементы подгружаются динамически. В этом случае можно изменить этот параметр.\n\n> при изменении pageLoadStrategy обратите внимание, что стратегия ожидания (implicit/explicit wait) настроена, чтобы компенсировать нестабильность прогонов;\n\nМожет иметь одно из 3 значений: normal, eager, none;\n\n|Strategy|Ready State|Note|\n|---|---|---|\n|normal|complete|Используется по умолчанию; ждет пока все ресурсы страницы будут загружены|\n|eager|interactive|Доступ к DOM загрузился, но остальные ресурсы например картинки могут еще подгружаться|\n|none| Any| Не делает проверку загрузки ресурсов страницы|\n\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);\nWebDriver driver = new ChromeDriver(chromeOptions);\n```\n\n#### platformName\nЗадает имя операционной системы необходимой для запуска\n\n#### acceptInsecureCerts\nВыполняется проверка сертификата безопасности сайта(TLS Certificate);\n\nесли выбрано `false` - то при наличии на сайте просроченного или невалидного сертификата будет выбрасываться исключение;  \nесли выбрано `true` - все сертификаты даже небезопасные будут считаться валидными\n\nПосле установки опции acceptInsecureCerts будет работать для все сессии.\n\n#### timeouts\nSelenium устанавливает определенные интервалы в течение которого пользователь может взаимодействовать с сайтом;\n\n- script timeout  \nТаймаут выполнения скриптов в текущем контексте. По умолчанию 30_000\n- Page Load Timeout  \nТаймаут загрузки страницы. По умолчанию 300_000. При превышении выбрасывает TimeoutException\n- Implicit Wait Timeout  \nвремя ожидания загрузки элемента страницы. По умолчанию 0.\n\n#### unhandledPromptBehavior\nЗадает поведение когда открывается диалоговое окно системы\nМожет иметь следущие значения:\n- dismiss\n- accept\n- dismiss and notify\n- accept and notify\n- ignore\n\nПо умолчанию dismiss and notify.\n\n#### strictFileInteractability\nЭта опция указывает должна ли применяться строгая проверка видимости поля input с атрибутом type=\"file\". Так как строгая проверка по умолчанию отключена, это может влиять на работу метода element.sendKeys при работе со скрытым элементом управления.\n\n#### proxy\nПрокси-сервер - это посредник для запросов между клиентом и сервером.\nТрафик проходит через прокси-сервер на пути к запрошенному адресу и обратно.\n\n```java\nProxy proxy = new Proxy();\nproxy.setHttpProxy(\"<HOST:PORT>\");\nChromeOptions options = new ChromeOptions();\noptions.setCapability(\"proxy\", proxy);\nWebDriver driver = new ChromeDriver(options);\n```\n\n### Firefox\n \nМожно установить кастомный профиль с нужными настройками\n\n```java\nFirefoxProfile profile = new FirefoxProfile();\nFirefoxOptions options = new FirefoxOptions();\noptions.setProfile(profile);\ndriver = new RemoteWebDriver(options);\n```\n\n### Internet Explorer\n\n#### fileUploadDialogTimeout\nВ некоторых окружениях Internet Explorer может с задержкой открывать окно Загрузка Файла. IEDriver по умолчанию устанавливает timeout ожидания этого окна в 1_000мс, но с помощью опции fileUploadDialogTimeout это время можно увеличить\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.waitForUploadDialogUpTo(Duration.ofSeconds(2));\nWebDriver driver = new RemoteWebDriver(options);\n```\n#### ensureCleanSession\nЕсли установлено в true - то кеш, история браузера и файлы cookie будут очищены для всех экземпляров Internet Explorer(в том числе запущенных вручную). По умолчанию false. При использовании этой опции при запуске браузера, дайвер будет ждать очистки кеша.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.destructivelyEnsureCleanSession();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreZoomSetting\nДрайвер InternetExplorer ожидает, что уровень масштабирования браузера будет равен 100%, иначе драйвер выдаст исключение. Это поведение по умолчанию можно отключить, установив для ignoreZoomSetting значение true.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.ignoreZoomSettings();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreProtectedModeSettings\nЕсли Protected Mode не включен и настройки защищенного режима не одинаковы для всех зон, драйвером будет выдано исключение. \n\nЕсли установлено значение true, драйвер будет игнорировать эту настройку, но тесты могут работать нестабильно, переставать отвечать или браузеры могут зависать. \n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.introduceFlakinessByIgnoringSecurityDomains();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### silent\nЕсли установлено значение true, эта опция игнорирует диагностические выходные данные IEDriverServer.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.setCapability(\"silent\", true);\nWebDriver driver = new InternetExplorerDriver(options);\n```\n\n#### Command-Line Options\nInternet Explorer включает несколько параметров командной строки, которые позволяют устранять неполадки и настраивать браузер. \n\nНиже описаны несколько поддерживаемых параметров командной строки.\n- -private: используется для запуска IE в режиме приватного просмотра. Это работает для IE 8 и более поздних версий. \n- -k : запускает Internet Explorer в режиме киоска. Браузер открывается в развернутом окне, в котором нет адресной строки, кнопок навигации или строки состояния. \n- -extoff : Запускает IE в режиме без дополнений. Этот параметр специально используется для устранения неполадок с надстройками браузера. Работает в IE 7 и более поздних версиях. \n\n> ForceCreateProcessApi должен быть включен для того, чтобы аргументы командной строки работали.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        options.addCommandSwitches(\"-k\");\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n```\n\n#### forceCreateProcessApi\nПринудительно запускает Internet Explorer с помощью API CreateProcess. Значение по умолчанию false. Для IE 8 и более поздних версий этот параметр требует, чтобы для параметра реестра \"TabProcGrowth\" было установлено значение 0.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n``` \n## Работа с браузером\n\n### Получение заголовка\n```java\ndriver.getTitle();\n```\n\n### Получение текущего URL\n\n```java\ndriver.getCurrentUrl();\n```\n\n### Навигация\n\n#### Переход на страницу\n```java\n//Convenient\ndriver.get(\"https://selenium.dev\");\n\n//Longer way\ndriver.navigate().to(\"https://selenium.dev\");\n```\n\n#### Возврат назад\n```java\ndriver.navigate().back();\n```\n\n#### Переход вперед\n```java\ndriver.navigate().forward();\n```\n\n#### Обновить страницу\n```java\ndriver.navigate().refresh();\n```\n\n### JavaScript окна\n#### Ожидание всплавающего окна браузера\n```java\nAlert alert = wait.until(ExpectedConditions.alertIsPresent());\n```\n\n#### Получить текст из всплывающего окна\n```java\nString text = alert.getText();\n```\n\n#### Нажать OK кнопку\n```java\nalert.accept();\n```\n\n#### Отклонить всплывающее окно\n```java\nalert.dismiss();\n```\n\n#### Ввести текст в всплывающем окне\n```java\nalert.sendKeys(\"Selenium\");\n```\n\n### Работа с Cookie\n\n#### Добавить Cookie\nПрежде чем выставлять куки нужно перейти на страницу сайта для которого нужно применить куки. Еслистраница долго грузится можно перейти на какую нибудь легковесную, например, страница с ошибкой 404.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class addCookie {\n    public static void main(String[] args) {\n        WebDriver driver = new ChromeDriver();\n        try {\n            driver.get(\"http://www.example.com\");\n\n            // Adds the cookie into current browser context\n            driver.manage().addCookie(new Cookie(\"key\", \"value\"));\n        } finally {\n            driver.quit();\n        }\n    }\n}\n  \n```\n#### Проверка что Cookie \n#### Получить имя Cookie\n\n#### Получить все Cookie\n\n#### Удалить Cookie\n\n#### Удалить все Cookie\n\n#### Проверка что Cookie отправляются с одного сайта\nПредназначенно для предотвращения подделки межсайтовых запросов (CSRF).\n\n- При установке значения Lax подразумевается, что куки должны отправляться при серфинге по одному сайту или через GET серфинг на ваш сайт с других сайтов. \n- Значение Strict ограничивало cookie запросами, исходящими только от одного сайта.\n\n> Работает только для Chrome(версия 80+) и Firefox(версия 79+) в Selenium 4 и более поздних.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class cookieTest {\n  public static void main(String[] args) {\n    WebDriver driver = new ChromeDriver();\n    try {\n      driver.get(\"http://www.example.com\");\n      Cookie cookie = new Cookie.Builder(\"key\", \"value\").sameSite(\"Strict\").build();\n      Cookie cookie1 = new Cookie.Builder(\"key\", \"value\").sameSite(\"Lax\").build();\n      driver.manage().addCookie(cookie);\n      driver.manage().addCookie(cookie1);\n      System.out.println(cookie.getSameSite());\n      System.out.println(cookie1.getSameSite());\n    } finally {\n      driver.quit();\n    }\n  }\n}\n```\n\n### Работа с iFrame\n\nФреймы — это устаревшее средство создания макета сайта из нескольких документов в одном домене. Вы вряд ли будете работать с ними, если вы не работаете с веб-приложением до HTML5. \n\nФреймы iframe позволяют вставлять документ из совершенно другого домена и до сих пор широко используются. \n\n#### Переключение на фрейм через WebElement\n```java\nWebElement iframe = driver.findElement(By.cssSelector(\"#modal>iframe\"));\n//Switch to the frame\ndriver.switchTo().frame(iframe);\n```\n#### Переключение на фрейм через имя или id\n```java\n//Using the ID\ndriver.switchTo().frame(\"buttonframe\");\n\n//Or using the name instead\ndriver.switchTo().frame(\"myframe\");\n```\n\n#### Переключение на фрейм через index\n```java\n// Switches to the second frame\ndriver.switchTo().frame(1);\n```\n\n#### Возврат на основную страницу\n```java\n// Return to the top level\ndriver.switchTo().defaultContent();\n```\n\n### Работа с окнами и вкладками\n\n#### Получить обработчик текущего окна\n```java\ndriver.getWindowHandle();\n```\n\n#### Переключиться на новое окно или вкладку\n```java\nString originalWindow = driver.getWindowHandle();\n\n//Check we don't have other windows open already\nassert driver.getWindowHandles().size() == 1;\n\n//Click the link which opens in a new window\ndriver.findElement(By.linkText(\"new window\")).click();\n\n//Wait for the new window or tab\nwait.until(numberOfWindowsToBe(2));\n\n//Loop through until we find a new window handle\nfor (String windowHandle : driver.getWindowHandles()) {\n    if(!originalWindow.contentEquals(windowHandle)) {\n        driver.switchTo().window(windowHandle);\n        break;\n    }\n}\n\n//Wait for the new tab to finish loading content\nwait.until(titleIs(\"Selenium documentation\"));\n```\n\n#### Создать(открыть) новое окно или вкладку и переключиться на нее(Selenium 4)\n```java\n// Opens a new tab and switches to new tab\ndriver.switchTo().newWindow(WindowType.TAB);\n\n// Opens a new window and switches to new window\ndriver.switchTo().newWindow(WindowType.WINDOW);\n```\n\n#### Закрыть окно или вкладку\n```java\n//Close the tab or window\ndriver.close();\n\n//Switch back to the old tab or window\ndriver.switchTo().window(originalWindow);\n```\n\n#### Закрыть браузер и закончить сессию\n```java\ndriver.quit();\n```\n\n#### Управление окном\n\n##### Получить размер окна\nВыдает размер в пикселях\n\n```java\n//Access each dimension individually\nint width = driver.manage().window().getSize().getWidth();\nint height = driver.manage().window().getSize().getHeight();\n\n//Or store the dimensions and query them later\nDimension size = driver.manage().window().getSize();\nint width1 = size.getWidth();\nint height1 = size.getHeight();\n```\n\n##### Установить размер окна\n```java\ndriver.manage().window().setSize(new Dimension(1024, 768));\n```\n\n##### Получить положение окна\n```java\n// Access each dimension individually\nint x = driver.manage().window().getPosition().getX();\nint y = driver.manage().window().getPosition().getY();\n\n// Or store the dimensions and query them later\nPoint position = driver.manage().window().getPosition();\nint x1 = position.getX();\nint y1 = position.getY();\n```\n\n#### Переместить окно\n```java\n// Move the window to the top left of the primary monitor\ndriver.manage().window().setPosition(new Point(0, 0));\n```\n\n##### Увеличить окно на максимум\n```java\ndriver.manage().window().maximize();\n```\n\n##### Свернуть окно(Selenium 4)\n```java\ndriver.manage().window().minimize();\n```\n\n##### Развернуть окно на полный экран\n```java\ndriver.manage().window().fullscreen();\n```\n\n##### Сделать скриншот\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.*;\nimport org.openqa.selenium.*;\n\npublic class SeleniumTakeScreenshot {\n    public static void main(String args[]) throws IOException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(\"http://www.example.com\");\n        File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);\n        FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n        driver.quit();\n    }\n}\n```\n\n##### Сделать скриншот элемента\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class SeleniumelementTakeScreenshot {\n  public static void main(String args[]) throws IOException {\n    WebDriver driver = new ChromeDriver();\n    driver.get(\"https://www.example.com\");\n    WebElement element = driver.findElement(By.cssSelector(\"h1\"));\n    File scrFile = element.getScreenshotAs(OutputType.FILE);\n    FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n    driver.quit();\n  }\n}\n```\n\n##### Выполнить скрипт\n```java\n    //Creating the JavascriptExecutor interface object by Type casting\n      JavascriptExecutor js = (JavascriptExecutor)driver;\n    //Button Element\n      WebElement button =driver.findElement(By.name(\"btnLogin\"));\n    //Executing JavaScript to click on element\n      js.executeScript(\"arguments[0].click();\", button);\n    //Get return value from script\n      String text = (String) js.executeScript(\"return arguments[0].innerText\", button);\n    //Executing JavaScript directly\n      js.executeScript(\"console.log('hello world')\");\n```\n\n##### Напечатать страницу\n> Необходимо чтобы Chromium браузер был в режиме headless\n```java\n    import org.openqa.selenium.print.PrintOptions;\n\n    driver.get(\"https://www.selenium.dev\");\n    printer = (PrintsPage) driver;\n\n    PrintOptions printOptions = new PrintOptions();\n    printOptions.setPageRanges(\"1-2\");\n\n    Pdf pdf = printer.print(printOptions);\n    String content = pdf.getContent();\n```\n\n## Элементы\n\n### Локаторы\n\n#### Относительные локаторы (Selenium 4)\n\n##### Above\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).above(By.id(\"password\"));\n```\n\n##### Below\n```java\nBy passwordLocator = RelativeLocator.with(By.tagName(\"input\")).below(By.id(\"email\"));\n```\n\n##### Left of\n```java\nBy cancelLocator = RelativeLocator.with(By.tagName(\"button\")).toLeftOf(By.id(\"submit\"));\n```\n\n##### Right of\n```java\nBy submitLocator = RelativeLocator.with(By.tagName(\"button\")).toRightOf(By.id(\"cancel\"));\n```\n\n##### Near\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).near(By.id(\"lbl-email\"));\n```\n\n### Поиск элементов\n```java\nWebElement vegetable = driver.findElement(By.className(\"tomatoes\"));\n```\n\n#### Поиск дочернего элемента \n```java\n// не оптимальный способ\nWebElement fruits = driver.findElement(By.id(\"fruits\"));\nWebElement fruit = fruits.findElement(By.id(\"tomatoes\"));\n\n// так лучше\nWebElement fruit = driver.findElement(By.cssSelector(\"#fruits .tomatoes\"));\n```\n\n#### Поиск нескольких элементов\n```java\nList<WebElement> plants = driver.findElements(By.tagName(\"li\"));\n```\n\n#### Получить активный элемент\nАктивный элемент - на котором фокус.\n```java\ndriver.switchTo().activeElement()\n```\n\n### Взаимодействие с элеентами\n\n#### Клик - Click\n```java\ndriver.findElement(By.name(\"button\")).click();\n```\n\n#### Ввод символов - Send Keys\n```java\ndriver.findElement(By.name(\"q\")).sendKeys(\"q\" + Keys.ENTER);\n```\n\n#### Очистить поле - Clear\n```java\nWebElement searchInput = driver.findElement(By.name(\"q\"));\nsearchInput.sendKeys(\"selenium\");\n// Clears the entered text\nsearchInput.clear();\n```\n\n### Информация об элементе\n\n#### Видимость\n```java\nboolean isButtonVisible = driver.findElement(By.css(\"[name='login']\")).isDisplayed();\n```\n\n#### Доступность\n```java\nboolean value = driver.findElement(By.name(\"btnK\")).isEnabled();\n```\n\n#### Выбран ли\n```java\nboolean value = driver.findElement(By.cssSelector(\"input[type='checkbox']:first-of-type\")).isSelected();\n```\n\n#### Имя тега\n```java\nString value = driver.findElement(By.cssSelector(\"h1\")).getTagName();\n```\n\n#### Размер и положение\n```java\nRectangle res =  driver.findElement(By.cssSelector(\"h1\")).getRect();\n\n// Rectangle class provides getX,getY, getWidth, getHeight methods\nSystem.out.println(res.getX());\n```\n\n#### Получить CSS свойство\n```java\nString cssValue = driver.findElement(By.linkText(\"More information...\")).getCssValue(\"color\");\n```\n\n#### Получить текст элемента\n```java\nString text = driver.findElement(By.cssSelector(\"h1\")).getText();\n```\n\n### Работа с выпадающим списком\n\n#### Определить элемент выпадающего списка \n```java\nimport org.openqa.selenium.support.ui.Select;\n\nWebElement selectElement = driver.findElement(By.id(\"selectElementID\"));\nSelect selectObject = new Select(selectElement);\n```\n\n#### Выбрать опцию\n- по индексу\n```java\n// Select an <option> based upon the <select> element's internal index\nselectObject.selectByIndex(1);\n```\n\n- по значению\n```java\n// Select an <option> based upon its value attribute\nselectObject.selectByValue(\"value1\");\n```\n  \n- по видимому тексту\n```java\n// Select an <option> based upon its text\nselectObject.selectByVisibleText(\"Bread\");\n```\n\n#### Получить все выбранные опции\n```java\n// Return a List<WebElement> of options that have been selected\nList<WebElement> allSelectedOptions = selectObject.getAllSelectedOptions();\n```\n#### Получить первую выбранную опцию\n```java\n\n// Return a WebElement referencing the first selection option found by walking down the DOM\nWebElement firstSelectedOption = selectObject.getFirstSelectedOption();\n```\n\n#### Получить все опции\n```java\n// Return a List<WebElement> of options that the <select> element contains\nList<WebElement> allAvailableOptions = selectObject.getOptions();\n```\n\n#### Отменить выбор \n- по индексу\n```java\n// Deselect an <option> based upon the <select> element's internal index\nselectObject.deselectByIndex(1);\n```\n\n- по значению\n```java\n// Deselect an <option> based upon its value attribute\nselectObject.deselectByValue(\"value1\");\n```\n\n- по видимому тексту\n```java\n// Deselect an <option> based upon its text\nselectObject.deselectByVisibleText(\"Bread\");\n```\n\n- отменить все\n```java\n// Deselect all selected <option> elements\nselectObject.deselectAll();\n```\n\n#### Поддерживает ли список множественный выбор\n```java\nBoolean doesThisAllowMultipleSelections = selectObject.isMultiple();\n```\n\n## Удаленный браузер\n\n```java\nFirefoxOptions firefoxOptions = new FirefoxOptions();\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), firefoxOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Добавление опций\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setCapability(\"browserVersion\", \"67\");\nchromeOptions.setCapability(\"platformName\", \"Windows XP\");\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), chromeOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Local file detector\nПозволяет загружать файл с клиентской машины на удаленную.\nНужно для загрузки файлов на сайт.\n\n```java\ndriver.setFileDetector(new LocalFileDetector());\n\ndriver.get(\"http://sso.dev.saucelabs.com/test/guinea-file-upload\");\nWebElement upload = driver.findElement(By.id(\"myfile\"));\nupload.sendKeys(\"/Users/sso/the/local/path/to/darkbulb.jpg\");\n  \n```\n\n### ","category":"automation","description":"Selenium API"},{"title":"Ресурсы. Selenium 4","path":"/resursy-selenium-4/","content":"\n## EN version\n\nhttps://www.youtube.com/watch?v=3SaCFLiKoTs\n\nhttps://www.youtube.com/watch?v=2VKeDFmQFVQ\n\n\n## RU version\n\nhttps://www.youtube.com/watch?v=d7aq0aXYEss&t\n\nhttps://www.youtube.com/watch?v=7_Q8x37fPLw","category":"automation","description":"Ресурсы. Selenium 4"},{"title":"Что такое Selenium?","path":"/chto-takoe-selenium/","content":"\n## Что такое Selenium?\n**Selenium** - это инструмент для автоматизированного управления браузерами _или_ драйвер для браузера, специальное ПО которое предназначено для управления браузерами и позволяет другим программам взаимодействовать с браузером.\n\nSelenium специальных средств для тестирования не имеет, он позволяет только управлять браузером.\n\n## Что умеет Selenium\nОбычно драйвер предоставляет некоторый набор команд, который соответствует некоторым функциям устройства, в нашем случае функциям браузера.\n\nДрайвер может:\n- запускать браузер \n- открывать URL адреса\n- находить ссылки или другие элементы\n- выполнять действия над элементами\n- остановить браузер\n\n## Реализации Selenium\nДля разных браузеров существуют разные драйверы, но они предоставляют одинаковый набор команд.\nТак же существуют разные реализации интерфейсов для разных языков программирования.\n\nВ рамках проекта Selenium разрабатываются интерфейсы для 5 языков:\n- Java\n- Python\n- Ruby\n- JavaScript\n- C#\n\n## Принцип работы\n\nКаждое веб приложение условно можно разделить на 2 части: \n- веб сервер, на котором реализуется логика и находится БД \n- браузер, который предоставляет графический пользовательский интерфейс к этому приложению. \n\nБраузер и веб сервер взаимодействуют по протоколу HTTP. Браузер отправляет запрос, сервер его обрабатывает и отправляет обратно ответ.\nЭтот ответ содержит информацию, которую браузер использует для визуализации. \n\nДля того, чтобы тестировать серверную часть, браузер не нужен, его можно заменить http клиентом(библиотека которая умеет отправлять запросы по протоколу http и получать ответы), такие клиенты сузествуют для разных языков они не имеют пользовательского интерфейс, только программный(API). \n\nОднако такой способ игнорирует всё, что происходит в браузере (в браузере может быть реализована часть логики плюс сам интерфес становится более динамичным и его тоже нужно тестировать).\n\nSelenium предоставляет клиентскую библиотеку для разных языков программирования, через которую можно связаться с самим Selenium интерфейсом, который уже взаимодействует с браузером.\n\nБольшинство браузеров сейчас  предоставляют интерфейс для управления или отладки, которым можно воспользоваться для внедрения JavaScript кода и выполнения этого кода в браузере.\n\nИзначально браузеры не предоставляли такие интерфейсы, кроме IExplorer и в нем работа была реализована изначально таким способом. Но потом появилась возможность взаимодействовать через интерфейсы и с другими браузерами.\n\n### Интерфесы которые предоставляют браузеры\nРазные браузеры предоставляют разные интерфейсы:\n- Chrome - Remote Debug\n- Firefox - Marionette\n- IE - COM API\n\n### Selenium интерфейсы для разных браузеров\nSelenium предоставляет единый интерфейс, а сам взаимодействует с браузерами по их интерфейсу:\n- Chrome - chromedriver\n- Firefox - geckodriver\n- IE - IEDriverServer","category":"automation","description":"Что такое Selenium?"},{"title":"Gradle","path":"/gradle/","content":"\nGradle - это инструмент для автоматической сборки приложений. Он отвечает за структуру, зависимости, плагины вашего проекта, чтобы управлять этапами сборки проекта: компиляция, запуск тестов, публикация. \n\nGradle написан на Java и запускается на JVM, поэтому нужно чтобы был установлен JDK. При этом Gradle не заточен только под java приложения и может собирать любые другие. \n\nДля реализации и описания процесса сборки в Gradle реализовано 2 DSL языка на Groovy и на Kotlin.\nОба этих языка предоставляют примерно одинаковый API для работы со сборкой и имеют 2 интерфейса, которые эту сборку описывают.\n\n`project` - описывает как и из чего собрать проект;  \n`settings.gradle` - описывает дополнительные метаданные и список дочерних проектов, если это мультимодульный проект;\n\n## `project`\n\n### task\nПредставляет собой набор задач, который вам нужно выполнить для сборки приложения; эти задачи можно писать самим или добавлять через плагины.\n\n### plugin\nБольшинство функционала gradle реализуется с помощью плагинов, поэтому сам gradle изначально достаточно легкий и не содержит лишнего мусора.\n\nПлагин - это реализация методов интерфейса проекта(project), которые могут реализовывать работу с зависимостями, добавлять нужные таски и почти полностью менять, то как работает процесс сборки.\n\n### dependencies\nМожно указать необходимые зависимости для работы вашего приложения. Gradle реализует только логику управления зависимостями а сам репозиторий можно выбрать, настроив это в build скрипте. Это может быть например maven или ivy репозиторий.\n\nТип Task в Gradle это по сути класс. Он состоит из действий(actions), которые выполняет класс, входных данных(inputs), над которыми мы производим действия и выходных данных(outputs). \n\nКаждая из этих состовляющих кастомизируема и необязательна. Например, существуют LifeCycle таски, которые сами ничего не делают, но объединяют несколько других тасок.\n\nЗа счет такого разделения Gradle реализует **_инкрементальную_** сборку: перед выполнением таски Gradle проверяет есть ли изменения входных данных и повлияют ли эти изменеия на выходные данные. Если нет, то Gradle просто пропустит таск с надписью **UP TO DATE**, таким образом оптимизируется процесс сборки, чтобы каждый раз не собирать неизменяемые модули, а собирать только то, что изменилось, но эту логику также можно отключить.\n\nЧтобы обеспечить нужный порядок выполнения тасок и что каждая таска выполнится только один раз, в процессе билдинга Gradle строит из тасок так называемый ориентированный ациклический граф(**DAG, Directed Acyclic Graph**). \n\nГраф - это набор объектов(в нашем случае тасок), обладающих парными связями (каждая таска связана с одной или несколькими(двумя) другими тасками). \n\nТаски - вершины, связи между ними - ребра. \n\nТо что граф ориентированный или по другому орграф значит, что у ребер есть направление (порядок исполнения тасок), то что он ациклический означает, что в нем нет направленных циклов, нельзя из одной точки прийти в нее же, но это не мешает из разных точек прийти в одну. Такие графы много где использются, например для представления искусственных нейронных сетей без обратной связи. \n\n**Граф для сборки Java приложения**\n\n```mermaid\ngraph TD;\n      build-->check;\n      build-->assemble;\n      check-->test;\n      assemble-->jar;\n      jar-->classes;\n      classes-->compileJava;\n      classes-->processResources;\n```\n\n## Сборка Java приложения\nПроцесс сборки делится на 3 тапа: инициализация (initialization), конфигурация (configuration) и исполнение (execution). \n\n### Инициализация\nВ процессе инициализации Gradle ищет `settings.gradle` файл, из которого определяет это одиночный или мультимодульный проект. После этого он создает instance одного или нескольких проектов. \n\n```mermaid\ngraph TD;\n      Initialization-->settings.gradle-->project;\n```\n\n### Конфигурация\nДалее в процессе конфигурации, gradle для каждого проекта ищет build.gradle скрипт и выполняет все указанные там конфигурационные действия в контексте текущего проекта: подключает плагины, скачивает зависимости, выполняет код находящийся в конфигурационном блоке, создавая объекты сборки - строит граф из тасок.\n\n```mermaid\ngraph TD;\n      Configuration-->build.gradle-->build_objects;\n```\n\n\nВо время фазы конфигурации gradle исполняет конфигурационные скрипты всех проектов если это мультимодульный проект, даже если вы собираете только один из модулей. Так что если логика не относится ко всему мультимодульному проекту, лучше ее помещать в конкретные таски. \n\n### Исполнение\n\nПо сути в процессе конфигурации он строит тот самый граф из тасок и в процессе выполнения, исполняет те таски, которые мы указали.\n\n```mermaid\ngraph TD;\n      Execution-->execute_tasks;\n```\n\nИннициализация Gradle проекта выполняется командой gradle init.\n\n```\n$ gradle init\n```\n\nДалее нужно ответить на несколько вопросов и дождаться окончания инициализации.\nПосле этого в проекте будут созданы файлы: \n- gradlew(исполняющий файл для Linux подобных систем), gradlew.bat(исполняющий файл для Windows);\n- папка gradle, в которой папка wrapper;  \nКак раз этот wrapper и запускает скрипты. Gradle использует wrapper, чтобы можно было однозначно понять версию Gradle, которая будет использоваться для сборки.  \nWrapper сам скачает эту версию Graddle, если на машине он не установлен. Поменять версию и откуда его скачивать можно в файле gradle/gradle-wrapper.properties\n- build.gradle, settings.gradle\n\nВ **settings.gradle** указано только имя проекта, для мультимодульных проектов также здесь указывается список модулей. \n\nВ **build.gradle** имеются следущие секции:\n\n- секция plugins  \nЗдесь размещается обычно плагин id: 'java', который используется для сборки java проектов;  \nЕще существует плагин java-library, он используется если вы хотите поставлять ваше приложение как библиотеку.\n\n```groovy\nplugins {\n    id 'java'\n}\n```\n\n- секция repositories  \nЗдесь можно задать url репозитория из которого будут скачиваться зависимости. \n```groovy\nrepositories {\n    maven{\n        url = uri('https://repo.maven.apache.org/maven2/')\n    }\n}\n```\n\nДля стандартного Maven репозитория есть алиас mavenCentral().\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n```\n\nТакже в build.gradle, как и в Maven содержатся group, version, description, java.sourceCompatibility, но в отличие от Maven их указывать не обязательно Gradle сможет сам сгенерировать эти данные.\nПосле компиляции нам доступны таски. В блоке verification есть таска test, которая будет запускать наши тесты. \n\n- секция dependencies  \n\nЕсть несколько типов зависимостей:\n- implementation - зависимость доступна и в main и в test директориях\n- testImplementation - зависимость доступна только в test директории\n- testAnnitationProcessor - зависимость, которая генерирует код в рантайме на основе аннотаций, требуется например для lombok\n- compileOnly - deprecated метод, вместо него нужно использовать implementation или testImplementation\n\nПосле названия метода указывается адрес зависимости, координаты адреса разделяются двоеточием - group:name:version.\n\n```groovy\ndependencies {\n    implementation 'com.codeborne:selenide:6.6.3'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'\n    testImplementation 'org.projectlombok:lombok:1.18.24'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.24'\n}\n```\n\nЧтобы после билда запустились тесты, нужно указать каким движком нужно запустить тесты.\n\n```groovy\ntest {\n    useJUnitPlatform() //для запуска тестов с помощью JUnit5\n}\n```\n\nКогда зависимость требует какой то сложной конфигурацией она зачастую реализуется плагином. Тогда достаточно подключить плагин и не нужно добавлять несколько зависимостей.\n\nВместо testAnnotationProcessor которую мы прописывали для lombok можно добавить плагин.\n\n```groovy\nplugins {\n    id 'io.freefair.lombok' version'5.3.0'\n}\n```\n\n## Custom task\n\nДля добавления своей таски используется коллекция tasks и новые таски в нее добавляются с помощью методы register. В метод register нужно передать название таски(по этому названию мы в последствии сможем обращаться к этой таске)\nвторой параметр опционален, в него можно передать тип таски можно использовать стандартный тип Test который был добавлен Java плагином. \n\n### Таска для запуска тестов из определенной директории\nОтфильтровать тесты которые будут запускаться можно с помощью блока filter в нем есть метод includeTestsMatching.\nНа вход этому методу можно передать wildcard - часть пути до наших тестов со звездочкой. Путь - это имя модуля, пакета, класса в котором тесты находятся.\n\n```\nsrc\n├── main\n    ├── java\n        ├── simple\n            ├── automation\n├── test\n    ├── java\n        ├── rest\n        ├── utils\n        ├── web\n            ├── findby\n            ├── simple\n```\n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n```\n\n### Указываем платформу для запуска тестов из Custom Tasks \n\nЧтобы не прописывать в каждой таске, что она должна запускаться с помощью Junit можно выполнить одну настройку для всех тасок с типом test. \nДля этого на контейнере tasks используем метод withType, который выберет все таски с типом Test, и внутри конфигурационного блока используем useJUnitPlatform().\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n}\n```\n\n### Зауск тестов из Custom Task\nВыполняем запуск тестов webtests командой:\n\n```\n$ ./gradlew webtests\n```\n\n### Добавляем еще одну custom таску\nАналогично можно настроить запуск для rest тестов:\n\n```groovy\ntasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n```\n\n### Добавляем зависимость одной таски от другой\nБывает что rest тесты могут использоваться при выполнении web тестов и зачастую бывает удобно прогонять web тесты только если прошли rest тесты.\nДля этого в Gradle есть метод dependsOn с аргументом в виде названия таска, от которой зависит текущая таска. \n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n    dependsOn 'resttests'\n}\n```\n\nСоответсвенно, при запуске web тестов будут также запущены rest тесты и они выполнятся только если rest тесты пройдут. \n\n### Запуск независимых тасок в одном скоупе\nНо если у нас rest и web тесты работают независимо как разные модули или части системы, мы можем создать еще один таск regress, который будет запускать и те и другие тесты. Используем тот же метод dependsOn но уаазываем и web и rest тесты.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n}\n```\n\nНо в таком виде запуска мы не знаем в каком порядке запустятся эти таски. \n\n### Настраиваем порядок запуска тасок\nЕсли мы хотим определить порядок, например, чтобы web тесты запускались после rest тестов, мы можем использовать метод mustRunAfter или shouldRunAfter(является менее строгим и не запускает тесты если из-за зависимости образуется петля).\nЧтобы найти ранее созданный таск используем метод getByName и из него запускаем mustRunAfter с аргументом ввиде названия таски после которой нужно запускать.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n    \n    tasks.getByName('webtests').mustRunAfter('resttests')\n}\n```\n\nЛибо при создании таска можно сохранить ее в переменную и тогда можно использовать эти переменные для вызова mustRunAfter.\n```groovy\ndef webtests = tasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n\ndef resttests = tasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n\n    webtests.mustRunAfter(resttests)\n}\n```\n\n### Запуск тестов из директории main\nЕсли по какой то причине тесты оказались не в папке test, а в папке main, то по умолчанию Gradle найти там тесты не может. Поэтому для того чтобы указать нестандартное место исходников можно использовать блок sourceSets.\n\n1. Добавляем новый sourceSet\n\nДля создания нового сета, просто пишем имя сета и скобку, внутри добавляем блок java чтобы указать свойства которые были добавлены java плагином, compileClasspath и runtimeClasspath, добавляем через += чтобы не затирать текущие значения. \nДобавляем туда путь к папке main(если тесты лежат в папке main) - main.output. Чтобы указать где взять исходники используем свойство srcDir. \n\n```groovy\nsourceSets {\n    maintests {\n        java {\n            compileClasspath += main.output\n            runtimeClasspath += main.output\n        }\n        srcDir = file(\"src/main/java/simple/automation\")\n    }\n}\n```\n\n2. Настраиваем зависимости для добавленного sourceSet\n\nТакже нам нужны зависимости из блока dependencies, по умолчанию они в блок sourceSet не попадают.\nДля этого используется блок configurations, в нем указываем имя нашего sourceSet и без пробела пишем Implementation или RuntimeOnly. \nДалее с помощью метода extendsFrom можем указать, что зависимости нужно брать стандартные из testImplementation и testRuntimeOnly.\n\n\n```groovy\nconfigurations{\n    maintestsImplementation.extendsFrom(testImplementation)\n    maintestsRuntimeOnly.extendsFrom(testRuntimeOnly)\n}\n```\n\n3. Добавляем таск для запуска тестов, используя sourceSet\n\nСоздаем таск для запуска псевдотестов и указываем, что нужно использовать наш кастомный sourceSet.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n}\n```\n\n4. Добавляем фильтрацию по тегам JUnit\n\nТеперь нужно отфильтровать псевдотесты чтобы запускались только они. Сделать как в предыдущих тасках мы не можем потому что по имени package simple.automation будут запущены также и web тесты.\nНо можно использовать фильтрацию по тегам Junit. Для этого вызываем метод useJUnitPlatform, но к нему добавляем конфигурационный блок includeTags и тег методов или классов которые хотите запустить.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n\n    useJUnitPlatform{\n        includeTags \"pseudo\"\n    }\n}\n```\n\n### Запуск тестов с логированием\nЧтобы добавить уровень логирования INFO при запуске gradlew нужно добавить ключ -i.\nТаком образом мы увидим сообщения которые выводятся в консоль из тестов.\n\n```\n$ ./gradlew -i pseudotests\n```\n\n### Отключаем инкрементальный билд при запуске\nНо сразу мы можем их не увидеть из-за инкрементального билда.\nТак как между запусками исходники тестов не поменялись Gradle просто не запустит их.\nЧтобы они запустились перед таской с тестами запустим также таску clean. Это актуально для запуска тестов из контекста main.\nЕсли запускаются тесты из директории test то нужно использовать таску cleanTest.\n\n```\n$ ./gradlew -i clean pseudotests\n```\n\n### Отключаем инкрементальный билд глобально при настройке таски\nЧтобы каждый раз не вызывать clean таску можно установить значение upToDateWhen в знасение false для всех тасок с типом Test.\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n    outputs.upToDateWhen {false}\n}\n```\n\nЕсли запускаетя несколько независимых тасок с тестами, то Gradle по умолчанию останавливает выполнение на первом упавшем тесте. \nМожно настроить чтобы он все равно переходил к следущей задаче даже если упала предыдущая.\nДля этого можно при запуске добавить ключ --continue\n\n```\n$ ./gradlew --continue resttests webtests\n```\n\n### Отключаем стандартную таску test при билде\n\nДля этого нужно в блоке test присвоить свойству enabled значение false\n\n```groovy\ntest {\n    enabled = false\n}\n``` \n\n### Порядок выполнения build скрипта \n\n### Как добавить кастомные экшены к таскам\n\nСоздаем еще одну таску, но не указываем тип. В этом случае у таски будет тип DefaultTask и к ней не будет привязано никаких экшенов.\nВыводить текст в консоль можно стандартной командой println, но для реального логирования лучше использовать нормальные логгеры.\nДобавим вывод текста в блок конфигурирования таски, а также перед таской и после нее.\nЧтобы добавить кастомные экшены в таску можно использовать блок doFirst - это действие которое будет выполнено перед стандартными экшенами.\nВ нашем случае таких экшенов нет а для тасок с типом Test таким стандартным экшеном был запуск тестов.\nЕще мы можем использовать блок doLast - запускает кастомные экшены после стандартных. И doFirst и doLast можно использовать несколько раз, тогда они будут исполняться в указанном порядке. \n\nПосле запуска по тексту в консоли мы видим порядок выполнения.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\").configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\nРезультат выполнения:\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 637ms\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nСначала вполняется код конфигурации, затем код конфигурации самой таски (код внутри таски вне блоков doFirst и doLast), \nа уже дальше выполняются экшены сначала doFirst, потом doLast в порядке в котором они указаны в скрипте.\n\n> Стоит иметь ввиду если бы у нас был многомодульный проект, то сначала вполнился бы код конфигурации из всех build скриптов всех модулей.\n\nТип таски это прсто класс. Можно создать свой тип. \nДля этого используется метод с аннотацией @TaskAction, при этом класс должен наследоваться от DefaultTask.\n\n```groovy\nclass CustomTask extends DefaultTask{\n    @TaskAction\n    def customAction(){\n        println \"from custom action\"\n    }\n}\n```\n\nТеперь можно указать наш кастомный тип при регистрации таски. И теперь между doFirst и doLast экшенами выполнился наш кастомный экшен.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom custom action\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nТаск может состоять из input, actions, output. Добавим input в наш тип. Это можно сделать с помощью переменной с аннотацией @Input.\nПрисвоим ей дефолтное значение и будем использовать в нашем экшене. Теперь стандартный экшен использует значение из input'а \nи мы можем этот input переопределить в конфигурации самой таски. \n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    input = \"overrided\"\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n\n\nclass CustomTask extends DefaultTask{\n    @Input\n    String input = \"default\"\n\n    @TaskAction\n    def customAction(){\n        println \"from custom action with $input\"\n    }\n}\n```\n\nПосле прогона тестов в build/test-results складывается xml отчет JUnit о прогоне тестов, а в папку reports сгенерированный из него html отчет.\nТакже есть тип таски zip позволяет что-нибудь заархивировать.\n\nИмя итогового архива задается через переменную archiveFileName, с помощью distinationDirectory указываем куда будет сложен этот архив и через\nметод from указываем какую именно папку заархивировать. Чтобы указать несколько папок используйте несколько строчек from. \n\nТаска чтобы заархивировать отчет:\n\n```groovy\ntasks.register(\"zipReport\", Zip).configure{\n    archiveFileName = 'report.zip'\n    distinationDirectory = file(\"$buildDir/reports\")\n    from \"$buildDir/reports/tests\"\n}\n```\n\nТакже потом его нужно куда нибудь скопировать. Для этого есть тип таски Copy. В ней указываем через from откуда взять файл(также можно указать несколько from),\nа в into указываем куда скопировать. \n\n```groovy\ntasks.register('copyReport', Copy).configure{\n    from file(\"$buildDir/reports/report.zip\")\n    into file(\"out\")\n}\n```\n\nЕще одна полезная таска это jar - позволяет заархивировать приложение в jar файл. \nУ него в блоке manifest в свойстве attributes можно задать атрибут Main-Class который указыывает класс в котром находится исполняемый метод main \nа в блоке from откуда взять скомпилированные классы \n\nJar собирается в папку build/libs и его можно запустить через команду java -jar \n\n```groovy\njar {\n    manifest {\n        attributes \"Main-Class\": \"simple.automation.Main\"\n    }\n    from {\n        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n}\n```\n\n## Источник информации \nhttps://www.youtube.com/watch?v=qYIz6URLxbU\n\n## TODO\n\nhttps://www.youtube.com/watch?v=WOBok2u-SL8\n\nhttps://www.youtube.com/watch?v=NZJTYPLb0iE","category":"automation","description":"Gradle"},{"title":"JUnit 5","path":"/j-unit-5/","content":"\nЗачастую для тестов нужно сделать какие то действия: до тестов, после тестов или перед каждым тестом.\nДля этих целей используются такие тест ранеры как JUnit или TestNG.\n\nJUnit5 разделен на 3 глобальных модулей: Platform, Jupiter, Vintage.\n\nPlatform - база которая позволяет строить свои собственные фреймворки для запуска тестов. На основе этого модуля сделали интеграцию с Intellij Idea, maven, gradle и сам Junit5. Сюда же входит лаунчер который позволяет запускать тесты из консоли. \n\nJupiter - прораммный код самого Junit5. Также этот модуль содержит новую концепцию extensions(расширений), которая заменила ранеры и правила из JUnit4. \n\nVintage - модуль для обратной совместимости. Позволяет запускать тесты написанных на JUnit3 и JUnit4. \n\n## Подключение зависимостей\n\nДля подключения JUnit5 добавляем в зависимости модуль Platform(junit-platform-launcher) и движок Jupiter(junit-jupiter-engine)\n\n### Maven\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher -->\n<dependency>\n    <groupId>org.junit.platform</groupId>\n    <artifactId>junit-platform-launcher</artifactId>\n    <version>1.10.2</version>\n    <scope>test</scope>\n</dependency>\n\n<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine -->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-engine</artifactId>\n    <version>5.10.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### Gradle\n\n```groovy\n// https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher\ntestImplementation 'org.junit.platform:junit-platform-launcher:1.10.2'\n\n// https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine\ntestImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'\n```\n\nПосле добавления к методу аннотации @Test в IDEA появляется кнопка play соответсвенно этот метод теперь можно запустить и его выполнит движок Junit. Если запустить класс то будут выполнены все тестовые методы из данного класса.\n\nМожно определять тестовые методы без модификатора (public, private, protected).\n\n```java\n@Test\nvoid someTest(){\n    assertTrue(true);\n}\n```\n\n## Аннотации JUnit 5\nJUnit 5 предлагает следующие аннотации для написания тестов.\n\n| Аннотации | Описание |\n| --- | --- |\n| @BeforeEach | Аннотированный метод будет запускаться перед каждым тестовым методом в тестовом классе. |\n| @AfterEach | Аннотированный метод будет запускаться после каждого тестового метода в тестовом классе. |\n| @BeforeAll | Аннотированный метод будет запущен перед всеми тестовыми методами в тестовом классе. Этот метод должен быть статическим. |\n| @AfterAll | Аннотированный метод будет запущен после всех тестовых методов в тестовом классе. Этот метод должен быть статическим. |\n| @Test | Он используется, чтобы пометить метод как тест junit. |\n| @DisplayName | Используется для предоставления любого настраиваемого отображаемого имени для тестового класса или тестового метода |\n| @Disable | Он используется для отключения или игнорирования тестового класса или тестового метода из набора тестов. |\n| @Nested | Используется для создания вложенных тестовых классов |\n| @Tag | Пометьте методы тестирования или классы тестов тегами для обнаружения и фильтрации тестов. |\n| @TestFactory | Отметить метод - это тестовая фабрика для динамических тестов. |\n\n\n### @BeforeAll\n\nАннотация @BoforeAll используются для указания о том, что аннотированный метод должен быть выполнен перед всеми @Test, @RepeatedTest, @ParameterizedTest и @TestFactory методами в текущем классе.\n\nПо умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeAll метод.\n\nАннотированный @BeforeAll метод ДОЛЖЕН быть статическим методом в тестовом классе.\n\n```java\n@BeforeAll\npublic static void init(){\n    System.out.println(\"BeforeAll init() method called\");\n}\n```\n\nИли мы можем применить эту аннотацию к default методам интерфейса, если тестовый интерфейс или тестовый класс аннотированы с помощью @TestInstance(Lifecycle.PER_CLASS).\n\n```java\n@TestInstance(Lifecycle.PER_CLASS)\ninterface TestLifecycleLogger {\n\n    @BeforeAll\n    default void beforeAllTests() {\n        //\n    }\n}\n```\n\nЕсли этого не сделать, JUnit выдаст ошибку времени выполнения типа JUnitException.\n\n```java\norg.junit.platform.commons.JUnitException: \n@BeforeAll method 'public void com.howtodoinjava.junit5.examples. \nJUnit5AnnotationsExample.init()' must be static.\nat org.junit.jupiter.engine.descriptor. \nLifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:66)\n```\n\n#### @BeforeAll в родительском и дочернем классах\n\n@BeforeAll методы наследуются от родительских классов (или интерфейсов), если они не скрыты или не переопределены. \n\nКроме того, @BeforeAll методы из родительских классов (или интерфейсов) будут выполняться перед @BeforeAll методами в дочерних классах.\n\n### @BeforeEach\n\nАннотация @BeforeEach используется для обозначения того, что аннотированный метод должен выполняться перед каждым методом @Test, @RepeatedTest, @ParameterizedTest, или @TestFactory в текущем классе.\n\nАннотация JUnit 5 @BeforeEach является одним из методов жизненного цикла и заменяет аннотацию @Before в JUnit 4.\n\nПо умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeEach метод.\n\n```java\n@BeforeEach\npublic void initEach(){\n     //test setup code\n}\n\n@Test\nvoid succeedingTest() {\n    //test code and assertions\n}\n```\n\nАннотированный @BeforeEach метод НЕ ДОЛЖЕН быть статическим, иначе он вызовет ошибку времени выполнения.\n\n```java\n@BeforeEach\npublic static void initEach(){\n     //test setup code\n}\n\n//Error\n\n\norg.junit.platform.commons.JUnitException: @BeforeEach method 'public static void com.howtodoinjava.junit5.examples. JUnit5AnnotationsExample.initEach()' must not be static.\nat org.junit.jupiter.engine.descriptor. LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:73)\n```\n\n#### @BeforeEach в родительском и дочернем классах\n\nМетод @BeforeEach наследуется от родительских классов (или интерфейсов) до тех пор, пока они не скрыты или не  переопределены. \n\nКроме того, каждый метод с аннотацией @Before из родительских классов (или интерфейсов) будет выполняться перед каждым методом с аннотацией @Before в дочерних классах.\n\n## @ParameterizedTest\n\nИспользуется, чтобы выполнить тест несколько раз, но с разными аргументами. \n\n1. Включите зависимость junit-jupiter-params, чтобы использовать параметризованные тесты.\n\nПоследнюю версию можно найти по этой ссылке https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params.\n\npom.xml\n\n```java\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-params</artifactId>\n    <version>${junit-version}</version>\n    <scope>test</scope>\n</dependency>\n```\n\n2. Нам не нужно использовать аннотацию @Test, вместо этого в таких тестах используется только аннотация @ParameterizedTest.\nМы должны объявить по крайней мере один источник аргументов, предоставляющий аргументы для каждого вызова, которые будут использоваться в тестовом методе.\n\nВ данном примере testPalindrome будет вызываться 2 раза для каждой строки, указанной в аннотации @ValueSource. Мы получаем доступ к аргументу, используя параметр word метода.\n\nИспользуйте аргумент name в аннотации @ParameterizedTest, чтобы настроить отображаемое сообщение.\n\n```java\npublic class ParameterizedTests \n{\n    public boolean isPalindrome(String s) {\n        return s == null ? false : StringUtils.reverse(s).equals(s);\n    }\n    \n    @ParameterizedTest(name = \"{index} - {0} is a palindrome\")\n    @ValueSource(strings = { \"12321\", \"pop\" })\n    void testPalindrome(String word) {\n        assertTrue(isPalindrome(word));\n    }\n}\n```\n\n### Источники тестовых аргументов\n\n#### Аннотация @ValueSource\nИспользуйте @ValueSource для простых буквальных значений, таких как примитивы и строки.\n\nОна определяет один массив значений и может использоваться только для предоставления одного аргумента для каждого параметризованного вызова теста.\n\nJava поддерживает автобоксирование, поэтому мы также можем использовать литералы в их классах-оболочках.\n\nМы не можем передавать null в качестве аргумента даже для типов String и Class.\n\n```java\n@ParameterizedTest\n@ValueSource(ints = { 1, 2, 3 })\nvoid testMethod(int argument) {\n    //test code\n}\n\n@ParameterizedTest\n@ValueSource(ints = { 1, 2, 3 })\nvoid testMethodWithAutoboxing(Integer argument) {\n    //test code\n}\n```\n\n#### Аннотация @NullSource\n\nОна предоставляет единственный null аргумент методу, аннотированному @ParameterizedTest.\n\n```java\n@ParameterizedTest\n@NullSource\nvoid testMethodNullSource(Integer argument) {\n    assertTrue(argument == null);\n}\n```\n\n#### Аннотация @EmptySource\nОна предоставляет метод, аннотированный @ParameterizedTest, с единственным пустым аргументом следующих типов:\n\njava.lang.String\n\njava.util.List\n\njava.util.Set\n\njava.util.Map\n\nпримитивные массивы (например, int [])\n\nмассивы объектов (например, String [])\n\n```java\n@ParameterizedTest\n@EmptySource\nvoid testMethodEmptySource(String argument) {\n    assertTrue(StringUtils.isEmpty(argument));\n}\n```\n\n#### Аннотация @NullAndEmptySource\nОна сочетает в себе функциональность @NullSource и @EmptySource. В данном примере тестовый метод будет вызываться два раза - сначала со значением null, а затем со значением empty.\n\n```java\n@ParameterizedTest\n@NullAndEmptySource\nvoid testMethodNullAndEmptySource(String argument) {\n    assertTrue(StringUtils.isEmpty(argument));\n}\n\n```\n\n##### Проверка null и non-null значений в одном тесте\n\nМы уже знаем, что аннотация @ValueSource не поддерживает значение null.\n\nТаким образом, используя @NullSource и @EmptySource в аннотации @ValueSource, мы можем тестировать null, non-null и пустые значения в одном и том же тесте.\n\n#### Аннотация @EnumSource\nЭто удобный способ использования Enum констант. Метод тестирования будет вызываться для каждой константы перечисления за раз.\n\nВ данном примере тестовый метод будет вызываться 4 раза, по одному разу для каждой Enum константы.\n\n```java\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n}\n\n@ParameterizedTest\n@EnumSource(Direction.class)\nvoid testWithEnumSource(Direction d) {\n    assertNotNull(d);\n}\n```\n\n#### Аннотация @MethodSource\nОна используется для ссылки на один или несколько фабричных методов тестового класса или внешних классов. Фабричный метод должен генерировать поток аргументов, где каждый аргумент в потоке будет использоваться методом, аннотированным @ParameterizedTest.\n\nФабричный метод должен быть static, если тестовый класс не аннотирован с помощью @TestInstance(Lifecycle.PER_CLASS).\n\nКроме того, фабричный метод не должен принимать аргументы.\n\n```java\n@ParameterizedTest\n@MethodSource(\"argsProviderFactory\")\nvoid testWithMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> argsProviderFactory() {\n    return Stream.of(\"alex\", \"brian\");\n}\n```\n\nЕсли мы явно не предоставим имя фабричного метода через @MethodSource, JUnit будет искать фабричный метод, имя которого по умолчанию совпадает с именем текущего метода с аннотацией @ParameterizedTest.\n\nПоэтому, в примере, если мы не предоставим имя метода argsProviderFactory в аннотации @MethodSource, Junit будет искать имя метода testWithMethodSource с возвращаемым типом `Stream<String>`.\n\n```java\n@ParameterizedTest\n@MethodSource\nvoid testWithMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> testWithMethodSource() {\n    return Stream.of(\"alex\", \"brian\");\n}\n```\n\nТакже поддерживаются потоки для примитивных типов (DoubleStream, IntStream и LongStream).\n\n```java\n@ParameterizedTest\n@MethodSource(\"argsProviderFactory\")\nvoid testWithMethodSource(int argument) {\n    assertNotEquals(9, argument);\n}\n\nstatic IntStream argsProviderFactory() {\n    return IntStream.range(0, 10);\n}\n```\n\n#### Аннотация @CsvSource\nЭта аннотация позволяет нам задавать списки аргументов как значения, разделенные запятыми. Каждый CSV токен представляет собой строку CSV и приводит к одному вызову параметризованного теста.\n\nЗадайте для свойства ignoreLeadingAndTrailingWhitespace значение true или false, указывающее на то, что Junit должен принимать или игнорировать пробелы в CSV токенах.\n\n```java\n@ParameterizedTest\n@CsvSource(value = {\n    \"alex, 30\",\n    \"brian, 35\",\n    \"charles, 40\"\n}, ignoreLeadingAndTrailingWhitespace = true)\nvoid testWithCsvSource(String name, int age) {\n    assertNotNull(name);\n    assertTrue(age > 0);\n}\n```\n\n#### Аннотация @CsvFileSource\nЭта аннотация очень похожа на @CsvSource за исключением того, что мы читаем токены CSV из файла вместо чтения токенов в исходном тексте. CSV файл можно прочитать по classpath или из локальной файловой системы.\n\nРазделителем по умолчанию является запятая (,), но мы можем использовать другой символ, установив атрибут разделителя.\n\nОбратите внимание, что любая строка, начинающаяся с символа #, будет интерпретироваться как комментарий и игнорироваться.\n\n```java\n@ParameterizedTest\n@CsvFileSource(resources = \"employeeData.csv\", numLinesToSkip = 0)\nvoid testWithCsvFileSource(String name, int age) {\n    assertNotNull(name);\n    assertTrue(age > 0);\n}\n```\n\n#### Аннотация @ArgumentsSource\nАннотацию @ArgumentsSource можно использовать для указания настраиваемого многоразового поставщика аргументов ArgumentsProvider.\n\n```java\n@ParameterizedTest(name = \"{index} - {0} is older than 40\")\n@ArgumentsSource(EmployeesArgumentsProvider.class)\nvoid isEmployeeAgeGreaterThan40(Employee e) {\n    assertTrue(Period.between(e.getDob(), LocalDate.now()).get(ChronoUnit.YEARS) > 40);\n}\n\nclass EmployeesArgumentsProvider implements ArgumentsProvider {\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n        return Stream.of(\n          Arguments.of(new Employee(1, \"Alex\", LocalDate.of(1980, 2, 3))),\n          Arguments.of(new Employee(2, \"Brian\", LocalDate.of(1979, 2, 3))),\n          Arguments.of(new Employee(3, \"Charles\", LocalDate.of(1978, 2, 3)))\n        );\n    }\n}\n```\n\n### Параметризованные тесты с несколькими аргументами\n\nЧтобы написать тесты, которые могут использовать несколько аргументов, мы можем использовать следующие аннотации:\n\n#### Аннотация @CsvSource\nКак показано в предыдущем разделе 3.7, с помощью аннотации @CsvSource мы можем предоставить множество литералов и простых типов аргументов.\n\nНам нужно предоставить все аргументы в одном токене CSV, а затем определить соответствующие аргументы метода.\n\n```java\n@ParameterizedTest\n@CsvSource({\n    \"alex, 30, HR, Active\",\n    \"brian, 35, Technology, Active\",\n    \"charles, 40, Finance, Purged\"\n})\nvoid testWithCsvSource(String name, int age, String department, String status) {\n    //test code\n}\n```\n\n#### Интерфейс ArgumentsProvider\nЧтобы предоставить несколько тестовых аргументов сложных или настраиваемых типов, мы должны использовать аннотацию @ArgumentsSource с аннотацией ArgumentsProvider.\n\nВ примере мы передаем три аргумента метода тестирования testArgumentsSource, типов Employee, LocalDateи enum константы типа Direction.\n\n```java\n@ParameterizedTest\n@ArgumentsSource(EmployeesArgumentsProvider.class)\nvoid testArgumentsSource(Employee e, LocalDate date, Direction d) {\n    assertTrue(Period.between(e.getDob(), LocalDate.now()).get(ChronoUnit.YEARS) > 40);\n    assertNotNull(date);\n    assertNotNull(d);\n}\n\nclass EmployeesArgumentsProvider implements ArgumentsProvider {\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n        return Stream.of(\n          Arguments.of(new Employee(1, \"Alex\", \n                  LocalDate.of(1980, 2, 3)), LocalDate.now(), Direction.EAST),\n          Arguments.of(new Employee(2, \"Brian\", \n                  LocalDate.of(1979, 2, 3)), LocalDate.now(), Direction.NORTH),\n          Arguments.of(new Employee(3, \"Charles\", \n                  LocalDate.of(1978, 2, 3)), LocalDate.now(), Direction.SOUTH)\n        );\n    }\n```\n\n## Build tool support\n\n```groovy\ntest {\n    useJUnitPlatform {\n        includeTags 'fast', 'smoke'\n        excludeTags 'slow', 'ci'\n\n        include 'org/foo/**'\n        exclude 'org/boo/**'\n    }\n}\n```\n\nhttps://www.youtube.com/watch?v=RAOAcq97KZM\n\nhttps://www.youtube.com/watch?v=w1ey2zjf3-s\n\nhttps://www.youtube.com/watch?v=DAszLeWMsqU\n\nhttps://www.youtube.com/watch?v=751gMXH-lEE\n\nhttps://www.youtube.com/watch?v=r-8EGXMFJaw\n\nhttps://www.youtube.com/watch?v=ZIkIUCyJBGU\n\nhttps://www.youtube.com/watch?v=3pOjh6O7-cg\n\nhttps://www.youtube.com/watch?v=W1INR0I3FCo&list=PLnh8EajVFTl5AqvBosxUefReW4nC35P0x","category":"automation","description":"JUnit 5"},{"title":"Создаем основу проекта","path":"/sozdaem-osnovu-proekta/","content":"\n- Какие тесты нужно автоматизировать в первую очередь?\nБерем тесты, которые чаще всего проверяются, чаще всего стреляют и которые больше всего затратны с точки зрения ручного тестирования.\n\n- эффективность автоматизации\nhttps://www.youtube.com/watch?v=GpvY3NF9mRc\n\nGradle\n\n1 создаем градл проект через идею.\n2 редактируем файл build.gradle \n\nПосле создания проекта дефолтный скрипт выглядит так:\n\n```groovy\nplugins {\n    id 'java' //плагин для сблорки java приложения\n}\n\n// группа и версия проекта\ngroup 'io.vvrozhkova'\nversion '1.0-SNAPSHOT'\n\n\n//репозиторий для скачивания зависимостей\nrepositories {\n    mavenCentral()\n}\n\n\n//список зависимостей\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'\n}\n\n\n//настройка запуска тестов через JUnit\ntest {\n    useJUnitPlatform()\n}\n```\n\n\n","category":"java","description":"Создаем основу проекта"},{"title":"План содания проекта для UI автотестов","path":"/plan-sodaniya-proekta-dlya-ui-avtotestov/","content":"\n1. [Создаем основу проекта](/sozdaem-osnovu-proekta/)\n","category":"java","description":"План содания проекта для UI автотестов"}]