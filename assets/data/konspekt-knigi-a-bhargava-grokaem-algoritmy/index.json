{"hash":"02799b688b4cb7ace869e49ff69fbf95eb6f42e6","data":{"post":{"title":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\"","content":"\n## Что такое алгоритм?\n\nНабор инструкций для выполнения некоторой задачи.\n\n## $О$-большое\n\nСпециальная нотация которая описывает скорость выполнения алгоритма, а именно показывает с какой скоростью растет время выполнения алгоритма при увеличении входных данных.  \n\n$О$-большое не сообщает скорость в секундах а позволяет сравнить количество операций.  \n$О$-большое определяет время выполнения в худшем случае.\n\n#### Разновидности:\n- $O(1)$ - постоянное время\n- $O(log(n))$ - логарифмическое время. Пример: _бинарный поиск_\n- $O(n)$ - линейное время. Пример: _простой поиск_\n- $O(n * log(n))$ - Пример: _эффективные алгоритмы_\n- $O(n^2)$ - Пример: _медленные алгоритмы сортировки (сортировка выбором)_\n- $O(n!)$ - Пример: _очень медленные алгоритмы (задача о коммивояжере)_\n\n## Линейный поиск\n\nПроходим по массиву и при нахождении первого элемента с искомым значением возвращаем его индекс. \n\n\n```java\nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = lineSearch(arr, 12);\nSystem.out.println(index);\nSystem.out.println(arr[index]);\n```\n\n```java\nstatic int lineSearch(int[] arr, int key) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == key) {\n            return i;\n        }\n    }\n    \n    // return -1\n    throw new RuntimeException(\"Key '\" + key + \"' is not found!\");\n}\n```\n\n**Сложность алгоритма** - $O(n)$.  \nСкорость каждой итерации $O(1)$.  \nВ худшем случай $n$ итераций.  \n\n## Бинарный поиск\n\n- работает когда список отсортирован\n\nАналогично поиску слова в словаре.\n\n#### Реализация через цикл:\n\n```java\nstatic int binarySearch(int[] arr, int key) {\n    int low = 0;\n    int high = arr.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (key < arr[mid]) {\n            high = mid - 1;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n#### Реализация через рекурсию:\n\n```java \nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = binarySearch(arr, 12, 0, arr.length - 1);\n```\n\n```java\nstatic int binarySearch(int[] arr, int key, int low, int high) {\n    int mid = low + (high - low) / 2;\n    if (high < low) {\n        return -1;\n    }\n    if (arr[mid] == key) {\n        return mid;\n    } else if (key < arr[mid]) {\n        return binarySearch(arr, key, low, mid - 1);\n\n    } else {\n        return binarySearch(arr, key, mid + 1, high);\n    }\n}\n```\n\n**Сложность алгоритма** - $O({log_{2}(n)})$.  \n\n${log_{2}(n)} = k$   \n$k$ - в какую степень надо возвести 2, чтобы получить n   \n\n$n={2^k}$\n\n- если число n - не степень двойки, то выбирается такое наименьшее k, что $2^k > n$.\n\n- $O({log_{2}(n)})$ лучше чем O(n).\n\n## Сортировка выбором\n\n```java\npublic static void main(String args[]) throws Exception {\n    int[] arr = {64, 42, 73, 41, 32, 53, 16, 24, 57, 42, 74, 55, 36};\n    System.out.println(Arrays.toString(selectionSort(arr)));\n}\n```\n\n```java\nstatic int[] selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        int ind = smallest(arr, i);\n        int temp = arr[i];\n        arr[i] = arr[ind];\n        arr[ind] = temp;\n    }\n    return arr;\n}\n\nstatic int smallest(int[] arr, int start) {\n    int index = start;\n    int smallest = arr[start];\n    for (int i = start; i < arr.length; i++) {\n        if (arr[i] < smallest) {\n            smallest = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n```\n\n**Сложность алгоритма** - $O(n^2)$.  \n\n\n## Рекурсия\n\n- Каждая рекурсивная функция состоит из двух частей:\n    - рекурсивного случая - функция вызывает сама себя\n    - базового случая - функция себя не вызывает, чтобы предотвратить зацикливание\n\n```java\n static int factorial(int n) {\n    if (n == 1) {\n        return n;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\n\n## Стратегия \"Разделяй и властвуй\"\n\nДанная стратегия состоит из двух шагов:\n\n1. Определяется базовый случай - простейший случай из всех возможных.\n2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.\n\nСтратегия \"Разделяй и властвуй\" - это не алгоритм, это подход к решению задачи.\n\n#### Пример:\nИмеется массив `{2, 4, 6}`. Нужно просуммировать все числа и вернуть сумму. \n\n\n```java\nstatic int sum(int[] arr) {\n    if (arr.length == 0) {\n        return 0;\n    } else if (arr.length == 1) {\n        return arr[0];\n    } else {\n        int[] newArr = Arrays.copyOfRange(arr, 1, arr.length);\n        return arr[0] + sum(newArr);\n    }\n}\n```\n\n> Если в рекурсивной функции используется массив, то базовым случаем чаще всего оказывается либо пустой массив, либо массив из одного элемента.\n\n\n## Быстрая сортировка\n\n- Работает быстрее сортировки выбором.\n- Основана на стратегии \"Разделяй и властвуй\"\n\n\nБазовый случай: массивы с одним элементом или пустой массив  \n\n#### Шаги рекурсивного случая:  \n1. Выбрать опорный элемент.\n2. Разделить массив на два подмассива:\n    - элементы, **меньшие** опрного \n    - элементы, **большие** опорного\n\n\n```java\npublic static void quickSort(int[] arr, int from, int to) {\n    if (from < to) {\n\n        int divideIndex = partition(arr, from, to);\n\n        quickSort(arr, from, divideIndex - 1);\n\n        quickSort(arr, divideIndex, to);\n    }\n}\n\nprivate static int partition(int[] arr, int from, int to) {\n    int rightIndex = to;\n    int leftIndex = from;\n\n    int pivot = arr[from + (to - from) / 2];\n    while (leftIndex <= rightIndex) {\n\n        while (arr[leftIndex] < pivot) {\n            leftIndex++;\n        }\n\n        while (arr[rightIndex] > pivot) {\n            rightIndex--;\n        }\n\n        if (leftIndex <= rightIndex) {\n            swap(arr, rightIndex, leftIndex);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return leftIndex;\n}\n\nprivate static void swap(int[] array, int index1, int index2) {\n    int tmp  = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n```\n\n## Хеш-таблицы\n\n**Хеш-функция** представляет собой функцию которая получает строку[^Под \"строкой\" понимаются любые данные - последовательность байтов.] и возвращает число.\nХеш функция должна соответствовать требованиям:\n- Она должна быть последовательной. Всегда возвращать одинаковое число на одну и ту же строку.\n- Разным словам должны соотвествовать разные числа.\n\nМассив который хранит элементы при помощи хеш-функций называется **хеш-таблицей**. Их также называют \"ассоциативным массивом\", \"словарем\", \"отображением\", \"хеш картой\" или просто \"хеш\".\nХеш таблицы упрощают моделировние отношений между объектами.\n\n```java\nHashMap<String, Double> book = new HashMap();\nbook.put(\"apple\", 0.67);\nbook.put(\"milk\", 1.49);\nbook.put(\"avocado\", 1.49);\nSystem.out.println(book.get(\"avocado\"));\n```\n\nХеши подходят для решения следующих задач:\n- моделирование отношений между объектами;\n- устранение дубликатов;\n- кеширование/запоминание данных вместо выполнения работы на сервере.\n\n## Коллизии\n\nСитуация когда несколько элементов по хешу попадают в одну и туже ячейку[^Двум ключам назначается один элемент массива].\n\n#### Одна из стратегий обработки коллизий:\n> Если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.\nНо если все элементы попадают в одну ячейку и содержатся в одном связанном списке то работа с данными замедляется.\n\nОтсюда следует:\n- _Выбор хеш-функции действительно важен._ В идеале хеш функция должна распределять ключи равномерно по всему хешу.\n- Если связанные списки становятся слишком длинными, то работа с хеш-таблицей сильно замедлится. \nНо они не станут длинными _при использовании хорошей хеш-функции_!\n\nДля предотвращения коллизий необходимы:\n- низкий коэфициент заполнения;\n- хорошая хеш-функция;\n\n## Поиск в ширину\n\nАлгоритм для решения задачи поиска кратчайшего пути называется **_поиском в ширину_**.\n\n## Граф\n\nГраф моделирует набор связей. Каждый граф строится из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называют _соседями_.\n\n![Иллюстрация графа](/images/graph_illustration.png)\n\nАлгоритм поиска в ширину может ответить на 2 вопроса:\n\n1. существует ли путь от узла А к узлу В?\n2. как выглядит кратчайший путь от узла А к узлу В?\n\n> Связи первого уровня добавляются в список поиска раньше связей второго уровня и т.д.  \n\n> Проверять связи необходимо в порядке их добавления. Для операций такого рода есть специальная структура данных, называемая **_очередью_**.\n\n## Очередь\n\nДля этой структуры данных доступно только две операции:\n- постановка в очередь;\n- извлечение из очереди;\n\nЭлементы добавленные в очередь первыми, первыми же будут из нее извлечены.\n\n> <u>Очередь</u> относится к категории структур данных FIFO: _First In, First Out_ (\"первым вошел, первым вышел\").\n\n> А <u>стек</u> принадлежит к категории LIFO: _Last In, First Out_ (\"последним вошел, первым вышел\").\n\n## Реализация графа\n\nГраф можно реализовать с помощью хеш-таблицы. В хеш таблице ключ связан со значением, а в нашем случае узел должен быть связан с соседями.\n\n```java\nHashMap<String, String[]> book = new HashMap();\nString[] siblings = {\"alice\", \"bob\", \"claire\"};\nbook.put(\"you\", siblings);\n```\n\nРазличают _направленный_ и _ненаправленный_ граф.  \n**_Направленный граф (ориентированный, орграф)_** - это граф в котором отношения действуют только в одну сторону.  \n**_Ненаправленный граф (неориентированный, неорграф)_** - направления отношений нет и каждый из узлов является соседом друг к другу.\n\n![Виды графов](/images/graph_types.png)\n\nАлгоритм графа:\n1. Создать очередь\n2. Извлечь из очереди первый элемент\n3. Выполнить поисковую проверку \n4. Если элемент соотвествует поиску закончить проверку, если нет то добавить всех соседей данного элемента в очередь\n5. Повторить шаги пока не закончится очередь либо элемент удолетворяющий поиску не будет найден.\n\n> Однако, если элемент встречается в двух и более списках, то он будет проверяться дважды, либо может войти в цикл.  \nЧтобы избежать такого поведения необходимо добавить список, в который помещаются уже проверенные элементы.\n\n\n```java\npublic static void main(String[] args) {\n    HashMap<String, String[]> all = new HashMap();\n    String[] siblings = {\"alice\", \"bob\", \"claire\"};\n    String[] claireSiblings = {\"jack\", \"steve\", \"bob\"};\n    String[] bobSiblings = {\"claire\", \"damon\"};\n    all.put(\"you\", siblings);\n    all.put(\"claire\", claireSiblings);\n    all.put(\"bob\", bobSiblings);\n\n    ArrayDeque<String> searchDeque = new ArrayDeque();\n    searchDeque.addAll(Arrays.asList(all.get(\"you\")));\n    if (!searchMangoSeller(all, searchDeque)) {\n        throw new RuntimeException(\"Mango seller is not found!\");\n    }\n}\n\nstatic boolean searchMangoSeller(HashMap<String, String[]> all,\n                                    ArrayDeque<String> searchDeque) {\n    ArrayList<String> searched = new ArrayList();\n    while (!searchDeque.isEmpty()) {\n        String person = searchDeque.pop();\n        if (!searched.contains(person)) {\n            if (isSeller(person)) {\n                System.out.println(person + \" is a mango seller!\");\n                return true;\n            } else {\n                String[] siblings = all.get(person);\n                if (siblings != null) {\n                    searchDeque.addAll(Arrays.asList(siblings));\n                }\n                searched.add(person);\n            }\n        }\n    }\n    return false;\n}\n\nstatic boolean isSeller(String person) {\n    return person.charAt(person.length() - 1) == 'n';\n}\n```\n\n#### Время выполнения: \nЕсли поиск выполнен по всей сети то значит вы прошли по каждому ребру $O(количество\\:ребер)$.  \nТакже в программе должна храниться очередь поиска. Добавление каждого человека потребует $O(количество\\:людей)$.\nВ итоге поиск в ширину займет $O(количество\\:людей + количество\\:ребер)$, что обычно записывается как $O(V+E)$, _V - кол-во вершин, E - кол-во ребер_.\n\n## Алгоритм Дейкстры\n\nАлгоритм поиска в ширину находит путь, состоящий из меньшего количества сегментов. Но если нужно найти наименьший путь с учетом определеных характеристик, то эту задачу решает **Алгоритм Дейкстры**.\n\nАлгоритм Дейкстры состоит из следующих шагов:\n\n1. Каждому ребру нужно назначить свой вес, в зависимости от иследуемой характеристики.\n2. Найти узел с наименьшей стоимостью.\n3. Проверить существует ли более дешевый путь к соседям этого узла и если существует, обновить их стоимости.\n4. Повторять, пока это не будет сделано для всех узлов графа.\n5. Вычислить итоговый путь.\n\nГраф с весами называется **_взвешенным графом_**. Граф без весов называется **_невзвешенным графом_**.\n\nДля вычисления кратчайшего пути в <u>невзвешенном графе</u> используется _поиск в ширину_. Кратчайшие пути во <u>взвешенном графе</u> вычисляются по _алгоритму Дейкстры_.\n\nВ графах также могут присутствовать **_циклы_**. Это означает, что вы можете начать с некоторого узла перемещаться по графу, а потом снова оказаться в том же узле. \n\n> В ненаправленном графе, каждый из двух узлов ведет к другому узлу, а это _цикл_!  \n> Поэтому, алгоритм Дейкстры работает только с _направленными ациклическими графами, DAG (Directed Acyclic Graph)_.\n\n### Работа с отрицательным весом\n\nВ том случае если проходя по определенному ребру мы не тратим вес а наоборот получаем дополнительный бонус к нужной характеристике, то такому ребру назначется _отрицательный вес_. \n\nОднако Алгоритм Дейкстры не может использоваться при наличии ребер имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_.\n","description":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\"","image":"null","category":{"id":"java","title":"java","path":"/category/java/"},"date":"23/05/2022","path":"/konspekt-knigi-a-bhargava-grokaem-algoritmy/","links":[{"title":"","items":[{"title":"Основы Java","link":"/osnovy-java"},{"title":"Примеры алгоритмов (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Алгоритмы (курс Тинькофф)","link":"/algoritmy-kurs-tinkoff/"},{"title":"Конспект книги А. Бхаргава 'Грокаем алгоритмы'","link":"/konspekt-knigi-a-bhargava-grokaem-algoritmy/"}]}],"headings":[{"value":"Что такое алгоритм?","anchor":"#что-такое-алгоритм"},{"value":"ООО-большое","anchor":"#о-большое"},{"value":"Линейный поиск","anchor":"#линейный-поиск"},{"value":"Бинарный поиск","anchor":"#бинарный-поиск"},{"value":"Сортировка выбором","anchor":"#сортировка-выбором"},{"value":"Рекурсия","anchor":"#рекурсия"},{"value":"Стратегия \"Разделяй и властвуй\"","anchor":"#стратегия-разделяй-и-властвуй"},{"value":"Быстрая сортировка","anchor":"#быстрая-сортировка"},{"value":"Хеш-таблицы","anchor":"#хеш-таблицы"},{"value":"Коллизии","anchor":"#коллизии"},{"value":"Поиск в ширину","anchor":"#поиск-в-ширину"},{"value":"Граф","anchor":"#граф"},{"value":"Очередь","anchor":"#очередь"},{"value":"Реализация графа","anchor":"#реализация-графа"},{"value":"Алгоритм Дейкстры","anchor":"#алгоритм-дейкстры"}],"subtitles":[{"depth":2,"value":"Что такое алгоритм?","anchor":"#что-такое-алгоритм"},{"depth":2,"value":"ООО-большое","anchor":"#о-большое"},{"depth":4,"value":"Разновидности:","anchor":"#разновидности"},{"depth":2,"value":"Линейный поиск","anchor":"#линейный-поиск"},{"depth":2,"value":"Бинарный поиск","anchor":"#бинарный-поиск"},{"depth":4,"value":"Реализация через цикл:","anchor":"#реализация-через-цикл"},{"depth":4,"value":"Реализация через рекурсию:","anchor":"#реализация-через-рекурсию"},{"depth":2,"value":"Сортировка выбором","anchor":"#сортировка-выбором"},{"depth":2,"value":"Рекурсия","anchor":"#рекурсия"},{"depth":2,"value":"Стратегия \"Разделяй и властвуй\"","anchor":"#стратегия-разделяй-и-властвуй"},{"depth":4,"value":"Пример:","anchor":"#пример"},{"depth":2,"value":"Быстрая сортировка","anchor":"#быстрая-сортировка"},{"depth":4,"value":"Шаги рекурсивного случая:","anchor":"#шаги-рекурсивного-случая"},{"depth":2,"value":"Хеш-таблицы","anchor":"#хеш-таблицы"},{"depth":2,"value":"Коллизии","anchor":"#коллизии"},{"depth":4,"value":"Одна из стратегий обработки коллизий:","anchor":"#одна-из-стратегий-обработки-коллизий"},{"depth":2,"value":"Поиск в ширину","anchor":"#поиск-в-ширину"},{"depth":2,"value":"Граф","anchor":"#граф"},{"depth":2,"value":"Очередь","anchor":"#очередь"},{"depth":2,"value":"Реализация графа","anchor":"#реализация-графа"},{"depth":4,"value":"Время выполнения:","anchor":"#время-выполнения"},{"depth":2,"value":"Алгоритм Дейкстры","anchor":"#алгоритм-дейкстры"},{"depth":3,"value":"Работа с отрицательным весом","anchor":"#работа-с-отрицательным-весом"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"}]},"comments":{"edges":[]}},"context":{}}