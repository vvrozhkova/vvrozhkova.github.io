{"hash":"aa5a7ff62b399012289acf12f7cc1503ba4e22e5","data":{"post":{"title":"Глава 10. Внутренние классы","content":"\n## Внутренние классы\n\nКласс, размещенный в определении другого класса называется внутренним(inner class).\n\nКак правило внешний класс содержит ссылку на внутренний класс.\n\nЕсли нужно создать объект внутреннего класса где-нибудь за пределами внешнего класса или в статическом методе, нужно будет указать тип этого объекта следующим образом: ИмяВнешнегоКласса.ИмяВнутреннегоКласса.\n\nВнутренний класс может обращаться к членам внешнего класса и ему доступны все элементы внешнего класса.\n\nВнутренний класс хранит ссылку на внешний класс, поэтому существование внутреннего класса невозможно без внешнего если он не является статическим.\n\nЕсли нужно получить ссылку на внешний класс то указывается имя класс и .this.\n\nЕсли нужно создать объект внутреннего класса из внешнего, например в статическом методе или за пределом внешнего класса то используется объект внешнего класса и .new\n\nЗакрытый внутренний класс позволяет разработчику класса полностью запретить использование определенных типов и скрыть детали реализации класса.\n\nВнутренние классы могут создаваться в методах и даже произвольных областях действия. Для этого есть 2 причины:\n1. Нужно создавать и возвращать ссылки на некоторый интерфейс\n2. Нужно решить сложную задачу и нужно создать класс, который будет задействован в его решении, но при этом сделать его недоступным для посторонних.\n\nВнутренний класс может быть:\n\n1. Класс, определенный в методе - локальный внутренний класс. К нему невозможно обратиться за пределами метода, в котором он определяется;\n2. Класс, определенный в области действия внутри метода - например вложен в область действия команды if. Внутренний класс не доступен за пределами действия в которой он определяется;\n3. Анонимный класс, реализованный в интерфейсе;\nЕсли вы определяете анонимный внутренний класс и хотите использовать внутри него объект передаваемый в аргументе, то необходимо чтобы аргумент был обозначен как final иначе компилятор выдаст ошибку.\n4. Анонимный класс, расширяющий класс с конструктором, который не является конструктором по умолчанию. В название класса передаются нужные аргументы и задается определение класса;\n5. Анонимный класс, выполняющий инициализацию поля;\n6. Анонимный класс, выполняющий конструирование с использованием инициализации экземпляра (анонимные внутренние классы не могут иметь конструкторов)\n\nВ отличие от обычного класса анонимные внутренние классы могут либо расширять класс, либо реализовать интерфейс но не оба действия сразу.\n\nПаттерн «Фабричный метод»\n\nВложенные классы\n\nЕсли связь между объектом внутреннего класса и объектом внешнего класса не нужна, внутренний класс можно сделать статическим (объявить его как static). Такой класс называют вложенным.\n\nВложенный класс:\n1. Для создания его объекта не нужен объект внешнего класса\n2. Нельзя обращаться к членам не-статического объекта внешнего класса из объекта вложенного класса.\n\nСтатические поля и методы внутреннего класса определяются только на уровне внешнего класса. Вложенные классы таких ограничений не имеют. Уточнить!!!\n\nВложенный класс может быть частью интерфейса. Даже без специальных обозначений любой класс помещенный в интерфейс считается public и static. Это может быть удобно при здании общего кода, который должен использоваться со всеми реализациями интерфейса.\n\nНеважно насколько глубоко вложен класс он будет иметь доступ ко всем полям и методам всех внешних классов.\n\n\nПричина для использования внутренних классов:\nКаждый внутренний класс способен наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовано в ситуациях, где внешний класс уже наследует реализацию.\n\nТаким образом, внутренний класс выступает как «довесок» множественного наследования.\n\nДля наследованная от внутреннего класса должна быть ссылка на внешний класс поэтому используется следующий синтаксис:\nextends ИмяВнешнегоКласса.ИмяВнутреннего класса\nи в конструктор нужно передать ссылку на внешний класс и определить его как \nСсылкаНаВнешнийКласс.super();\n\nПереопределение внутреннего класса не имеет никакого эффекта. Внутренние класс совершенно отдельные составляющие, с независимым пространством имен, но можно явно унаследовать от внутреннего класса.\n\nЛокальный внутренний класс не имеет модификатора доступа, но имеет доступ к членам внешнего класса и final переменным.\nУ локального внутренний класса может быть свой конструктор.\n\nАнонимный внутренний класс не может содержать конструктора только инициализатор экземпляра.\n\nЕдинственный довод в пользу локального внутреннего класс перед анонимным внутренним классом есть необходимость в именованном конструкторе и/или перегруженных конструкторах и  возможность создавать более чем один объект такого класса.\n\n\n\n#философия_java","description":"Глава 10. Внутренние классы","image":"null","category":null,"date":"24/02/2024","path":"/glava-10-vnutrennie-klassy/","links":[{"title":"","items":[{"title":"Глава 1. Введение в объекты","link":"/glava-1-vvedenie-v-obekty/"},{"title":"Глава 5. Инициализация и завершение","link":"/glava-5-iniczializacziya-i-zavershenie/"},{"title":"Глава 10. Внутренние классы","link":"/glava-10-vnutrennie-klassy/"}]}],"headings":[{"value":"Внутренние классы","anchor":"#внутренние-классы"}],"subtitles":[{"depth":2,"value":"Внутренние классы","anchor":"#внутренние-классы"}],"tags":[{"id":"java","title":"java","path":"/tag/java/"},{"id":"ооп","title":"ооп","path":"/tag/%D0%BE%D0%BE%D0%BF/"}]},"comments":{"edges":[]}},"context":{}}