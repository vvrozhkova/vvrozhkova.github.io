{"hash":"7ef89d9cd3f6579eddc6e6b2d3ffbd18a73c2491","data":{"post":{"title":"Префиксные суммы и два указателя","content":"\n## Префиксные суммы\n\nОдин из вариантов, когда нужно использовать алгоритм префиксные суммы, это определение чему равна сумма элементов на полуинтервале [L, R) или отрезке. \n\n> Пусть у нас есть массив `nums` из `N` чисел и необходимо ответить на запрос \"Чему равна сумма элементов на полуинтервале [L, R)?\"\n\nЧтобы решить эту задачу нужно совершить предподсчет, некоторые предварительные действия с помощью которых мы потом сможем быстро отвечать на запрос.\n\nЭти действия имеют смысл только если запросов много. Если не много то лучше просто пробежаться и посчитать.\n\n> Подсчитаем массив `prefixsum` длиной `N+1`, где `prefixsum[k]` будет хранить сумму всех чисел из `nums` с индексами от `0` до `k-1`.\n\nСоздадим массив префиксных сумм. Длина у него будет больше чем у исходного массива.\nИ к-тый элемент этого массива будет равняться сумме всех чисел исходного массива с индексами от `0` до `k-1`.\nТакой массив легко посчитать за O(N^2). Но можно и еще быстрее.\n\n### Построение массива префиксных сумм\n\nДля построения массива префиксных сумм не обязательно каждый раз складывать все значения по индексам. Достаточно взять предыдущую префиксную сумму и прибавить к ней очередное значение.\n\nO(N): prefixsum[i] = prefixsum[i-1] + nums[i-1]\n\n|Индекс|0|1|2|3|4|5|6|\n|---|---|---|---|---|---|---|---|\n|nums|5|3|8|1|4|6|\n|prefixsum|0|5|8|16|17|21|27|\n\nПри составлении префиксного массива нужно помнить 2 вещи:\n\n1. Массив префиксных сумм должен быть на 1 больше, чем исходный!\n2. Переполнение. Целые числа могут переполнить допустимое значение. При сложении 2х int значений, при переполнении получается не верный результат. Если складывать long + int то значение будет приведено к типу long\n\n### Ответ на запрос суммы на полуинтервале\n\n> Ответ за O(1): sum(L, R) = prefixsum[R] - prefixsum[L]\n\n> Найдем sum(2, 5) = prefixsum[5] - prefixsum[2] = 21 - 8 = 13\n\nПочему мы ищем полуинтервал?\nЧтобы избежать проблемы запросов прижатых к левому краю.\nЕсли мы будем искать значение от 0 до 3, как для полуинтервала, то все будет корректно. А если считать как для отрезка то чтобы взять значение прижатое к левому краю нам пришлось бы выйти за пределы массива и взять элементс индексом -1.\n\n### Реализация RSQ(Range Summ Query) через префиксные суммы\n\n```java\npublic static long[] makePrefixSum(int[] nums) {\n      long[] prefixsum = new long[nums.length + 1];\n      for (int i = 1; i < nums.length + 1; i++) {\n          prefixsum[i] = prefixsum[i - 1] + nums[i - 1];\n      }\n      return prefixsum;\n  }\n\n  public static long rsq(long[] prefixsum, int l, int r) {\n      return prefixsum[r] - prefixsum[l];\n  }\n  ```\n\nПример задачи:\n\nПусть на сайт заходят люди и для каждого человека записано, когда он зашел. Нужно посчитать сколько людей у нас было на сайте с L дня по R.Получится массив где в каждом элементе будет храниться число человек посетивших сайт в этот день. И далее с помощью алгоритма префиксных сумм можно ответить на целевой вопрос.\n\n\n### Задача 1\n\n> Дана последовательность чисел длиной N и M запросов\n\nЗапросы: Сколько нулей на полуинтервале [l, R)\n\n#### Решение за O(NM)\n\n> Для каждого запроса переберем все числа от L до R (не включительно) и считаем количество нулей. В худшем случае каждый запрос за `O(N)`. Так как всего запросов M то общая сложность решения `O(NM)`.\n\n\n```java\npublic static int countZeroes(int[] nums, int l, int r) {\n    int cnt = 0;\n    for (int i = l; i < r; i++) {\n        if(nums[i] == 0){\n            cnt+=1;\n        }\n    }\n    return cnt;\n}\n```\n\n#### Решение за O(N+M)\nПопробуем применить метод префиксных сумм. Вместо префиксных сумм будем считать количество нулей на префиксе.\n\n> Для каждого префикса посчитаем количество нулей на нем (prefixZeroes). Тогда ответ на запрос на полуинтервале [L, R): prefixZeroes[R] - prefixZeroes[L].\n\n||0|1|2|3|4|5|6|7|\n|---|---|---|---|---|---|---|---|---|\n|nums|1|0|1|1|0|0|1|\n|prefixZeroes|0|0|1|1|1|2|3|3|\n\n```java\npublic static long[] makePrefixZeroes(int[] nums) {\n    long[] prefixsum = new long[nums.length + 1];\n    for (int i = 1; i < nums.length + 1; i++) {\n        if(nums[i-1] == 0){\n            prefixsum[i] = prefixsum[i - 1] + 1;\n        }else{\n            prefixsum[i] = prefixsum[i - 1];\n        }\n    }\n    return prefixsum;\n}\n\npublic static long countZeroes(long[] prefixZeroes, int l, int r) {\n    return prefixZeroes[r] - prefixZeroes[l];\n}\n```\n\nПолучается сложность O(N+M). O(N) уйден на построение тк у нас N элементов. И на каждый из M запросов мы отвечаем за O(1).\n\n\n### Задача 2\n\n>Дана последовательность чисел длиной N.\nНеобходимо найти количество отрезков с нулевой суммой.\n\n#### Решение за $O(N^3)$\n\n> Переберем начало и конец отрезка и просто просуммируем все его элементы.\n\nПеребираем левую и правую границу отрезка и перебираем цифры которые находятся между ними.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length + 1; j++) {\n            int rangeSum = 0;\n            for (int k = i; k < j; k++) {\n                rangeSum += nums[k];\n            }\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N^2)$\n\n> Переберем начало и будем двигать конец, сумируя элементы.\n\nФиксируем значение слева и затем двигая от этой точки указатель правого края высчитываем сумму.\nНам не нужно каждый раз заново высчитывать всю сумму.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int rangeSum = 0;\n        for (int j = i; j < nums.length; j++) {\n            rangeSum += nums[j];\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N)$\n\nНасчитаем префиксные суммы. Одинаковые префиксные суммы означают, что сумма на отрезке с началом и концом в позициях, на которых достигаются одинаковые префиксные суммы, будет равна нулю.\n\n1. Проходим по массиву и считаем префиксые суммы, при подсчете в словаре увеличиваем количество точек в этой сумме на 1.\n2. Проходим по словарю и для каждой суммы высчитываем количество пар сочетаний по комбинаторной формуле, где k = 2 так как ищем пару\n\n${C_{n}^{k}} = \\frac{n!}{k!(n-k)!} = \\frac{n \\times (n -1) \\times (n - 2)!} {2! \\times (n - 2)!} = \\frac{n \\times (n - 1)} {2}$\n\n```java\npublic static Map<Integer, Integer> countPrefixSums(int[] nums) {\n    Map<Integer, Integer> prefixSumByValue = new HashMap<>();\n    {\n        prefixSumByValue.put(0, 1);\n    }\n    int nowSum = 0;\n    for (int now : nums) {\n        nowSum += now;\n        if (!prefixSumByValue.containsKey(nowSum)) {\n            prefixSumByValue.put(nowSum, 0);\n        }\n        prefixSumByValue.put(nowSum, prefixSumByValue.get(nowSum) + 1);\n    }\n    return prefixSumByValue;\n}\n\npublic static int countZeroSumRanges(Map<Integer, Integer> prefixSumByValue) {\n    int cntRanges = 0;\n    for (Integer nowSum : prefixSumByValue.keySet()) {\n        int cntSum = prefixSumByValue.get(nowSum);\n        cntRanges += cntSum * (cntSum - 1) / 2;\n    }\n\n    return cntRanges;\n}\n```\n\n## Два указателя\n\n### Задача 1\n\n> Дана отсортированная последовательность чисел длиной N и число K. \nНеобходимо найти количество пар чисел A, B, таких что B - A > K.\n\n#### Решение за $O(N^2)$\n\nПереберем все пары чисел и для каждой проверим условие.\n\nВо вложенном цикле можно идти не каждый раз сначала перебирая цифры, а дигаясь вправо от левой границы.\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    for (int i = 0; i < sortedNums.length; i++) {\n        for (int j = i; j < sortedNums.length; j++) {\n            if (sortedNums[j] - sortedNums[i] > k) {\n                cntPairs += 1;\n            }\n        }\n    }\n    return cntPairs;\n}\n```\n#### Решение за $O(N)$\n\nВозьмем наименьшее число и найдем для него первое подходящее большее. Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, а указатель первого подходящего большего будем двигать начиная с той позиции, где он находится сейчас\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    int last = 0;\n    for (int first = 0; first < sortedNums.length; first++) {\n\n        while (last < sortedNums.length && sortedNums[last] - sortedNums[first] <= k) {\n            last += 1;\n        }\n        cntPairs += sortedNums.length - last;\n    }\n    return cntPairs;\n}\n```\n\n### Задача 2\n\n> Игрок в футбол обладает одной числовой характеристикой - профессионализмом. Команда называется сплоченной, если профессионализм любого игрока не превосходит сумарный профессионализм любых других двух игроков из команды. Команда может состоять из любого количества игроков. Дана отсортированная последовательность чисел длиной N - профессионализм игроков.\n\nНеобходимо найти максимальный суммарный профессионализм сплоченной команды.\n\n```java\npublic static int bestTeamSum(int[] players) {\n    int bestSum = 0;\n    int nowSum = 0;\n    int last = 0;\n    for (int first = 0; first < players.length; first++) {\n\n        while (last < players.length && (last == first || players[last] + players[first] >= players[last]) {\n            nowSum += players[last];\n            last += 1;\n        }\n        bestSum = bestSum >= nowSum ? bestSum : nowSum;\n        nowSum -= players[first];\n    }\n    return bestSum;\n}\n```\n\n### Задача 3\n\nДаны две отсортированные последовательности чисел (длиной N и M соответсвенно) \n\nНеобходимо слить их в одну отсортированную последовательность.\n\nРешение\n\n\nДве последовательности могуть быть не обязательно одинаковые по длине, могут быть одинаковые числа.\n\nИдея решения: делаем указатель на текущий элемент первой и во второй последовательности и просто выводим то что меньше по текущему указателю. Например, из чисел из 1 и 3 меньше 1 - 1 записали в ответ и указатель двинули в той последовательности из которой мы взяли очередное число и так далее. Если одна из последовательностей заканчивается мы просто выписываем весь оставшийся хвост текущей последовательности.\n\n#### Неидеальная реализация\n\nПоставим два указателя на начало каждой из последовательностей. Выберем тот, который указывает на меньшее число, запишем это число в результат и сдвинем указатель\n\n\n\n","description":"Префиксные суммы и два указателя","image":"null","category":null,"date":"01/02/2024","path":"/prefiksnye-summy-i-dva-ukazatelya/","links":[{"title":"","items":[{"title":"Алгоритмы (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Сложность, тестирование, особые случаи","link":"/slozhnost-testirovanie-osobye-sluchai/"},{"title":"Линейный поиск","link":"/linejnyj-poisk/"},{"title":"Множества","link":"/mnozhestva/"},{"title":"Словари и сортировка подсчётом","link":"/slovari-i-sortirovka-podschyotom/"},{"title":"Префиксные суммы и два указателя","link":"/prefiksnye-summy-i-dva-ukazatelya/"},{"title":"Бинарный поиск","link":"/binarnyj-poisk/"},{"title":"Сортировка событий","link":"/sortirovka-sobytij/"},{"title":"Деревья","link":"/derevya/"}]}],"headings":[{"value":"Префиксные суммы","anchor":"#префиксные-суммы"},{"value":"Два указателя","anchor":"#два-указателя"}],"subtitles":[{"depth":2,"value":"Префиксные суммы","anchor":"#префиксные-суммы"},{"depth":3,"value":"Построение массива префиксных сумм","anchor":"#построение-массива-префиксных-сумм"},{"depth":3,"value":"Ответ на запрос суммы на полуинтервале","anchor":"#ответ-на-запрос-суммы-на-полуинтервале"},{"depth":3,"value":"Реализация RSQ(Range Summ Query) через префиксные суммы","anchor":"#реализация-rsqrange-summ-query-через-префиксные-суммы"},{"depth":3,"value":"Задача 1","anchor":"#задача-1"},{"depth":4,"value":"Решение за O(NM)","anchor":"#решение-за-onm"},{"depth":4,"value":"Решение за O(N+M)","anchor":"#решение-за-onm-1"},{"depth":3,"value":"Задача 2","anchor":"#задача-2"},{"depth":4,"value":"Решение за O(N3)O(N^3)O(N3)","anchor":"#решение-за-on3"},{"depth":4,"value":"Решение за O(N2)O(N^2)O(N2)","anchor":"#решение-за-on2"},{"depth":4,"value":"Решение за O(N)O(N)O(N)","anchor":"#решение-за-on"},{"depth":2,"value":"Два указателя","anchor":"#два-указателя"},{"depth":3,"value":"Задача 1","anchor":"#задача-1-1"},{"depth":4,"value":"Решение за O(N2)O(N^2)O(N2)","anchor":"#решение-за-on2-1"},{"depth":4,"value":"Решение за O(N)O(N)O(N)","anchor":"#решение-за-on-1"},{"depth":3,"value":"Задача 2","anchor":"#задача-2-1"},{"depth":3,"value":"Задача 3","anchor":"#задача-3"},{"depth":4,"value":"Неидеальная реализация","anchor":"#неидеальная-реализация"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"алгоритмы","title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}]},"comments":{"edges":[]}},"context":{}}