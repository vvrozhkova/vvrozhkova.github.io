{"hash":"74078440e78cf7eff9cd218b18924da13af0a419","data":{"post":{"title":"Виды тестирования по техникам и подходам","content":"\n## Классификация по принципам работы с приложением\n- Позитивное\n- Негативное\n\n## Тестирование на основе опыта тестировщика, сценариев, чек-листов\n- Исследовательское\n- Свободное(интуитивное)\n\n## Классификация по степени вмешательства в работу приложения\n### Инвазивное тестирование (Intrusive testing)\nТестирование, выполнение которого может повлиять на функционирование приложения в силу работы инструментов тестирования (например, будут искажены показатели производительности) или в силу вмешательства (level of intrusion) в сам код приложения (например, для анализа работы приложения было добавлено дополнительное протоколирование, включён вывод отладочной информации и т.д.) \n\nНекоторые источники рассматривают инвазивное тестирование как форму негативного или даже стрессового тестирования.\n\n### Неинвазивное тестирование (Nonintrusive testing)\nТестирование, выполнение которого незаметно для приложения и не влияет на процесс его обычной работы.\n\n## Классификация по техникам автоматизации:\n### Тестирование под управлением данными ( Data-driven testing)\nCпособ разработки автоматизированных тест-кейсов, в котором входные данные и ожидаемые результаты выносятся за пределы тест-кейса и хранятся вне его — в файле, базе данных и т. д.\n\n### Тестирование под управлением ключевыми словами (Keyword-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором за пределы тест-кейса выносится не только набор входных данных и ожидаемых результатов, но и логика поведения тест-кейса, которая описывается ключевыми словами (командами).\n\n### Тестирование под управлением поведением (Behavior-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором основное внимание уделяется корректности работы бизнес-сценариев, а не отдельным деталям функционирования приложения.\n\n## Классификация на основе(знания) источников ошибок\n### Тестирование предугадыванием ошибок (Error guessing)\nТехника тестирования, в которой тесты разрабатываются на основе опыта тестировщика и его знаний о том, какие дефекты типичны для тех или иных компонентов или областей функциональности приложения. \n\nМожет комбинироваться с техникой т.н. «ошибкоориентированного» тестирования (failure-directed testing), в котором новые тесты строятся на основе информации о ранее обнаруженных в приложении проблемах.\n\n### Эвристическая оценка (Heuristic evaluation)\nТехника тестирования удобства использования, направленная на поиск проблем в интерфейсе пользователя, представляющих собой отклонение от общепринятых норм.\n\n### Мутационное тестирование (Mutation testing)\n Nехника тестирования, в которой сравнивается поведение нескольких версий одного и того же компонента, причём часть таких версий может быть специально разработана с добавлением ошибок (что позволяет оценить эффективность тест-кейсов — качественные тесты обнаружат эти специально добавленные ошибки). \n\nМожет комбинироваться со следующим в этом списке видом тестирования (тестированием добавлением ошибок).\n\n### Тестирование добавлением ошибок (Error seeding)\nТехника тестирования, в которой в приложение специально добавляются заранее известные, специально продуманные ошибки с целью мониторинга их обнаружения и устранения и, таким образом, формирования более точной оценки показателей процесса тестирования. \n\nМожет комбинироваться с предыдущим в этом списке видом тестирования (мутационным тестированием).\n\n## Классификация на основе выбора входных данных или спецификаций\n### Тестирование на основе классов эквивалентности (Equivalence partitioning)\nТехника тестирования, направленная на сокращение количества разрабатываемых и выполняемых тест-кейсов при сохранении достаточного тестового покрытия. \n\nСуть техники состоит в выявлении наборов эквивалентных тест-кейсов (каждый из которых проверяет одно и то же поведение приложения) и выборе из таких наборов небольшого подмножества тест-кейсов, с наибольшей вероятностью обнаруживающих проблему.\n\n### Тестирование на основе граничных условий (Boundary value analysis)\nИнструментальная техника тестирования на основе классов эквивалентности, позволяющая выявить специфические значения исследуемых параметров, относящиеся к границам классов эквивалентности. \n\nЭта техника значительно упрощает выявление наборов эквивалентных тест-кейсов и выбор таких тест-кейсов, которые обнаружат проблему с наибольшей вероятностью.\n\n### Доменное тестирование (Domain analysis, Domain testing)\nТехника тестирования на основе классов эквивалентности и граничных условий, позволяющая эффективно создавать тест-кейсы, затрагивающие несколько параметров (переменных) одновременно (в том числе с учётом взаимозависимости этих параметров). \n\nДанная техника также описывает подходы к выбору минимального множества показательных тест-кейсов из всего набора возможных тест-кейсов.\n\n### Попарное тестирование (Pairwise testing)\nТехника тестирования, в которой тест-кейсы строятся по принципу проверки пар значений параметров (переменных) вместо того, чтобы пытаться проверить все возможные комбинации всех значений всех параметров. Эта техника является частным случаем N-комбинационного тестирования (n-wise testing) и позволяет существенно сократить трудозатраты на тестирование (а иногда и вовсе сделать возможным тестирование в случае, когда количество «всех комбинаций всех значений всех параметров» измеряется миллиардами).\n\nПопарное тестирование (pairwise testing) — это НЕ парное тестирование (pair testing)!\n\n### Тестирование на основе ортогональных массивов (Orthogonal array testing)\nИнструментальная техника попарного и N-комбинационного тестирования, основанная на использовании т.н. «ортогональных массивов» (двумерных массивов, обладающих следующим свойством: если взять две любые колонки такого массива, то получивший- ся «подмассив» будет содержать все возможные попарные комбинации значений, представленных в исходном массиве).\n\n## Классификация на основе среды выполнения\n### Тестирование в процессе разработки (Development testing)\nТестирование, выполняемое непосредственно в процессе разработки приложения и/или в среде выполнения, отличной от среды реального использования приложения. Как правило, выполняется самими разработчиками.\n\n### Операционное тестирование\n\n## Тестирование на основе кода (Code based testing)\nВ различных источниках эту технику называют по-разному (чаще всего — тестированием на основе структур, причём некоторые авторы смешивают в один набор тестирование по потоку управления и по потоку данных, а некоторые строго разделяют эти стратегии). \n\nПодвиды этой техники также организуют в разные комбинации, но наиболее универсально их можно классифицировать так:\n\n- **_Тестирование по потоку управления (Control flow testing)_**\nСемейство техник тестирования, в которых тест-кейсы разрабатываются с целью активации и проверки выполнения различных последовательностей событий, которые определяются посредством анализа исходного кода приложения. \n\n- **_Тестирование по потоку данных (Data-flow testing)_**\nСемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных.\n\n- **_Тестирование по диаграмме или таблице состояний (State transition testing)_**\nТехника тестирования, в которой тест-кейсы разрабатываются для проверки переходов приложения из одного состояния в другое. Состояния могут быть описаны диаграммой состояний (state diagram) или таблицей состояний (state table).\n\nИногда эту технику тестирования также называют «тестированием по принципу конечного автомата» (finite state machine testing). \nВажным преимуществом этой техники является возможность применения в ней теории конечных автоматов (которая хорошо формализована), а также возможность использования автоматизации для генерации комбинаций входных данных.\n\n- **_Инспекция (аудит) кода (Code review, Code inspection)_**\nСемейство техник повышения качества кода за счёт того, что в процессе создания или совершенствования кода участвуют несколько человек. Степень формализации аудита кода может варьироваться от достаточно беглого просмотра до тщательной формальной инспекции. \n\nВ отличие от техник статического анализа кода (по потоку управления и потоку данных) аудит кода также улучшает такие его характеристики, как понятность, поддерживаемость, соответствие соглашениям об оформлении и т.д. Аудит кода выполняется в основном самими программистами.\n\n## Тестирование на основе структур кода (Structure-based techniques)\nПредполагает возможность исследования логики выполнения кода в зависимости от различных ситуаций и включает в себя:\n\n- **_Тестирование на основе выражений (Statement testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется корректность (и сам факт) выполне- ния отдельных выражений в коде.\n\n- **_Тестирование на основе ветвей (Branch testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных ветвей кода (под ветвью понимается атомарная часть кода, выполнение которой происходит или не происходит в зависимости от истинности или ложности некоторого условия).\n\n- **_Тестирование на основе условий (Condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных условий (условием считается выражение, которое может быть вычислено до значения «истина» или «ложь»).\n\n- **_Тестирование на основе комбинаций условий(Multiple condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных (составных) условий.\n\n- **_Тестирование на основе отдельных условий, порождающих ветвление («решающих условий») (Modified condition decision coverage testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение таких отдельных условий в составе сложных условий, которые в одиночку определяют результат вычисления всего сложного условия.\n\n- **_Тестирование на основе решений (decision testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных ветвлений (с двумя и более возможными вариантами). Несмотря на то что «два варианта» сюда также подходит, формально такую ситуацию стоит отнести к тестированию на основе условий.\n\n- **_Тестирование на основе путей (path testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение всех или некоторых специально выбранных путей в коде приложения.\n\nЕсли говорить строго научно, то определения большинства видов тестирования на основе структур кода должны звучать чуть-чуть иначе, т.к. в программировании условием считается выражение без логических операторов, а решением — выражение с логическими операторами. Но глоссарий ISTQB не делает на этом акцента, а потому приведённые выше определения можно считать корректными.\n\n## Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)\n### Тестирование по таблице принятия решений (Decision table testing)\nтехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе т.н. таблицы принятия решений, в которой отражены входные данные (и их комбинации) и воздействия на приложение, а также соответствующие им выходные данные и реакции приложения.\n\n### Тестирование по диаграмме или таблице состояний\n\n### Тестирование по спецификациям (Specification-based testing, black box testing)\n\n### Тестирование по моделям поведения приложения (Model-based testing)\nТехника тестирования, в которой исследование приложения (и разработка тест-кейсов) строится на некой модели: таблице принятия решений, таблице или диаграмме состояний, пользовательских сценариев, модели нагрузки и т. д.\n\n### Тестирование на основе вариантов использования (Use case testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе вариантов использования. Варианты использования выступают в основном источником информации для шагов тест-кейса, в то время как наборы входных данных удобно разрабатывать с помощью техник выбора входных данных. \n\nВ общем случае источником информации для разработки тест-кейсов в этой технике могут выступать не только варианты использования, но и другие пользовательские требования в любом их виде. \n\nВ случае если методология разработки проекта подразумевает использование пользовательских историй, этот вид тестирования может быть заменён тестированием на основе пользовательских историй (user story testing).\n\n### Параллельное тестирование (Parallel testing)\nТехника тестирования, в которой поведение нового (или модифицированного) приложения сравнивается с поведением эталонного приложения (предположительно работающего верно). \n\nТермин «параллельное тестирование» также может использоваться для обозначения способа проведения тестирования, когда несколько тестировщиков или систем автоматизации выполняют работу одновременно, т. е. параллельно. Очень редко (и не совсем верно) под парал- лельным тестированием понимают мутационное тестирование.\n\n### Тестирование на основе случайных данных (Random testing)\nТехника тестирования (по методу чёрного ящика), в которой входные данные, действия или даже сами тест-кейсы выбираются на основе (псевдо)случайных значений так, чтобы соответствовать операционному профилю (operational profile) — подмножеству действий, соответствующих некоей ситуации или сценарию работы с приложением. Не стоит пу- тать этот вид тестирования с т.н. «обезьяньим тестированием» (monkey testing).\n\n### A/B-тестирование (A/B testing, Split testing)\nТехника тестирования, в которой исследуется влияние на результат выполнения операции изменения одного из входных параметров. Однако куда чаще можно встретить трактовку A/B-тестирования как технику тестирования удобства использования, в которой пользователям случайным образом предлагаются разные варианты элементов интерфейса, после чего оценивается разница в реакции пользователей.\n\n## Тестирование на основе дерева классификаций(Classification tree method)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе иерархически организованных наборов эквивалентных входных и выходных данных.\n\n## Тестирование на основе синтаксиса (Syntax testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе определения наборов входных и выходных данных.\n\n## Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)\nСпособ выбрать подходящий набор комбинаций тестовых данных для достижения установленного уровня тестового покрытия в случае, когда проверка всех возможных наборов значений тестовых данных невозможна за имеющееся время. \n\nСуществуют следующие комбинаторные техники:\n- Тестирование всех комбинаций (All combinations testing)\nтестирование всех воз- можных комбинаций всех значений всех тестовых данных (например, всех параметров функции).\n\n- Попарное тестирование\n\n- Тестирование с выбором значений-представителей (Each choice testing)\nтестирование, при котором по одному значению из каждого набора тестовых данных должно быть использовано хотя бы в одном тест-кейсе.\n\n- Тестирование с выбором базового набора значений (Base choice testing)\nтестирование, при котором выделяется набор значений (базовый набор), который используется для проведения тестирования в первую очередь, а далее тест-кейсы строятся на основе выбора всех базовых значений, кроме одного, которое заменяется значением, не входящим в базовый набор.\n\n## Тестирование по графу причинно-следственных связей (Cause-effect graphing)\nтех- ника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе графа причинно-следственных связей (графического представления входных дан- ных и воздействий со связанными с ними выходными данными и эффектами).\n\n## Тестирование по потоку данных (Data-flow testing)\nсемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных. \n\nЭти техники позволяют обнаружить такие ситуации, как: \n- переменная определена, но нигде не используется;\n- переменная используется, но не определена; \n- переменная определена несколько раз до того, как она используется;\n- переменная удалена до последнего случая использования.\n\nЗдесь придётся немного погрузиться в теорию. Над переменной в общем случае может выполняться несколько действий (покажем на примере переменной x):\n- объявление (declaration): `int x;`\n- определение (definition, d-use): `x = 99;`\n- использование в вычислениях (computation use, c-use): `z = x + 1;` \n- использование в условиях (predicate use, p-use): `if (x > 17) { ... }; - удаление (kill, k-use): x = null;`\n\nТеперь можно рассмотреть техники тестирования на основе потока данных.\n\n- **_Проверка использования всех объявлений (All-definitions testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от её определения к её использованию в вычислениях или условиях.\n\n- **_Проверка всех вычислений на основе всех объявлений (All-c-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в вычислениях.\n\n- **_Проверка всех ветвлений на основе всех объявлений (All-p-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в условиях.\n\n- **_Проверка всех вычислений и ветвлений на основе всех объявлений (All-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует хотя бы один путь от каждого её определения к каждому её использованию в вычислениях и в условиях.\n\n- **_Проверка использования всех объявлений и всех путей без переобъявлений (без циклов или с однократными повторениями циклов) (All-du-paths testing)_**\nТестовым набором для каждой переменной проверяются все пути от каждого её определения к каждому её использованию в вычислениях и в условиях (самая мощная стратегия, которая в то же время требует наибольшего количества тест-кейсов).","description":"Виды тестирования по техникам и подходам","image":"null","category":{"id":"manual","title":"manual","path":"/category/manual/"},"date":"16/05/2022","path":"/vidy-testirovaniya-po-tehnikam-i-podhodam/","links":[{"title":"","items":[{"title":"10. Виды тестирования","link":"/vidy-testirovaniya/"},{"title":"Классификация по запуску кода на исполнение","link":"/vidy-testirovaniya-po-zapusku-koda-na-ispolnenie/"},{"title":"Классификация по доступу к коду и архитектуре приложения","link":"/vidy-testirovaniya-po-dostupu-k-kodu-i-arhitekture-prilozheniya/"},{"title":"Классификация по степени автоматизации","link":"/vidy-testirovaniya-po-stepeni-avtomatizaczii/"},{"title":"Классификация по уровню деталиции приложения (по уровню тестирования)","link":"//vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/"},{"title":"Классификация по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)","link":"/vidy-testirovaniya-po-ubyvaniyu-stepeni-vazhnosti-testiruemyh-funkczij-po-urovnyu-funkczionalnogo-testirovaniya/"},{"title":"Классификация по принципам работы с приложением","link":"/vidy-testirovaniya-po-princzipam-raboty-s-prilozheniem/)"},{"title":"Классифкация по природе приложения","link":"/vidy-testirovaniya-po-prirode-prilozheniya/"},{"title":"Классификация по фокусировке на уровне архитектуры приложения","link":"/vidy-testirovaniya-po-fokusirovke-na-urovne-arhitektury-prilozheniya/"},{"title":"Классификация по привлечению конечных пользователей","link":"/vidy-testirovaniya-po-privlecheniyu-konechnyh-polzovatelej/"},{"title":"Классификация по степени формализации","link":"/vidy-testirovaniya-po-stepeni-formalizaczii/"},{"title":"Классификация по целям и задачам","link":"/vidy-testirovaniya-po-czelyam-i-zadacham/"},{"title":"Классификация по техникам и подходам","link":"/vidy-testirovaniya-po-tehnikam-i-podhodam/"},{"title":"Классификация по моменту выполнения (хронологии)","link":"/vidy-testirovaniya-po-momentu-vypolneniya-hronologii/"},{"title":"Другие виды тестирования","link":"/drugie-vidy-testirovaniya/"}]}],"headings":[{"value":"Классификация по принципам работы с приложением","anchor":"#классификация-по-принципам-работы-с-приложением"},{"value":"Тестирование на основе опыта тестировщика, сценариев, чек-листов","anchor":"#тестирование-на-основе-опыта-тестировщика-сценариев-чек-листов"},{"value":"Классификация по степени вмешательства в работу приложения","anchor":"#классификация-по-степени-вмешательства-в-работу-приложения"},{"value":"Классификация по техникам автоматизации:","anchor":"#классификация-по-техникам-автоматизации"},{"value":"Классификация на основе(знания) источников ошибок","anchor":"#классификация-на-основезнания-источников-ошибок"},{"value":"Классификация на основе выбора входных данных или спецификаций","anchor":"#классификация-на-основе-выбора-входных-данных-или-спецификаций"},{"value":"Классификация на основе среды выполнения","anchor":"#классификация-на-основе-среды-выполнения"},{"value":"Тестирование на основе кода (Code based testing)","anchor":"#тестирование-на-основе-кода-code-based-testing"},{"value":"Тестирование на основе структур кода (Structure-based techniques)","anchor":"#тестирование-на-основе-структур-кода-structure-based-techniques"},{"value":"Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)","anchor":"#тестирование-на-основе-моделей-поведения-приложения-application-behaviormodel-based-testing"},{"value":"Тестирование на основе дерева классификаций(Classification tree method)","anchor":"#тестирование-на-основе-дерева-классификацийclassification-tree-method"},{"value":"Тестирование на основе синтаксиса (Syntax testing)","anchor":"#тестирование-на-основе-синтаксиса-syntax-testing"},{"value":"Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)","anchor":"#комбинаторные-техники-или-комбинаторное-тестирование-combinatorial-testing"},{"value":"Тестирование по графу причинно-следственных связей (Cause-effect graphing)","anchor":"#тестирование-по-графу-причинно-следственных-связей-cause-effect-graphing"},{"value":"Тестирование по потоку данных (Data-flow testing)","anchor":"#тестирование-по-потоку-данных-data-flow-testing"}],"subtitles":[{"depth":2,"value":"Классификация по принципам работы с приложением","anchor":"#классификация-по-принципам-работы-с-приложением"},{"depth":2,"value":"Тестирование на основе опыта тестировщика, сценариев, чек-листов","anchor":"#тестирование-на-основе-опыта-тестировщика-сценариев-чек-листов"},{"depth":2,"value":"Классификация по степени вмешательства в работу приложения","anchor":"#классификация-по-степени-вмешательства-в-работу-приложения"},{"depth":3,"value":"Инвазивное тестирование (Intrusive testing)","anchor":"#инвазивное-тестирование-intrusive-testing"},{"depth":3,"value":"Неинвазивное тестирование (Nonintrusive testing)","anchor":"#неинвазивное-тестирование-nonintrusive-testing"},{"depth":2,"value":"Классификация по техникам автоматизации:","anchor":"#классификация-по-техникам-автоматизации"},{"depth":3,"value":"Тестирование под управлением данными ( Data-driven testing)","anchor":"#тестирование-под-управлением-данными--data-driven-testing"},{"depth":3,"value":"Тестирование под управлением ключевыми словами (Keyword-driven testing)","anchor":"#тестирование-под-управлением-ключевыми-словами-keyword-driven-testing"},{"depth":3,"value":"Тестирование под управлением поведением (Behavior-driven testing)","anchor":"#тестирование-под-управлением-поведением-behavior-driven-testing"},{"depth":2,"value":"Классификация на основе(знания) источников ошибок","anchor":"#классификация-на-основезнания-источников-ошибок"},{"depth":3,"value":"Тестирование предугадыванием ошибок (Error guessing)","anchor":"#тестирование-предугадыванием-ошибок-error-guessing"},{"depth":3,"value":"Эвристическая оценка (Heuristic evaluation)","anchor":"#эвристическая-оценка-heuristic-evaluation"},{"depth":3,"value":"Мутационное тестирование (Mutation testing)","anchor":"#мутационное-тестирование-mutation-testing"},{"depth":3,"value":"Тестирование добавлением ошибок (Error seeding)","anchor":"#тестирование-добавлением-ошибок-error-seeding"},{"depth":2,"value":"Классификация на основе выбора входных данных или спецификаций","anchor":"#классификация-на-основе-выбора-входных-данных-или-спецификаций"},{"depth":3,"value":"Тестирование на основе классов эквивалентности (Equivalence partitioning)","anchor":"#тестирование-на-основе-классов-эквивалентности-equivalence-partitioning"},{"depth":3,"value":"Тестирование на основе граничных условий (Boundary value analysis)","anchor":"#тестирование-на-основе-граничных-условий-boundary-value-analysis"},{"depth":3,"value":"Доменное тестирование (Domain analysis, Domain testing)","anchor":"#доменное-тестирование-domain-analysis-domain-testing"},{"depth":3,"value":"Попарное тестирование (Pairwise testing)","anchor":"#попарное-тестирование-pairwise-testing"},{"depth":3,"value":"Тестирование на основе ортогональных массивов (Orthogonal array testing)","anchor":"#тестирование-на-основе-ортогональных-массивов-orthogonal-array-testing"},{"depth":2,"value":"Классификация на основе среды выполнения","anchor":"#классификация-на-основе-среды-выполнения"},{"depth":3,"value":"Тестирование в процессе разработки (Development testing)","anchor":"#тестирование-в-процессе-разработки-development-testing"},{"depth":3,"value":"Операционное тестирование","anchor":"#операционное-тестирование"},{"depth":2,"value":"Тестирование на основе кода (Code based testing)","anchor":"#тестирование-на-основе-кода-code-based-testing"},{"depth":2,"value":"Тестирование на основе структур кода (Structure-based techniques)","anchor":"#тестирование-на-основе-структур-кода-structure-based-techniques"},{"depth":2,"value":"Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)","anchor":"#тестирование-на-основе-моделей-поведения-приложения-application-behaviormodel-based-testing"},{"depth":3,"value":"Тестирование по таблице принятия решений (Decision table testing)","anchor":"#тестирование-по-таблице-принятия-решений-decision-table-testing"},{"depth":3,"value":"Тестирование по диаграмме или таблице состояний","anchor":"#тестирование-по-диаграмме-или-таблице-состояний"},{"depth":3,"value":"Тестирование по спецификациям (Specification-based testing, black box testing)","anchor":"#тестирование-по-спецификациям-specification-based-testing-black-box-testing"},{"depth":3,"value":"Тестирование по моделям поведения приложения (Model-based testing)","anchor":"#тестирование-по-моделям-поведения-приложения-model-based-testing"},{"depth":3,"value":"Тестирование на основе вариантов использования (Use case testing)","anchor":"#тестирование-на-основе-вариантов-использования-use-case-testing"},{"depth":3,"value":"Параллельное тестирование (Parallel testing)","anchor":"#параллельное-тестирование-parallel-testing"},{"depth":3,"value":"Тестирование на основе случайных данных (Random testing)","anchor":"#тестирование-на-основе-случайных-данных-random-testing"},{"depth":3,"value":"A/B-тестирование (A/B testing, Split testing)","anchor":"#ab-тестирование-ab-testing-split-testing"},{"depth":2,"value":"Тестирование на основе дерева классификаций(Classification tree method)","anchor":"#тестирование-на-основе-дерева-классификацийclassification-tree-method"},{"depth":2,"value":"Тестирование на основе синтаксиса (Syntax testing)","anchor":"#тестирование-на-основе-синтаксиса-syntax-testing"},{"depth":2,"value":"Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)","anchor":"#комбинаторные-техники-или-комбинаторное-тестирование-combinatorial-testing"},{"depth":2,"value":"Тестирование по графу причинно-следственных связей (Cause-effect graphing)","anchor":"#тестирование-по-графу-причинно-следственных-связей-cause-effect-graphing"},{"depth":2,"value":"Тестирование по потоку данных (Data-flow testing)","anchor":"#тестирование-по-потоку-данных-data-flow-testing"}],"tags":[{"id":"Виды тестирования","title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}]},"comments":{"edges":[]}},"context":{}}