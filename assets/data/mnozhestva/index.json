{"hash":"7ef89d9cd3f6579eddc6e6b2d3ffbd18a73c2491","data":{"post":{"title":"Множества","content":"\n## Как устроено множество\n\nМножество - это математическая структура, где каждый элемент либо есть, либо его нету.\n\nЧто должно уметь делать множество:\n\n- добавлять элемент\n- проверять наличие элемента\n- удалять элемент\n\n### Как реализовать множество\n\n- Придумаем какую-нибудь функцию которая сопоставляет каждому элементу какое-либо небольшое число\n- Вычислим функцию от элемента\n- Положим элемент в список с номером, равным значению фуекции\n\nСпособ 1: Завести массив где в ячейку с индексом равным числу которое мы кладем класть boolean переменную true что такое число есть. При удалении менять на false. Но тогда если множество будет большим это будет есть большое количество памяти а если таких множеств несколько то съест еще больше.\n\nСпособ 2: Чтобы поместить большое количество элементов в сравнительно небольшой массив нужно сопоставить каждому элементу какое-либо небольшое число. Для этого сформируем соответсвующую функцию. \n\n### Пример функции добавления для чисел\n\n- Функция - последняя цифра числа $X (F(X) = X \\% 10)$. \nФункция которая переводит большие числа в маленькие  - хеш функция.\n- Вычислим функцию от элемента.\n- Положим элемент в список с номером, равным значению функции.\n\nНапример, наша функция преобразует число 137 -> 7 и  17 -> 7. Такая ситуация называется **коллизией**.\nЕсли мы будем класть в ячейку true/false то когда мы получим число 137 мы положим в ячейку с номером 7 флаг true и когда нас запросят узнать есть ли в множестве число 17 мы скажем что да а это неверно.\n\nОдним из решений этой проблемы - класть в ячейку не флаг а само число. Но в таком виде множество не может одновременно хранить в себе значения и 137 и 17 и т.д. \n\nРешением стало - завести список для всех чисел которые имеют одинаковый хеш. \n\nЕсли у нас множество длины N и внем лежит K элементов, то мы можем перебрать все элементов за N + K. Мы будем идти по всем спискам пока список пустой мы его пропускаем, а как только обнаруживаем непустой список у нас запускается внутренний цикл проходит по всем элементам и их возвращает.\n\nЕсли мы решим напечатать значения Set'a, то оно выводся в произвольном порядке (в порядке возрастания значения хеш функции).\n\nДля того чтобы удалить элемент мы сначала находим значение хеш функции находим ячейку с этим знаением и в найденном списке находим нужный элемент. \nУдаление-1: мы перемещаем элементы  на 1 позицию влево, начиная с позиции того элемента который хотим удалить и последний элемент удаляем. \nУдаление-2: копируем последний элемент на место элемента который удаляем и удаляем самый последний это возможно когда не важен порядок элементов.\nУдаление элемента происходит $O(1)$ а его поиск за $O(K/N)$.\n\n```java\npublic class MySet {\n\n    int setSize = 10;\n    int[][] mySet = new int[setSize][];\n\n\n    public void add(int x) {\n        int[] xSet = mySet[x % 10];\n        if (xSet == null) {\n            mySet[x % 10] = new int[]{x};\n        } else {\n            mySet[x % 10] = ArrayUtils.add(xSet, x);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"MySet{\" +\n                \"setSize=\" + setSize +\n                \", mySet=\" + Arrays.toString(mySet) +\n                '}';\n    }\n\n    public boolean find(int x) {\n        for (int now : mySet[x % 10]) {\n            if (now == x) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void delete(int x) {\n        int[] xList = mySet[x % 10];\n        for (int i = 0; i < xList.length; i++) {\n            int now = xList[i];\n            if (now == x) {\n                xList[i] = xList[xList.length - 1];\n                mySet[x % 10] = ArrayUtils.remove(xList, xList.length - 1);\n                return;\n            }\n        }\n    }\n}\n```\n\nМультимножество - такое множество в которое элемент входит несколько раз.\nЧтобы такого не допускать в методе добавления элемента стоит добавить проверку что такого элемента еще нет.\n\n$F(X) = X \\% setSize$ - хеш функция\n\n$MySet$ - хеш таблица\n\nСовпадение значений хеш-функции для разных параметров - коллизия.\n\n### Что можно эффективно хранить в множестве\n\n- Эффективно можно хранить только неизменяемые объекты.\n- Для неизменяемых объектов можно посчитать значение хеш-функции при их создании\n- Хеш функция должна давать равномерное распределение\n\n## Амортизированная сложность\n\nСлишком большой размер - ест много памяти $O(N)$\n\nСлишком маленький размер - большой коэфициент заполнения и медленный поиск и удаление $O(K/N)$\n\nХочется иметь разумный баланс, например, коэфициент заполнения не больше единицы (т.е. $K<=N$)\nТогда все операции в среднем будут занимать $O(1)$\n\nРешение проблемы: Когда таблица наполнится - увеличим ее размер вдвое и перестроим. Нужно пересчитать хеш каждого элемента в зависимости от нового размера и переместить элементы в соответсвующую ячейку.\n\nАмортизированная сложность - это среднее время выполнения опреации (условно).\n\nУ нас амортизированная сложность операции $O(1)$ - всего было N операций и суммарно на это ушло $O(N)$.\n\nВ худшем случае отдельная операция выполняется за $O(N)$ - может не подходить для систем реального времени.\n\n## Примеры задач\n\n### Задача 1. \nПереберем число А за $O(N)$. Переберем число B за $O(N)$. Если их сумма равна X, то вернем эту пару.\n\nРешение 1 (неправильное)\n\nНеправильное, так как не учитывает, что числа должны быть разные.\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int a : nums) {\n        for (int b : nums) {\n            if (a + b == sum) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\nРешение (исправленное)\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == sum) {\n                return new int[]{nums[i], nums[j]};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\n### Задача 2\nДан словарь из N слов, длина каждого не превосходит K. \nВ записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущеной буквой) в словарь.\n\n","description":"Множества","image":"null","category":null,"date":"24/07/2022","path":"/mnozhestva/","links":[{"title":"","items":[{"title":"Алгоритмы (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Сложность, тестирование, особые случаи","link":"/slozhnost-testirovanie-osobye-sluchai/"},{"title":"Линейный поиск","link":"/linejnyj-poisk/"},{"title":"Множества","link":"/mnozhestva/"},{"title":"Словари и сортировка подсчётом","link":"/slovari-i-sortirovka-podschyotom/"},{"title":"Префиксные суммы и два указателя","link":"/prefiksnye-summy-i-dva-ukazatelya/"},{"title":"Бинарный поиск","link":"/binarnyj-poisk/"},{"title":"Сортировка событий","link":"/sortirovka-sobytij/"},{"title":"Деревья","link":"/derevya/"}]}],"headings":[{"value":"Как устроено множество","anchor":"#как-устроено-множество"},{"value":"Амортизированная сложность","anchor":"#амортизированная-сложность"},{"value":"Примеры задач","anchor":"#примеры-задач"}],"subtitles":[{"depth":2,"value":"Как устроено множество","anchor":"#как-устроено-множество"},{"depth":3,"value":"Как реализовать множество","anchor":"#как-реализовать-множество"},{"depth":3,"value":"Пример функции добавления для чисел","anchor":"#пример-функции-добавления-для-чисел"},{"depth":3,"value":"Что можно эффективно хранить в множестве","anchor":"#что-можно-эффективно-хранить-в-множестве"},{"depth":2,"value":"Амортизированная сложность","anchor":"#амортизированная-сложность"},{"depth":2,"value":"Примеры задач","anchor":"#примеры-задач"},{"depth":3,"value":"Задача 1.","anchor":"#задача-1"},{"depth":3,"value":"Задача 2","anchor":"#задача-2"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"алгоритмы","title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}]},"comments":{"edges":[]}},"context":{}}