{"hash":"7783b48d4c1d73fdd39dd248e548414e3a71e66c","data":{"tag":{"title":"java","path":"/tag/java/","belongsTo":{"totalCount":22,"pageInfo":{"totalPages":3,"currentPage":1},"edges":[{"node":{"id":"3be64faa1fe9afd96ff0c811fa66f4b8","title":"Code Style","content":"\nqwerty","date":"2023-05-21T00:00:00.000Z","path":"/code-style/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"code style","path":"/tag/code%20style/"},{"title":"java","path":"/tag/java/"}],"headings":[]}},{"node":{"id":"5747b944f0af5ac4fbdcc63d1a76ed8f","title":"Алгоритмы (курс Тинькофф)","content":"\n## Асимптотический анализ\nИспользуется для оценки алгоритмов. Оценивается не то сколько алгоритм работает на конкретных данных, а то сколько алгоритм работает в зависимости от размера входа (объема данных). \n\nT(n) - сколько времени работает алгоритм на входе какого-то размера n.\n\n### В чем измерить сколько работает программа?\nНужно посчитать количество действий которые выполняет программа, колисество read/write операций. \n\n### RAM(Random Access Memory) - модель \nИмеет следующие правила:\n- К любой ячейке памяти можно за O(1) обратиться(read) и за O(1) записать что-то(write).\n\nБазовыми операциями, которыми можно вычислять скорость - это опреации read, write.\n\n$O(n)$ - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **ниже**, чем график функции, которая ее определяет - оценка сверху. (условно худшая скорость)\n\n$\\Omega(n)$ - оценка снизу - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **выше**, чем график функции, которая ее определяет - оценка снизу.\n\n$\\Theta(n)$ - если одновременно выполняются условия  $O(n)$ и $\\Omega(n)$\n\n\n\n\n\nhttps://www.youtube.com/watch?v=1cXq7F3ijxM&list=PLjCCarnDJNssC82zhyeg8BxfhPG3b8iZ2\n","date":"2022-07-24T00:00:00.000Z","path":"/algoritmy-kurs-tinkoff/","icon":"fas fa-code","image":"null","order":null,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"}],"headings":[{"value":"Асимптотический анализ","anchor":"#асимптотический-анализ"}]}},{"node":{"id":"8e8b9ac6c819939f0b5118e99f672242","title":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\"","content":"\n## Что такое алгоритм?\n\nНабор инструкций для выполнения некоторой задачи.\n\n## $О$-большое\n\nСпециальная нотация которая описывает скорость выполнения алгоритма, а именно показывает с какой скоростью растет время выполнения алгоритма при увеличении входных данных.  \n\n$О$-большое не сообщает скорость в секундах а позволяет сравнить количество операций.  \n$О$-большое определяет время выполнения в худшем случае.\n\n#### Разновидности:\n- $O(1)$ - постоянное время\n- $O(log(n))$ - логарифмическое время. Пример: _бинарный поиск_\n- $O(n)$ - линейное время. Пример: _простой поиск_\n- $O(n * log(n))$ - Пример: _эффективные алгоритмы_\n- $O(n^2)$ - Пример: _медленные алгоритмы сортировки (сортировка выбором)_\n- $O(n!)$ - Пример: _очень медленные алгоритмы (задача о коммивояжере)_\n\n## Линейный поиск\n\nПроходим по массиву и при нахождении первого элемента с искомым значением возвращаем его индекс. \n\n\n```java\nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = lineSearch(arr, 12);\nSystem.out.println(index);\nSystem.out.println(arr[index]);\n```\n\n```java\nstatic int lineSearch(int[] arr, int key) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == key) {\n            return i;\n        }\n    }\n    \n    // return -1\n    throw new RuntimeException(\"Key '\" + key + \"' is not found!\");\n}\n```\n\n**Сложность алгоритма** - $O(n)$.  \nСкорость каждой итерации $O(1)$.  \nВ худшем случай $n$ итераций.  \n\n## Бинарный поиск\n\n- работает когда список отсортирован\n\nАналогично поиску слова в словаре.\n\n#### Реализация через цикл:\n\n```java\nstatic int binarySearch(int[] arr, int key) {\n    int low = 0;\n    int high = arr.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (key < arr[mid]) {\n            high = mid - 1;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n#### Реализация через рекурсию:\n\n```java \nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = binarySearch(arr, 12, 0, arr.length - 1);\n```\n\n```java\nstatic int binarySearch(int[] arr, int key, int low, int high) {\n    int mid = low + (high - low) / 2;\n    if (high < low) {\n        return -1;\n    }\n    if (arr[mid] == key) {\n        return mid;\n    } else if (key < arr[mid]) {\n        return binarySearch(arr, key, low, mid - 1);\n\n    } else {\n        return binarySearch(arr, key, mid + 1, high);\n    }\n}\n```\n\n**Сложность алгоритма** - $O({log_{2}(n)})$.  \n\n${log_{2}(n)} = k$   \n$k$ - в какую степень надо возвести 2, чтобы получить n   \n\n$n={2^k}$\n\n- если число n - не степень двойки, то выбирается такое наименьшее k, что $2^k > n$.\n\n- $O({log_{2}(n)})$ лучше чем O(n).\n\n## Сортировка выбором\n\n```java\npublic static void main(String args[]) throws Exception {\n    int[] arr = {64, 42, 73, 41, 32, 53, 16, 24, 57, 42, 74, 55, 36};\n    System.out.println(Arrays.toString(selectionSort(arr)));\n}\n```\n\n```java\nstatic int[] selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        int ind = smallest(arr, i);\n        int temp = arr[i];\n        arr[i] = arr[ind];\n        arr[ind] = temp;\n    }\n    return arr;\n}\n\nstatic int smallest(int[] arr, int start) {\n    int index = start;\n    int smallest = arr[start];\n    for (int i = start; i < arr.length; i++) {\n        if (arr[i] < smallest) {\n            smallest = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n```\n\n**Сложность алгоритма** - $O(n^2)$.  \n\n\n## Рекурсия\n\n- Каждая рекурсивная функция состоит из двух частей:\n    - рекурсивного случая - функция вызывает сама себя\n    - базового случая - функция себя не вызывает, чтобы предотвратить зацикливание\n\n```java\n static int factorial(int n) {\n    if (n == 1) {\n        return n;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\n\n## Стратегия \"Разделяй и властвуй\"\n\nДанная стратегия состоит из двух шагов:\n\n1. Определяется базовый случай - простейший случай из всех возможных.\n2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.\n\nСтратегия \"Разделяй и властвуй\" - это не алгоритм, это подход к решению задачи.\n\n#### Пример:\nИмеется массив `{2, 4, 6}`. Нужно просуммировать все числа и вернуть сумму. \n\n\n```java\nstatic int sum(int[] arr) {\n    if (arr.length == 0) {\n        return 0;\n    } else if (arr.length == 1) {\n        return arr[0];\n    } else {\n        int[] newArr = Arrays.copyOfRange(arr, 1, arr.length);\n        return arr[0] + sum(newArr);\n    }\n}\n```\n\n> Если в рекурсивной функции используется массив, то базовым случаем чаще всего оказывается либо пустой массив, либо массив из одного элемента.\n\n\n## Быстрая сортировка\n\n- Работает быстрее сортировки выбором.\n- Основана на стратегии \"Разделяй и властвуй\"\n\n\nБазовый случай: массивы с одним элементом или пустой массив  \n\n#### Шаги рекурсивного случая:  \n1. Выбрать опорный элемент.\n2. Разделить массив на два подмассива:\n    - элементы, **меньшие** опрного \n    - элементы, **большие** опорного\n\n\n```java\npublic static void quickSort(int[] arr, int from, int to) {\n    if (from < to) {\n\n        int divideIndex = partition(arr, from, to);\n\n        quickSort(arr, from, divideIndex - 1);\n\n        quickSort(arr, divideIndex, to);\n    }\n}\n\nprivate static int partition(int[] arr, int from, int to) {\n    int rightIndex = to;\n    int leftIndex = from;\n\n    int pivot = arr[from + (to - from) / 2];\n    while (leftIndex <= rightIndex) {\n\n        while (arr[leftIndex] < pivot) {\n            leftIndex++;\n        }\n\n        while (arr[rightIndex] > pivot) {\n            rightIndex--;\n        }\n\n        if (leftIndex <= rightIndex) {\n            swap(arr, rightIndex, leftIndex);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return leftIndex;\n}\n\nprivate static void swap(int[] array, int index1, int index2) {\n    int tmp  = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n```\n\n## Хеш-таблицы\n\n**Хеш-функция** представляет собой функцию которая получает строку[^Под \"строкой\" понимаются любые данные - последовательность байтов.] и возвращает число.\nХеш функция должна соответствовать требованиям:\n- Она должна быть последовательной. Всегда возвращать одинаковое число на одну и ту же строку.\n- Разным словам должны соотвествовать разные числа.\n\nМассив который хранит элементы при помощи хеш-функций называется **хеш-таблицей**. Их также называют \"ассоциативным массивом\", \"словарем\", \"отображением\", \"хеш картой\" или просто \"хеш\".\nХеш таблицы упрощают моделировние отношений между объектами.\n\n```java\nHashMap<String, Double> book = new HashMap();\nbook.put(\"apple\", 0.67);\nbook.put(\"milk\", 1.49);\nbook.put(\"avocado\", 1.49);\nSystem.out.println(book.get(\"avocado\"));\n```\n\nХеши подходят для решения следующих задач:\n- моделирование отношений между объектами;\n- устранение дубликатов;\n- кеширование/запоминание данных вместо выполнения работы на сервере.\n\n## Коллизии\n\nСитуация когда несколько элементов по хешу попадают в одну и туже ячейку[^Двум ключам назначается один элемент массива].\n\n#### Одна из стратегий обработки коллизий:\n> Если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.\nНо если все элементы попадают в одну ячейку и содержатся в одном связанном списке то работа с данными замедляется.\n\nОтсюда следует:\n- _Выбор хеш-функции действительно важен._ В идеале хеш функция должна распределять ключи равномерно по всему хешу.\n- Если связанные списки становятся слишком длинными, то работа с хеш-таблицей сильно замедлится. \nНо они не станут длинными _при использовании хорошей хеш-функции_!\n\nДля предотвращения коллизий необходимы:\n- низкий коэфициент заполнения;\n- хорошая хеш-функция;\n\n## Поиск в ширину\n\nАлгоритм для решения задачи поиска кратчайшего пути называется **_поиском в ширину_**.\n\n## Граф\n\nГраф моделирует набор связей. Каждый граф строится из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называют _соседями_.\n\n![Иллюстрация графа](/images/graph_illustration.png)\n\nАлгоритм поиска в ширину может ответить на 2 вопроса:\n\n1. существует ли путь от узла А к узлу В?\n2. как выглядит кратчайший путь от узла А к узлу В?\n\n> Связи первого уровня добавляются в список поиска раньше связей второго уровня и т.д.  \n\n> Проверять связи необходимо в порядке их добавления. Для операций такого рода есть специальная структура данных, называемая **_очередью_**.\n\n## Очередь\n\nДля этой структуры данных доступно только две операции:\n- постановка в очередь;\n- извлечение из очереди;\n\nЭлементы добавленные в очередь первыми, первыми же будут из нее извлечены.\n\n> <u>Очередь</u> относится к категории структур данных FIFO: _First In, First Out_ (\"первым вошел, первым вышел\").\n\n> А <u>стек</u> принадлежит к категории LIFO: _Last In, First Out_ (\"последним вошел, первым вышел\").\n\n## Реализация графа\n\nГраф можно реализовать с помощью хеш-таблицы. В хеш таблице ключ связан со значением, а в нашем случае узел должен быть связан с соседями.\n\n```java\nHashMap<String, String[]> book = new HashMap();\nString[] siblings = {\"alice\", \"bob\", \"claire\"};\nbook.put(\"you\", siblings);\n```\n\nРазличают _направленный_ и _ненаправленный_ граф.  \n**_Направленный граф (ориентированный, орграф)_** - это граф в котором отношения действуют только в одну сторону.  \n**_Ненаправленный граф (неориентированный, неорграф)_** - направления отношений нет и каждый из узлов является соседом друг к другу.\n\n![Виды графов](/images/graph_types.png)\n\nАлгоритм графа:\n1. Создать очередь\n2. Извлечь из очереди первый элемент\n3. Выполнить поисковую проверку \n4. Если элемент соотвествует поиску закончить проверку, если нет то добавить всех соседей данного элемента в очередь\n5. Повторить шаги пока не закончится очередь либо элемент удолетворяющий поиску не будет найден.\n\n> Однако, если элемент встречается в двух и более списках, то он будет проверяться дважды, либо может войти в цикл.  \nЧтобы избежать такого поведения необходимо добавить список, в который помещаются уже проверенные элементы.\n\n\n```java\npublic static void main(String[] args) {\n    HashMap<String, String[]> all = new HashMap();\n    String[] siblings = {\"alice\", \"bob\", \"claire\"};\n    String[] claireSiblings = {\"jack\", \"steve\", \"bob\"};\n    String[] bobSiblings = {\"claire\", \"damon\"};\n    all.put(\"you\", siblings);\n    all.put(\"claire\", claireSiblings);\n    all.put(\"bob\", bobSiblings);\n\n    ArrayDeque<String> searchDeque = new ArrayDeque();\n    searchDeque.addAll(Arrays.asList(all.get(\"you\")));\n    if (!searchMangoSeller(all, searchDeque)) {\n        throw new RuntimeException(\"Mango seller is not found!\");\n    }\n}\n\nstatic boolean searchMangoSeller(HashMap<String, String[]> all,\n                                    ArrayDeque<String> searchDeque) {\n    ArrayList<String> searched = new ArrayList();\n    while (!searchDeque.isEmpty()) {\n        String person = searchDeque.pop();\n        if (!searched.contains(person)) {\n            if (isSeller(person)) {\n                System.out.println(person + \" is a mango seller!\");\n                return true;\n            } else {\n                String[] siblings = all.get(person);\n                if (siblings != null) {\n                    searchDeque.addAll(Arrays.asList(siblings));\n                }\n                searched.add(person);\n            }\n        }\n    }\n    return false;\n}\n\nstatic boolean isSeller(String person) {\n    return person.charAt(person.length() - 1) == 'n';\n}\n```\n\n#### Время выполнения: \nЕсли поиск выполнен по всей сети то значит вы прошли по каждому ребру $O(количество\\:ребер)$.  \nТакже в программе должна храниться очередь поиска. Добавление каждого человека потребует $O(количество\\:людей)$.\nВ итоге поиск в ширину займет $O(количество\\:людей + количество\\:ребер)$, что обычно записывается как $O(V+E)$, _V - кол-во вершин, E - кол-во ребер_.\n\n## Алгоритм Дейкстры\n\nАлгоритм поиска в ширину находит путь, состоящий из меньшего количества сегментов. Но если нужно найти наименьший путь с учетом определеных характеристик, то эту задачу решает **Алгоритм Дейкстры**.\n\nАлгоритм Дейкстры состоит из следующих шагов:\n\n1. Каждому ребру нужно назначить свой вес, в зависимости от иследуемой характеристики.\n2. Найти узел с наименьшей стоимостью.\n3. Проверить существует ли более дешевый путь к соседям этого узла и если существует, обновить их стоимости.\n4. Повторять, пока это не будет сделано для всех узлов графа.\n5. Вычислить итоговый путь.\n\nГраф с весами называется **_взвешенным графом_**. Граф без весов называется **_невзвешенным графом_**.\n\nДля вычисления кратчайшего пути в <u>невзвешенном графе</u> используется _поиск в ширину_. Кратчайшие пути во <u>взвешенном графе</u> вычисляются по _алгоритму Дейкстры_.\n\nВ графах также могут присутствовать **_циклы_**. Это означает, что вы можете начать с некоторого узла перемещаться по графу, а потом снова оказаться в том же узле. \n\n> В ненаправленном графе, каждый из двух узлов ведет к другому узлу, а это _цикл_!  \n> Поэтому, алгоритм Дейкстры работает только с _направленными ациклическими графами, DAG (Directed Acyclic Graph)_.\n\n### Работа с отрицательным весом\n\nВ том случае если проходя по определенному ребру мы не тратим вес а наоборот получаем дополнительный бонус к нужной характеристике, то такому ребру назначется _отрицательный вес_. \n\nОднако Алгоритм Дейкстры не может использоваться при наличии ребер имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_.\n","date":"2022-05-23T00:00:00.000Z","path":"/konspekt-knigi-a-bhargava-grokaem-algoritmy/","icon":"fas fa-code","image":"null","order":null,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"}],"headings":[{"value":"Что такое алгоритм?","anchor":"#что-такое-алгоритм"},{"value":"ООО-большое","anchor":"#о-большое"},{"value":"Линейный поиск","anchor":"#линейный-поиск"},{"value":"Бинарный поиск","anchor":"#бинарный-поиск"},{"value":"Сортировка выбором","anchor":"#сортировка-выбором"},{"value":"Рекурсия","anchor":"#рекурсия"},{"value":"Стратегия \"Разделяй и властвуй\"","anchor":"#стратегия-разделяй-и-властвуй"},{"value":"Быстрая сортировка","anchor":"#быстрая-сортировка"},{"value":"Хеш-таблицы","anchor":"#хеш-таблицы"},{"value":"Коллизии","anchor":"#коллизии"},{"value":"Поиск в ширину","anchor":"#поиск-в-ширину"},{"value":"Граф","anchor":"#граф"},{"value":"Очередь","anchor":"#очередь"},{"value":"Реализация графа","anchor":"#реализация-графа"},{"value":"Алгоритм Дейкстры","anchor":"#алгоритм-дейкстры"}]}},{"node":{"id":"5b61610dde2e594b0b45d814b26e90e3","title":"Как установить OpenJDK на Mac OS","content":"\n\n## Скачиваем JDK \n\nЧтобы скачать пакет Open JDK нужно:\n\n1. Зайти на сайт [jdk.java.net](https://jdk.java.net/)\n2. Перейти по ссылке с нужной версией Java, последняя стабильная версия Java находится в пункте Ready for use\n3. В разделе Build выбираем ссылку на архив с пакетом. Для Mac OS - это macOS / x64\ttar.gz (sha256)\n\n## Извлекаем архив\n\n1. Переходим в папку в которую будем производить установку и создаем в ней папку для хранения jdk[^Here is the footnote]\n\n```bash{outputLines: 2}\ncd /Library/Java/JavaVirtualMachines/\n```\n\n2. Копируем в созданую папку скаченный архив\n\n```bash{outputLines: 2}\nuser@TestAutomation.Space:/usr$ sudo mv ~/Downloads/openjdk-..._bin.tar.gz /Library/Java/JavaVirtualMachines/\n[sudo] пароль для user: \n```\n\n3. И распаковываем tar-архив\n\n```bash{outputLines: 2}\nsudo tar zxvf /usr/java/openjdk-..._bin.tar.gz\n[sudo] пароль для user: \n```\n\n## Настраиваем переменные окружения PATH и JAVA_HOME\n\n1. Открыть на редактирование файл `.profile`\n\n```bash\nnano ~/.bash_profile\n```\n\n2. В конец добавляем строчки\n\n```bash\nJAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk.../Contents/Home\"\nexport JAVA_HOME\n\nPATH=${JAVA_HOME}/bin:${PATH}\nexport PATH\n```\n\n3. Нажимаем `Ctrl+X` и соглашаемся с сохранением изменений, нажав на `Y`\n4. Выполняем команду для инициализации изменени и проверяем что переменная среды выводится верно\n\n```bash\nsource ~/.bash_profile\nenv\necho $JAVA_HOME\necho $PATH\n```\n\n4. Теперь нужно перезапустить консоль и проверить версию Java\n\n```bash\njava -version\n```","date":"2020-04-26T00:00:00.000Z","path":"/kak-ustanovit-open-jdk-na-mac-os/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"setup","path":"/tag/setup/"},{"title":"macos","path":"/tag/macos/"}],"headings":[{"value":"Скачиваем JDK","anchor":"#скачиваем-jdk"},{"value":"Извлекаем архив","anchor":"#извлекаем-архив"},{"value":"Настраиваем переменные окружения PATH и JAVA_HOME","anchor":"#настраиваем-переменные-окружения-path-и-java_home"}]}},{"node":{"id":"5475e7c2947d9aa4170220de97792abc","title":"Как создать новый Gradle проект","content":"Для создания нового проекта с модулем Gradle нужно выполнить следущие шаги:\n\n## Создаем новый проект в Idea или открываем уже созданный\n- Если вы только что установили Inteliji Idea и у вас ещё нет созданных проектов, то после запуска Idea предложит создать новый проект, поэтому выбираем Create New Project.\n![Добавляем новый проект](/images/add_new_project_step1.1.png)\n\n- Если вы находитесь в уже созданном проекте то выбираем в верхнем меню File - New - Module...\n![Добавляем новый проект](/images/add_new_project_step1.2.png)\n\n## Выбираем модуль Gradle\nВыбираем модуль Gradle, библиотека Java. Нажимаем Next.\n![Добавляем новый проект](/images/add_new_project_step2.png)\n\n## Указываем GroupId и ArtifactId\nУказываем индетификаторы GroupId и ArtifactId. Нажимаем Finish.\n![Добавляем новый проект](/images/add_new_project_step3.png)\n\nДалее в нашем проекте формируются 2 файла: settings.gradle и build.gradle.\nВ файле build.gradle видим следущее содержание\n\n```groovy\nplugins {\n    id 'java'\n}\n\ngroup 'ru.qa'\nversion '1.0-SNAPSHOT'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    testCompile group: 'junit', name: 'junit', version: '4.12'\n}\n```\n## Подключаем библиотеку Selenium\n\n### Переходим в цетральный репозиторий Maven\nПерехом по url: [search.maven.org](http://search.maven.org)\n\n### Ищем библиотеку Selenium\nВводим в поисковую строку запрос java-selenium и выбираем библиотеку\n![Ищем библиотеку Selenium в репозитории Maven Central](/images/search_maven_central_selenium_lib.png)\n\n### Выбираем последнюю версию библиотеки и копируем строку для подключения для сборщика Gradle\n\n![Копируем строку для подключения Selenium для сборщика Gradle](/images/selenium_gradle_implementation_command.png)\n\n```groovy\ndependencies {\n    testImplementation group: 'junit', name: 'junit', version: '4.12'\n    testImplementation 'org.seleniumhq.selenium:selenium-java:4.0.0-alpha-5'\n}\n```\n\n## Указываем путь к Chrome Driver и запускаем первый тест\n\n### Скачиваем дитрибутив Chrome Driver\n\n1. Переходим по url [chromedriver.chromium.org/downloads](https://chromedriver.chromium.org/downloads)\n2. Выбираем ссылку для дистрибутива последней версии\n3. Скачиваем версию для вашей ОС\n4. Извлекаем дистрибутив из архива и помещаем его в папку нашего проекта: src/test/resources\n\n### Указываем путь к Chrome Driver и запускаем первый тест\n\nДля проверки на нужо будет создать файл с простым тестом и запустить его.\nСоздаем src/test/java/FirstTest.java\n\n```java\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport static org.openqa.selenium.support.ui.ExpectedConditions.titleIs;\n\npublic class FirstTest {\n\n    private WebDriver driver;\n    private WebDriverWait wait;\n\n    @Before\n    public void start(){\n        System.setProperty(\"webdriver.chrome.driver\",\"./src/test/resources/chromedriver\");\n        driver = new ChromeDriver();\n        wait = new WebDriverWait(driver, 10);\n    }\n\n    @Test\n    public void myFirstTest(){\n        driver.get(\"http://www.google.com/\");\n        driver.findElement(By.name(\"q\")).sendKeys(\"webdriver\");\n        driver.findElement(By.name(\"btnK\")).click();\n        wait.until(titleIs(\"webdriver - Поиск в Google\"));\n    }\n\n    @After\n    public void stop(){\n        driver.quit();\n        driver = null;\n    }\n}\n```\n\n","date":"2020-05-01T00:00:00.000Z","path":"/kak-sozdat-novyj-gradle-proekt/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"gradle","path":"/tag/gradle/"},{"title":"setup","path":"/tag/setup/"},{"title":"java","path":"/tag/java/"}],"headings":[{"value":"Создаем новый проект в Idea или открываем уже созданный","anchor":"#создаем-новый-проект-в-idea-или-открываем-уже-созданный"},{"value":"Выбираем модуль Gradle","anchor":"#выбираем-модуль-gradle"},{"value":"Указываем GroupId и ArtifactId","anchor":"#указываем-groupid-и-artifactid"},{"value":"Подключаем библиотеку Selenium","anchor":"#подключаем-библиотеку-selenium"},{"value":"Указываем путь к Chrome Driver и запускаем первый тест","anchor":"#указываем-путь-к-chrome-driver-и-запускаем-первый-тест"}]}},{"node":{"id":"8a6b33e55a7ca748d1b9e12020f95b24","title":"Алгоритмы (курс Яндекс)","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","date":"2022-07-24T00:00:00.000Z","path":"/algoritmy-kurs-yandeks/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"c66f02339f21ce00fa32d069c52d071a","title":"Java Core","content":"\nJava Core\n\n## Что такое программа\n\nЛюбая программа это набор инструкций, которые выполняет процессор или его микропрограмма. Эти инструкции называются машинным кодом. \nОни показывают процессору откуда взять данные, что с ними сделать и куда поожить результат. Hello world на машинном языке выглядел бы как набор цифр и букв, набор инструкций зависит от реализации конкретного процессора и унифицируется на уровне операционных систем(созданием виртуального процесора с универсальным набором инструкций). \n\n\n## Появление и развитие языка программирования\n\n1. Чтобы было проще запоминать машинные коды для каждого кода придумали мнемоники. Так появился язык Asembler и код стал немного понятнее. \n\n2. Затем появились языки высокого уровня которые оперируют простыми словами, а специальные программы - компеляторы и интерпретаторы приводили их в машинный код. \n\n3. Следующим этапом развития стало компиляция языка программирования не напрямую в машинный код, а сначала в промежуточный байт-код, по этому пути пошли разработчики java и dotNet'a. \n\n- Разработчики Java создали концепцию JVM - java virtual machine - виртуальная машина, которая может исполнять bytecode скомпелированный из java кода. Создав реализацию такой виртуальной машины для разных платформ, мы получили возможность писать на джаве для любой платформы. \n\n- Разработчики из дотнета пошли другим путем и создали clr - common language runtime если разработчики джава были сосредоточены только на языке джава, то clr был создан для возможности писать на разных языках в пределах одного решения но при этом все ставки делались только на windows. \n\nВ настоящее время обе команды пересмотрели свою концепцию: в jvm появилась поддержка в том числе и других языков, а для дот нета почвилась платформа Mono которая позволяет запускать C# практически на любом устройстве. \n\n## Что такое JVM?\n\nJVM состоит из:\n- Class Loader, загружающего файлы с байт кодом в память;\n- виртуальная память, куда все это загружается;\n- движок, который исполняет и оптимизирует код;\n- дополнительные интерфейсы и библиотеки для работы с нативным кодом (кодом написанном на c/c++/assembler'e).\n\n### Class Loader\n\nРазличают 3 вида:\n- bootstrap - загружает все стандартные классы Java, т.е. все которые содержатся в пакетах java.lang, java.net и т.д.;\n- extension - загружает классы из дополнительных библиотек, которые стаятся вместе с jdk и jre;\n- application - загружает классы из  classpath папок, которые может настроить сам разработчик.\n\n### JVM Memory - виртуальная память\n\n- Method Area, metaspace - здесь хранятся все статичные структуры и сам код, эта область является частью Heap(кучи)\n- Heap - большая область памяти в которой хранятся все создаваемые объекты, она выделяется сразу при запуске и делится между всеми основными потоками. Здесь обычно происходят основные утечки память и здесь же работает garbage collector(уборщик мусора). GC - собирает информацию о данных которые больше не используются и пытается их удалить.\n- Stack - более емкая область памяти, которая создается при создании потока, у каждого потока свой стек. Стек устроен по принципу первый вошел последний вышел(FILO). Для каждого вызываемого метода в стеке создается frame, набор именнованных параметров которые хранит переменные созданные в этом методе, промежуточные результаты и итоговый результат который возвращается через return. После выполнения метода его фрейм извлекается из стека и происходит переход к фрейму метода который был положен в стек перед ним, те тот метод который вызывал данный метод. \n- PC Registers - содержат указатели на внутренние инструкции самой java.\n- Native Method Stack - стек для нативных методов.\n\n### Движок\n\n- JIT - just-in-time компилятор - оптимизирует уже скомпелированный байт код \n- Интерпретатор который исполняет скомпелированный байт код\n\n\n### JRE\n\nJVM + java библиотеки\n\n### JDK\n\nJRE + инструменты разработчика + компилятор\n\n","date":"2024-03-29T00:00:00.000Z","path":"/java-core/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[{"value":"Что такое программа","anchor":"#что-такое-программа"},{"value":"Появление и развитие языка программирования","anchor":"#появление-и-развитие-языка-программирования"},{"value":"Что такое JVM?","anchor":"#что-такое-jvm"}]}},{"node":{"id":"ed89b68c81d3d449616e5c4bbd9e6630","title":"Глава 1. Введение в объекты","content":"\n## Развитие абстракции\n\nВсе языки программирования построены на <u>**абстракции**</u>.\n\nРазличают тип и качество абстракции. Под словом \"Тип\" имеется ввиду ответ на вопрос \"Что конкретно мы абстрагируем?\"\n\nЯзык ассемблера - есть небольшая абстракция от компьютера, на базе которого он работает.\n\n\"Командные\" языки, созданные вслед за ним, такие как Fortran, BASIC и C представляют собой абстракции следующего уровня, но по-прежнему заставляли мыслить в контектсте структуры компьютера, а не решаемой задачи.\n\n### Моделирование машины\nНужно устанавливать связь между моделью машины(в \"пространстве решения\" - место, где реализуется решение, н-р компьютер) и моделью задачи(н-р прикладная область). В результате затрачиваются дополнительные усилия и появляются программы, которые трудно писать и тяжело поддерживать.\n\n### Моделирование решаемой задачи\n\n#### Моделирование окружающего мира\nЯзыки, подобные LISP и APL, имели особый подход к моделированию окружающего мира (\"Все задачи решаются списками\" или \"Алгоритмы решают все\") \n\n#### Проблемы как цепочки решений \nPROLOG трактует все проблемы как цепочки решений. \n\n#### Cистемs ограничений и манипуляциb с графическими конструкциями\nСуществовали языки для программирования, основанного на системе ограничений и специальные языки, в которых программирование осуществлялось посредством манипуляций с графическими конструкциями(областьприменения оказалась слишком узкой).\n\nКадый из подходов хорош, но не позволяет выйти из области решаемых задач. Использование их вне их сферы становится затруднительно.\n\n#### Объектный подход\nОбъектный подход предоставляет средства для представления задачи в ее пространстве. Имеет общий характер и не накладывает ограничений на тип решаемой проблемы. \n\nЭлементы пространства задачи и их представления в пространстве решения называются \"объектами\".\n\nПрограмма может адаптироваться к специфике задачи посредством создания новых типов объектов. Т.о. ООП описывает задачу в контексте самой задачи. \n\nСвязь с компьютером однако сохранилась т.к. каждый объект похож на компьютер - у него есть состояние и операции, которые он позвояет проводить, что сочетается с реальным миром - <i>**\"реальность, данная нам в объектах\"**</i>, обладающих характеристиками и поведением.\n\n### Характеристики академического подхода к ООП\n\n- Всё является объектом;<br>\n<i>Объект - это усовершенствованная переменная, он хранит данные, но к нему можно \"обращаться с запросами\", приказывая выполнить операции над собой. Любой компонент решаемой задачи может быть представлен в виде объекта.</i>\n\n- Программа - это набор объектов, указывающих друг другу, что делать, посредством сообщений;<br>\n<i>Чтобы обратиться с запросом, вы \"посылаете сообщение\". Сообщение - это запрос на вызов метода, принадлежащего определенному объекту.</i>\n\n- Каждый объект имеет собственную \"память\", состоящую из других объектов;<br>\n<i>Новый объект создается  путем встраивания в него уже существующих объектов, скрывая общую сложность за простотой отдельных объектов.</i>\n\n- У каждого объекта есть тип;<br>\n<i>Каждый объект является экземпляром класса, \"класс\" - синоним слова \"тип\". Отличие классов друг от друга - ответ на вопрос \"Какие сообщения можно объекту посылать?\"</i> \n\n- Все объекты определенного типа могут получать одинаковые сообщения;<br>\n<i>Объект типа \"круг\" также является объектом типа \"фигура\" и справедливо что \"круг\" также  может принимать сообщения для типа \"фигура\".</i>\n\n\n#### Описание объекта (Буч)\n<i>**Объект обладает состоянием, поведением и индивидуальностью.**</i>\n Объект может иметь внутренние данные(состояние объекта), методы(определяют поведение) и каждый объект можно уникальным образом отличить от другого объекта(н-р уникальным адресом в памяти)\n\n## Объект обладает интерфейсом\n\nПонятие типа можно сравнить с понятием Аристотеля о \"классе рыб и классе птиц\".\n\nКонцепция, что все объекты будучи уникальными являются частью класса объектов со сходными характеристиками и поведением, использована в <u>первом</u> объектно-ориентированном языке <i>Simula-67</i>, с введением слова class, которое вводило новый тип в прорамму.\n\n\n\n\n\n\n","date":"2024-02-04T00:00:00.000Z","path":"/glava-1-vvedenie-v-obekty/","icon":"fas fa-code","image":"null","order":1,"category":null,"tags":[{"title":"java","path":"/tag/java/"},{"title":"ооп","path":"/tag/%D0%BE%D0%BE%D0%BF/"}],"headings":[{"value":"Развитие абстракции","anchor":"#развитие-абстракции"},{"value":"Объект обладает интерфейсом","anchor":"#объект-обладает-интерфейсом"}]}},{"node":{"id":"c3df7d90d4bbd4a557fa97ed5ab680d2","title":"Создаем основу проекта","content":"\n- Какие тесты нужно автоматизировать в первую очередь?\nБерем тесты, которые чаще всего проверяются, чаще всего стреляют и которые больше всего затратны с точки зрения ручного тестирования.\n\n- эффективность автоматизации\nhttps://www.youtube.com/watch?v=GpvY3NF9mRc\n\nGradle\n\n1 создаем градл проект через идею.\n2 редактируем файл build.gradle \n\nПосле создания проекта дефолтный скрипт выглядит так:\n\n```groovy\nplugins {\n    id 'java' //плагин для сблорки java приложения\n}\n\n// группа и версия проекта\ngroup 'io.vvrozhkova'\nversion '1.0-SNAPSHOT'\n\n\n//репозиторий для скачивания зависимостей\nrepositories {\n    mavenCentral()\n}\n\n\n//список зависимостей\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'\n}\n\n\n//настройка запуска тестов через JUnit\ntest {\n    useJUnitPlatform()\n}\n```\n\n\n","date":"2024-03-29T00:00:00.000Z","path":"/sozdaem-osnovu-proekta/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[]}},{"node":{"id":"b98339b91504be9db7d95591e1741b37","title":"План содания проекта для UI автотестов","content":"\n1. [Создаем основу проекта](/sozdaem-osnovu-proekta/)\n","date":"2024-03-29T00:00:00.000Z","path":"/plan-sodaniya-proekta-dlya-ui-avtotestov/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[]}}]}},"relatedTag":{"id":"65ea055e129559ddcdb88e00ae7f2f81","title":"java","path":"/tag/java/","related":[{"id":"ui","path":"/tag/ui/","title":"ui"},{"id":"java","path":"/tag/java/","title":"java"}]}},"context":{}}