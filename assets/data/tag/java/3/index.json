{"hash":"aa5a7ff62b399012289acf12f7cc1503ba4e22e5","data":{"tag":{"title":"java","path":"/tag/java/","belongsTo":{"totalCount":22,"pageInfo":{"totalPages":3,"currentPage":3},"edges":[{"node":{"id":"453a9dbb35a392e23321f9611535e302","title":"Глава 10. Внутренние классы","content":"\n## Внутренние классы\n\nКласс, размещенный в определении другого класса называется внутренним(inner class).\n\nКак правило внешний класс содержит ссылку на внутренний класс.\n\nЕсли нужно создать объект внутреннего класса где-нибудь за пределами внешнего класса или в статическом методе, нужно будет указать тип этого объекта следующим образом: ИмяВнешнегоКласса.ИмяВнутреннегоКласса.\n\nВнутренний класс может обращаться к членам внешнего класса и ему доступны все элементы внешнего класса.\n\nВнутренний класс хранит ссылку на внешний класс, поэтому существование внутреннего класса невозможно без внешнего если он не является статическим.\n\nЕсли нужно получить ссылку на внешний класс то указывается имя класс и .this.\n\nЕсли нужно создать объект внутреннего класса из внешнего, например в статическом методе или за пределом внешнего класса то используется объект внешнего класса и .new\n\nЗакрытый внутренний класс позволяет разработчику класса полностью запретить использование определенных типов и скрыть детали реализации класса.\n\nВнутренние классы могут создаваться в методах и даже произвольных областях действия. Для этого есть 2 причины:\n1. Нужно создавать и возвращать ссылки на некоторый интерфейс\n2. Нужно решить сложную задачу и нужно создать класс, который будет задействован в его решении, но при этом сделать его недоступным для посторонних.\n\nВнутренний класс может быть:\n\n1. Класс, определенный в методе - локальный внутренний класс. К нему невозможно обратиться за пределами метода, в котором он определяется;\n2. Класс, определенный в области действия внутри метода - например вложен в область действия команды if. Внутренний класс не доступен за пределами действия в которой он определяется;\n3. Анонимный класс, реализованный в интерфейсе;\nЕсли вы определяете анонимный внутренний класс и хотите использовать внутри него объект передаваемый в аргументе, то необходимо чтобы аргумент был обозначен как final иначе компилятор выдаст ошибку.\n4. Анонимный класс, расширяющий класс с конструктором, который не является конструктором по умолчанию. В название класса передаются нужные аргументы и задается определение класса;\n5. Анонимный класс, выполняющий инициализацию поля;\n6. Анонимный класс, выполняющий конструирование с использованием инициализации экземпляра (анонимные внутренние классы не могут иметь конструкторов)\n\nВ отличие от обычного класса анонимные внутренние классы могут либо расширять класс, либо реализовать интерфейс но не оба действия сразу.\n\nПаттерн «Фабричный метод»\n\nВложенные классы\n\nЕсли связь между объектом внутреннего класса и объектом внешнего класса не нужна, внутренний класс можно сделать статическим (объявить его как static). Такой класс называют вложенным.\n\nВложенный класс:\n1. Для создания его объекта не нужен объект внешнего класса\n2. Нельзя обращаться к членам не-статического объекта внешнего класса из объекта вложенного класса.\n\nСтатические поля и методы внутреннего класса определяются только на уровне внешнего класса. Вложенные классы таких ограничений не имеют. Уточнить!!!\n\nВложенный класс может быть частью интерфейса. Даже без специальных обозначений любой класс помещенный в интерфейс считается public и static. Это может быть удобно при здании общего кода, который должен использоваться со всеми реализациями интерфейса.\n\nНеважно насколько глубоко вложен класс он будет иметь доступ ко всем полям и методам всех внешних классов.\n\n\nПричина для использования внутренних классов:\nКаждый внутренний класс способен наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовано в ситуациях, где внешний класс уже наследует реализацию.\n\nТаким образом, внутренний класс выступает как «довесок» множественного наследования.\n\nДля наследованная от внутреннего класса должна быть ссылка на внешний класс поэтому используется следующий синтаксис:\nextends ИмяВнешнегоКласса.ИмяВнутреннего класса\nи в конструктор нужно передать ссылку на внешний класс и определить его как \nСсылкаНаВнешнийКласс.super();\n\nПереопределение внутреннего класса не имеет никакого эффекта. Внутренние класс совершенно отдельные составляющие, с независимым пространством имен, но можно явно унаследовать от внутреннего класса.\n\nЛокальный внутренний класс не имеет модификатора доступа, но имеет доступ к членам внешнего класса и final переменным.\nУ локального внутренний класса может быть свой конструктор.\n\nАнонимный внутренний класс не может содержать конструктора только инициализатор экземпляра.\n\nЕдинственный довод в пользу локального внутреннего класс перед анонимным внутренним классом есть необходимость в именованном конструкторе и/или перегруженных конструкторах и  возможность создавать более чем один объект такого класса.\n\n\n\n#философия_java","date":"2024-02-24T00:00:00.000Z","path":"/glava-10-vnutrennie-klassy/","icon":"fas fa-code","image":"null","order":10,"category":null,"tags":[{"title":"java","path":"/tag/java/"},{"title":"ооп","path":"/tag/%D0%BE%D0%BE%D0%BF/"}],"headings":[{"value":"Внутренние классы","anchor":"#внутренние-классы"}]}},{"node":{"id":"84a6d711b6dc393cc22855dea2e075ef","title":"Глава 15. Обобщенные типы","content":"\nОдин из механизмов обобщения в ООП основан на полиморфизме.\nНапример, имеется метод, который принимает в аргументе объект базового класса, после чего его можно использовать для любых классов производных от базового.\n\nЭтот принцип действует и для классов. \nОграничение можно выставить по типу базового класса, интерфейса или указать некий \"условный тип\".\n\n<i>**Обобщения(generics)**</i> реализуют концепцию параметризованных типов, позволяющих создавать компоненты(контейнеры), которые удобно использовать с разными типами.\n\nПод темином \"обобщение\" следует понимать \"применимость к большой группе классов\".\n\n## Простые обобщения\n\nОдна из причин использования обобщений - это классы контейнеры. Контейнер - это хранилище для объектов.\n\nПример класса-контейнера с использованием \"условного\" типа для хранения. На это указывает параметр-тип в угловых скобках после имени класса.\n\n```java\npublic class Holder3<T> {\n    private T a;\n\n    public Holder3(T a) {\n        this.a = a;\n    }\n\n    public void set(T a) {\n        this.a = a;\n    }\n\n    public T get() {\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Holder3<Automobile> h3 =\n                new Holder3<Automobile>(new Automobile());\n        Automobile a = h3.get();\n    }\n}\n\nclass Automobile {\n}\n```\n\n## Библиотека кортежей\n\nПри вызове метода иногда возникает необходимость вернуть несколько объектов. Команда return позволяет вернуть только один объект, но задачу можно решить созданием объекта, содержащего несколько возвращаемых объектов. Можно писать специальный класс при необходимости, но обобщения позволяют решить задачу сразу на все случаи. \n\nГруппа объектов, завернутых в один объект, называется <i>**кортежем**</i>. Кортеж может иметь произвольную длину и все объекты могут относиться к разным типам. Получатель может читать элементы, но не может добавлять новые (концепция \"объект передачи данных\").\n\n\n```java\npublic class TwoTuple<A, B> {\n    public final A first;\n    public final B second;\n\n    public TwoTuple(A first, B second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n```\n\n```java\npublic class ThreeTuple<A, B, C> extends TwoTuple<A, B> {\n\n    public final C third;\n\n    public ThreeTuple(A first, B second, C third) {\n        super(first, second);\n        this.third = third;\n    }\n}\n```\n\nПоля first, second, third объявляются public и final, что позволяет не добавлять get и set методы, тк получить значение можно просто обратившись к переменной, тк она public, а изменить нельзя, тк она final. Данная форма оказывается короче чем добавление геттеров и сеттеров.\nДля того чтобы изменить элементы кортежа лучше будет просто создать новый объект. Для оздания кортежа с большим количеством элементов, можно применить наследование.\n\n## Класс стека\n\nПри каждом вызове `push()` новый узел `Node<T>` создается и связывается с предыдущим узлом `Node<T>`. При вызове `pop()` всегда возвращается `top.item`, после чего текущий узел `Node<T>` удаляется и происходит переход к следующему узлу; но при достижении сторожа(значение `null`, признак пустого стека) перемещение не выполняется.\n\n```java\npublic class LinkedStack<T> {\n\n  private static class Node<U> {\n    U item;\n    Node<U> next;\n    Node() { item = null; next = null; }\n    Node(U item, Node<U> next) {\n      this.item = item;\n      this.next = next;\n    }\n    boolean end() { return item == null && next == null; }\n  }\n\n  private Node<T> top = new Node<T>(); // End sentinel\n\n  public void push(T item) {\n    top = new Node<T>(item, top);\n  }\t\n\n  public T pop() {\n    T result = top.item;\n    if(!top.end())\n      top = top.next;\n    return result;\n  }\n\n  public static void main(String[] args) {\n    LinkedStack<String> lss = new LinkedStack<String>();\n    for(String s : \"Phasers on stun!\".split(\" \"))\n      lss.push(s);\n    String s;\n    while((s = lss.pop()) != null)\n      System.out.println(s);\n  }\n\n}\n```\n\n## RandomList\n\n```java\npublic class RandomList<T> {\n  private ArrayList<T> storage = new ArrayList<T>();\n  private Random rand = new Random(47);\n  public void add(T item) { storage.add(item); }\n  public T select() {\n    return storage.get(rand.nextInt(storage.size()));\n  }\n  public static void main(String[] args) {\n    RandomList<String> rs = new RandomList<String>();\n    for(String s: (\"The quick brown fox jumped over \" +\n        \"the lazy brown dog\").split(\" \"))\n      rs.add(s);\n    for(int i = 0; i < 11; i++)\n      System.out.print(rs.select() + \" \");\n  }\n}\n```\n\n## Обобщенные интерфейсы\n\nС интерфейсами обобщения работают почти также, как с классами. Рассмотрим интерфейс для создания генератора. От него требуется возвращать следущий элемент передаваемого типа. Для этого добавляется метод `next()`.\n\n```java\npublic interface Generator<T> { T next(); }\n```\n\nПродемонстрируем реализацию интерфейса Generator.\n\n```java\npublic class Coffee {\n\n    private static long counter = 0;\n    private final long id = counter++;\n\n    public String toString() {\n        return this.getClass().getSimpleName() + \" \" + id;\n    }\n}\n\nclass Latte extends Coffee {\n}\n\nclass Mocha extends Coffee{\n}\n\nclass Americano extends Coffee {\n}\n```\n\n```java\npublic class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee> {\n\n    // Реализация генератора\n\n    private Class[] types = {Americano.class, Mocha.class, Latte.class};\n\n    private Random rand = new Random(47);\n\n    @Override\n    public Coffee next() {\n        try {\n            return (Coffee) types[rand.nextInt(types.length)].getDeclaredConstructor().newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Реализация итератора\n    private int size = 0;\n\n    public CoffeeGenerator(int size) {\n        this.size = size;\n    }\n\n    public CoffeeGenerator() {\n    }\n\n    class CoffeeIterator implements Iterator<Coffee> {\n\n        int count = size;\n\n        @Override\n        public boolean hasNext() {\n            return count > 0;\n        }\n\n        @Override\n        public Coffee next() {\n            count--;\n            return CoffeeGenerator.this.next();\n        }\n    }\n\n    @Override\n    public Iterator<Coffee> iterator() {\n        return new CoffeeIterator();\n    }\n\n\n    public static void main(String[] args) {\n        CoffeeGenerator generator = new CoffeeGenerator();\n        for (int i = 0; i < 5; i++) {\n            System.out.println(generator.next());\n        }\n        System.out.println();\n        for (Coffee c : new CoffeeGenerator(5)) {\n            System.out.println(c);\n        }\n    }\n    \n}\n```\n\nПример генератора для генерации чисел Фибоначчи.\n\nВариант с рекурсией:\n```java\npublic class FibonacciGenerator implements Generator<Integer> {\n\n    private static int counter = 0;\n\n    @Override\n    public Integer next() {\n        return fib(counter++);\n    }\n\n    public Integer fib(int n) {\n        if (n < 2) return 1;\n        return fib(n - 2) + fib(n - 1);\n    }\n\n    public static void main(String[] args) {\n        FibonacciGenerator generator = new FibonacciGenerator();\n        for (int i = 0; i < 10; i++) {\n           System.out.println(generator.next());\n        }\n    }\n}\n```\n\nВариант без рекурсии\n```java\npublic class FibonacciGenerator implements Generator<Integer> {\n\n    private int first = 0;\n    private int second = 1;\n\n    private static int counter = 0;\n\n    @Override\n    public Integer next() {\n        if (counter < 1) {\n            counter++;\n            return 1;\n        } else {\n            int result = first + second;\n            first = second;\n            second = result;\n            counter++;\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        FibonacciGenerator generator = new FibonacciGenerator();\n        for (int i = 0; i < 10; i++) {\n            System.out.println(generator.next());\n        }\n    }\n}\n```\n\nСоздание итератора для вывода числе Фибоначчи с помощью паттерна Адаптер:\n\n```java\npublic class IterableFibonacci extends FibonacciGenerator implements Iterable<Integer> {\n\n    private int count;\n\n    public IterableFibonacci(int count) {\n        this.count = count;\n    }\n\n    class FibonacciIterator implements Iterator<Integer> {\n\n\n        @Override\n        public boolean hasNext() {\n            return count > 0;\n        }\n\n        @Override\n        public Integer next() {\n            count--;\n            return IterableFibonacci.this.next();\n        }\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new FibonacciIterator();\n    }\n\n    public static void main(String[] args) {\n        for (Integer n : new IterableFibonacci(5)) {\n            System.out.println(n);\n        }\n    }\n}\n```\n\n## Обобщенные методы\n\nПараметризация возможна не только для классов но и для методов.\nКак правило, применять обощенные методы следует там, где только возможно.\n\nЧтобы определить обобщенный метод, следует поместить список параметров-типов перед возвращаемым значением:\n\n```java\npublic <T> void f(T x) {\n    System.out.println(x.getClass().getName());\n}\n```\n\n## Использование автоматического определения аргументов-типов\n\nКлассическое обявление объектов параметризованных классов может быть громоздким для этого можно сделать специальную бибилиотеку для обозначения основных параметризованных классов.\n\n```java\npublic class New {\n  public static <K,V> Map<K,V> map() {\n    return new HashMap<K,V>();\n  }\n  public static <T> List<T> list() {\n    return new ArrayList<T>();\n  }\n  public static <T> LinkedList<T> lList() {\n    return new LinkedList<T>();\n  }\n  public static <T> Set<T> set() {\n    return new HashSet<T>();\n  }\t\n  public static <T> Queue<T> queue() {\n    return new LinkedList<T>();\n  }\n  // Examples:\n  public static void main(String[] args) {\n    Map<String, List<String>> sls = New.map();\n    List<String> ls = New.list();\n    LinkedList<String> lls = New.lList();\n    Set<String> ss = New.set();\n    Queue<String> qs = New.queue();\n  }\n}\n```\n\nОднако, такое присвоение работает только при объявлении переменной при попытке использовать на прямую в методе, компилятор не вычисляет тип и будет возникать ошибка.\n\nНо если использовать специальный синтаксис с помощью которого можно задать тип, метод выполнится успешно.\n\nВ Java 13 работают оба варианта.\n\n```java\npublic class LimitsOfInference {\n  static void f(Map<Person, List<? extends Pet>> petPeople) {}\n  public static void main(String[] args) {\n    // f(New.map()); // Does not compile\n    f(New.<Person, List<Pet>>map());\n  }\n}\n```\n\n## Списки аргументов переменной длины и обобщенные методы\n\nОбобщенные методы можно использовать со списками переменной длины.\n\n```java\npublic class GenericVarargs {\n  public static <T> List<T> makeList(T... args) {\n    List<T> result = new ArrayList<T>();\n    for(T item : args)\n      result.add(item);\n    return result;\n  }\n  public static void main(String[] args) {\n    List<String> ls = makeList(\"A\");\n    System.out.println(ls);\n    ls = makeList(\"A\", \"B\", \"C\");\n    System.out.println(ls);\n    ls = makeList(\"ABCDEFFHIJKLMNOPQRSTUVWXYZ\".split(\"\"));\n    System.out.println(ls);\n  }\n}\n```\n\n","date":"2024-03-07T00:00:00.000Z","path":"/glava-15-obobshhennye-tipy/","icon":"fas fa-code","image":"null","order":15,"category":null,"tags":[{"title":"java","path":"/tag/java/"},{"title":"ооп","path":"/tag/%D0%BE%D0%BE%D0%BF/"}],"headings":[{"value":"Простые обобщения","anchor":"#простые-обобщения"},{"value":"Библиотека кортежей","anchor":"#библиотека-кортежей"},{"value":"Класс стека","anchor":"#класс-стека"},{"value":"RandomList","anchor":"#randomlist"},{"value":"Обобщенные интерфейсы","anchor":"#обобщенные-интерфейсы"},{"value":"Обобщенные методы","anchor":"#обобщенные-методы"},{"value":"Использование автоматического определения аргументов-типов","anchor":"#использование-автоматического-определения-аргументов-типов"},{"value":"Списки аргументов переменной длины и обобщенные методы","anchor":"#списки-аргументов-переменной-длины-и-обобщенные-методы"}]}}]}},"relatedTag":{"id":"65ea055e129559ddcdb88e00ae7f2f81","title":"java","path":"/tag/java/","related":[{"id":"ui","path":"/tag/ui/","title":"ui"},{"id":"java","path":"/tag/java/","title":"java"}]}},"context":{}}