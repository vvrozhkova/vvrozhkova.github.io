{"hash":"03f7058ba488a165454bf4fd228c446ef5a28a6f","data":{"tag":{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","belongsTo":{"totalCount":10,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"8a6b33e55a7ca748d1b9e12020f95b24","title":"Алгоритмы (курс Яндекс)","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","date":"2022-07-24T00:00:00.000Z","path":"/algoritmy-kurs-yandeks/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"9916f091823ac5e3105f733f94759092","title":"Сортировки. Быстрая, слиянием и поразрядная","content":"\n## Быстрая сортировка. Quick sort","date":"2023-11-19T00:00:00.000Z","path":"/sortirovki-bystraya-sliyaniem-i-porazryadnaya/","icon":"fas fa-code","image":"null","order":2,"category":null,"tags":[{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"},{"title":"сортировки","path":"/tag/%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/"},{"title":"быстрая сортировка","path":"/tag/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F%20%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/"},{"title":"сортировка слиянием","path":"/tag/%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC/"},{"title":"поразрядная сортировка","path":"/tag/%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/"}],"headings":[{"value":"Быстрая сортировка. Quick sort","anchor":"#быстрая-сортировка-quick-sort"}]}},{"node":{"id":"6eb2710fac45f4b875e8f37a1c0d5eaf","title":"Сложность, тестирование, особые случаи","content":"\n## Сложность\n\nДля тренировки нужно написать 10000 строк кода.\nДля этого можно использовать сайты leetcode.com, codeforces.com\n\n**Сложность алгоритма** - это порядок количества действий, которые выполняет алгоритм.\n\nЕсли сложность $O(N)$ - это значит, что скорость алгоритма зависит напрямую от количества данных и такую сложность называют **линейной**. \nНапример, обычный цикл от $1$ до $N$.\n\nЕсли в программе два вложенных цикла, каждый от $1$ до $N$, тогда сложность составит $O(N^2)$.\n\n$O$ никак не зависит от константы.  \n$100*N = O(N), 2*N=O(N)$. Здесь 2 и 100 - константы, не зависящие от размера входных данных.  Константы не так сильно влияют на скорость алгоритма при больших параметрах.\n\nНапример, алгоритм, который работает за $O(100*N)$ будет работать лучше, чем $O(1*N^2)$, поэтому константа не так принципиальна.\n\nТ.е. если в алгоритме выполняется цикл, то не важно сколько действий выполняется внутри цикла, важно сколько вхождений выполнится.\n\n$O$(O-большое) означает, что наш алгоритм работает не более, чем за столько действий сколько указано в скобках, например $O(N) = 10 * N$ - означает что найдется такое число, в нашем случае 10, что наш алгоритм гарантировано совершит не больше, чем 10 * N  действий. Чем асимптотическая сложность ниже, тем лучше, тем быстрее решается.\n\nСравнение алгоритмов по асимптотической сложности имеет смысл проводить только для больших значений параметров, пока он маленький там может произойти, что угодно :). \n\nЕще существует **\"пространственная сложность\"** - количество использованной памяти, сколькдополнительной памяти потребляет наш алгоритм.\nПамяти алгортим не может потребить больше чем он потратил времяБ потому что чтобы что то положить в ячейку памяти это тоже элементарная операция. \nНо иногда алгоритмы отличаются и по дополнительной памяти которую они употребляют. \n\n### Задача №1. Условие.\nДана строка в кодировке UTF-8.  \nНайти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.\n\n### Задача №1. Решение 1.\n\nПереберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n--- \n\nЗаводим внешние переменные для максимального количества повторений и для значения символа. \n\nВнешний цикл сначала выбирает первый символ и далее проходит по строке и ищет сколько раз этот символ в ней встречается, запоминаем значение символа и количество повторений и сохраняем их во внешнюю переменную. \n\nЗатем переходим ко второму символу и также проверяем сколько раз он встретился, если количество его повторений больше, чем во внешней переменной, то обновляем значения для максимального количества повторений и для значения символа во внешних переменных и так далее до конца строки.\n\n**_Сложность алгоритма: _**$O(N^2)$, тк 2 вложенных цикла.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    int ansCount = 0;\n    char ans = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char nowChar = s.charAt(i);\n        int nowCount = 0;\n\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == nowChar) {\n                nowCount += 1;\n            }\n        }\n\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = nowChar;\n        }\n    }\n    return ans;\n}\n```\n\nНо есть более эффективное решение. \n\n### Задача №1. Решение 2.\n\nПереберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n---\n\nПолучаем список уникальных букв через Set. \n\nПроходим по нему в цикле и для каждой из букв запускаем цикл, который подсчитывает количество повторений для этой буквы. \n\nЗаписываем в счетчик и возвращаем искомый символ.\n\n**_Сложность алгоритма: _**$O(N*K)$, где K - количество уникальных букв, цикл по ним чтобы узнать, сколько каждая из них встречалась раз, N - общее количество букв, цикл по N, чтобы найти количество повторений для каждой из уникальных букв.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    Set<Character> str = s.chars().mapToObj(e -> (char) e).collect(Collectors.toSet());\n\n    char ans = 0;\n    int ansCount = 0;\n\n    for (Character now : str) {\n        int nowCount = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == now) {\n                nowCount += 1;\n            }\n        }\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = now;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача №1. Решение 3.\n\nЗаведем словарь, где ключом является символ, а значением - сколько раз он встретился. \n\nПроходим в цикле по всем символам строки и если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Далее для текущего символа в словаре прибавляем к элементу словаря с ключом, совпадающим с этим символом единицу. \n\nПосле выполнения прохода по всем символам, запускаем цикл прохода по ключам словаря и сравниваем значение по ключу с текущим максимальным повторением, если значение больше то переписываем символ в ответе и макимальное количество повторений.\n\n**_Сложность алгоритма: _**$O(N + K) = O(N)$, N - количество проходов пока формировали словарь, K - количество прохода только по (уникальным) ключам. Но так как K обычно меньше N то можно сказать что алгоритм выполняется за $O(N)$.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    char ans = 0;\n    int ansCount = 0;\n    Map<Character, Integer> dict = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char now = s.charAt(i);\n        if (!dict.containsKey(now)) {\n            dict.put(now, 0);\n        }\n        dict.put(now, dict.get(now) + 1);\n    }\n\n    for (Character key : dict.keySet()) {\n        if (dict.get(key) > ansCount) {\n            ansCount = dict.get(key);\n            ans = key;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Сравниваем затраченное время и память (дополнительную)\n\n|Решение|Время|Память|\n|---|---|---|\n|#1 Проход по строке для каждого символа|$O(N^2)$|$O(N)$ - так как храним только саму строку|\n|#2 Проход по строке для каждого символа в множестве|$O(N*K)$|$O(N+K) = O(N)$ - храним строку и множество ($K$)|\n|#3 Использование словаря|$O(N)$|$O(K)$ - храним только словарь из K элементов|\n\n## Особые случаи\n\n### Сумма последовательности\n\nВ данном алгоритме не обязательно делать проверку на пустую строку так как и без этой проверки у нас выведется ноль.\n\n```java\npublic static int sequenceSum(String s) {\n    int[] sequence = s.chars().toArray();\n    int sequenceSum = 0;\n    for (int i = 0; i < sequence.length; i++) {\n        sequenceSum += sequence[i];\n    }\n    \n    return sequenceSum;\n}\n```\n\n### Максимум последовательности\n\nВ этом алгоритме мы не можем задать начальное значение нулем, тк в массиве могут быть еще и отрицательные значения, поэтому необходимо добавить ночальную проверку на пустую строку и при выполнении алгоритма стартовому значению присвоить первое значение в массиве.\n\n```java\npublic static double sequenceMax(String s) {\n    int[] sequence = s.chars().toArray();\n    if (sequence.length == 0) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        int sequenceMax = sequence[0];\n        for (int i = 0; i < sequence.length; i++) {\n            if (sequence[i] > sequenceMax) {\n                sequenceMax = sequence[i];\n            }\n        }\n        return sequenceMax;\n    }\n}\n```\n\n## Тестирование\n\nПри тестировании алгоритма нужно проверить:\n\n- тесты из условия (если есть)\n- общие случаи\n- особые случаи (все числа отрицательные, пустая последовательность)\n\nТесты для алгоритма на поиск максимума последовательности:\n\n- 1 3 2 - общий случай (максимум в середине)\n- 1 2 3, 3 2 1 - максимум по краям \n- 1 1 1 - все элементы одинаковы\n- 1 - один элемент\n- _ - пустая последовательность\n- -2 -1 -3 - все числа отрицательные\n\n### Советы по составлению тестов\n\n- Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу;\n- Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить;\n- Проверь последовательность из одного элемента и пустую последовательность;\n- \"Краевые эффекты\" - проверь что программа работает корректно в начале и конце последовательности сделай тесты чтоы ответ находился на первом и на последнем месте последовательности;\n- Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else;\n- Подбери тесты чтобы не было ни одного входа в цикл;\n- Один тест - одна возможная ошибка;\n\n## Вопросы\n\n1. **_Что приоритетней оптимизация по памяти или по времени исполнения?_**\n\nЧаще всего по времени исполнения, а если есть несколько алгориитмов с одинаковым временем то уже по памяти.\nНо бывают редкие задачи, где память играет решающее значение.\n\n2. **_Почему в решение №3 мы использовали Set но не считали его асимптотическую сложность?_**\n\nДобавление в Set происходит за $O(1)$ времени. Объяснение будет в следующих лекциях.\n\n3. **_Как проверить алгоритм, если не знаешь где может быть ошибка?_**\n\n    1. пишем самый простой базовый алгоритм для решения задачи\n    2. пишем генератор маленьких массивов из случайных чисел\n    3. запускаем цикл и сравниваем ответ нашего алгоритма с ответом примитивного алгоритма","date":"2022-07-24T00:00:00.000Z","path":"/slozhnost-testirovanie-osobye-sluchai/","icon":"fas fa-code","image":"null","order":2,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Сложность","anchor":"#сложность"},{"value":"Особые случаи","anchor":"#особые-случаи"},{"value":"Тестирование","anchor":"#тестирование"},{"value":"Вопросы","anchor":"#вопросы"}]}},{"node":{"id":"11e057dfa368eb6b8d0d3f8135876333","title":"Линейный поиск","content":"\n## Классические задачи линейного поиска\n\nЛинейный поиск - способ поиска, когда перебираются все элементы.\n\nСложность линейного поиска - линейная, т.е. $O(N)$.\n\nОбычно ищут \"подходящий\" элемент или \"наиболее подходящий элемент\".\n\n### Задача 1. Найти первое вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию.\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (ans == -1 && seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 2. Найти последнее вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию (без проверки что текущая позиция равна -1).\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 3. Найти максимальное число в последовательности.\nДана последовательность чисел длиной N (N>0). Найти максимальное число в последовательности.\n\nРешение:\n\nСначала положим в ответ нулевой элемент последовательности (он точно существует, тк N>0), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент.\n\n```java\npublic static int findMax(int[] seq) {\n    int ans = seq[0];\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i] > ans) {\n            ans = seq[i];\n        }\n    }\n\n    return ans;\n}\n```\n\nЕсли условие допускает пустую последовательность то этот случай нужно обрабатывать отдельно через if.\n\nСтроки сравниваются по символьно и когда символы начинают отличаться можно сказать какая строка меньше или больше. Если строки длинные то сравнение будет идти долго, время равно длине строки. \n\nЛексикографический порядок - это сравнение с учетом регистра.\nАлфавитный порядок - это сравннеие, как в словаре, без учета регистра.\n\nРешение задачи не подойдет для строк, так как будет постоянно перезаписываться значение ans, а для строк это требует больше времени, строки могут быть длинные.\n\nНужно запоминать не значение, а индекс максимального элемента. \n\n```java\npublic static String findMax(String[] seq) {\n    int ans = 0;\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i].compareTo(seq[ans]) == 0) {\n            ans = i;\n        }\n    }\n\n    return seq[ans];\n}\n```\n\n### Задача 4. Найти максимальное число в последовательности и второе по величине число.\nДана последовательность чисел длиной N (N>1). \nНайти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число).\n\nРешение:\n\nЗаведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого макисмума, а меньшее - для второго. Пройдем по всей последовательности. Если очередное число больше первого максимума, то запишем во второй макисмум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй макисмум.\n\n```java\npublic static int[] findMax2(int[] seq) {\n        int max1, max2;\n        if (seq[0] > seq[1]) {\n            max1 = seq[0];\n            max2 = seq[1];\n        } else {\n            max1 = seq[1];\n            max2 = seq[0];\n        }\n        for (int i = 2; i < seq.length; i++) {\n            if (seq[i] > max1) {\n                max2 = max1;\n                max1 = seq[i];\n            } else if (seq[i] > max2) {\n                max2 = seq[i];\n            }\n        }\n        return new int[]{max1, max2};\n    }\n```\n\n### Задача 5. Найти минимальное четное число в последовательности.\nДана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого не существует.\n\nРешение:\n\nВ переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.\n\nУниверсальный способ для решения это завести boolean переменную с признаком встречали ли мы четное число или нет. Изначально она равна fasle, а как встретили четное число делаем ее true.\n\n```java\npublic static int findMinEven(int[] seq) {\n    int ans = 0;\n    boolean isFound = false;\n\n    for (int i = 0; i < seq.length; i++) {\n        int now = seq[i];\n        if (now % 2 == 0 && (!isFound || now < ans)) {\n            ans = now;\n            isFound = true;\n        }\n    }\n    return ans;\n}\n```\n\n## Два прохода\n\n### Задача 6. Вывести все самые короткие слова через пробел.\n\nДана последовательность слов. Вывести все самые короткие слова через пробел.\n\nЕсли решать задачу за один проход, то есть сохранять количество символов в строке и саму строку и при нахождении еще более меньшей обновлять ее, это будет медленно и будет лишняя память заниматься. Так как мы будем накапливать слова, и хороше если добавление слова будет занимать $O(1)$, но может быть и больше, если копировать сами объекты. В Java лучше использовать для этих целей StringBuilder или StringBuffer.\n\n```java\npublic static String shortWords(String[] words) {\n    int minLength = words[0].length();\n    for (String word : words) {\n        if (word.length() < minLength) {\n            minLength = word.length();\n        }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (String word : words) {\n        if (word.length() == minLength) {\n            ans.append(word).append(\" \");\n        }\n    }\n\n    return ans.toString();\n}\n```\n\n### Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.\n\nИгра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окруженный морем. Над островом прошел сильный дождь, который затопил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень.\n\nПо ландшафту острова определить, скоолько блоков воды осталось после дождя в низинах острова.\n\n**_Решение:_**\n\nПосле того как вода нальется наш остров примет форму ступенек. Давайте найдем самый высокий столбик(вершину) и до этой вершины будут ступеньки на подъем, вся вода будет сливаться влево от вершины, а все что справа от вершины будет утекать вправо. \n\nРазделим задачу на две задачи по вершине острова и решим сначала для левой а потом по аналогии для правой.\n\nБудем идти и запоминать максимальную высоту столбика который нам встретился, если следующий столбик меньше то добавляем разность высот между этими столбиками которая зальется водой, если же произошло обновление максимума, то количество воды не добавляем.\n\n```java\npublic static int isleFlood(int[] h) {\n    int maxPos = 0;\n    for (int i = 0; i < h.length; i++) {\n        if (h[i] > h[maxPos]) {\n            maxPos = i;\n        }\n    }\n\n    int ans = 0;\n    int nowMax = 0;\n    for (int i = 0; i < maxPos; i++) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n\n    nowMax = 0;\n    for (int i = h.length - 1; i > maxPos; i--) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n    return ans;\n}\n```\n\n## Задача с собеседования\n\n### Задача 8 - RLE\n\nДана строка (возможно пустая), состоящая из букв A-Z: AAAABBBCCХYZDDDВEEEFFFAAAAAABBBBBBBBBBBBBBBBBB}\nНужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3F3A6B18. И сгенерирует ошибку если на вход пришла невалидная строка.\n\nЕсли символ встречался один раз, он остается без изменений; Если символ повторяется более 1 раза, к нему добавляется количество повторений.\n\n\nПопробуем упростить задачу и написать сначала функцию которая выдаст в ответе строку ABCXYZDEFAB.  \nКладем изначально в переменную значение первого символа, далее проходим по всей строки и проверяем если символ не соответсвует предыдущему то добавляем предыдущий символ и обновляем его. В конце добавляем оставшийся последний символ.\n\n```java\npublic static String easyPeasy(String s){\n    StringBuilder ans = new StringBuilder();\n    char lastCh = s.charAt(0);\n    for (int i = 1; i < s.length(); i++) {\n        if(s.charAt(i) != lastCh){\n            ans.append(lastCh);\n            lastCh = s.charAt(i);\n        }\n    }\n    ans.append(lastCh);\n\n    return ans.toString();\n}\n```\n\nДля полноценного выполнения задачи чтобы посчитать сколько раз символ подряд встретился в строке нужно добавить разность между последней позицией текщего повторяющегося символа и позицией последнего отличающегося символа. Добавим анонимную функцию для вычисления.\n\n```java\npublic static String rle(String s) {\n    StringBuilder ans = new StringBuilder();\n    int lastPos = 0;\n    char lastCh = s.charAt(0);\n\n    BiFunction<StringBuilder, Integer, StringBuilder> pack =\n            (str, cnt) -> {\n                if (cnt > 1) {\n                    return str.append(cnt);\n                }\n                return str;\n            };\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) != lastCh) {\n            ans.append(lastCh);\n            pack.apply(ans, i - lastPos);\n            lastCh = s.charAt(i);\n            lastPos = i;\n        }\n    }\n\n    ans.append(lastCh);\n    pack.apply(ans, s.length() - lastPos);\n\n    return ans.toString();\n}\n```\n## Вопросы\n\n1. _**Алгоритмы линейного поиска это про алгоритмы Рабина Карпа?**_\nАлгоритм Рабина Карпа - это алгоритм поиска подстроки в строке и его с большой натяжкой можно назвать алгоритмом линейного поиска. Это довольно умный алгоритм.\n\n2. **_Волнует ли вопрос оптимизации в алгоритме линейного поиска?_**\nДа, волнует, но бывают такие последовательности которые не обладают никаким свойством и задачи поиска максимума или поиска значения в последовательности про которую ничего не известно, никак быстрее не сделать мы так или иначе должны посмотреть каждое значение. ","date":"2022-07-24T00:00:00.000Z","path":"/linejnyj-poisk/","icon":"fas fa-code","image":"null","order":3,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Классические задачи линейного поиска","anchor":"#классические-задачи-линейного-поиска"},{"value":"Два прохода","anchor":"#два-прохода"},{"value":"Задача с собеседования","anchor":"#задача-с-собеседования"},{"value":"Вопросы","anchor":"#вопросы"}]}},{"node":{"id":"c5acffab6a1865f81692199e8114cdf1","title":"Множества","content":"\n## Как устроено множество\n\nМножество - это математическая структура, где каждый элемент либо есть, либо его нету.\n\nЧто должно уметь делать множество:\n\n- добавлять элемент\n- проверять наличие элемента\n- удалять элемент\n\n### Как реализовать множество\n\n- Придумаем какую-нибудь функцию которая сопоставляет каждому элементу какое-либо небольшое число\n- Вычислим функцию от элемента\n- Положим элемент в список с номером, равным значению фуекции\n\nСпособ 1: Завести массив где в ячейку с индексом равным числу которое мы кладем класть boolean переменную true что такое число есть. При удалении менять на false. Но тогда если множество будет большим это будет есть большое количество памяти а если таких множеств несколько то съест еще больше.\n\nСпособ 2: Чтобы поместить большое количество элементов в сравнительно небольшой массив нужно сопоставить каждому элементу какое-либо небольшое число. Для этого сформируем соответсвующую функцию. \n\n### Пример функции добавления для чисел\n\n- Функция - последняя цифра числа $X (F(X) = X \\% 10)$. \nФункция которая переводит большие числа в маленькие  - хеш функция.\n- Вычислим функцию от элемента.\n- Положим элемент в список с номером, равным значению функции.\n\nНапример, наша функция преобразует число 137 -> 7 и  17 -> 7. Такая ситуация называется **коллизией**.\nЕсли мы будем класть в ячейку true/false то когда мы получим число 137 мы положим в ячейку с номером 7 флаг true и когда нас запросят узнать есть ли в множестве число 17 мы скажем что да а это неверно.\n\nОдним из решений этой проблемы - класть в ячейку не флаг а само число. Но в таком виде множество не может одновременно хранить в себе значения и 137 и 17 и т.д. \n\nРешением стало - завести список для всех чисел которые имеют одинаковый хеш. \n\nЕсли у нас множество длины N и внем лежит K элементов, то мы можем перебрать все элементов за N + K. Мы будем идти по всем спискам пока список пустой мы его пропускаем, а как только обнаруживаем непустой список у нас запускается внутренний цикл проходит по всем элементам и их возвращает.\n\nЕсли мы решим напечатать значения Set'a, то оно выводся в произвольном порядке (в порядке возрастания значения хеш функции).\n\nДля того чтобы удалить элемент мы сначала находим значение хеш функции находим ячейку с этим знаением и в найденном списке находим нужный элемент. \nУдаление-1: мы перемещаем элементы  на 1 позицию влево, начиная с позиции того элемента который хотим удалить и последний элемент удаляем. \nУдаление-2: копируем последний элемент на место элемента который удаляем и удаляем самый последний это возможно когда не важен порядок элементов.\nУдаление элемента происходит $O(1)$ а его поиск за $O(K/N)$.\n\n```java\npublic class MySet {\n\n    int setSize = 10;\n    int[][] mySet = new int[setSize][];\n\n\n    public void add(int x) {\n        int[] xSet = mySet[x % 10];\n        if (xSet == null) {\n            mySet[x % 10] = new int[]{x};\n        } else {\n            mySet[x % 10] = ArrayUtils.add(xSet, x);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"MySet{\" +\n                \"setSize=\" + setSize +\n                \", mySet=\" + Arrays.toString(mySet) +\n                '}';\n    }\n\n    public boolean find(int x) {\n        for (int now : mySet[x % 10]) {\n            if (now == x) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void delete(int x) {\n        int[] xList = mySet[x % 10];\n        for (int i = 0; i < xList.length; i++) {\n            int now = xList[i];\n            if (now == x) {\n                xList[i] = xList[xList.length - 1];\n                mySet[x % 10] = ArrayUtils.remove(xList, xList.length - 1);\n                return;\n            }\n        }\n    }\n}\n```\n\nМультимножество - такое множество в которое элемент входит несколько раз.\nЧтобы такого не допускать в методе добавления элемента стоит добавить проверку что такого элемента еще нет.\n\n$F(X) = X \\% setSize$ - хеш функция\n\n$MySet$ - хеш таблица\n\nСовпадение значений хеш-функции для разных параметров - коллизия.\n\n### Что можно эффективно хранить в множестве\n\n- Эффективно можно хранить только неизменяемые объекты.\n- Для неизменяемых объектов можно посчитать значение хеш-функции при их создании\n- Хеш функция должна давать равномерное распределение\n\n## Амортизированная сложность\n\nСлишком большой размер - ест много памяти $O(N)$\n\nСлишком маленький размер - большой коэфициент заполнения и медленный поиск и удаление $O(K/N)$\n\nХочется иметь разумный баланс, например, коэфициент заполнения не больше единицы (т.е. $K<=N$)\nТогда все операции в среднем будут занимать $O(1)$\n\nРешение проблемы: Когда таблица наполнится - увеличим ее размер вдвое и перестроим. Нужно пересчитать хеш каждого элемента в зависимости от нового размера и переместить элементы в соответсвующую ячейку.\n\nАмортизированная сложность - это среднее время выполнения опреации (условно).\n\nУ нас амортизированная сложность операции $O(1)$ - всего было N операций и суммарно на это ушло $O(N)$.\n\nВ худшем случае отдельная операция выполняется за $O(N)$ - может не подходить для систем реального времени.\n\n## Примеры задач\n\n### Задача 1. \nПереберем число А за $O(N)$. Переберем число B за $O(N)$. Если их сумма равна X, то вернем эту пару.\n\nРешение 1 (неправильное)\n\nНеправильное, так как не учитывает, что числа должны быть разные.\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int a : nums) {\n        for (int b : nums) {\n            if (a + b == sum) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\nРешение (исправленное)\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == sum) {\n                return new int[]{nums[i], nums[j]};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\n### Задача 2\nДан словарь из N слов, длина каждого не превосходит K. \nВ записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущеной буквой) в словарь.\n\n","date":"2022-07-24T00:00:00.000Z","path":"/mnozhestva/","icon":"fas fa-code","image":"null","order":4,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Как устроено множество","anchor":"#как-устроено-множество"},{"value":"Амортизированная сложность","anchor":"#амортизированная-сложность"},{"value":"Примеры задач","anchor":"#примеры-задач"}]}},{"node":{"id":"6f14f695df4e6204a9c00933b3230a4c","title":"Словари и сортировка подсчётом","content":"\n## Сортировка подсчетом\n\nПусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K. Все эти числа довольно маленькие. Например, школьные оценки от 1 до 5.\n\nОбычная сортировка(например, из классических быстрая, слиянием, пирамидальная) займет $O(N logN)$.\nНо мы не будем пользоваться классической сортировкой, если значения довольно не большие.\n\nБудем считать количество вхождений каждого числа, а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.\n\nИнтервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.\n\nРешение\n\nСоздаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. \nКогда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. \n\nЗатем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.\nДля языков, у которых нумерация массива начинается с нуля, рекомендуется не экономить эту ячейку памяти, а включить нулевую ячейку, чтобы не напутать с индексами.\n\nМы потратим $O(K)$ времени и $O(K)$ памяти, где К количество возможных значений.\n\n$O(K)$ памяти - тк нам нужно завести массив из К элементов.\n\n$O(K)$ времени - тк на создание массива тоже тратится время, пропорционально его длине. Если не на выделение памяти, то на заполнение нулями точно потратится.\n\n$O(N)$ времени - мы за один проход заполним этот массив, тк каждая операция это прибавление единицы и она занимает $O(1)$ времени. И поскольку чисел N, в сумме это займет $O(N)$.\n\nВ итоге на построение массива уходит $O(N+K)$ времени и $O(K)$ дополнительной памяти.\nТоже самое с выводом: мы пройдемся по всем возможным значениям - это цикл до К и в сумме мы совершим N действий на вывод. То есть на вывод мы тоже потратим $O(N+K)$ времени.\n\nЕсли бы мы не делали нулевой элемент в массиве этобы уменьшило количество занимаемой памяти но затруднило и усложнило вычисление, тк пришлось бы постоянно отнимать дополнительное число.\n\nНо если нужно отсортировать числа далекие от нуля, то этот интервал лучше перенести.\n\n```java\npublic static void countSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt(); // сложность O(N)\n    int min = Arrays.stream(arr).min().getAsInt(); // сложность O(N)\n\n    int k = max - min + 1;\n    int[] array = new int[k];\n    Arrays.fill(array, 0);\n\n    for (int i = 0; i < arr.length; i++) {\n        array[arr[i] - min] += 1;\n    }\n\n    int nowPos = 0;\n    for (int i = 0; i < array.length; i++) {\n        for (int j = 0; j < array[i]; j++) {\n            arr[nowPos] = i + min;\n            nowPos += 1;\n        }\n    }\n}\n```\n\n### Задача 1\n\nДано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.\n\nПосчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10. \nРазложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. \n\nЦиклом while проходим по каждой цифре пока после деления не останется 0. Такой способ возможен только если число без ведущих нулей. Это как раз наш случай.\nРаскладываем цифры в массив от 0 до 9, в соответсвии со значением индекса. Пришла цифра 9 увеличиваем на один значение в ячейке с индексом 9 и тд.\nДелаем это для обоих чисел и сравним эти массивы по элементно. Достаточно найти всего одно несовпадение.\n\nСортировка подсчетом уместна, когда разница между максимальным и минимальным значением небольшая и числа с одним и тем же значением встречаются достаточно часто, тогда N > K и сложность сортировки фактически стала $O(N)$.\nЕсли это не так, то точная оценка $O(N+K)$, но в случаях когда K большое, а N маленькое, сортировка подсчетом не лучший выбор.\nМожно вычислить конкретное значение K и сравнить с $N logN$.\n\n```java\npublic static boolean isDigitPerMutation(int x, int y) {\n    int[] digitsX = countDigits(x);\n    int[] digitsY = countDigits(y);\n    for (int i = 0; i < 10; i++) {\n        if (digitsX[i] != digitsY[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static int[] countDigits(int num) {\n    int[] digitCount = new int[10];\n    Arrays.fill(digitCount, 0);\n\n    while (num > 0) {\n        int lastDigit = num % 10;\n        digitCount[lastDigit] += 1;\n        num /= 10;\n    }\n    return digitCount;\n}\n```\n\n\n## Словари\n\nБолее универсальный алгоритм, но в некоторых случаях может работать хуже чем сортировка подсчетом.\n\nСловарь - он как множество, но к каждому ключу приписано значение.\nВ словаре есть пара ключ - значение (key, value). И все что происходит в множестве (подсчет хеша, раскладываение и тд), оно проходит только по ключу.\n\nКлюч должен быть неизменяемым объектом, чтобы у него эффективно хеш вычислялся, а значение может быть каким угодно, от него хеш ни в какой момент не считается, оно просто болтается рядом с ключом.\n \nИскать по значению в словаре нельзя.\n\nСложность поиска в словарях $O(1)$. НО константа большая. Тк может происходить расширение словаря, может считаться хеш функция и тд. Работает это медленее, чем доступ по индексу, как это происходит в сортировке подсчетом.\n\nКонстанта в сложности словарей заметно больше, чем у массивов, поэтому где можно - лучше использовать сортировку подсчетом (если начения лежат довольно плотно (разность между максимальным и минимальным не велика) и значения встречаются по несколько раз).\n\nСортировку подсчетом использовать неразумно, если данные разреженные(редкие вхождения, например числа до миллиарда).\n\n### Задача 1\n\nНа шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) \nОпределите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.\n\n$1<= N <= 10^9, 0<=M<=2*10^5$.\n\nРешение\n\nДля каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.\n\nЧтобы оценить время работы программы мы можем посмотреть на входные данные, значение N может достигать $10^9$ или $1 000 000 000$ - 1 миллиард операций. Даже на языке C, при наличии не примитивных операций, это может быть достаточно долго, для других языков тем более.\nПоэтому нужно ориентироваться на значение M, оно может достигать $2*10^5$ или $200 000$ - 200 тысяч оперций.\n\n> Ладья бьет другую ладью, если они стоят на одной вертикали или горизонтали.\n\n> Ферзь бьет другого ферзя, если они стоят на одной вертикали или горизонтали или на одной диагонмали(диагональ слева направо /, диагональ справа налево \\\\).\n\nОбратим внимание, что если на одной линии стоит 3 ладьи то они образуют 2 пары которые бьют друг друга.\nЕсли на одной линии 4 ладьи, то они образуют 3 пары и т.д.\nПолучается что пар ладей на 1 меньше, чем количество ладей на одной линии.\n\nОтталкиваясь от этого нужно завести 2 словаря для вертикали и горизонтали в которой будем подсчитывать количество ладей на соответсвующей линии.\n\n```java\npublic static int countBeatingRooks(int[][] rookcoords) {\n    Map rooksInRow = new HashMap<Integer, Integer>();\n    Map rooksInCol = new HashMap<Integer, Integer>();\n    for (int i = 0; i < rookcoords.length; i++) {\n        addRook(rooksInRow, rookcoords[i][0]);\n        addRook(rooksInCol, rookcoords[i][1]);\n    }\n    return countPairs(rooksInCol) + countPairs(rooksInRow);\n}\n\npublic static void addRook(Map<Integer, Integer> rowOrCol, int key) {\n    if (!rowOrCol.containsKey(key)) {\n        rowOrCol.put(key, 0);\n    }\n    rowOrCol.put(key, rowOrCol.get(key) + 1);\n}\n\npublic static int countPairs(Map<Integer, Integer> rowOrCol) {\n    int pairs = 0;\n    for (Integer key : rowOrCol.keySet()) {\n        pairs += rowOrCol.get(key) - 1;\n    }\n    return pairs;\n}\n```\n\nСложность данного решения составит $O(M)$. N - никак не участвует в оценке сложности.\nЕсли нужно будет посчитать ферзей, то нужно завести 2 словаря для диагоналей, в которых в качестве ключа для диагонали из нижнего левого угала в правй верхний (/) будет сумма между координатами (row + col или x+y),\nа для диагонали из левого верхнего угла в нижний правый угол (\\\\) будет разность между координатами (row - col или x-y).\n\n### Задача 2\n\nДана строка S.\nВыведите гистограмму как в примере (коды символов отсортированы)\n\nS = Hello, world!\n```\n      #\n      ##\n##########\n !,Hdelorw\n```\n\nПосчитать для каждой буквы сколько раз она встречается и вывести таким образом, как в примере.\n\nРешение\n\nДля каждого символа в словаре посчитаем, сколько раз он встречался. Найдем самый частый символ и переберем количество от этого числа до 1. Пройдем по всем отсортированным ключам и если количество больше счетчика - выведем #.\n\n1. Заводим словарь. Так как когда мы работаем с текстом, алфавит может быть очень большой, могут какие-нибудь иероглифы или эмоджи или еще какие либо символы использоваться. Если явно не сказано что только латинские буквы то лучше использовать словарь.\n2. Проходим по символам и добавляем в словарь по ключу со значением символа сколько раз он встречается.\n3. Отсортировать ключи и вывести нужным образом символы #.\n\nДля того чтобы вывести символы # по условию задачи, нужно найти максимальное значение(n), когда встречается один и тот же символ и для каждого символа в цикле пройтись от 1 до n и если значение меньше того что вышло в цикле то ставим пробел иначе ставим #. \n\n```java\npublic static void printChart(String s) {\n    Map<Character, Integer> symCount = new HashMap();\n    int maxSymCount = 0;\n    char[] charArray = s.toCharArray();\n    for (int i = 0; i < charArray.length; i++) {\n        char sym = charArray[i];\n        if (!symCount.containsKey(sym)) {\n            symCount.put(sym, 0);\n        }\n        symCount.put(sym, symCount.get(sym) + 1);\n        if (symCount.get(sym) > maxSymCount) {\n            maxSymCount = symCount.get(sym);\n        }\n    }\n    List<Character> sortedUniqSyms = symCount\n            .keySet()\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n    for (int i = maxSymCount; i > 0; i--) {\n        for (Character sym : sortedUniqSyms) {\n            if (symCount.get(sym) >= i) {\n                System.out.print('#');\n            } else {\n                System.out.print(' ');\n            }\n        }\n        System.out.println();\n    }\n\n    String str = sortedUniqSyms.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n    System.out.println(str);\n}\n```\n\nЭтот алгоритм не самый эффективный, во-первый вместо вызова функции print луше класть символы в массив и потом выводить строку через join, во-вторых в худшем случае этот алгоритм может работать за $O(N^2)$ или $O((N/2)^2)$\n\n\n## Задел под оптимизацию\n\nПреждевременная оптимизация страшный грех :). Так как иногда нужно сделать быстро  и нет времени на реализацию эффективных алгоритмов. В этом случае лучше сделать таким образом чтобы если вдруг придется решать проблему со скоростью было примерно понятно как это сделать при теущей реализации.\n\n### Всегда ли асмиптотически лучшее решение лучше?\n\n>  Например есть 2 алгоритма: \n- линейный - $1000 * N$ - $O(N)$ \n- алгоритм $2 * NlogN$ - $O(NlogN)$\n\nНа первый взгляд первый алгоритм лучше, но константа отличается в 500 раз.\nДля уточнения разделим обе части на N.\n\n> $2 * logN$ или $1000$\n\nТеперь делим на 2.\n\n> $logN$ или $500$\n\nТеперь то какой алгоримт лучше будет зависить от N.\n\nПри $N>2^{500}$ решение за $O(N)$ лучше, чем решение за $O(NlogN)$, но $2^{500}$ это $3*10^{150}$, что примерно в  $10^{70}$ раз больше количества атомов во вселенной. И вряд ли наш алгоритм будут запускать для таких чисел.\n\n> В реальности разница констант в 500 раз все же случается редко.\n\n### Некоторые другие критерии качества алгоритма\n\n- Потребление памяти - часто бывает, что есть 2 алгоритма с одной асимтотической сложностью, но разным потреблением памяти. Но чаще все равно выбирается время с хорошей асимтотикой.\n\n- Время на реализацию - если нужно писать какой то хороший алгорим но очень долго. То тут может не быть нужного оличества времени.\n\n- Сложность поддержки - как легко алгоритм будет поддерживать\n\n- Возможность распараллеливания - возможно ли будет алгортим разложить на несколько серверов если увеличится нагрузка.\n\n- Необходимая квалификация сотрудника - насколько легко найти человека который сможет поддерживать и разобраться в написанном вами алгоритме.\n\n- Стоимость оборудования - мы можем посидеть потратить время или купить более дорогое железо которое будет быстрее выполнять не самый эффективный алгоритм.\n\n### Задача 3\n\nСгруппировать слова по общим буквам.\n\n> ```Sample Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]```\n\n> ```Sample Output: [\"ate\", \"eat\", \"tea\"], [\"nat\", \"tan\"], [\"bat\"]```\n\n\nОтсортируем в каждом слове буквы и это будет выступать в роли ключа, а значением будет список слов.\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        char[] sortedWord = word.toCharArray();\n        Arrays.sort(sortedWord);\n        String srtWord = new String(sortedWord);\n        if (!groups.containsKey(srtWord)) {\n            groups.put(srtWord, new ArrayList<Character>());\n        }\n        groups.get(srtWord).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String sortedWord : groups.keySet()) {\n        ans.add(groups.get(sortedWord));\n    }\n\n    return ans;\n}\n```\n\nВдруг слово будет длинное (N)? Сортировка займет $O(NlogN)$. Количество различных букв в слове $K{\\leq}N$, можем посчитать количество каждой за $O(N)$ и отсортировать за $O(KlogK)$ с помощью сортировки подсчетом, теоретически \n\n#### Задел под оптимизацию\nНо так как в данный момент все успешно работает и нет времени на переделывание, то можно вынести шаги с сортировкой в отдельный метод.\n\n> Будет тормозить - посмотрим на профилировщике где, и если долго считается ключ - легко поправим на что-то более эффективное.\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Arrays.sort(sortedWord);\n    return new String(sortedWord);\n}\n```\n\n#### Оптимизация\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Map<Character, Integer> symCnt = new HashMap();\n    for (char sym : sortedWord) {\n        if (!symCnt.containsKey(sym)) {\n            symCnt.put(sym, 0);\n        }\n        symCnt.put(sym, symCnt.get(sym) + 1);\n    }\n    ArrayList<String> lst = new ArrayList<>();\n\n    for (char sym : symCnt.keySet().stream().sorted().collect(Collectors.toList())) {\n        lst.add(Character.toString(sym));\n        lst.add(symCnt.get(sym).toString());\n    }\n    return lst.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n}\n```\n\nВ худших случаях этот алгоритм будет работать быстрее, но в среднем будет тормозить.\nИ в некоторых случаях этот алгоритм можно сломать :)\n\n#### Сомнительная оптимизация (?)\n\nНо человек может не выделить часть под оптимизацию в отдельную функцию а вставить код прямо в основной алгоритм.\nКак минимум такой код будет тяжело читать. И вносить изменения, если придется.\n\n\n## Вопросы для проработки\n\n1. Как сджойнить массив символов в строку?\n```java\nlst.stream().map(String::valueOf).collect(Collectors.joining());\n```\n\n2. Как отсортировать массив?\n```java\nsymCnt.keySet().stream().sorted().collect(Collectors.toList())\n```\n\nhttps://www.youtube.com/embed/Nb5mW1yWVSs?si=IN4XvqnlTrMeJ7SK","date":"2022-07-25T00:00:00.000Z","path":"/slovari-i-sortirovka-podschyotom/","icon":"fas fa-code","image":"null","order":5,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Сортировка подсчетом","anchor":"#сортировка-подсчетом"},{"value":"Словари","anchor":"#словари"},{"value":"Задел под оптимизацию","anchor":"#задел-под-оптимизацию"},{"value":"Вопросы для проработки","anchor":"#вопросы-для-проработки"}]}},{"node":{"id":"22c652dcdaead037696450e6145fb608","title":"Префиксные суммы и два указателя","content":"\n## Префиксные суммы\n\nОдин из вариантов, когда нужно использовать алгоритм префиксные суммы, это определение чему равна сумма элементов на полуинтервале [L, R) или отрезке. \n\n> Пусть у нас есть массив `nums` из `N` чисел и необходимо ответить на запрос \"Чему равна сумма элементов на полуинтервале [L, R)?\"\n\nЧтобы решить эту задачу нужно совершить предподсчет, некоторые предварительные действия с помощью которых мы потом сможем быстро отвечать на запрос.\n\nЭти действия имеют смысл только если запросов много. Если не много то лучше просто пробежаться и посчитать.\n\n> Подсчитаем массив `prefixsum` длиной `N+1`, где `prefixsum[k]` будет хранить сумму всех чисел из `nums` с индексами от `0` до `k-1`.\n\nСоздадим массив префиксных сумм. Длина у него будет больше чем у исходного массива.\nИ к-тый элемент этого массива будет равняться сумме всех чисел исходного массива с индексами от `0` до `k-1`.\nТакой массив легко посчитать за O(N^2). Но можно и еще быстрее.\n\n### Построение массива префиксных сумм\n\nДля построения массива префиксных сумм не обязательно каждый раз складывать все значения по индексам. Достаточно взять предыдущую префиксную сумму и прибавить к ней очередное значение.\n\nO(N): prefixsum[i] = prefixsum[i-1] + nums[i-1]\n\n|Индекс|0|1|2|3|4|5|6|\n|---|---|---|---|---|---|---|---|\n|nums|5|3|8|1|4|6|\n|prefixsum|0|5|8|16|17|21|27|\n\nПри составлении префиксного массива нужно помнить 2 вещи:\n\n1. Массив префиксных сумм должен быть на 1 больше, чем исходный!\n2. Переполнение. Целые числа могут переполнить допустимое значение. При сложении 2х int значений, при переполнении получается не верный результат. Если складывать long + int то значение будет приведено к типу long\n\n### Ответ на запрос суммы на полуинтервале\n\n> Ответ за O(1): sum(L, R) = prefixsum[R] - prefixsum[L]\n\n> Найдем sum(2, 5) = prefixsum[5] - prefixsum[2] = 21 - 8 = 13\n\nПочему мы ищем полуинтервал?\nЧтобы избежать проблемы запросов прижатых к левому краю.\nЕсли мы будем искать значение от 0 до 3, как для полуинтервала, то все будет корректно. А если считать как для отрезка то чтобы взять значение прижатое к левому краю нам пришлось бы выйти за пределы массива и взять элементс индексом -1.\n\n### Реализация RSQ(Range Summ Query) через префиксные суммы\n\n```java\npublic static long[] makePrefixSum(int[] nums) {\n      long[] prefixsum = new long[nums.length + 1];\n      for (int i = 1; i < nums.length + 1; i++) {\n          prefixsum[i] = prefixsum[i - 1] + nums[i - 1];\n      }\n      return prefixsum;\n  }\n\n  public static long rsq(long[] prefixsum, int l, int r) {\n      return prefixsum[r] - prefixsum[l];\n  }\n  ```\n\nПример задачи:\n\nПусть на сайт заходят люди и для каждого человека записано, когда он зашел. Нужно посчитать сколько людей у нас было на сайте с L дня по R.Получится массив где в каждом элементе будет храниться число человек посетивших сайт в этот день. И далее с помощью алгоритма префиксных сумм можно ответить на целевой вопрос.\n\n\n### Задача 1\n\n> Дана последовательность чисел длиной N и M запросов\n\nЗапросы: Сколько нулей на полуинтервале [l, R)\n\n#### Решение за O(NM)\n\n> Для каждого запроса переберем все числа от L до R (не включительно) и считаем количество нулей. В худшем случае каждый запрос за `O(N)`. Так как всего запросов M то общая сложность решения `O(NM)`.\n\n\n```java\npublic static int countZeroes(int[] nums, int l, int r) {\n    int cnt = 0;\n    for (int i = l; i < r; i++) {\n        if(nums[i] == 0){\n            cnt+=1;\n        }\n    }\n    return cnt;\n}\n```\n\n#### Решение за O(N+M)\nПопробуем применить метод префиксных сумм. Вместо префиксных сумм будем считать количество нулей на префиксе.\n\n> Для каждого префикса посчитаем количество нулей на нем (prefixZeroes). Тогда ответ на запрос на полуинтервале [L, R): prefixZeroes[R] - prefixZeroes[L].\n\n||0|1|2|3|4|5|6|7|\n|---|---|---|---|---|---|---|---|---|\n|nums|1|0|1|1|0|0|1|\n|prefixZeroes|0|0|1|1|1|2|3|3|\n\n```java\npublic static long[] makePrefixZeroes(int[] nums) {\n    long[] prefixsum = new long[nums.length + 1];\n    for (int i = 1; i < nums.length + 1; i++) {\n        if(nums[i-1] == 0){\n            prefixsum[i] = prefixsum[i - 1] + 1;\n        }else{\n            prefixsum[i] = prefixsum[i - 1];\n        }\n    }\n    return prefixsum;\n}\n\npublic static long countZeroes(long[] prefixZeroes, int l, int r) {\n    return prefixZeroes[r] - prefixZeroes[l];\n}\n```\n\nПолучается сложность O(N+M). O(N) уйден на построение тк у нас N элементов. И на каждый из M запросов мы отвечаем за O(1).\n\n\n### Задача 2\n\n>Дана последовательность чисел длиной N.\nНеобходимо найти количество отрезков с нулевой суммой.\n\n#### Решение за $O(N^3)$\n\n> Переберем начало и конец отрезка и просто просуммируем все его элементы.\n\nПеребираем левую и правую границу отрезка и перебираем цифры которые находятся между ними.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length + 1; j++) {\n            int rangeSum = 0;\n            for (int k = i; k < j; k++) {\n                rangeSum += nums[k];\n            }\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N^2)$\n\n> Переберем начало и будем двигать конец, сумируя элементы.\n\nФиксируем значение слева и затем двигая от этой точки указатель правого края высчитываем сумму.\nНам не нужно каждый раз заново высчитывать всю сумму.\n\n\n```java\npublic static int countZeroSumRanges(int[] nums) {\n    int cntRanges = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int rangeSum = 0;\n        for (int j = i; j < nums.length; j++) {\n            rangeSum += nums[j];\n            if (rangeSum == 0) {\n                cntRanges += 1;\n            }\n        }\n    }\n    return cntRanges;\n}\n```\n\n#### Решение за $O(N)$\n\nНасчитаем префиксные суммы. Одинаковые префиксные суммы означают, что сумма на отрезке с началом и концом в позициях, на которых достигаются одинаковые префиксные суммы, будет равна нулю.\n\n1. Проходим по массиву и считаем префиксые суммы, при подсчете в словаре увеличиваем количество точек в этой сумме на 1.\n2. Проходим по словарю и для каждой суммы высчитываем количество пар сочетаний по комбинаторной формуле, где k = 2 так как ищем пару\n\n${C_{n}^{k}} = \\frac{n!}{k!(n-k)!} = \\frac{n \\times (n -1) \\times (n - 2)!} {2! \\times (n - 2)!} = \\frac{n \\times (n - 1)} {2}$\n\n```java\npublic static Map<Integer, Integer> countPrefixSums(int[] nums) {\n    Map<Integer, Integer> prefixSumByValue = new HashMap<>();\n    {\n        prefixSumByValue.put(0, 1);\n    }\n    int nowSum = 0;\n    for (int now : nums) {\n        nowSum += now;\n        if (!prefixSumByValue.containsKey(nowSum)) {\n            prefixSumByValue.put(nowSum, 0);\n        }\n        prefixSumByValue.put(nowSum, prefixSumByValue.get(nowSum) + 1);\n    }\n    return prefixSumByValue;\n}\n\npublic static int countZeroSumRanges(Map<Integer, Integer> prefixSumByValue) {\n    int cntRanges = 0;\n    for (Integer nowSum : prefixSumByValue.keySet()) {\n        int cntSum = prefixSumByValue.get(nowSum);\n        cntRanges += cntSum * (cntSum - 1) / 2;\n    }\n\n    return cntRanges;\n}\n```\n\n## Два указателя\n\n### Задача 1\n\n> Дана отсортированная последовательность чисел длиной N и число K. \nНеобходимо найти количество пар чисел A, B, таких что B - A > K.\n\n#### Решение за $O(N^2)$\n\nПереберем все пары чисел и для каждой проверим условие.\n\nВо вложенном цикле можно идти не каждый раз сначала перебирая цифры, а дигаясь вправо от левой границы.\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    for (int i = 0; i < sortedNums.length; i++) {\n        for (int j = i; j < sortedNums.length; j++) {\n            if (sortedNums[j] - sortedNums[i] > k) {\n                cntPairs += 1;\n            }\n        }\n    }\n    return cntPairs;\n}\n```\n#### Решение за $O(N)$\n\nВозьмем наименьшее число и найдем для него первое подходящее большее. Все еще большие числа точно подходят. Возьмем в качестве меньшего числа следующее, а указатель первого подходящего большего будем двигать начиная с той позиции, где он находится сейчас\n\n```java\npublic static int cntPairsWithDiffGtk(int[] sortedNums, int k) {\n    int cntPairs = 0;\n    int last = 0;\n    for (int first = 0; first < sortedNums.length; first++) {\n\n        while (last < sortedNums.length && sortedNums[last] - sortedNums[first] <= k) {\n            last += 1;\n        }\n        cntPairs += sortedNums.length - last;\n    }\n    return cntPairs;\n}\n```\n\n### Задача 2\n\n> Игрок в футбол обладает одной числовой характеристикой - профессионализмом. Команда называется сплоченной, если профессионализм любого игрока не превосходит сумарный профессионализм любых других двух игроков из команды. Команда может состоять из любого количества игроков. Дана отсортированная последовательность чисел длиной N - профессионализм игроков.\n\nНеобходимо найти максимальный суммарный профессионализм сплоченной команды.\n\n```java\npublic static int bestTeamSum(int[] players) {\n    int bestSum = 0;\n    int nowSum = 0;\n    int last = 0;\n    for (int first = 0; first < players.length; first++) {\n\n        while (last < players.length && (last == first || players[last] + players[first] >= players[last]) {\n            nowSum += players[last];\n            last += 1;\n        }\n        bestSum = bestSum >= nowSum ? bestSum : nowSum;\n        nowSum -= players[first];\n    }\n    return bestSum;\n}\n```\n\n### Задача 3\n\nДаны две отсортированные последовательности чисел (длиной N и M соответсвенно) \n\nНеобходимо слить их в одну отсортированную последовательность.\n\nРешение\n\n\nДве последовательности могуть быть не обязательно одинаковые по длине, могут быть одинаковые числа.\n\nИдея решения: делаем указатель на текущий элемент первой и во второй последовательности и просто выводим то что меньше по текущему указателю. Например, из чисел из 1 и 3 меньше 1 - 1 записали в ответ и указатель двинули в той последовательности из которой мы взяли очередное число и так далее. Если одна из последовательностей заканчивается мы просто выписываем весь оставшийся хвост текущей последовательности.\n\n#### Неидеальная реализация\n\nПоставим два указателя на начало каждой из последовательностей. Выберем тот, который указывает на меньшее число, запишем это число в результат и сдвинем указатель\n\n\n\n","date":"2024-02-01T00:00:00.000Z","path":"/prefiksnye-summy-i-dva-ukazatelya/","icon":"fas fa-code","image":"null","order":6,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Префиксные суммы","anchor":"#префиксные-суммы"},{"value":"Два указателя","anchor":"#два-указателя"}]}},{"node":{"id":"c6c09582f5874298494603fa9eb85f00","title":"Бинарный поиск","content":"","date":"2022-07-24T00:00:00.000Z","path":"/binarnyj-poisk/","icon":"fas fa-code","image":"null","order":7,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"f0bc8f5215664a8dc315c8444ce617be","title":"Сортировка событий","content":"","date":"2022-07-24T00:00:00.000Z","path":"/sortirovka-sobytij/","icon":"fas fa-code","image":"null","order":8,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"e6e65d2d9d8ae4c94f59d2f36ce4023e","title":"Деревья","content":"","date":"2022-07-24T00:00:00.000Z","path":"/derevya/","icon":"fas fa-code","image":"null","order":9,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}}]}},"relatedTag":null},"context":{}}