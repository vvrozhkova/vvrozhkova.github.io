{"hash":"aa5a7ff62b399012289acf12f7cc1503ba4e22e5","data":{"tag":{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/","belongsTo":{"totalCount":16,"pageInfo":{"totalPages":2,"currentPage":2},"edges":[{"node":{"id":"3af94f116f420bf83db600a7070f6b77","title":"Test Scenario","content":"","date":"2022-05-13T00:00:00.000Z","path":"/test-scenario/","icon":"fas fa-bug","image":"null","order":24,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[]}},{"node":{"id":"7f14dbdf826b67d63cfea164b4cbe91b","title":"External Test Reports","content":"## Виды отчетов (Reports)\n\nОтчет - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.\n\nНам важно понять, для кого, для чего и в каких условиях мы это делаем и на сколько это улучшит восприятие излагаемой нами информации. Надо помнить, что каждое действие преследует определенную цель. В случае отчета нам важно понять, для кого, для чего и в каких условиях мы это делаем.\n\nНиже перечислены наиболее известные варианты отчетов в тестировании.\n\n**Отчет по инциденту (incident report)**\n\n_Отчет по инциденту (incident report): Документ, описывающий событие, которое произошло, например, во время тестирования, и которое необходимо исследовать. (IEEE 829)_\n\nОтчет об инцидентах можно определить как письменное описание инцидента, наблюдаемого во время тестирования. Чтобы лучше понять, давайте начнем с того, что такое «инцидент». Инцидент при тестировании программного обеспечения можно определить как наблюдаемое изменение или отклонение поведения системы от ожидаемого. Это может быть отклонение от функционального требования или от настроек среды. Очень часто инцидент называют дефектом или ошибкой, но это не всегда так. Инцидент - это в основном любое неожиданное поведение или реакция программного обеспечения, требующая расследования.\n\nИнцидент необходимо расследовать, и на основании расследования инцидент может быть преобразован в дефект. Чаще всего это оказывается дефектом, но иногда это может произойти из-за различных факторов, например:\n\n* Человеческий фактор;\n* Требование отсутствует или неясно;\n* Проблема среды, например отсутствие ответа от внутреннего сервера, вызывающее периодическое непредвиденное поведение или ошибку. Либо неправильная конфигурация среды;\n* Ошибочные тестовые данные;\n* Некорректный ожидаемый результат.\n\nIncident report призван зафиксировать и сообщить об инциденте заинтересованным лицам, провести расследование. Составляется аналогично баг-репорту, возможно с упором на расследование, обсуждение, влияние (impact) и может быть назначен не на разработчиков для уточнения деталей.\n\n**Отчет о результатах тестирования (test result report)**\n\nОтчет о результатах тестирования - периодический отчет, в котором документируется подробная информация о выполнении теста и его результате. Также он содержит условия, предположения, ограничения теста, какой элемент теста кем тестируется. Помимо этого вносится подробная информация об оставшейся работе, чтобы показать, сколько еще работы необходимо выполнить в проекте.\n\n**Отчет о выполнении теста (Test Execution Report)**\n\nОтчет о выполнении теста содержит детали выполнения и результат выполнения теста. Обычно его готовят для отправки вышестоящему руководству от группы тестирования, чтобы показать состояние выполнения теста и ход тестирования. Когда мы доставляем программное обеспечение клиенту, мы вкратце отправим полную информацию о выполнении теста. Это даст клиенту лучшее понимание выполненного теста и покрытия.\n\n**Отчет о ходе тестирования (test progress report)**\n\n_Отчет о ходе тестирования (test progress report): Документ, подводящий итог задачам и результатам, составляемый с определенной периодичностью с целью сравнения прогресса тестирования с базовой версией (например, с исходным планом тестирования) и извещения о рисках и альтернативах, требующих решения руководства. (ISTQB)_\n\n**Аналитический отчет о тестировании (test evaluation report)**\n\n_Аналитический отчет о тестировании (test evaluation report): Документ, создаваемый в конце процесса тестирования и подводящий итог тестовым активностям и результатам. Также в нем содержится оценка процесса тестирования и полученный опыт. (ISTQB)_\n\n**Итоговый отчет о тестировании (test summary report)**\n\n_Итоговый отчет о тестировании (test summary report): Документ, подводящий итог задачам и результатам тестирования, также содержащий оценку соответствующих объектов тестирования относительно критериев выхода. (IEEE 829)_\n\nСводный отчет о тестировании содержит подробную информацию о тестировании, проведенном на протяжении жизненного цикла разработки программного обеспечения. Элементы в итоговом отчете по тестированию различаются от организации к организации, а также различаются для разных проектов. Информация в отчете об испытаниях основывается на аудитории отчета об испытаниях. Аудитория может быть клиентом, менеджментом, бизнес-аналитиком, разработчиками, членами команды тестирования, членами организации и т. д.\n\n**Отчет о пользовательском приемочном тестировании (User acceptance test report)**\n\nОтчет о пользовательском приемочном тестировании создается во время и после UAT. В нем указываются подробности проведенного пользователем приемочного теста и результат пользовательского приемочного теста. В нем также перечислены дефекты, не учтенные при UAT.\n\nИсточники:\n\n* [Создание понятных отчетов о тестировании](https://habr.com/ru/company/performance\\_lab/blog/207512/)\n* [What Is Incident Report In Software Testing?](https://www.softwaretestingclass.com/what-is-incident-report-in-software-testing/)\n* [Software Testing Artifacts - Test Reports](https://www.softwaretestingclass.com/test-report-artifacts/)\n\nДоп. материал:\n\n* [Как составить отчет о тестировании](https://telegra.ph/test-report-04-15)\n* [48+ SAMPLE Test Report Templates](https://www.sample.net/reports/test-report/)\n* [Отчет по результатам тестирования сайта](https://www.performance-lab.ru/wp-content/themes/pureengineering/images/sitetesting/test\\_report\\_example.pdf)\n* [Отчет о тестировании релиза](https://vk.com/@usetalkrostov-otchet-o-testirovanii-reliza)\n* [Test report templates](https://strongqa.com/qa-portal/testing-docs-templates/test-report)\n* [Test Summary Reports Tutorial: Learn with Example & Template](https://www.guru99.com/how-test-reports-predict-the-success-of-your-testing-project.html)\n","date":"2022-05-13T00:00:00.000Z","path":"/external-test-reports/","icon":"fas fa-bug","image":"null","order":25,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Виды отчетов (Reports)","anchor":"#виды-отчетов-reports"}]}},{"node":{"id":"b322c5bcfb57e7082e6220267066bc6a","title":"Критерии приемки","content":"\n## Критерии приемки (Acceptance Criteria)\n\n_Критерии приемки (acceptance criteria): Критерии выхода, которым должны соответствовать компонент или система, для того, чтобы быть принятыми пользователем, заказчиком или другим уполномоченным лицом. (IEEE 610)_\n\nКритерии приемки - это условия, которым должен удовлетворять программный продукт, чтобы быть принятым пользователем, заказчиком или, в случае функциональности системного уровня, потребляющей системой. Проще говоря - это список деталей (также известных как требования) о том, как новая функция (feature) программного обеспечения должна работать / выглядеть. Это гарантирует, что:\n\n* Функция разработана хорошо. В противном случае важный или полезный аспект может быть упущен - и никто этого не заметит до самого конца.\n* Это работает так, как было задумано. Если описание расплывчато, разработчикам, возможно, придется сделать предположения о том, как должна работать каждая область. С критериями приемки разработчики точно знают, какой дизайн и функциональность ожидаются.\n* QA знает, чего ожидать во время тестирования. Даже если функция не выглядит сломанной, она может работать не так, как хотели менеджеры по продукту. Если критерии приемки отсутствуют, тестировщики не могут сообщать о подобных проблемах.\n\nХорошие критерии приемки должны быть простыми для понимания, но с достаточной детализацией, чтобы убедиться, что они не слишком расплывчаты. Это не всегда универсальный подход. Но они всегда должны предоставлять достаточно информации для разработчиков, чтобы создать функцию, а для QA - для ее тестирования. Это не значит, что в процессе разработки программного обеспечения не возникнет вопросов. Но в целом функция должна быть понятной.\n\nФормат / макет / шаблон критериев приемки (Acceptance Criteria Format/Layout/Template): существует два основных типа критериев приемки, основанные на сценариях и правилах:\n\n* Критерии приемлемости, основанные на сценариях (Scenario-based acceptance criteria), используют шаблон для подробного описания конкретного поведения / последовательности действий пользователя;\n* Критерии приемлемости на основе правил (Rule-based acceptance criteria) - это скорее простой список того, как функция должна выглядеть / работать;\n\n**Scenario-based acceptance criteria** соответствует формату “Дано/Когда/Тогда” (“Given/When/Then”) (основан на BDD - [behavior driven development](https://en.wikipedia.org/wiki/Behavior-driven\\_development)):\n\n* Given /_какой-то аспект, связанный с поведением пользователя_/\n* When /_пользователь выполняет определенное действие_/\n* Then /_происходит определенный результат_/\n\nМежду ними в случае нескольких условий можно добавлять “И” (“AND”).\n\n**Rule-Based Acceptance Criteria** - это простой список «правил» о том, как функция должна выглядеть / работать:\n\n* Все кнопки должны быть определенного цвета;\n* Кнопка входа должна перенаправлять пользователя в определенный раздел;\n* Кнопка регистрации должна находиться в определенной области;\n* Все кнопки должны быть серыми, если не выполняются определенные требования;\n* и многое другое;\n\nХотя критерии, основанные на правилах, имеют более простой формат, нет причин, по которым они не могут быть длинными и подробными.\n\n**Кто пишет критерии приемки?** Обычно в создании критериев приемки участвуют несколько человек или команд. Тем не менее, это в первую очередь делает product manager (или “product owner”). Разработчики несут ответственность за обеспечение функциональности функции, а QA - за подтверждение ее удобства использования. Но критерии приемки создаются человеком или командой, ответственной за решение, какие новые функции добавить в продукт (независимо от типа приложения или веб-сайта).\n\nБольшая часть Agile включает внесение изменений по мере развития проекта. Так **могут ли критерии приемки измениться в середине спринта?** Ответ: «Это зависит от обстоятельств». Если спринт начался, но разработчики еще не завершили эту функцию, можно изменить требования. Но важно всегда сначала согласовывать с разработчиками и держать других (например, QA) в курсе. Тестировщики могли написать test cases, которые больше не актуальны после изменений. Кроме того, новый объем работы может оказаться слишком большим, чтобы разработчики могли завершить его вовремя.\n\n\\*\\*User Stories vs Acceptance Criteria: \\*\\*пользовательские истории и критерии приемки идут рука об руку. Пользовательская история описывает основную цель новой функции - обзор того, как она поможет пользователям. Критерии приемки перечисляют способы работы функции с технической точки зрения. Обычно в тикетах (например, в Jira или Trello) вверху указывается пользовательская история, за которой следуют критерии приемки\n\n**Definition of Done:** чтобы заявка (или функция) считалась «выполненной», все критерии должны работать. Например, предположим, что пользовательская история была: “Как пользователь, я хочу иметь возможность войти в систему, чтобы получить доступ к панели управления моей учетной записи”. Как уже упоминалось, пользователь может войти в систему, чтобы получить доступ к панели управления своей учетной записи. Но тикет не считался бы «done», если бы он также содержал следующие критерии приемки: “Кнопка входа должна быть бирюзовой”, а фактически кнопка входа была бы, например, желтой. Иногда команда решает запустить функцию даже с незначительными несоответствиями. Таким образом, они могут пометить тикет как выполненный (или создать отдельный для решения оставшихся аспектов), даже если не все критерии работают. Но с точки зрения технического определения, это не «готово», пока не пройдут все критерии приемки.\n\nИсточник: [What is Acceptance Criteria?](https://www.mindfulqa.com/acceptance-criteria/)\n","date":"2022-05-13T00:00:00.000Z","path":"/kriterii-priemki/","icon":"fas fa-bug","image":"null","order":26,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Критерии приемки (Acceptance Criteria)","anchor":"#критерии-приемки-acceptance-criteria"}]}},{"node":{"id":"47d0003949bf891ccadba9c4abb28824","title":"Метрики тестирования","content":"\n## Метрики тестирования (Software Test Metrics)\n\n_Метрика (metric): Шкала измерений и метод, используемый для измерений (ISO 14598)_\n\n“Вы не можете контролировать то, что не можете измерить” - Том Демакро.\n\nОсновная цель тестирования заключается в предоставлении информации, необходимой для управления рисками. Чтобы контролировать и управлять тестированием, а также предоставлять своевременную информацию заинтересованным сторонам, необходимы эффективные измерения процесса тестирования. Для измерения процесса тестирования нужно определить, какая информация должна быть предоставлена, как ее получить и как она должна быть представлена. Таким образом, для всех действий тестирования необходимо определить и использовать метрики, а также предоставить показатели измерений, как для продуктов, так и для процессов.\n\nМетрики тестирования программного обеспечения подразделяются на два типа:\n\n* **Метрики процесса** (Process metrics): используются в процессе подготовки и выполнения тестирования.\n  *   **Продуктивность подготовки тест-кейсов** (Test Case Preparation Productivity): используется для расчета количества подготовленных тест-кейсов и усилий (Effort), затраченных на их подготовку.\n\n      _Test Case Preparation Productivity = (No of Test Case) / (Effort spent for Test Case Preparation)_\n  *   **Охват тестового дизайна** (Test Design Coverage): процент покрытия тест-кейсами требований.\n\n      _Test Design Coverage = ((Total number of requirements mapped to test cases) / (Total number of requirements)\\*100_\n  *   **Продуктивность выполнения тестов** (Test Execution Productivity): определяет количество тест-кейсов, которые могут быть выполнены в час.\n\n      _Test Execution Productivity = (No of Test cases executed) / (Effort spent for execution of test cases)_\n  *   **Покрытие выполненных тестов** (Test Execution Coverage): предназначено для измерения количества выполненных тест-кейсов по сравнению с количеством запланированных тест-кейсов.\n\n      _Test Execution Coverage = (Total no. of test cases executed / Total no. of test cases planned to execute)\\*100_\n  *   **Успешные тест-кейсы** (Test Cases Passed): для измерения процента пройденных успешно тест-кейсов.\n\n      _Test Cases Pass = (Total no. of test cases passed) / (Total no. of test cases executed) \\* 100_\n  *   **Неуспешные тест-кейсы** (Test Cases Failed): для измерения процента заваленных тест-кейсов.\n\n      _Test Cases Failed = (Total no. of test cases failed) / (Total no. of test cases executed) \\* 100_\n  *   **Заблокированные тест-кейсы** (Test Cases Blocked): для измерения процента блокированных тест-кейсов.\n\n      _Test Cases Blocked = (Total no. of test cases blocked) / (Total no. of test cases executed) \\* 100_\n* **Метрики продукта** (Product metrics):\n  *   **Уровень обнаружения ошибок** (Error Discovery Rate): для определения эффективности тест-кейсов.\n\n      _Error Discovery Rate = (Total number of defects found /Total no. of test cases executed)\\*100_\n  * **Процент выявления дефектов** (Defect Detection Percentage (DDP)): _Количество дефектов, выявленных в фазе тестирования, поделенное на число дефектов, найденных в этой фазе тестирования, а также во всех последующих фазах. См. также ускользнувший дефект. (ISTQB)_\n  *   **Уровень исправления дефектов** (Defect Fix Rate): помогает узнать качество сборки (build) с точки зрения устранения дефектов.\n\n      _Defect Fix Rate = (Total no of Defects reported as fixed - Total no. of defects reopened) / (Total no of Defects reported as fixed + Total no. of new Bugs due to fix)\\*100_\n  *   **Плотность дефектов** (Defect Density): _количество дефектов, обнаруженных в компоненте или системе, поделенное на размер компонента или системы (выраженный в стандартных единицах измерения, например строках кода, числе классов или функций). (ISTQB)_\n\n      _Defect Density = Total no. of defects identified / Actual Size (requirements)_\n  *   **Утечка дефектов** (Defect Leakage): используется для проверки эффективности процесса тестирования перед UAT.\n\n      _Defect Leakage = ((Total no. of defects found in UAT)/(Total no. of defects found before UAT)) \\* 100_\n  *   **Эффективность устранения дефектов** (Defect Removal Efficiency): позволяет сравнивать общую (дефекты, обнаруженные до и после поставки) эффективность устранения дефектов.\n\n      _Defect Removal Efficiency = ((Total no. of defects found pre-delivery) /( (Total no. of defects found pre-delivery )+ (Total no. of defects found post-delivery)))\\* 100_\n\n**Тестовое покрытие (Test Coverage)**\n\nТестовое Покрытие - это одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода. Сложность современного ПО и инфраструктуры сделало невыполнимой задачу проведения тестирования со 100% тестовым покрытием. Поэтому для разработки набора тестов, обеспечивающего более-менее высокий уровень покрытия можно использовать специальные инструменты либо техники тест дизайна.\n\nСуществуют следующие подходы к оценке и измерению тестового покрытия:\n\n* [Покрытие требований (Requirements Coverage)](http://www.protesting.ru/testing/testcoverage.html#requirements) - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix).\n* [Покрытие кода (Code Coverage)](http://www.protesting.ru/testing/testcoverage.html#code) - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей ПО.\n* [Тестовое покрытие на базе анализа потока управления](http://www.protesting.ru/testing/testcoverage.html#flow) - это одна из техник тестирования белого ящика, основанная на определении путей выполнения кода программного модуля и создания выполняемых тест кейсов для покрытия этих путей.&#x20;\n\nРазличия:\\\nМетод покрытия требований сосредоточен на проверке соответствия набора проводимых тестов требованиям к продукту, в то время как анализ покрытия кода - на полноте проверки тестами разработанной части продукта (исходного кода), а анализ потока управления - на прохождении путей в графе или модели выполнения тестируемых функций (Control Flow Graph).\n\nОграничения:\n\n* Метод оценки покрытия кода не выявит нереализованные требования, так как работает не с конечным продуктом, а с существующим исходным кодом.\n* Метод покрытия требований может оставить непроверенными некоторые участки кода, потому что не учитывает конечную реализацию.\n\n_**Альтернативное мнение**_\n\nПокрытие кода - совершенно бесполезная метрика. Не существует «правильного» показателя. Это вопрос-ловушка. У вас может быть проект с близким к 100% покрытием кода, в котором по-прежнему остаются баги и проблемы. В реальности нужно следить за другими метриками - хорошо известными показателям CTM (Codepipes testing Metrics).\n\n![](https://lh5.googleusercontent.com/ycWdGw8XfGW\\_7xun6DdJ2HLdCP5FaAIht4em7L99M4Pu58zUki4bgk6V0o4VjnGCxPcxyZFsXKep5rwyJP-KVQa9daBeK0XdCUgOkSUvBsPJyLOTxnYOHunUBfvIOrgMuUeH7f61)\n\n* **PDWT** (процент разработчиков, пишущих тесты) - вероятно, самый важный показатель. Нет смысла говорить об антипаттернах тестирования ПО, если у вас вообще нет тестов. Все разработчики в команде должны писать тесты. Любую новую функцию можно объявлять сделанной только если она сопровождается одним или несколькими тестами.\n* **PBCNT** (процент багов, приводящих к созданию новых тестов). Каждый баг в продакшне - отличный повод для написания нового теста, проверяющего соответствующее исправление. Любой баг должен появиться в продакшне не более одного раза. Если ваш проект страдает от появления повторных багов даже после их первоначального «исправления», то команда действительно выиграет от использования этой метрики.\n* **PTVB** (процент тестов, которые проверяют поведение, а не реализацию). Тесно связанные тесты пожирают массу времени при рефакторинге основного кода.\n* **PTD** (процент детерминированных тестов от общего числа). Тесты должны завершаться ошибкой только в том случае, если что-то не так с бизнес-кодом. Если тесты периодически ломаются без видимой причины - это огромная проблема.\\\n  \\\n  Если после прочтения о метриках вы по-прежнему настаиваете на установке жесткого показателя для покрытия кода, я дам вам число 20%. Это число должно использоваться как эмпирическое правило, основанное на законе Парето. 20% вашего кода вызывает 80% ваших ошибок\n\nИсточники:\n\n* [ГОСТ Р 56920-2016/ISO/IEC/IEEE 29119-1:2013](https://docs.cntd.ru/document/1200134996)\n* [Software Test Metrics - Product Metrics & Process Metrics](https://www.softwaretestingmaterial.com/test-metrics/)\n* [Антипаттерны тестирования ПО](https://habr.com/ru/post/358178/)\n\nДоп. материал:\n\n* [What Metrics Should You Be Using?](https://blog.gurock.com/qa-metrics/)\n* [Different Software Quality Metrics used by Expert Test Managers](https://www.softwaretestinggenius.com/different-software-quality-metrics-used-by-expert-test-managers/)\n* [Code Coverage: How to Measure You've Done Enough Testing](https://hackernoon.com/code-coverage-how-to-measure-youve-done-enough-testing)\n* [Understanding time to quality](https://theqalead.com/topics/time-to-quality-concept-explained/)\n* [Метрики в тестировании](https://www.youtube.com/watch?v=OyCnB2LvAtQ\\&t=656s)\n* [Самый полный список метрик тестирования на русском языке](https://habr.com/ru/post/546562/)\n* [Code Coverage Best Practices](https://testing.googleblog.com/2020/08/code-coverage-best-practices.html)\n* [Лекция 4: Оценка оттестированности проекта: метрики и методика интегральной оценки](https://intuit.ru/studies/courses/48/48/lecture/1430)\n* [Тестовое покрытие по Бейзеру // Бесплатный урок OTUS](https://www.youtube.com/watch?v=jqjJ256CZhk)\n* [Оцениваем риски в тестировании с помощью open source-проекта Drill4j](https://www.youtube.com/watch?v=zN-F71rEXh4)\n* [Метрики в тестировании. Матрица трассировки](https://www.youtube.com/watch?v=OyCnB2LvAtQ)\n","date":"2022-05-13T00:00:00.000Z","path":"/metriki-testirovaniya/","icon":"fas fa-bug","image":"null","order":27,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Метрики тестирования (Software Test Metrics)","anchor":"#метрики-тестирования-software-test-metrics"}]}},{"node":{"id":"9996657a95ccd8f1bd701d75cd35bfca","title":"Требования","content":"\n## Требования (Requirements)\n\n_Требование (requirement): Условия или возможности, необходимые пользователю для решения определенных задач или достижения определенных целей, которые должны быть достигнуты для выполнения контракта, стандартов, спецификации, или других формальных документов. (IEEE 610)_\n\n_Спецификация (specification): Документ, описывающий (в идеале - исчерпывающе, однозначно и доступно) требования, дизайн, поведение или иные характеристики компонента или системы. Зачастую в спецификацию включаются процедуры контроля исполнения. (ISTQB)_\n\n_Спецификация компонента (component specification): Описание функций компонента в терминах его выходных значений для заданных входных значений при определенных условиях, а также требуемого нефункционального поведения (например, использование ресурсов). (ISTQB)_\n\n_Спецификация проектирования теста (test design specification): Документ, описывающий тестовое условие (элементы покрытия) для элемента тестирования, детализированный подход к тестированию, и идентифицирующий соответствующие тестовые сценарии высокого уровня. (IEEE 829)_\n\n_Спецификация процедуры тестирования (test procedure specification): Документ, описывающий последовательность действий при выполнении теста. Также известен как ручной сценарий тестирования. (IEEE 829)_\n\n_Спецификация теста (test specification): Документ, состоящий из спецификации проектирования теста, спецификации тестовых сценариев и/или спецификации процедуры тестирования._\n\n_Спецификация тестовых сценариев (test case specification): Документ, описывающий комплект тестовых сценариев - цель, входы, тестовые операции, ожидаемые результаты и предусловия выполнения для объекта тестирования. (IEEE 829)_\n\nТребования являются отправной точкой для определения того, что проектная команда будет проектировать, реализовывать и тестировать. Вне зависимости от того, какая модель разработки ПО используется на проекте, чем позже будет обнаружена проблема, тем сложнее и дороже будет ее решение. Если проблема в требованиях будет выяснена на начальной стадии, ее решение может свестись к исправлению пары слов в тексте, в то время как недоработка, вызванная пропущенной проблемой в требованиях и обнаруженная на стадии эксплуатации, может даже полностью уничтожить проект.\n\n**Источники и пути выявления требований**\n\nТребования начинают свою жизнь на стороне заказчика. Их сбор (gathering) и выявление (elicitation) осуществляются с помощью следующих основных техник:\n\n* **Интервью**. Самый универсальный путь выявления требований, заключающийся в общении проектного специалиста (как правило, бизнес-аналитика) и представителя заказчика (или эксперта, пользователя и т.д.). Интервью может проходить в классическом понимании этого слова (беседа в виде «вопрос ответ»), в виде переписки и т.п. Главным здесь является то, что ключевыми фигурами выступают двое - интервьюируемый и интервьюер (хотя это и не исключает наличия «аудитории слушателей», например, в виде лиц, поставленных в копию переписки).\n* **Работа с фокусными группами**. Может выступать как вариант «расширенного интервью», где источником информации является не одно лицо, а группа лиц (как правило, представляющих собой целевую аудиторию, и/или обладающих важной для проекта информацией, и/или уполномоченных принимать важные для проекта решения).\n* **Анкетирование**. Этот вариант выявления требований вызывает много споров, т.к. при неверной реализации может привести к нулевому результату при объемных затратах. В то же время при правильной организации анкетирование позволяет автоматически собрать и обработать огромное количество ответов от огромного количества респондентов. Ключевым фактором успеха является правильное составление анкеты, правильный выбор аудитории и правильное преподнесение анкеты.\n* **Семинары и мозговой штурм**. Семинары позволяют группе людей очень быстро обменяться информацией (и наглядно продемонстрировать те или иные идеи), а также хорошо сочетаются с интервью, анкетированием, прототипированием и моделированием - в том числе для обсуждения результатов и формирования выводов и решений. Мозговой штурм может проводиться и как часть семинара, и как отдельный вид деятельности. Он позволяет за минимальное время сгенерировать большое количество идей, которые в дальнейшем можно не спеша рассмотреть с точки зрения их использования для развития проекта.\n* **Наблюдение**. Может выражаться как в буквальном наблюдении за некими процессами, так и во включении проектного специалиста в эти процессы в качестве участника. С одной стороны, наблюдение позволяет увидеть то, о чём (по совершенно различным соображениям) могут умолчать интервьюируемые, анкетируемые и представители фокусных групп, но с другой - отнимает очень много времени и чаще всего позволяет увидеть лишь часть процессов.\n* **Прототипирование**. Состоит в демонстрации и обсуждении промежуточных версий продукта (например, дизайн страниц сайта может быть сначала представлен в виде картинок, и лишь затем сверстан). Это один из лучших путей поиска единого понимания и уточнения требований, однако он может привести к серьезным дополнительным затратам при отсутствии специальных инструментов (позволяющих быстро создавать прототипы) и слишком раннем применении (когда требования еще не стабильны, и высока вероятность создания прототипа, имеющего мало общего с тем, что хотел заказчик).\n* **Анализ документов**. Хорошо работает тогда, когда эксперты в предметной области (временно) недоступны, а также в предметных областях, имеющих общепринятую устоявшуюся регламентирующую документацию. Также к этой технике относится и просто изучение документов, регламентирующих бизнес-процессы в предметной области заказчика или в конкретной организации, что позволяет приобрести необходимые для лучшего понимания сути проекта знания.\n* **Моделирование процессов и взаимодействий**. Может применяться как к «бизнес-процессам и взаимодействиям» (например: «договор на закупку формируется отделом закупок, визируется бухгалтерией и юридическим отделом…»), так и к «техническим процессам и взаимодействиям» (например: «платежное поручение генерируется модулем “Бухгалтерия”, шифруется модулем “Безопасность” и передаётся на сохранение в модуль “Хранилище”»). Данная техника требует высокой квалификации специалиста по бизнес-анализу, т.к. сопряжена с обработкой большого объема сложной (и часто плохо структурированной) информации.\n* **Самостоятельное описание**. Является не столько техникой выявления требований, сколько техникой их фиксации и формализации. Очень сложно (и даже нельзя!) пытаться самому «придумать требования за заказчика», но в спокойной обстановке можно самостоятельно обработать собранную информацию и аккуратно оформить ее для дальнейшего обсуждения и уточнения.\n\n**Уровни и типы требований**\n\n![](https://lh5.googleusercontent.com/reoIE5sFFhpiNAY1ZgN\\_cFtkQuEF2FFhSQvR1SkW8zk5NKvCFt3L7JNrCSzGhVG0zzLF6hb78h39BvYeEhEecai-E\\_YpycdghBjqvVzRdF4vqlITR1t1gRlETVXKgnYTV1jfJUcE)\n\n* **Бизнес-требования** (business requirements) выражают цель, ради которой разрабатывается продукт (зачем вообще он нужен, какая от него ожидается польза, как заказчик с его помощью будет получать прибыль). Результатом выявления требований на этом уровне является общее видение (vision and scope) - документ, который, как правило, представлен простым текстом и таблицами. Здесь нет детализации поведения системы и иных технических характеристик, но вполне могут быть определены приоритеты решаемых бизнес-задач, риски и т.п. Несколько простых, изолированных от контекста и друг от друга примеров бизнес-требований:\n  * Нужен инструмент, в реальном времени отображающий наиболее выгодный курс покупки и продажи валюты;\n  * Необходимо в два-три раза повысить количество заявок, обрабатываемых одним оператором за смену;\n  * Нужно автоматизировать процесс выписки товарно-транспортных накладных на основе договоров.\n* **Пользовательские требования** (user requirements) описывают задачи, которые пользователь может выполнять с помощью разрабатываемой системы (реакцию системы на действия пользователя, сценарии работы пользователя). Поскольку здесь уже появляется описание поведения системы, требования этого уровня могут быть использованы для оценки объема работ, стоимости проекта, времени разработки и т.д. Пользовательские требования оформляются в виде вариантов использования (use cases), пользовательских историй (user stories), пользовательских сценариев (user scenarios). Несколько простых, изолированных от контекста и друг от друга примеров пользовательских требований:\n  * При первом входе пользователя в систему должно отображаться лицензионное соглашение;\n  * Администратор должен иметь возможность просматривать список всех пользователей, работающих в данный момент в системе;\n  * При первом сохранении новой статьи система должна выдавать запрос на сохранение в виде черновика или публикацию.\n* **Бизнес-правила** (business rules) описывают особенности принятых в предметной области (и/или непосредственно у заказчика) процессов, ограничений и иных правил. Эти правила могут относиться к бизнес-процессам, правилам работы сотрудников, нюансам работы ПО и т.д. Несколько простых, изолированных от контекста и друг от друга примеров бизнес-правил:\n  * Никакой документ, просмотренный посетителями сайта хотя бы один раз, не может быть отредактирован или удален;\n  * Публикация статьи возможна только после утверждения главным редактором;\n  * Подключение к системе извне офиса запрещено в нерабочее время.\n* **Атрибуты качества** (quality attributes) расширяют собой нефункциональные требования и на уровне пользовательских требований могут быть представлены в виде описания ключевых для проекта показателей качества (свойств продукта, не связанных с функциональностью, но являющихся важными для достижения целей создания продукта - производительность, масштабируемость, восстанавливаемость). Атрибутов качества очень много, но для любого проекта реально важными является лишь некоторое их подмножество. Несколько простых, изолированных от контекста и друг от друга примеров атрибутов качества:\n  * Максимальное время готовности системы к выполнению новой команды после отмены предыдущей не может превышать одну секунду;\n  * Внесенные в текст статьи изменения не должны быть утеряны при нарушении соединения между клиентом и сервером;\n  * Приложение должно поддерживать добавление произвольного количества неиероглифических языков интерфейса.\n* **Функциональные требования** (functional requirements) описывают поведение системы, т.е. ее действия (вычисления, преобразования, проверки, обработку и т.д.). В контексте проектирования функциональные требования в основном влияют на дизайн системы. Стоит помнить, что к поведению системы относится не только то, что система должна делать, но и то, что она не должна делать (например: «приложение не должно выгружать из оперативной памяти фоновые документы в течение 30 минут с момента выполнения с ними последней операции»). Несколько простых, изолированных от контекста и друг от друга примеров функциональных требований:\n  * В процессе инсталляции приложение должно проверять остаток свободного места на целевом носителе;\n  * Система должна автоматически выполнять резервное копирование данных ежедневно в указанный момент времени;\n  * Электронный адрес пользователя, вводимый при регистрации, должен быть проверен на соответствие требованиям RFC822.\n* **Нефункциональные требования** (non-functional requirements) описывают свойства системы (удобство использования, безопасность, надежность, расширяемость и т.д.), которыми она должна обладать при реализации своего поведения. Здесь приводится более техническое и детальное описание атрибутов качества. В контексте проектирования нефункциональные требования в основном влияют на архитектуру системы. Несколько простых, изолированных от контекста и друг от друга примеров нефункциональных требований:\n  * При одновременной непрерывной работе с системой 1000 пользователей, минимальное время между возникновением сбоев должно быть более или равно 100 часов;\n  * Ни при каких условиях общий объем используемой приложением памяти не может превышать 2 ГБ;\n  * Размер шрифта для любой надписи на экране должен поддерживать настройку в диапазоне от 5 до 15 пунктов.\n\nСледующие требования в общем случае могут быть отнесены к нефункциональным, однако их часто выделяют в отдельные подгруппы (здесь для простоты рассмотрены лишь три таких подгруппы, но их может быть и гораздо больше; как правило, они проистекают из атрибутов качества, но высокая степень детализации позволяет отнести их к уровню требований к продукту).\n\n* **Ограничения** (limitations, constraints) представляют собой факторы, ограничивающие выбор способов и средств (в том числе инструментов) реализации продукта. Несколько простых, изолированных от контекста и друг от друга примеров ограничений:\n  * Все элементы интерфейса должны отображаться без прокрутки при разрешениях экрана от 800x600 до 1920x1080;\n  * Не допускается использование Flash при реализации клиентской части приложения;\n  * Приложение должно сохранять способность реализовывать функции с уровнем важности «критический» при отсутствии у клиента поддержки JavaScript.\n* **Требования к интерфейсам** (external interfaces requirements) описывают особенности взаимодействия разрабатываемой системы с другими системами и операционной средой. Несколько простых, изолированных от контекста и друг от друга примеров требований к интерфейсам:\n  * Обмен данными между клиентской и серверной частями приложения при осуществлении фоновых AJAX-запросов должен быть реализован в формате JSON;\n  * Протоколирование событий должно вестись в журнале событий операционной системы;\n  * Соединение с почтовым сервером должно выполняться согласно RFC3207 («SMTP over TLS»).\n* **Требования к данным** (data requirements) описывают структуры данных (и сами данные), являющиеся неотъемлемой частью разрабатываемой системы. Часто сюда относят описание базы данных и особенностей её использования. Несколько простых, изолированных от контекста и друг от друга примеров требований к данным:\n  * Все данные системы, за исключением пользовательских документов, должны храниться в БД под управлением СУБД MySQL, пользовательские документы должны храниться в БД под управлением СУБД MongoDB;\n  * Информация о кассовых транзакциях за текущий месяц должна храниться в операционной таблице, а по завершении месяца переноситься в архивную;\n  * Для ускорения операций поиска по тексту статей и обзоров должны быть предусмотрены полнотекстовые индексы на соответствующих полях таблиц.\n\n**Свойства качественных требований** (требования к самим требованиям)\n\n* **Завершенность** (completeness). Требование является полным и законченным с точки зрения представления в нем всей необходимой информации, ничто не пропущено по соображениям «это и так всем понятно». Типичные проблемы с завершенностью:\n  * Отсутствуют нефункциональные составляющие требования или ссылки на соответствующие нефункциональные требования (например: «пароли должны храниться в зашифрованном виде» - каков алгоритм шифрования?);\n  * Указана лишь часть некоторого перечисления (например: «экспорт осуществляется в форматы PDF, PNG и т.д.» - что мы должны понимать под «и т.д.»?);\n  * Приведённые ссылки неоднозначны (например: «см. выше» вместо «см. раздел 123.45.b»).\n* **Атомарность, единичность** (atomicity). Требование является атомарным, если его нельзя разбить на отдельные требования без потери завершенности и оно описывает одну и только одну ситуацию. Типичные проблемы с атомарностью:\n  * В одном требовании, фактически, содержится несколько независимых (например: «кнопка “Restart” не должна отображаться при остановленном сервисе, окно “Log” должно вмещать не менее 20-ти записей о последних действиях пользователя» - здесь зачем-то в одном предложении описаны совершенно разные элементы интерфейса в совершенно разных контекстах);\n  * Требование допускает разночтение в силу грамматических особенностей языка (например: «если пользователь подтверждает заказ и редактирует заказ или откладывает заказ, должен выдаваться запрос на оплату» - здесь описаны три разных случая, и это требование стоит разбить на три отдельных во избежание путаницы). Такое нарушение атомарности часто влечёт за собой возникновение противоречивости;\n  * В одном требовании объединено описание нескольких независимых ситуаций (например: «когда пользователь входит в систему, ему должно отображаться приветствие; когда пользователь вошел в систему, должно отображаться имя пользователя; когда пользователь выходит из системы, должно отображаться прощание» - все эти три ситуации заслуживают того, чтобы быть описанными отдельными и куда более детальными требованиями).\n* **Непротиворечивость, последовательность** (consistency). Требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам. Типичные проблемы с непротиворечивостью:\n  * Противоречия внутри одного требования (например: «после успешного входа в систему пользователя, не имеющего права входить в систему…» - тогда как он успешно вошёл в систему, если не имел такого права?);\n  * Противоречия между двумя и более требованиями, между таблицей и текстом, рисунком и текстом, требованием и прототипом и т.д. (например: «712.a Кнопка “Close” всегда должна быть красной» и «36452.x Кнопка “Close” всегда должна быть синей» - так всё же красной или синей?);\n  * Использование неверной терминологии или использование разных терминов для обозначения одного и того же объекта или явления (например: «в случае, если разрешение окна составляет менее 800x600…» - разрешение есть у экрана, у окна есть размер).\n* **Недвусмысленность** (unambiguousness, clearness). Требование должно быть описано без использования жаргона, неочевидных аббревиатур и расплывчатых формулировок, должно допускать только однозначное объективное понимание и быть атомарным в плане невозможности различной трактовки сочетания отдельных фраз. Типичные проблемы с недвусмысленностью:\n  * Использование терминов или фраз, допускающих субъективное толкование (например: «приложение должно поддерживать передачу больших объемов данных» - насколько «больших»?) Вот лишь небольшой перечень слов и выражений, которые можно считать верными признаками двусмысленности: адекватно (adequate), быть способным (be able to), легко (easy), обеспечивать (provide for), как минимум (as a minimum), быть способным (be capable of), эффективно (effectively), своевременно (timely), применимо (as applicable), если возможно (if possible), будет определено позже (to be determined, TBD), по мере необходимости (as appropriate), если это целесообразно (if practical), но не ограничиваясь (but not limited to), быть способно (capability of), иметь возможность (capability to), нормально (normal), минимизировать (minimize), максимизировать (maximize), оптимизировать (optimize), быстро (rapid), удобно (user-friendly), просто (simple), часто (often), обычно (usual), большой (large), гибкий (flexible), устойчивый (robust), по последнему слову техники (state-of-the-art), улучшенный (improved), результативно (efficient). Вот утрированный пример требования, звучащего очень красиво, но совершенно нереализуемого и непонятного: «В случае необходимости оптимизации передачи больших файлов система должна эффективно использовать минимум оперативной памяти, если это возможно»;\n  * Использование неочевидных или двусмысленных аббревиатур без расшифровки (например: «доступ к ФС осуществляется посредством системы прозрачного шифрования» и «ФС предоставляет возможность фиксировать сообщения в их текущем состоянии с хранением истории всех изменений» - ФС здесь обозначает файловую систему? Точно? А не какой-нибудь «Фиксатор Сообщений»?);\n  * Формулировка требований из соображений, что нечто должно быть всем очевидно (например: «Система конвертирует входной файл из формата PDF в выходной файл формата PNG» - и при этом автор считает совершенно очевидным, что имена файлов система получает из командной строки, а многостраничный PDF конвертируется в несколько PNG-файлов, к именам которых добавляется «page-1», «page-2» и т.д.). Эта проблема перекликается с нарушением корректности.\n* **Выполнимость** (feasibility). Требование должно быть технологически выполнимым и реализуемым в рамках бюджета и сроков разработки проекта. Типичные проблемы с выполнимостью:\n  * Так называемое «озолочение» (gold plating) - требования, которые крайне долго и/или дорого реализуются и при этом практически бесполезны для конечных пользователей (например: «настройка параметров для подключения к базе данных должна поддерживать распознавание символов из жестов, полученных с устройств трёхмерного ввода»).\n  * Технически нереализуемые на современном уровне развития технологий требования (например: «анализ договоров должен выполняться с применением искусственного интеллекта, который будет выносить однозначное корректное заключение о степени выгоды от заключения договора»).\n  * В принципе нереализуемые требования (например: «система поиска должна заранее предусматривать все возможные варианты поисковых запросов и кэшировать их результаты»).\n* **Обязательность, нужность** (obligatoriness) и актуальность (up-to-date). Если требование не является обязательным к реализации, оно должно быть просто исключено из набора требований. Если требование нужное, но «не очень важное», для указания этого факта используется указание приоритета (см. «проранжированность по…»). Также исключены (или переработаны) должны быть требования, утратившие актуальность. Типичные проблемы с обязательностью и актуальностью:\n  * Требование было добавлено «на всякий случай», хотя реальной потребности в нём не было и нет;\n  * Требованию выставлены неверные значения приоритета по критериям важности и/или срочности;\n  * Требование устарело, но не было переработано или удалено.\n* **Прослеживаемость** (traceability). Прослеживаемость бывает вертикальной (vertical traceability) и горизонтальной (horizontal traceability). Вертикальная позволяет соотносить между собой требования на различных уровнях требований, горизонтальная позволяет соотносить требование с тест-планом, тест-кейсами, архитектурными решениями и т.д. Для обеспечения прослеживаемости часто используются специальные инструменты по управлению требованиями (requirements management tool) и/или матрицы прослеживаемости (traceability matrix). Типичные проблемы с прослеживаемостью:\n  * Требования не пронумерованы, не структурированы, не имеют оглавления, не имеют работающих перекрестных ссылок;\n  * При разработке требований не были использованы инструменты и техники управления требованиями;\n  * Набор требований неполный, носит обрывочный характер с явными «пробелами».\n* **Модифицируемость** (modifiability). Это свойство характеризует простоту внесения изменений в отдельные требования и в набор требований. Можно говорить о наличии модифицируемости в том случае, если при доработке требований искомую информацию легко найти, а ее изменение не приводит к нарушению иных описанных в этом перечне свойств. Типичные проблемы с модифицируемостью:\n  * Требования неатомарны (см. «атомарность») и непрослеживаемы (см. «прослеживаемость»), а потому их изменение с высокой вероятностью порождает противоречивость (см. «непротиворечивость»);\n  * Требования изначально противоречивы (см. «непротиворечивость»). В такой ситуации внесение изменений (не связанных с устранением противоречивости) только усугубляет ситуацию, увеличивая противоречивость и снижая прослеживаемость;\n  * Требования представлены в неудобной для обработки форме (например, не использованы инструменты управления требованиями, и в итоге команде приходится работать с десятками огромных текстовых документов).\n* **Проранжированность по важности, стабильности, срочности** (ranked for importance, stability, priority). Важность характеризует зависимость успеха проекта от успеха реализации требования. Стабильность характеризует вероятность того, что в обозримом будущем в требование не будет внесено никаких изменений. Срочность определяет распределение во времени усилий проектной команды по реализации того или иного требования. Типичные проблемы с проранжированностью состоят в ее отсутствии или неверной реализации и приводят к следующим последствиям:\n  * Проблемы с проранжированностью по важности повышают риск неверного распределения усилий проектной команды, направления усилий на второстепенные задачи и конечного провала проекта из-за неспособности продукта выполнять ключевые задачи с соблюдением ключевых условий;\n  * Проблемы с проранжированностью по стабильности повышают риск выполнения бессмысленной работы по совершенствованию, реализации и тестированию требований, которые в самое ближайшее время могут претерпеть кардинальные изменения (вплоть до полной утраты актуальности);\n  * Проблемы с проранжированностью по срочности повышают риск нарушения желаемой заказчиком последовательности реализации функциональности и ввода этой функциональности в эксплуатацию.\n* **Корректность** (correctness) **и проверяемость** (verifiability). Фактически эти свойства вытекают из соблюдения всех вышеперечисленных (или можно сказать, что они не выполняются, если нарушено хотя бы одно из вышеперечисленных). В дополнение можно отметить, что проверяемость подразумевает возможность создания объективного тест-кейса (тест-кейсов), однозначно показывающего, что требование реализовано верно и поведение приложения в точности соответствует требованию. К типичным проблемам с корректностью также можно отнести:\n  * опечатки (особенно опасны опечатки в аббревиатурах, превращающие одну осмысленную аббревиатуру в другую также осмысленную, но не имеющую отношения к некоему контексту; такие опечатки крайне сложно заметить);\n  * наличие неаргументированных требований к дизайну и архитектуре;\n  * плохое оформление текста и сопутствующей графической информации, грамматические, пунктуационные и иные ошибки в тексте;\n  * неверный уровень детализации (например, слишком глубокая детализация требования на уровне бизнес-требований или недостаточная детализация на уровне требований к продукту);\n  * требования к пользователю, а не к приложению (например: «пользователь должен быть в состоянии отправить сообщение» - увы, мы не можем влиять на состояние пользователя).\n\n**Источники требований**:\n\n* Федеральное и муниципальное отраслевое законодательство (конституция, законы, распоряжения);\n* Нормативное обеспечение организации (регламенты, положения, уставы, приказы);\n* Текущая организация деятельности объекта автоматизации;\n* Модели деятельности (диаграммы бизнес-процессов);\n* Представления и ожидания потребителей и пользователей системы;\n* Журналы использования существующих программно-аппаратных систем;\n* Конкурирующие программные продукты.\n\n**Виды документов требований**:\n\n* **Спецификация требований к программному обеспечению** (SRS - Software Requirement Specification): представляет собой документ, подготовленный группой системных аналитиков (system analysts), который используется для описания программного обеспечения, которое будет разработано, основной бизнес-цели и функциональности определенного продукта, а также того, как он выполняет свои основные функции. В организациях, которые используют SRS, они обычно очень похожи на то, что описывается в PRD и FSD. SRS - это основа любого проекта, поскольку он состоит из структуры, которой будет следовать каждый член команды. SRS также является основой контракта с заинтересованными сторонами (пользователями / клиентами), который включает в себя все подробности о функциональности будущего продукта и о том, как он должен работать. SRS широко используется разработчиками программного обеспечения в процессе разработки продукта или программы. SRS включает как функциональные, так и нефункциональные требования, а также варианты использования. В идеальном документе SRS учитывается не только то, как программное обеспечение будет взаимодействовать с другим программным обеспечением или когда оно встроено в оборудование, но также потенциальных пользователей и способы их взаимодействия с программным обеспечением. Он также содержит ссылки на таблицы и диаграммы, чтобы получить четкое представление обо всех деталях, связанных с продуктом. Документ SRS помогает членам команды из разных отделов оставаться в единстве и обеспечивать выполнение всех требований. Этот документ также позволяет минимизировать затраты и время на разработку программного обеспечения.;\n* **Спецификация бизнес-требований** (BRS - Business Requirement Specification): BRS - это спецификация бизнес-требований, цель которой - показать, как удовлетворить бизнес-требования на более широком уровне. Документ BRS является одним из наиболее широко распространенных документов со спецификациями. Это очень важно, и BRS обычно создается в самом начале жизненного цикла продукта и описывает основные цели продукта или потребности, которые клиент хочет достичь с помощью определенного программного обеспечения или продукта. Он обычно создается бизнес-аналитиком (business analyst) на основе спецификаций других заинтересованных сторон и после тщательного анализа компании-клиента. Обычно окончательная версия документа проверяется клиентом, чтобы убедиться, что ожидания всех заинтересованных сторон бизнеса верны. BRS включает в себя все требования, запрошенные клиентом. Как правило, он состоит из цели продукта, пользователей, общего объема работ, всех перечисленных функций и возможностей, требований к удобству использования и производительности. В этот тип документа не включены варианты использования, а также диаграммы и таблицы. BRS используется в основном высшим и средним менеджментом, инвесторами в продукты, бизнес-аналитиками;\n* **Спецификация функциональных требований** (FRS - Functional Requirement Specification): документ, в котором описаны все функции, которые должно выполнять программное обеспечение или продукт. Фактически, это пошаговая последовательность всех операций, необходимых для разработки продукта от начала до конца. FRS объясняет подробности того, как определенные программные компоненты будут вести себя во время взаимодействия с пользователем. Этот документ создан квалифицированными разработчиками и инженерами и считается результатом тесного сотрудничества между тестировщиками и разработчиками. Основное отличие от документа SRS заключается в том, что FRS не включает варианты использования. Он также может содержать диаграммы и таблицы, но это не обязательно. Этот документ является наиболее подробным, поскольку в нем подробно объясняется, как программное обеспечение должно функционировать (включая бизнес-аспекты, соответствие требованиям, требования безопасности), поскольку оно также должно удовлетворять всем требованиям, упомянутым в документах SRS и BRS. FRS помогает разработчикам понять, какой продукт они должны создать, а тестировщики программного обеспечения лучше разбираются в различных тестовых примерах и сценариях, в которых ожидается тестирование продукта;\n* **Документ бизнес-требований** (BRD - Business Requirements Document, Business Needs Specification, Business Requirements): BRD фокусируются на определении бизнес задач проекта. BRD определяет одну или несколько бизнес задач стоящих перед пользователями, которые могут быть решены с помощью продукта компании. После этого предлагается решение - обычно это новый продукт или усовершенствование существующего продукта в нужной части. Он также может включать какой-то предварительный бизнес анализ - прогноз прибылей, анализ рынка и конкурентов, а также стратегию продаж и продвижения. Чаще всего он пишется Менеджером по продукту, Менеджером по маркетингу продукта или Бизнес аналитиком. В маленьких компаниях это может быть даже директор или владелец фирмы;\n*   **Документ требований рынка** (MRD - Market Requirements Document): MRD фокусируется на определении требований рынка к предлагаемому новому продукту. Если BRD определяет круг проблем и предлагает вариант их решения - то MRD более подробно описывает детали предлагаемого решения. Он может включать несколько или все нижеприведенные аспекты:\n\n    * Функциональные возможности, необходимые для решения бизнес задач;\n    * Анализ рынка и конкурентов;\n    * Функциональные и нефункциональные требования;\n    * Приоритезацию требований и функциональных возможностей;\n    * Варианты использования;\n\n    Чаще всего он пишется Менеджером по продукту, Менеджером по маркетингу продукта или Бизнес аналитиком совместно с Системным аналитиком. Некоторые организации объединяют MRD и PRD в один документ и называют этот документ MRD. В этом случае MRD будет включать то, что описано в этой части и то, что описано в следующей - и может содержать более 50 страниц;\n* **Документ требований к продукту** (PRD - Product Requirements Document): PRD фокусируется на определении требований к предлагаемому новому продукту. Если MRD фокусируется на требованиях с точки зрения нужд рынка, PRD фокусируется на требованиях с точки зрения самого продукта. Обычно он более детально описывает возможности и функциональные требования и может даже содержать скриншоты и лэйауты пользовательских интерфейсов. В организациях, где MRD не включает детализацию требований и варианты использования, PRD закрывает эту брешь. Обычно он пишется Менеджером по продукту, Бизнес аналитиком или Продуктовым аналитиком;\n* **Функциональная спецификация** (FSD - Functional Specifications Document): FSD детально определяет функциональные требования к продукту с фокусировкой на реализации. FSD может определять продукт последовательно форму за формой и одну функциональную возможность за другой. Это документ, который уже может непосредственно использоваться командой разработчиков для создания продукта. Если MRD и PRD фокусируются на требованиях с точки зрения потребностей рынка и продукта, FSD фокусируется на определении деталей продукта, в форме, которая может быть использована разработчиками. FSD может также включать законченные скриншоты и детальное описание пользовательских интерфейсов (UI). Обычно он пишется Системным аналитиком, Архитектором решения или Главным разработчиком - т.е. автор обычно сам относится к разработчикам;\n* **Спецификация продукта** (PSD - Product Specifications Document): PSD - это наименее популярная аббревиатура, но в тех организациях, которые используют эти документы, они обычно соответствуют по содержанию и объему Функциональной спецификации (Functional Specifications Document FSD) описанный выше;\n* **Спецификация функционального дизайна** (FDS - Functional Design Specification);\n* **Спецификация технического дизайна** (TDS - Technical Design Specification);\n* …\n\nТехники тестирования требований см. в теме “Тестирование документации” в видах тестирования.\n\nИсточники:\n\n* [Святослав Куликов “Тестирование программного обеспечения. Базовый курс”](https://svyatoslav.biz/software\\_testing\\_book/). Глава 2.\n* [Требования к программному обеспечению](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\\_%D0%BA\\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%BC%D1%83\\_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8E)\n* [Important Software Testing Documentation: SRS, FRS and BRS](https://dzone.com/articles/important-software-testing-documentation-srs-frs-a)\n* [BRD, MRD, PRD, FSD и прочие ТБА](https://www.sites.google.com/site/sloutskov/brd-mrd-prd-fsd-%D0%B8-%D0%BF%D1%80%D0%BE%D1%87%D0%B8%D0%B5-%D1%82%D0%B1%D0%B0)\n\nДоп. материал:\n\n* [Критерии качества требований и как им следовать](https://dou.ua/forums/topic/35139/)\n* [IEEE Guide to the Software Engineering Body of Knowledge](https://ieeecs-media.computer.org/media/education/swebok/swebok-v3.pdf). Chapter 1.\n* [Software Requirements Engineering: What, Why, Who, When, and How By Linda Westfall](http://www.westfallteam.com/Papers/The\\_Why\\_What\\_Who\\_When\\_and\\_How\\_Of\\_Software\\_Requirements.pdf)\n* Карл Вигерс «Разработка требований к программному обеспечению»\n* [Святослав Куликов “Тестирование программного обеспечения. Базовый курс”](https://svyatoslav.biz/software\\_testing\\_book/). Раздел 2.2.8. “Типичные ошибки при анализе и тестировании требований”.\n* [Не только функциональные требования](https://www.youtube.com/watch?v=3U7oxrpc7ek)\n* [Нефункциональные требования. Как не упустить качество продукта](https://www.youtube.com/watch?v=IEWlrZcqXCw)\n* [Интервью. Как говорить с людьми про требования](https://www.youtube.com/watch?v=Izw0086q8iM)\n* [«File Converter» Project Requirements SAMPLE](https://drive.google.com/file/d/1MV7IPacZZ77W0YGs6d3UHhCt-8Drpe6r/view)\n* [Системные требования и требования к программному обеспечению](https://intuit.ru/studies/curriculums/15720/courses/174/lecture/4714?page=2)\n* [Ицыксон В.М. ПТППО - Управление требованиями](http://kspt.icc.spbstu.ru/media/files/2010/course/se/requirements-management.pdf)\n* [Почему требования так важны для тестировщика](https://dou.ua/forums/topic/34549/)\n* [Явные и неявные требования](https://www.youtube.com/watch?v=4AYoRhbViwA)\n* [Сколько вопросов задавать по ТЗ](https://okiseleva.blogspot.com/2019/02/blog-post\\_28.html)\n* [Сбор требований по TROPOS](https://studopedia.ru/9\\_168380\\_metodologiya-proektirovaniya-Tropos.html)\n* [Принципы CustDev при сборе требований на разработку](https://www.youtube.com/watch?v=h7tZGDKVvvs)\n\n## Пользовательские истории (User stories)\n\n_Пользовательская история (user story): Высокоуровневое пользовательское или бизнес-требование, обычно использующееся в гибких методологиях разработки программного обеспечения. Обычно состоит из одного или нескольких предложений на разговорном или формальном языке, описывающих функциональность, необходимую пользователю, любые нефункциональные требования и включающих в себя критерии приемки. (ISTQB)_\n\nВ индустрии разработки ПО слово «требование» определяет нашу цель, что именно нужно клиентам и что заставит нашу компанию развивать свой бизнес. Будь то продуктовая компания, которая производит программные продукты, или сервисная компания, которая предлагает услуги в различных областях программного обеспечения, основной базой для всех из них является требование, а успех определяется тем, насколько хорошо эти требования выполняются. Термин «требование» имеет разные названия в разных методологиях проекта. В Waterfall это называется Requirement/Specification Document, в Agile или SCRUM требования документируются в виде «Epic» и «User Story». В модели Waterfall документы с требованиями представляют собой огромные документы на сотни страниц, поскольку весь продукт реализуется за один этап. Но это не относится к Agile / SCRUM, потому что в этих случаях требования предъявляются к небольшим функциям или фичам, поскольку продукт готовится поэтапно.\n\nПользовательская история определяет требования к любой функциональности или фиче, в то время как критерии приемки (Acceptance Criteria) определяют критерии готовности (Definition of done) для пользовательской истории или требования.\n\n![https://www.softwaretestinghelp.com/wp-content/qa/uploads/2018/02/User-Story-and-Acceptance-Criterion.jpg](https://www.softwaretestinghelp.com/wp-content/qa/uploads/2018/02/User-Story-and-Acceptance-Criterion.jpg)\n\n**Пользовательская история** - это требование для любой функциональности или фичи, которое записано в 1-2 строки. Пользовательская история обычно является самым простым из возможных требований и касается одной-единственной функции/фичи.\n\n**Формат**:\n\nКак /_роль пользователя или клиента_/, я хочу /_цель, которую нужно достичь_/, чтобы я мог /_причина цели_/.\n\nНапример, “Как _пользователь WhatsApp_, я хочу, чтобы _значок камеры в поле ввода чата позволял захватывать и отправлять изображения_, чтобы я мог _щелкнуть и поделиться своими фотографиями одновременно со всеми своими друзьями_.”\n\nЭто стандартный формат, но далеко не обязательный или единственно-возможный. Главное  в пользовательской истории -  это ценность, которую пользователь получит от функции, т.е. User Story -  это приём записи требований, который помогает команде разработки понять нужду клиента и после обсуждения выбрать, описать и утвердить то решение, которое удовлетворит эту нужду.\n\n**Job Stories**\n\nВ целом Job Stories - схожая с US техника. Можно назвать их приёмом-субститутом, ведь обычно они не используются вместе и выполняют максимально похожую функцию. Job Stories представляют требование в виде действия, которое выполняет пользователь. Они не описывают саму функцию, а лишь концентрируют внимание команды на потребности. Job Stories концентрируются на психологической части фичи, на эмоциях, тревогах и прочем, что может возникнуть во время использования функции.\n\n“Тело” JS делится на три части:\n\n* Situation: дает контекст обо всей JS, который помогает dev-команде придумать возможное решение;\n* Motivation: описывает невидимую руку, которая ведет юзера к использованию данной функции;\n* Expected Outcome: описывает, что получит юзер после использования функции.\n\nJob Stories могут писаться по двум форматам:\n\n* В одну строку: When X I want to Y so I can Z\" или \"When X, actor is Y so that Z;\n* В три строки:\n  * When X\n  * I want to Y\n  * So I can Z.\n\nПример: When I want to withdraw money from my bank account, I want to know I have enough money in my account to withdraw some now so that I can go out to dinner with my friends.\n\nИсточники:\n\n* [What Is User Story And Acceptance Criteria (Examples)](https://www.softwaretestinghelp.com/user-story-acceptance-criteria/)\n* [Гайд по User Stories](https://habr.com/ru/post/577420/)\n\nДоп. материал:\n\n* [User Stories Full Study: внутри и снаружи](https://www.youtube.com/watch?v=E07TXH\\_QpY0)\n* [10 советов для написания хороших пользовательских историй](https://habr.com/ru/company/otus/blog/546518/)\n* [Гайд по Job Stories в помощь к написанию user stories](https://dkapaev.medium.com/%D0%B3%D0%B0%D0%B9%D0%B4-%D0%BF%D0%BE-job-stories-c7d513f72e8f)\n* [Юзер-стори идеальная, а багов 100500? Как мы тестируем документацию](https://habr.com/ru/company/testit-tms/blog/564666/)\n* [Job Stories Offer a Viable Alternative to User Stories](https://www.mountaingoatsoftware.com/blog/job-stories-offer-a-viable-alternative-to-user-stories)\n* [25 sample user stories](https://www.yodiz.com/help/agile-user-stories-and-groomed-product-backlog/)\n* [User Stories](https://www.agilealliance.org/glossary/user-stories/#q=\\~\\(infinite\\~false\\~filters\\~\\(postType\\~\\(\\~'page\\~'post\\~'aa\\_book\\~'aa\\_event\\_session\\~'aa\\_experience\\_report\\~'aa\\_glossary\\~'aa\\_research\\_paper\\~'aa\\_video\\)\\~tags\\~\\(\\~'user\\*20stories\\)\\)\\~searchTerm\\~'\\~sort\\~false\\~sortDirection\\~'asc\\~page\\~1\\))\n* [User stories to acceptance criterias examples](https://i.pinimg.com/originals/35/4c/32/354c320f1bf9722791a7ccdbb40476cd.png)\n* [The User Story Value Hypothesis](https://qablog.practitest.com/the-user-story-value-hypothesis/)\n* [Use case или User story? Хватит выбирать - даешь все и сразу](https://www.youtube.com/watch?v=KNsznqqcUgI)\n","date":"2022-05-13T00:00:00.000Z","path":"/trebovaniya/","icon":"fas fa-bug","image":"null","order":28,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Требования (Requirements)","anchor":"#требования-requirements"},{"value":"Пользовательские истории (User stories)","anchor":"#пользовательские-истории-user-stories"}]}},{"node":{"id":"0cafdc908156c06bd4f56ad416608e58","title":"Тестовый оракул","content":"\n## Тестовый оракул (Test oracle)\n\n_Тестовый предсказатель (test oracle): Источник, при помощи которого можно определить ожидаемые результаты для сравнения с реальными результатами, выдаваемыми тестируемой системой. В роли тестового предсказателя могут выступать уже имеющаяся система (для эталонного тестирования), руководство пользователя, профессиональные знания специалиста, однако им не может быть программный код. (ISTQB)_\n\n**Тестовый оракул** - это механизм для определения того, прошел ли тест или нет. Использование оракулов включает сравнение (для заданных входных данных тестового примера) выходных данных тестируемой системы с выходными данными, которые, по определению оракула, должен иметь продукт. Термин «тестовый оракул» впервые был введен в статье Уильяма Э. Хаудена. Дополнительная работа над различными видами оракулов была исследована Элейн Вейкер.\n\n**Категории тестовых оракулов**:\n\nОпределенные (**Specified**): Эти оракулы обычно связаны с формализованными подходами к моделированию программного обеспечения и построению программного кода. Они связаны с formal specification, model-based design, который может использоваться для создания тестовых оракулов, state transition specification, для которой могут быть получены оракулы, чтобы помочь model-based testing and protocol conformance testing, and design by contract, для которого эквивалентный тестовый оракул является утверждением (assertion). Указанные тестовые оракулы имеют ряд проблем. Формальная спецификация основана на абстракции, которая, в свою очередь, может иметь элемент неточности, поскольку все модели не могут зафиксировать все поведение;\n\nПолученные (**Derived**): полученный тестовый оракул различает правильное и неправильное поведение, используя информацию, полученную из артефактов системы. Они могут включать в себя документацию, результаты выполнения системы и характеристики версий тестируемой системы. Regression test suites (or reports) являются примером производного тестового оракула - они построены на предположении, что результат из предыдущей версии системы может быть использован в качестве помощника (оракула) для будущей версии системы. Ранее измеренные характеристики производительности могут быть использованы в качестве оракула для будущих версий системы, например, чтобы задать вопрос о наблюдаемом потенциальном ухудшении производительности. Текстовая документация из предыдущих версий системы может использоваться в качестве основы для определения ожиданий в будущих версиях системы. Псевдо-оракул попадает в категорию полученных тестовых оракулов. Псевдо-оракул, по определению Вейукера, представляет собой отдельно написанную программу, которая может принимать те же входные данные, что и тестируемая программа или система, так что их выходные данные могут быть сопоставлены, чтобы понять, может ли быть проблема для исследования. Частичный оракул - это гибрид указанного тестового оракула и производного тестового оракула. Он определяет важные (но не полные) свойства тестируемой системы. Например, при метаморфическом тестировании (Metamorphic testing) такие свойства, называемые метаморфическими отношениями, используются при нескольких запусках системы.\n\nПримеры:\n\n* формальная спецификация, используемая в качестве входных данных для model-based design and model-based testing;\n* документация, которая не является полной спецификацией продукта, такая как руководство по использованию или установке, или запись характеристик производительности или минимальных требований;\n* оракул согласованности, сравнивающий результаты выполнения одного теста с другим на предмет сходства;\n* псевдо-оракул: вторая программа, которая использует другой алгоритм для вычисления того же математического выражения, что и тестируемый продукт;\n* Specified+derived: во время поиска Google у нас нет полного оракула, чтобы проверить правильность количества возвращенных результатов. Мы можем определить метаморфическое отношение так, что последующий суженный поиск будет давать меньше результатов.\n\nНеявные (**Implicit**): Неявный тестовый оракул полагается на подразумеваемую информацию и предположения. Например, может быть какой-то подразумеваемый вывод из сбоя программы, то есть нежелательное поведение - оракул, чтобы определить, что может быть проблема. Существует несколько способов поиска и тестирования нежелательного поведения, независимо от того, называют ли это отрицательным тестированием, где есть специализированные подмножества, такие как фаззинг. У неявных тестовых оракулов есть ограничения, поскольку они полагаются на подразумеваемые выводы и предположения. Например, сбой программы или процесса может не быть приоритетной проблемой, если система является отказоустойчивой и поэтому работает в форме самовосстановления / самоуправления. Неявные тестовые оракулы могут быть подвержены ложным срабатываниям из-за зависимостей от среды;\n\nЧеловек (**Human**): Если предыдущие категории оракулов не могут быть использованы, то потребуется участие человека. Это можно рассматривать как количественный и качественный подходы. Количественный подход направлен на поиск нужного количества информации, которую нужно собрать о тестируемой системе (например, результатов тестирования), чтобы заинтересованная сторона могла сделать решения о соответствии или выпуске программного обеспечения. Качественный подход направлен на определение репрезентативности и пригодности входных данных тестирования и контекста выходных данных тестируемой системы. Примером может служить использование реалистичных и репрезентативных данных испытаний и понимание результатов (если они реалистичны). При этом можно руководствоваться эвристическими подходами, такими как интуиция, эмпирические правила, вспомогательные контрольные списки и опыт, чтобы помочь адаптировать конкретную комбинацию, выбранную для тестируемой программы / системы.\n\nПримеры:\n\n* Качественный: эвристический оракул предоставляет репрезентативные или приблизительные результаты по классу тестовых входных данных;\n* Количественный: статистический оракул использует вероятностные характеристики, например, с анализом изображений, где определен диапазон достоверности и неопределенности для того, чтобы тестовый оракул решил о совпадении.\n\nИсточники:\n\n* [Test oracle](https://en.wikipedia.org/wiki/Test\\_oracle)\n\nДоп. материал:\n\n* [Оракулы в тестировании](https://telegra.ph/Orakuly-v-testirovanii-10-17)\n* [Oracles from the inside out](https://www.developsense.com/blog/2015/09/oracles-from-the-inside-out/)","date":"2022-05-13T00:00:00.000Z","path":"/testovyj-orakul/","icon":"fas fa-bug","image":"null","order":29,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Тестовый оракул (Test oracle)","anchor":"#тестовый-оракул-test-oracle"}]}}]}},"relatedTag":null},"context":{}}