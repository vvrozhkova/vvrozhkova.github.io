{"hash":"02799b688b4cb7ace869e49ff69fbf95eb6f42e6","data":{"tag":{"title":"микросервисы","path":"/tag/%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B/","belongsTo":{"totalCount":1,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"dfb6220aef4f7a7060af2e915f6a4522","title":"Микросервисная архитектура","content":"\n## Микросервисная архитектура\n\n### Особенности\n\n- дает простоту и независисмость деплоймента;\nМы можем деплоить каждый микросервис отдельно.\nНапример, если есть изменения в микросервисе А, то мы деплоим только его и нам не нужно передеплаивать UI или другие микросервисы;\n\n- каждый микросервис имеет одну свою собственную, как правило простую функцию;\nи как правило, поддерживается одной командой, иногда даже из 1-2 человек;\n\n- отсутсвие иерархической структуры;\nмикросервис может комуницировать с БД или с другим микросервисом, нет какой то четкой структуры.\n\n- микросервисы взаимодействуют друг с другом напрямую;\n\n### Преимущества\n\n- микросервисы взаимодействуют по очень легковесным сетевым протоколам, как правило это REST;\n\n- мы можем в пределах одного приложения использовать какие угодно технологии и языки программирования;\nнапример, один микросервис на java, а другой на nodejs и это отлично работает;\n\n- простота масштабирования микросервисной архитектуры;\n\n### Проблемы для автоматизации тестирования\n\n- каждый микросервис имеет собственную ценность для заказчика \nесли монолитное приложение мы тестируем и используем все целиком, то в тут каждый микросервис имеет свою ценность;\nи не обязательно его использовать с тем UI клиентом, который был написан изначально, клиент может захотеть использовать другой клиент, мобильный клиент или переписать UI;\nнам важно, чтобы микросервис сам по себе выполнял те функции, которые на него возложены;\n\n- проблема мертвого кода\nкогда есть микросервисы и один микросервис мы больше не используем, его заменили на другой микросервис\nпри этом если automation framework остается монолитным то возникает проблема что есть автотесты которые существую но при этом они уже не нужны.\n\n- нужно также тестировать взаимодействие между микросервисами\n\n### Архитектура для автотестирования\n- тесты на java\n- конфигурация spring\n- билд через Maven\n- BDD - Cucumber\n- взаимодействие с UI - Selenium(Selenide)\n- взаимодействие с BackEnd - RestAssured\n- хранилице тестов - Google Cloud Platform\n- управление контейнерами - Kubernetes\n- для запуска тестов - Selenoid\n- для отчетности - Report Portal, Allure\n\n**Unit тесты** пишутся разработчиками.\n\n**Integrartion тестирование** - разбито  на 2 слоя: слой клиента, который работает как аналог UI, отправляет запросы и принимает ответы\nи уровень тестов, где происходят проверки.\n\n**UI тестирование** - имеет 3 слоя: уровень страниц (pages), уровень шагов (steps), уровень тестов (tests)\n\nДалее UI тесты подключаются к Selenoid - это браузеры, которые запускаются в докер контейнерах и оркестрируются Kubernetes' ом.\nЧтобы включить ui тесты в pipeline. \n\nUI тесты и BackEnd тесты не взаимодействуют между собой, поэтому чтобы создать тестовые данные, например пользователя который будет логиниться в приложение, это нужно будет делать через UI, что не совсем удобно.\n\nДля решения этой проблемы мы подключаем клиентскую часть Backend тестов через dependency в Мавен проект UI тестов, для того чтобы создать тестовые данные или ускорить работу UI тестов(например для быстрого логина в приложение).\n\nДля проверки взаимодействия микросервисов, мы подключаем клиентскую часть backEnd тестов для микросервиса 1 к клиентской часть backend тестов микросервиса 2 и проверяем.\n\nДля предоставления результатов используется Allure репорт, он используется для внутренних нужд.\n\nДля кастомера используется Report Pirtal, где отображаются результаты со всех уровенй тестирования.\n\n#### Selenoid\n\n- доступен сразу из коробки\n\n- есть 2 решения:\n  1. деплоится на виртуальную машину\n  2. деплоится в kubernetes кластер\nесли есть cloud платформа то можно бытсро с помощью seleonoid поднять браузер в cloud'е\n\n- браузеры стартуют очень быстро (~30сек)\n\n- надежность\nбраузеры сами закрываются ничего не зависает\n\n- запись видео\n\n## Docker\n\nDocker container - экземпляр Docker Image который содержит три атрибута:\n- docker image\n- среда запуска\n- стандартный набор инструкций\n\n### Преимущества\n\n- приложения портируемые и стандартно упакованные\nзапустить можно везде где есть docker engine\n- деплоймент простой и повторяемый \n- поддержка микросервисной архитектуры\nкаждый микросервис запакован, изолирован и запускается отдельно\n\n### Tools for containers orchestration\n\n- kubernetes - самый распространненый инструмент\n- docker swarm - нативный tool\n- rancher\n- mesos\n\n#### Источник информации:\n1. ❗[Automation testing solution for micro service architecture](https://www.youtube.com/watch?v=0QVlMsObhuQ)","date":"2022-07-27T00:00:00.000Z","path":"/mikroservisnaya-arhitektura/","icon":"fas fa-robot","image":"null","order":1,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"},{"title":"микросервисы","path":"/tag/%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B/"}],"headings":[{"value":"Микросервисная архитектура","anchor":"#микросервисная-архитектура"},{"value":"Docker","anchor":"#docker"}]}}]}},"relatedTag":null},"context":{}}