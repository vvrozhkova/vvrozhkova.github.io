{"hash":"03f7058ba488a165454bf4fd228c446ef5a28a6f","data":{"tag":{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/","belongsTo":{"totalCount":21,"pageInfo":{"totalPages":3,"currentPage":1},"edges":[{"node":{"id":"8d9bed2d7f5e2e7fb092ceb89f92f47f","title":"Проблемы и решения","content":"\n## Ошибка Timeout waiting to lock... во время сборки Gradle проекта \nВ терминале нужно выполнить команду \n```\nfind ~/.gradle -type f -name \"*.lock\" -delete\n``` \n\n## ITK\nSelenide вернет проинициализированный объкт после того как откроет страницу по указанному url.\n\n```java\nHuman h = Selenide.open(\"\", Human.class);\n```\n\n## Папка test не подсвечивается как модуль\nНужно пометить папку src-test-java как Test Source и пересобрать проект в gradle\n","date":"2022-06-13T00:00:00.000Z","path":"/problemy-i-resheniya/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Ошибка Timeout waiting to lock... во время сборки Gradle проекта","anchor":"#ошибка-timeout-waiting-to-lock-во-время-сборки-gradle-проекта"},{"value":"ITK","anchor":"#itk"},{"value":"Папка test не подсвечивается как модуль","anchor":"#папка-test-не-подсвечивается-как-модуль"}]}},{"node":{"id":"7d1a83289c7e76ef68e0e31d8e39a35f","title":"Инфраструктура проекта автотестирования","content":"\n## Общая схема инфраструктуры\n\nИнфраструктура проекта по автоматизации тестирования состоит из следующих компонентов:\n\n- Selenium WebDriver\n- Язык программирования\n- Сборщик, менеджер зависимостей\n- Тестовый фреймворк\n\n## Инфраструктура для Java\n\n- Selenium WebDriver - chromedriver\n- Язык программирования - Java\n- Сборщик - Gradle\n- Менеджер зависимостей - Maven Central\n- Тестовый фреймворк - JUnit\n\n","date":"2022-06-12T00:00:00.000Z","path":"/infrastruktura-proekta-avtotestirovaniya/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Общая схема инфраструктуры","anchor":"#общая-схема-инфраструктуры"},{"value":"Инфраструктура для Java","anchor":"#инфраструктура-для-java"}]}},{"node":{"id":"c9a5d9cd4f6903515e864e4fc9743724","title":"Понятие автоматизированного тестирования","content":"\n## Что такое автоматизированное тестирование?\nАвтоматизированное тестирование (Automation Testing, Test Automation) — техника тестирования, в которой для выполнения тест кейсов используются специальные программы. Это отличает ее от ручного тестирования, в котором тест кейсы выполняются вручную тестировщиком.\n\nПрограммы для автоматизации сравнивают полученные результаты с актуальными и генерируют подробные тест-репорты.\n\nРазработка продукта циклична и итерационна — и на каждой итерации, как правило, требуется выполнение одного и того же набора тестов. С помощью инструментов автоматизированного тестирования можно записывать наборы тестов (test suites) и выполнять, когда это необходимо. Как только набор тестов автоматизирован, участие человека в выполнении тестов практически не требуется. Это делает автоматизированное тестирование эффективной техникой. Цель автоматизации — уменьшить количество тестов, которые нужно выполнять вручную.\n\n## Зачем нужно автоматизированное тестирование?\nАвтоматизированное тестирование — лучший способ улучшить эффективность, покрытие продукта тестами, уменьшить время на тестирование. \n\nПреимущества автоматизированного тестирования:\n\n- Автоматизированное тестирование увеличивает скорость тестирования\n- Автоматизированное тестирование не требует участия человека для выполнения тестов. Отсутсвует влияние человеческого фактора.\n- Средства автоматизации способны выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов. \n- Средства автоматизации способны собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.\n- Ручное тестирование всех возможных сценариев использования требует много времени (и, следовательно, денег)\n- Автоматизированные тесты могут быть запущены в любое время (днем, ночью, в выходные и праздники)\n- Многократное ручное тестирование одной и той же функциональности скучно\n\nНедостатки автоматизированного тестирования:\n\n- Необходимость наличия высококвалифицированного персонала в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, ко- дом и т.д.).\n- Разработка и сопровождение как самих автоматизированных тест-кейсов, так и всей необ- ходимой инфраструктуры занимает очень много времени.\n- Автоматизация требует более тщательного планирования и управления рисками,т.к. в противном случае проекту может быть нанесён серьёзный ущерб&\n- Коммерческие средства автоматизации стоят ощутимо дорого, а имеющиеся бесплатные аналоги не всегда позволяют эффективно решать поставленные задачи. \n- Средств атоматизации крайне много, что усложняет проблему выбора того или иного средства, затрудняет планирование и определение стратегии тестирования, может повлечь за собой дополнительные временные и финансовые затраты, а также необходимость обучения персонала или найма соответствующих специалистов.\n\n## Что автоматизировать в первую очередь?\n\nДля максимальной эффективности, для определения сценариев, подходящих под автоматизацию, пользуйтесь следующими критериями:\n\n- Критически важная бизнес-функциональность\n- Тест кейсы, которые нужно выполнять много раз\n- Тест кейсы, которые сложно воспроизвести вручную\n- Тест кейсы, воспроизведение которых занимает много времени\n\nСледующие критерии не подходят для автоматизации:\n\n- Новые тест кейсы, которые еще не были выполнены вручную\n- Тест кейсы для функциональности, требования к которой часто меняются\n- Тест кейсы, которые выполняются редко\n\n## Процесс автоматизированного тестирования\n\nШаг 1: Выбор инструмента для автоматизации\nШаг 2: Определение функциональности, которую нужно автоматизировать\nШаг 3: Планирование, тест дизайн и разработка тестов\nШаг 4: Выполнение тестов\nШаг 5: Поддержка написанных тестов\n\n### Определение функциональности, которую нужно автоматизировать\n\nОбласть для автоматизации может быть определена по следующим критериям:\n\n- Функциональность, которая важна для бизнеса\n- Сценарии, для тестирования которых нужны большие объемы входных данных\n- Функциональность, использующаяся в нескольких частях приложения\n- Целесообразность с технической точки зрения\n- Сложность написания тест кейсов\n- Возможность использования одних и тех же тест кейсов для кроссбраузерного тестирования\n- Планирование, тест дизайн и разработка\n\nСценарии, обычно подходящие для автоматизации:\n\nТесты, которые повторяются во всех билдах\nТесты, в которых легко могут возникать ошибки тестировщиков\nТесты с большими объемами данных\nЧасто используемые функции с большими рисками\nТесты, забирающие много ручного времени\nТесты, задействующие много разных программных/аппаратных конфигураций\n\nДалее пять вещей, которые нужно оценить до того как приступать к автоматизации.\n\n1. Автоматизируй Smoke-тесты.\nТакие тесты позволяют удостовериться, что приложение в целом работоспособно, и их желательно делать при каждом изменении функциональности, и после каждого билда. Smoke-тесты должны интегрироваться в CI/CD-процессы — это позволяет выловить критические ошибки. Smoke-тестами проверяют основные части приложения/сайта, они должны оставаться работоспособными в любых условиях; гарантируется, что билд достаточно стабилен, значит можно продвигаться дальше в пайплайне.\n\nАвтоматизация Smoke-тестирования помогает:\n\nОперативно найти критические баги, и сделать это очень рано в пайплайне. Главная страница/экран не открывается; у клиент не получается залогиниться или сделать себе аккаунт; платежные системы не подключаются и т.п.\nБыстрее идет устранение новых или “регрессионных” дефектов. Smoke-тесты сами по себе “дают широкое покрытие, но малую глубину” этого покрытия. Получается много тестовых кейсов без необходимости “глубокого погружения” тестировщиков в проект. Убедились, что самые важные части работоспособны — и идем дальше, к менее важным компонентам.\nАвтоматизация Smoke-тестов позволяет экономить время за счет уменьшения большого количества ручной работы. Включение автотестов в CI/CD позволяет проводить smoke-тестирование еще на этапе сборки билда. \n2. Автоматизируй тесты, которые пишутся всегда, и которые пишутся в начале каждого этапа\nТогда получаются стабильные тест-сьюты. К примеру, тестирование создания аккаунта должно делаться до того как юзер может логиниться и видеть свое клиентское окно, проводить платежи и т.п.\n\nСоздание автоматического “регрессионного” тестового набора (сьюта) позволяет:\n\nДелать тесты, оперативно находящие баги, возникающие из правок в коде. Правки могут быть новыми функциями, или “фиксами” прошлых багов. \nТестовый набор, как уже было сказано, получается с повышенной стабильностью и надежностью. Регрессионное тестирование обычно касается существующей функциональности, то есть функции уже тестированы неоднократно. Это повышает стабильность сьютов, экономится время ручных тестировщиков, когда не знаешь, реально “падают” тесты или они нестабильные.\nЭкономится время: можно сосредоточиться на ручном тестировании (особенно граничных значений).\n3. Автоматизируй “большие тесты” — с большим массивом данных\n“Большие тесты” — это может быть ввод больших массивов данных, тестирование форм, или тесты предполагающие многократный ручной ввод самых разных данных. Их-то и надо автоматизировать. Если речь идет о формах, автоматизация позволяет быстро протестировать комбинации данных в форме, например ситуации когда пропущены поля, данные неполные, и т.п. Тут полезно DDT-тестирование, позволяющее модифицировать только данные, а не весь скрипт. Это то что называется “реюзабельный” и эффективный подход.\n\n4. Автоматизируй тесты с множественными конфигурациями\nЕсли в проекте множество ОС и целый “парк браузеров”, будет сложная конфигурация.\n\nРучная конфигурация всего этого “парка” — утомительная вещь, и для экономии времени такое тестирование стараются автоматизировать. Тесты запускают в разных окружениях, меняя лишь переменную среды достаточно удобным образом. \n\nЖелательно также почитать что-то о параллельном тестировании, которое также экономит время. Можно применять специальные “тулзы” типа CircleCI — прописывают ОС/браузер/окружение, в которых будут выполняться параллельные тесты. \n\n5. Автоматизируй тесты производительности\nТакие тесты проводятся для устранения отказов приложения, улучшения пресловутого User Experience, и, разумеется, контроля производительности приложения. Проверяется, как приложение ведет себя под серьезной нагрузкой; находят ее проблемные точки; контролируют то что называется “плавность” приложения, время реакции на действия, стабильность, степень задействования аппаратных ресурсов девайса, и способность безболезненно реагировать на резкий рост нагрузки. \n\nАвтоматизация тестирования производительности — это когда генерируются тысячи условных “пользователей”, и проверяют, как реагирует приложение. \n\nКак часто будут выполняться написанные тесты?\nСамый важный вопрос. Автоматизировать тест-кейс имеет смысл в том случае, если он будет выполняться постоянно. Обязательно учитывайте частоту использования при составлении плана по автоматизации.\n\nДля какой функциональности разрабатываются автотесты?\nНекоторые части приложения имеют большее значение/влияние, чем другие. Очень важно, чтобы критическая функциональность была покрыта тестами в первую очередь — баги в таких местах будут стоить очень дорого. Здесь автоматизация однозначно себя окупит.\n\nПланируется ли запускать тест с разными наборами данных?\nРучное выполнение тест-кейсов с разными наборами входных данных — тяжелая работа. С помощью автотестов можно освободить время ручных тестировщиков и минимизировать шансы багов на продакшене.\n\nТест будет выполняться в регрессионном или smoke-тестировании?\nРегрессионное и smoke-тестирование выполняются очень часто. Это тест-сьюты, которые тестируют приложение “вширь” — т.е. тестируют корректность работы всего базового функционала. Регрессионные тесты интегрируются в процесс сборки приложения и выполняются во время каждого билда. Их автоматизация поможет улучшить качество продукта.\n\nПросто ли написать автотест с помощью ваших инструментов?\nНужно проводить анализ возможности (сложности) разработки конкретного тест-сьюта с помощью используемого инструмента автоматизации. Например, попытка автоматизировать тестирование запросов к SAP — не лучшая трата вашего времени, если инструмент не поддерживает такое тестирование. Использование другого инструмента для одной конкретной задачи тоже не лучшее решение. Такие места дешевле всего тестировать вручную.\n\nКак часто будет меняться/дорабатываться функциональность, которую планируется покрывать?\nВажный вопрос. В случае, если часть приложения будет часто меняться, дорабатываться, переписываться с нуля и т.п. — писать автотетсы для нее рано. Каждый раз после изменения функционала тесты нужно будет обновлять/переписывать заново.\n\nПоэтому узнайте о планах разработчиков на ближайшее время — если функциональность планируют менять, отложите написание автотестов до лучших времен.\n\nЭто негативный тест?\nПисать негативные автотесты — не лучшее решение.\n\nСмогут ли написанные тесты выполняться параллельно?\nЕсли процесс автоматизации хорошо выстроен, можно сэкономить много времени, запуская тесты параллельно. Параллельное выполнение очень важно для получение максимальной отдачи от автоматизации. Поэтому тесты, которые в конечном итоге смогут быть выполнены только в определенном последовательном порядке — не лучшие кандидаты на автоматизацию. Это не значит, что их не нужно автоматизировать вообще. Просто на данном этапе лучше поискать что-то более подходящее.\n\nНе пишутся ли тесты только ради отчетов?\nСовременные инструменты для автоматизации дают возможность генерировать классные отчеты о результатах тестирования. Однако, отчеты не являются целью автоматизации. Для улучшения качества нужно разбирать каждый упавший тест — определять, почему он упал и что нужно исправить. Написанные тесты нужно постоянно поддерживать в актуальном состоянии. Все это нужно держать в уме, когда вы собираетесь писать автотест для какой-либо функциональности. Автоматизация гораздо больше, чем красивые отчеты.\n\nНа этом этапе создается тест стратегия и тест-план, которые содержат следующие детали:\n\n- Выбранный инструмент автоматизации\n- Фреймворк с описанием его особенностей\n- Описание функциональности, тестирование которой будет автоматизировано\n- Подготовка стендов для выполнения тестов\n- Расписание выполнения автотестов\n- Результаты автоматизированного тестирования\n\n### Выполнение тестов\n\nВо время этой стадии происходит выполнение автотестов. После выполнения генерируется подробный тест репорт.\n\nВыполнение тестов может быть запущено как из инструмента автоматизации напрямую, так и с помощью системы управления тестированием (Test Management Tool), который запустит инструмент автоматизации.\n\n### Поддержка написанных тестов\n\nНа стадии поддержки происходит изменение существующих тестов (в случае планируемого изменения функциональности) или добавление новых тестов.\n\n## Советы по использованию инструментов автоматизации\n\n- Функциональность, подходящая для автоматизации, должна быть определена до начала разработки проекта.\n- Инструмент для автоматизации должен быть выбран исходя из требований конкретного продукта, а не из популярности.\n- Придерживайтесь стандартов написания кода, когда разрабатываете автотесты. Вот некоторые из них:\n    - Придерживайтесь гайдлайнов при написании кода\n    - Оставлйте комментарии\n    - Обрабатывайте ошибки — при разработке думайте о том, как отработает ваша система в случае некорректного поведения приложения.\n- Собирайте метрики, чтобы определить эффективность автоматизированного тестирования. Вот некоторые из них:\n    - Процент найденных багов\n    - Время, затраченное на выполнение автотестов для каждого релиза\n\n## Типы автоматизированного тестирования\n\n|Случай/задача | В чём проблема автоматизации|\n|---|---|\n|Регрессионное тестирование|Необходимость выполнять вручную тесты, количество которых неуклонно растёт с каждым билдом, но вся суть которых сводится к проверке того факта, что ранее работавшая функциональность продолжает работать корректно.|\n|Инсталляционное тестирование и настройка тестового окружения.|Множество часто повторяющихся рутинных операций по проверке работы инсталлятора, размещения файлов в файловой системе, содержимого конфигурационных файлов, реестра и т. д. Подготовка прило- жения в заданной среде и с заданными настройками для проведения основного тестирования.|\n|Конфигурационное тестирование и тестирование совместимости.|Выполнение одних и тех же тест-кейсов на большом множестве входных данных, под разными платформами и в разных условиях. Классический пример: есть файл настроек, в нём сто параметров, каждый может принимать сто значений: существует 100100 вариантов конфигурационного файла — все их нужно проверить.|\n|Использование комбинаторных техник тестирования (в т.ч. доменного тестирования).|Генерация комбинаций значений и многократное выполнение тест-кейсов с использованием этих сгенерированных комбинаций в качестве входных данных.|\n|Модульное тестирование.|Проверка корректности работы атомарных участков кода и элементарных взаимодействий таких участков кода — практически невыполнимая для человека задача при условии, что нужно выполнить тысячи таких проверок и нигде не ошибиться.|\n|Интеграционное тестирование.|Глубокая проверка взаимодействия компонентов в ситуации, когда человеку почти нечего наблюдать, т. к. все представляющие интерес и подвергаемые тестированию процессы проходят на уровнях более глубоких, чем пользовательский интерфейс.|\n|Тестирование безопасности.|Необходимость проверки прав доступа, паролей по умолчанию, открытых портов, уязвимостей текущих версий ПО и т. д., т. е. быстрое выполнения очень большого количества проверок, в процессе которого нельзя что-то пропустить, забыть или «не так понять».|\n|Тестирование производительности.|Создание нагрузки с интенсивностью и точностью, недоступной человеку. Сбор с высокой скоростью большого набора параметров работы приложения. Анализ большого объёма данных из журналов работы системы автоматизации.\n|Дымовой тест для крупных систем.|Выполнение при получении каждого билда большого количества достаточно простых для автоматизации тест-кейсов.|\n|Приложения (или их части) без графического интерфейса.|Проверка консольных приложений на больших наборах значений параметров командной строки (и их комбинаций). Проверка приложений и их компонентов, вообще не предназначенных для взаимодействия с человеком (веб-сервисы, серверы, библиотеки и т. д.)|\n|Длительные, рутинные, утомительные для человека и/или требующие повышенного внимания операции.|Проверки, требующие сравнения больших объёмов данных, высокой точности вычислений, обработки большого количества размещённых по всему дереву каталогов файлов, ощутимо большого времени выполнения и т.д. Особенно, когда такие проверки повторяются очень часто.|\n|Проверка «внутренней функциональности» веб-приложений (ссылок, доступности страниц и т. д.)|Автоматизация предельно рутинных действий (например, проверить все 30’000+ ссылок на предмет того, что все они ведут на реально существующие страницы). Автоматизация здесь упрощается в силу стандартности задачи — существует много готовых решений.|\n|Стандартная, однотипная для многих проектов функциональность.|Даже высокая сложность при первичной автоматизации в таком слу- чае окупится за счёт простоты многократного использования полу- ченных решений в разных проектах.|\n|«Технические задачи».|Проверки корректности протоколирования, работы с базами данных, корректности поиска, файловых операций, корректности форматов и содержимого генерируемых документов и т. д.|\n ","date":"2022-05-28T00:00:00.000Z","path":"/ponyatie-avtomatizirovannogo-testirovaniya/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Что такое автоматизированное тестирование?","anchor":"#что-такое-автоматизированное-тестирование"},{"value":"Зачем нужно автоматизированное тестирование?","anchor":"#зачем-нужно-автоматизированное-тестирование"},{"value":"Что автоматизировать в первую очередь?","anchor":"#что-автоматизировать-в-первую-очередь"},{"value":"Процесс автоматизированного тестирования","anchor":"#процесс-автоматизированного-тестирования"},{"value":"Советы по использованию инструментов автоматизации","anchor":"#советы-по-использованию-инструментов-автоматизации"},{"value":"Типы автоматизированного тестирования","anchor":"#типы-автоматизированного-тестирования"}]}},{"node":{"id":"108cafef145bb82258b23c4a45f530b2","title":"Профессионально работаем с IntelliJ IDEA","content":"\n## Основы\n\n_Alt + 1(Win), ⌘ + 1(MacOs)_ - отобразить/скрыть вид проекта слева\n\n_Alt + Insert(Win), ⌘ + N(MacOs)_  \n_(клик в левом меню)_ - открывает диалог создания нового файла\n\n_Alt + Insert(Win), ⌘ + N(MacOs)_  \n_(клик в основной области окна)_ - открывает окно генерации методов разных типов (@Test, @SetUp, @TearDown)\n\n_Ctrl + P(Win), ⌘ + P(MacOS)_ - открывет подсказку параметров текущего метода\n\n_Alt + Enter(Win), Option + Enter(MacOs)_  \n_Alt + Shift + V(Win), Option + ⌘ + V(MacOs)_  - формирует из выражения новую переменную\n\n_⌘ + Shift + I(MacOs)_ - сбилдить gradle проект\n\n### Postfix\n\n_после выражения дописать .var_ - формирует из выражения новую переменную\n_после числа дописать .for_ - формирует циклы от 0 до заданного числа\n\n### Справочная информация по работе в IDE\n\n_Shift + Shift_ - поиск по командам, файлам и всему остальному в проекте\n\n_Help + Keyboard Shortcuts PDF_ - загружает PDF файл со всеми сочетаниями клавиш\n\n_Плагин Key Promoter Х_ - подсказывает какие shortcuts нужно выбирать при совершении действий мышью\n\n_Ctrl + Alt + O(Win), Option + ⌘ + N(MacOs)_ - перемещает значение переменной непосредственно в метод\n\n_Option + Enter (на запускаемом методе), F9_ - выполнить запуск кода\n\n_Ctrl + F11(Win), Option + F3(MacOs)_ - добавить файл в закладки\n\n_View - Tool Windows - TODO_ - открывается окно посмотра добавленных todo комментариев.  \nЗдесь можно настроить фильтр поиска todo содержащие определенный текст, и добавить им соответсвующее выделение\n\nВ момент дебага можно внести изменения в код и чтобы он применился на лету нужно запустить билд приложения и продолжить выполнение.\n\n\n## Git/VSC\n\n### Редактирование коммита\n\nВ окне `Git/VSC` вкладка `Log` - можно нажать на коммит и изменить сообщение\n\n### Объединение коммитов\n\n1. Выбираем в вверхнем меню `Git` - `Rebase`, \n2. Выбираем текущую ветку из удаленного репозитория и выбираем опцию `--interactive`\n3. Нажимаем Rebase\n4. Откроется окно, в нем также можно выбрать и переименовать комит (`Reword`). \n5. Выделяем коммиты, которые хотим объединить и вверху выбираем `Fixup` и нажимаем `Start Rebasing`.\n\n### Отмена коммита\n\nНа вкладке Log нажимаем ПКМ на коммит до которого хотим откатиться и выбираем `Reset Current Branch to Here...`.  \nВыбираем опцию `Hard` - все коммиты выше выбранного будут удалены без сохранения.\n\nЕсли коммит был запушен то отменить его лучше через `Revert commit`, будет создан комит отменяющий выполненные изменения.\n\n\n_Ctrl + Q(Win), F1(MacOS)_ - показывает короткую документацию по текущему методу/переменной.\n\n_Ctrl + B(Win), ⌘ + B(MacOs)_ - переход к объявлению кода/либо поиск мест где данные код используется.\n\n_Ctrl + E(Win), ⌘ + E(MacOs)_ - открывается окно с недавними файлами которые были ранее открыты.\n\n_Ctrl + Alt + ⇨(Win), ⌘ + Option + ⇨(MacOs)_ - позволяет перемещаться по истории в том числе между открытыми ранее файлами выставляя курсор в том месте, где он ранее был при работе в этих файлах.\n\n_Ctrl + shift + E(Win), ⌘ + Shift + E(MacOs)_ - показывает последние участки кода с которыми была работа.\n\nДля работы с рандомными файлами которые возможно даже не относятся к текущему проекту можно пользоваться разделом `Scratches and Console`. Он находится слева в окне с деревом проекта в самом низу.\nЭти файлы будут доступны в любых проектах. Можно сохранять разные шаблоны, шпаргалки и т.д.\n\n## Библиотека JsonPath\n\n_Alt + Enter(Win), Option + Enter(MacOs)_ - при нажатии на значении строковой переменной позволяет выбрать `Inject language or reference` после чего можно выбрать язык, чтобы содержимое строки отформатировалось и подсветилось в соотвествии с синтаксисом выбранного языка, например JSON. При повторном вызове команды, можно выбрать `Edit JSON Fragment` и в открывшемся окне отредактировать выбранный JSON или вставить большой фрагмент.\n\n### Прочитать данные из JSON\n\n```java\nString json = \"{\\\"name\\\": 10}\";\nJsonPath.read(json, \"$..name\")\n```\n\nПри нажатии `Option + Enter`(MacOs) на команде `\"$..name\"` выбираем `Evaluate JSONPath Expression`\nОткрывается окно в котором можно инспектировать json.\n\nЕсли json код находится в отдельном файле, то открыв этот файл и выбрав `Edit` - `Find` - `Evaluate JSONPath Expression`, можно инспектировать текущий json не копируя его содержимое.\n\n_Find By XPath_ - Аналогичный инструмент для XML. \n\n### Регулярные выражения\n\nПри нажатии `Option + Enter`(MacOs) на строке с регулярным выражением можно выбрать `Check RegExp` и выполнить проверку регулярного выражения\n\n## Плагины\n\n### Docker \n\nМожно установить из MarketPlace.\n\nОткрываем Tool окно `Services` (Alt + 8, ⌘ + 8) \n\nНажимаем на `+` - Docker Connection \nМожно смотреть разную информацию. Удалять, смотреть контейнеры.\n\n## Работа с БД (Ultimate Edition)\n\n- Вкладка Database - + - Data Source (выбираем тип БД) PostgreSQL.\n- Указываем Credentials - Test Connection.\n- Вкладка Schemas, обновить выбираем схему и отмечаем public.\n- После этого IDE подключается к БД и можно увидеть всю структуру БД.\nИ выполнять SQL запросы нажимая Cntl + Enter(Win), ⌘ + Enter(MacOs)\n\nЧтобы SQL распознавался в строковой переменной и была возможность автодополнения перед переменной в строке выше нужно добавить комментарий\n\n```java\n// language=SQL\n```\n\nЧтобы нужные колонки одтягивались из нашей БД нужно настроить диалект.\nНажимаем `Option + Enter`(MacOs) на SQL строке, выбираем `Change dialect to...`.\nВ диалоговом окне выбираем `Project SQL Dialect` нашу БД, например `PostgreSQL` и нажимаем `ОК`.\n\nПрямо в IDE можно менять данные в БД.\n\n## Selenium UI Testing (Ultimate Edition)\n\nПозволяет сформировать стартовый проект с подключенными нужными зависимостями (Allure, Selenide и т.д.)\nПодсвечивает и подсказывает в формировании селекторов(XPath, Css и т.д.)\nЕсть автодополнение разных атрибутов и Css свойств.\nTools - Generate Selenium PageObject - открыается браузер, в котором можно перейти на страницу для которой создается Page Object; при нажатии на элементы их можно быстро добавить в текущую страницу.\n\nТакже страницу можно: \n  - сохранить в scratches \n  - нажать иконку копировать и при вставке в дерево проекта будет создан файл с названием класса и содержимым копируемой страницы.\n\nЕсть интеграция с Selenoid: \nпри открытии файла browsers.json в верхней части окна можно выбрать ссылку Launch и запустить selenoid node в docker'e\n\nЕсть интеграция с Allure:\n  - при добавлении аннотации @Issue, @TmsLink можно будет проваливаться непосредственно в задачу, на которую ссылается данный тест.  \n  Для этого нужно тобы путь к проекту был настроен либо в allure.properties либо в настройках IDE: `Preferences` - `Version Control` - `Issue Navigation`,\n  `+` - `Add Pattern`\n\n## Работа с Web Services (Ultimate Edition)\n\nМожно генерировать и исполнять запросы с помощью специального языка http для этого создается файл с соответсвующим разрешением (.http)  \nМожет подсказывать параметры, заголовки и т.д.  \nМожно писать тест на языке javascript и выполнять их прямо из таких файлов.\n\n```javaScript\nGET https://httpbin.org/status/200\n\n> {%\nclient.test(\"Request executed succesfully\", function() {\n  client.assert(responce.status == 200, \"Response status is not 200\");\n});\n%}\n```\n\nПри написании Rest тестов например через библиотеку RestAssured IDE может подсказывать все url, которые есть в вашем проекте или в OpenApi спецификациях.\n\nЧтобы добавить спецификацию идем внизу во вкладку Endpoints, через шестиренку выбираем `Configure OpenApi Sources...` через + выбираем Swagger Hub, ищем конфигурацию и нажимаем `Add Selected`.  \nПосле этого в автодополнении появятся нужные url.  \nЕсли открыть swagger.yaml, то через иконку можно в соседнем открыть swagger ui в котором также можно делать отладку и отправлять запросы.\n\n## Плагины\n\n### Test Management (Ultimate Edition)\n\nНужно установить соответсвующий плагин и в настройках IDE - Preferences - Tools - Tms указать путь к ссиетме управления тестами TestRail.\n\nТогда в соседнем окне появятся тест кейсы, тест раны, тест планы, которые будут синхронизироваться.\n\nМожно скопировать нужный тест кейс и вставить в код автотестов, в результате будет сгененрирован тестовый метод с комментариями шагов, которые нужно автоматизировать.\n\nТакже эти кейсы можно фильтровать по каким-либо параметрам или например, автоматизирован тест или нет.\n\nТакже этот плагин позволяет хранить кейсы как код (test cases as a code). Они сохраняются в виде .md файлов в папочке specs, их можно обновлять и эти изменения будут отражаться в дереве кейсов справа. Их также можно фильтровать по параметрам, хранить в VSC. \nЕсть специальный формат, который позволяет добавлять статусы, assignee и т.д.\n\n### Test Data\n\nПлагин позволяет генерировать данные.\nЧерез `Option + Enter`(MacOs) в строковой переменной можно выбрать тип данных, который нужно сгененрировать.\n\n\nhttps://www.youtube.com/watch?v=_rj7dx6c5R8","date":"2022-06-11T00:00:00.000Z","path":"/professionalno-rabotaem-s-intelli-j-idea/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Основы","anchor":"#основы"},{"value":"Git/VSC","anchor":"#gitvsc"},{"value":"Библиотека JsonPath","anchor":"#библиотека-jsonpath"},{"value":"Плагины","anchor":"#плагины"},{"value":"Работа с БД (Ultimate Edition)","anchor":"#работа-с-бд-ultimate-edition"},{"value":"Selenium UI Testing (Ultimate Edition)","anchor":"#selenium-ui-testing-ultimate-edition"},{"value":"Работа с Web Services (Ultimate Edition)","anchor":"#работа-с-web-services-ultimate-edition"},{"value":"Плагины","anchor":"#плагины-1"}]}},{"node":{"id":"d766f676baa4347410612acd4568d8da","title":"Gradle","content":"\nGradle - это фреймворк который отвечает за структуру, зависимости, плагины вашего проекта для того чтобы управлять этапами сборки этого проекта: компиляция, запуск тестов, публикация. \n\nНаписан на Java  и запускается на JVM. \n\nДля реализации и описания процесса сборки в Gradle реализовано 2 DSL языка на Groovy и на Kotlin.\nОба этих языка предоставляют примерно одинаковый API для работы со сборкой и имеют 2 интерфейса, которые эту сборку описывают.\n\n`project` - описывает как и из чего собрать проект;  \n`settings.gradle` - описывает дополнительные метаданные и список дочерних проектов, если это мультимодульный проект;\n\n## `project`\n\n### task\nПредставляет собой набор задач, который вам нужно выполнить для сборки приложения; эти задачи можно писать самим или добавлять через плагины.\n\n### plugin\nПлагин - это реализация методов интерфейса project, которые могут реализовывать работу с зависимостями, добавлять нужные таски и почти полностью менять, то как работает процесс сборки.\n\n### dependencies\nМожно указать необходимые зависимости для работы вашего приложения. Gradle реализует только логику управления зависимостями а сам репозиторий можно выбрать, настроив это в build скрипте. Это может быть например maven репозиторий.\n\nТип Task в Gradle это по сути класс, который состоит из действия, которое выполняет класс или нескольких действий, входных и выходных данных.\n\nКаждая из этих состовляющих кастомизируема и необязательна. Например, существуют LifeCycle таски, которые сами ничего не делают, но объединяют несколько других тасок.\n\nЗа счет такого разделения Gradle реализует **_инкрементальную_** сборку: перед выполнением таски Gradle проверяет есть ли изменения входных данных и повлияют ли эти изменеия на выходные данные. Если нет, то Gradle просто пропустит таск с надписью **UP TO DATE**, таким образом оптимизируется процесс сборки, чтобы каждый раз не собирать неизменяемые модули, а собирать только то, что изменилось, но эту логику также можно отключить.\n\nЧтобы обеспечить нужный порядок выполнения тасок Gradle строит ориентированный ациклический граф (**DAG, Directed Acyclic Graph**). \n\nГраф - это набор объектов(в нашем случае тасок), обладающих парными связями (каждая таска связана с одной или несколькими(двумя) тасками). \n\nТаски - вершины, связи между ними - ребра. \n\nТо что граф ориентированный значит, что у ребер есть направление (порядок исполнения тасок), то что он ациклический означает, что в нем нет направленных циклов, нельзя из одной точки прийти в нее же, но это не мешает из разных точек прийти в одну. \n\n**Граф для сборки Java приложения**\n\n```mermaid\ngraph TD;\n      build-->check;\n      build-->assemble;\n      check-->test;\n      assemble-->jar;\n      jar-->classes;\n      classes-->compileJava;\n      classes-->processResources;\n```\n\n## Сборка Java приложения\nПроцесс сборки делится на 3 тапа: инициализация, конфигурация и исполнение. \n\n### Инициализация\nВ процессе инициализации Gradle ищет `settings.gradle` файл, из которого определяет это одиночный или мультимодульный проект. После этого он создает instance одного или нескольких проектов. \n\n### Конфигурация\nДалее в процессе конфигурации, gradle для каждого проекта ищет build.gradle скрипт и выполняет все указанные там конфигурационные действия в контексте текущего проекта: подключает плагины, скачивает зависимости, выполняет код находящийся в конфигурационном блоке, создавая объекты сборки. \n\nВо время фазы конфигурации gradle исполняет конфигурационные скрипты всех проектов если это мультимодульный проект, даже если вы собираете только один из модулей. Так что если логика не относится ко всему мультимодульному проекту, лучше ее помещать в конкретные таски. \n\n### Исполнение\nПо сути в процессе конфигурации он строит тот самый граф из тасок и в процессе выполнения, исполняет те таски, которые мы указали.\n\n\nИннициализация Gradle проекта выполняется командой gradle init.\n\n```\n$ gradle init\n```\n\nДалее нужно ответить на несколько вопросов и дождаться окончания инициализации.\nПосле этого в проекте будут созданы файлы: \n- gradlew(исполняющий файл для Linux подобных систем), gradlew.bat(исполняющий файл для Windows);\n- папка gradle, в которой папка wrapper;  \nКак раз этот wrapper и запускает скрипты. Gradle использует wrapper, чтобы можно было однозначно понять версию Gradle, которая будет использоваться для сборки.  \nWrapper сам скачает эту версию Graddle, если на машине он не установлен. Поменять версию и откуда его скачивать можно в файле gradle/gradle-wrapper.properties\n- build.gradle, settings.gradle\n\nВ **settings.gradle** указано только имя проекта, для мультимодульных проектов также здесь указывается список модулей. \n\nВ **build.gradle** имеются следущие секции:\n\n- секция plugins  \nЗдесь размещается обычно плагин id: 'java', который используется для сборки java проектов;  \nЕще существует плагин java-library, он используется если вы хотите поставлять ваше приложение как библиотеку.\n\n```groovy\nplugins {\n    id 'java'\n}\n```\n\n- секция repositories  \nЗдесь можно задать url репозитория из которого будут скачиваться зависимости. Для стандартного Maven репозитория есть алиас mavenCentral().\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n```\n\nТакже в build.gradle, как и в Maven содержатся group, version, description, java.sourceCompatibility, но в отличие от Maven их указывать не обязательно Gradle сможет сам сгенерировать эти данные.\nПосле компиляции нам доступны таски.\n\n- секция dependencies  \n\nЕсть несколько типов зависимостей:\n- implementation - зависимость доступна и в main и в test директориях\n- testImplementation - зависимость доступна только в test директории\n- testAnnitationProcessor - зависимость, которая генерирует код в рантайме на основе аннотаций\n\n```groovy\ndependencies {\n    implementation 'com.codeborne:selenide:6.6.3'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.24'\n}\n```\n\nЧтобы после билда запустились тесты, нужно указать каким движком нужно запустить тесты.\n\n```groovy\ntest {\n    useJUnitPlatform()\n}\n```\n\nКогда зависимость требует какой то сложной конфигурацией она зачастую реализуется плагином. Тогда достаточно подключить плагин и не нужно добавлять несколько зависимостей.\n\nВместо testAnnotationProcessor которую мы прописывали для lombok можно добавить плагин.\n\n```groovy\nplugins {\n    id 'io.freefair.lombok' version'5.3.0'\n}\n```\n\n## Custom task\n\nДля добавления своей таски используется коллекция tasks и новые таски в нее добавляются с помощью методы register. В метод register нужно передать название таски(по этому названию мы в последствии сможем обращаться к этой таске)\nвторой параметр опционален, в него можно передать тип таски можно использовать стандартный тип Test который был добавлен Java плагином. \n\n### Таска для запуска тестов из определенной директории\nОтфильтровать тесты которые будут запускаться можно с помощью блока filter в нем есть метод includeTestsMatching.\nНа вход этому методу можно передать wildcard - часть пути до наших тестов со звездочкой.  \n\n```\nsrc\n├── main\n    ├── java\n        ├── simple\n            ├── automation\n├── test\n    ├── java\n        ├── rest\n        ├── utils\n        ├── web\n            ├── findby\n            ├── simple\n```\n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n```\n\n### Указываем платформу для запуска тестов из Custom Tasks \n\nЧтобы не прописывать в каждой таске, что она должна запускаться с помощью Junit можно выполнить одну настройку для всех тасок с типом test. \nДля этого на контейнере tasks используем метод withType, который выберет все таски с типом Test, и внутри конфигурационного блока используем useJUnitPlatform().\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n}\n```\n\n### Зауск тестов из Custom Task\nВыполняем запуск тестов webtests командой:\n\n```\n$ ./gradlew webtests\n```\n\n### Добавляем еще одну custom таску\nАналогично можно настроить запуск для rest тестов:\n\n```groovy\ntasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n```\n\n### Добавляем зависимость одной таски от другой\nБывает что rest тесты могут использоваться при выполнении web тестов и зачастую бывает удобно прогонять web тесты только если прошли rest тесты.\nДля этого в Gradle есть метод dependsOn с аргументом в виде названия таска, от которой зависит текущая таска. \n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n    dependsOn 'resttests'\n}\n```\n\nСоответсвенно, при запуске web тестов будут также запущены rest тесты и они выполнятся только если rest тесты пройдут. \n\n### Запуск независимых тасок в одном скоупе\nНо если у нас rest и web тесты работают независимо как разные модули или части системы, мы можем создать еще один таск regress, который будет запускать и те и другие тесты. Используем тот же метод dependsOn но уаазываем и web и rest тесты.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n}\n```\n\nНо в таком виде запуска мы не знаем в каком порядке запустятся эти таски. \n\n### Настраиваем порядок запуска тасок\nЕсли мы хотим определить порядок, например, чтобы web тесты запускались после rest тестов, мы можем использовать метод mustRunAfter или shouldRunAfter(является менее строгим и не запускает тесты если из-за зависимости образуется петля).\nЧтобы найти ранее созданный таск используем метод getByName и из него запускаем mustRunAfter с аргументом ввиде названия таски после которой нужно запускать.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n    \n    tasks.getByName('webtests').mustRunAfter('resttests')\n}\n```\n\nЛибо при создании таска можно сохранить ее в переменную и тогда можно использовать эти переменные для вызова mustRunAfter.\n```groovy\ndef webtests = tasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n\ndef resttests = tasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n\n    webtests.mustRunAfter(resttests)\n}\n```\n\n### Запуск тестов из директории main\nЕсли по какой то причине тесты оказались не в папке test, а в папке main, то по умолчанию Gradle найти там тесты не может. Поэтому для того чтобы указать нестандартное место исходников можно использовать блок sourceSets.\n\n1. Добавляем новый sourceSet\n\nДля создания нового сета, просто пишем имя сета и скобку, внутри добавляем блок java чтобы указать свойства которые были добавлены java плагином, compileClasspath и runtimeClasspath, добавляем через += чтобы не затирать текущие значения. \nДобавляем туда путь к папке main - main.output. Чтобы указать где взять исходники используем свойство srcDir. \n\n```groovy\nsourceSets {\n    maintests {\n        java {\n            compileClasspath += main.output\n            runtimeClasspath += main.output\n        }\n        srcDir = file(\"src/main/java/simple/automation\")\n    }\n}\n```\n\n2. Настраиваем зависимости для добавленного sourceSet\n\nТакже нам нужны зависимости из блока dependencies, по умолчанию они в блок sourceSet не попадают.\nДля этого используется блок configurations, в нем указываем имя нашего sourceSet и без пробела пишем Implementation или RuntimeOnly. \nДалее с помощью метода extendsFrom можем указать, что зависимости нужно брать стандартные из testImplementation и testRuntimeOnly.\n\n\n```groovy\nconfigurations{\n    maintestsImplementation.extendsFrom(testImplementation)\n    maintestsRuntimeOnly.extendsFrom(testRuntimeOnly)\n}\n```\n\n3. Добавляем таск для запуска тестов, используя sourceSet\n\nСоздаем таск для запуска псевдотестов и указываем, что нужно использовать наш кастомный sourceSet.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n}\n```\n\n4. Добавляем фильтрацию по тегам JUnit\n\nТеперь нужно отфильтровать псевдотесты чтобы запускались только они. Сделать как в предыдущих тасках мы не можем потому что по имени package simple.automation будут запущены также и web тесты.\nНо можно использовать фильтрацию по тегам Junit. Для этого вызываем метод useJUnitPlatform, но к нему добавляем конфигурационный блок includeTags и тег методов или классов которые хотите запустить.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n\n    useJUnitPlatform{\n        includeTags \"pseudo\"\n    }\n}\n```\n\n### Запуск тестов с логированием\nЧтобы добавить уровень логирования INFO при запуске gradlew нужно добавить ключ -i.\nТаком образом мы увидим сообщения которые выводятся в консоль из тестов.\n\n```\n$ ./gradlew -i pseudotests\n```\n\n### Отключаем инкрементальный билд при запуске\nНо сразу мы можем их не увидеть из-за инкрементального билда.\nТак как между запусками исходники тестов не поменялись Gradle просто не запустит их.\nЧтобы они запустились перед таской с тестами запустим также таску clean. Это актуально для запуска тестов из контекста main.\nЕсли запускаются тесты из директории test то нужно использовать таску cleanTest.\n\n```\n$ ./gradlew -i clean pseudotests\n```\n\n### Отключаем инкрементальный билд глобально при настройке таски\nЧтобы каждый раз не вызывать clean таску можно установить значение upToDateWhen в знасение false для всех тасок с типом Test.\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n    outputs.upToDateWhen {false}\n}\n```\n\nЕсли запускаетя несколько независимых тасок с тестами, то Gradle по умолчанию останавливает выполнение на первом упавшем тесте. \nМожно настроить чтобы он все равно переходил к следущей задаче даже если упала предыдущая.\nДля этого можно при запуске добавить ключ --continue\n\n```\n$ ./gradlew --continue resttests webtests\n```\n\n### Отключаем стандартную таску test при билде\n\nДля этого нужно в блоке test присвоить свойству enabled значение false\n\n```groovy\ntest {\n    enabled = false\n}\n``` \n\n### Порядок выполнения build скрипта \n\n### Как добавить кастомные экшены к таскам\n\nСоздаем еще одну таску, но не указываем тип. В этом случае у таски будет тип DefaultTask и к ней не будет привязано никаких экшенов.\nВыводить текст в консоль можно стандартной командой println, но для реального логирования лучше использовать нормальные логгеры.\nДобавим вывод текста в блок конфигурирования таски, а также перед таской и после нее.\nЧтобы добавить кастомные экшены в таску можно использовать блок doFirst - это действие которое будет выполнено перед стандартными экшенами.\nВ нашем случае таких экшенов нет а для тасок с типом Test таким стандартным экшеном был запуск тестов.\nЕще мы можем использовать блок doLast - запускает кастомные экшены после стандартных. И doFirst и doLast можно использовать несколько раз, тогда они будут исполняться в указанном порядке. \n\nПосле запуска по тексту в консоли мы видим порядок выполнения.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\").configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\nРезультат выполнения:\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 637ms\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nСначала вполняется код конфигурации, затем код конфигурации самой таски (код внутри таски вне блоков doFirst и doLast), \nа уже дальше выполняются экшены сначала doFirst, потом doLast в порядке в котором они указаны в скрипте.\n\n> Стоит иметь ввиду если бы у нас был многомодульный проект, то сначала вполнился бы код конфигурации из всех build скриптов всех модулей.\n\nТип таски это прсто класс. Можно создать свой тип. \nДля этого используется метод с аннотацией @TaskAction, при этом класс должен наследоваться от DefaultTask.\n\n```groovy\nclass CustomTask extends DefaultTask{\n    @TaskAction\n    def customAction(){\n        println \"from custom action\"\n    }\n}\n```\n\nТеперь можно указать наш кастомный тип при регистрации таски. И теперь между doFirst и doLast экшенами выполнился наш кастомный экшен.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom custom action\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nТаск может состоять из input, actions, output. Добавим input в наш тип. Это можно сделать с помощью переменной с аннотацией @Input.\nПрисвоим ей дефолтное значение и будем использовать в нашем экшене. Теперь стандартный экшен использует значение из input'а \nи мы можем этот input переопределить в конфигурации самой таски. \n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    input = \"overrided\"\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n\n\nclass CustomTask extends DefaultTask{\n    @Input\n    String input = \"default\"\n\n    @TaskAction\n    def customAction(){\n        println \"from custom action with $input\"\n    }\n}\n```\n\nПосле прогона тестов в build/test-results складывается отчет JUnit о прогоне тестов.\nТакже есть тип таски zip позволяет что-нибудь заархивировать.\n\nИмя итогового архива задается через переменную archiveFileName, с помощью distinationDirectory указываем куда будет сложен этот архив и через\nметод from указываем какую именно папку заархивировать. Чтобы указать несколько папок используйте несколько строяек from. \n\nТаска чтобы заархивировать отчет:\n\n```groovy\ntasks.register(\"zipReport\", Zip).configure{\n    archiveFileName = 'report.zip'\n    distinationDirectory = file(\"$buildDir/reports\")\n    from \"$buildDir/reports/tests\"\n}\n```\n\nТакже потом его нужно куда нибудь скопировать. ддля этого есть тип таски Copy. В ней указываем через from откуда взять файл(также можно указать несколько from),\nа в into указываем куда скопировать. \n\n```groovy\ntasks.register('copyReport', Copy).configure{\n    from file(\"$buildDir/reports/report.zip\")\n    into file(\"out\")\n}\n```\n\nЕще одна полезная таска это jar - позволяет заархивировать приложение в jar файл. \nУ него в блоке manifest в свойстве attributes можно задать атрибут Main-Class который указыывает класс в котром наодится исполняемый метод main \nа в блоке from откуда взять скомпилированные классы \n\nJar собирается в папку build/libs и его можно запустить через команду java -jar \n\n```groovy\njar {\n    manifest {\n        attributes \"Main-Class\": \"simple.automation.Main\"\n    }\n    from {\n        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n}\n```\n\n## TODO\n\nhttps://www.youtube.com/watch?v=WOBok2u-SL8\n\nhttps://www.youtube.com/watch?v=NZJTYPLb0iE","date":"2022-06-17T00:00:00.000Z","path":"/gradle/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"project","anchor":"#project"},{"value":"Сборка Java приложения","anchor":"#сборка-java-приложения"},{"value":"Custom task","anchor":"#custom-task"},{"value":"TODO","anchor":"#todo"}]}},{"node":{"id":"8633524d3902fdb2475292951a58be9e","title":"Maven","content":"\nВсе pom.xml переопределяют super pom который идет в поставке maven\nЭто позвояет писать компактный xml.\nPom.xml содержит\n- описание проекта(название, версия, ссылки на исходные коды, CI, лицензия, разработчики и т.п.)\n- список зависимостей\n- список плагинов и их конфигурации описывает то что нужно сделать\n- профили - возможность выполнять некоторые действия при определенных обстоятельствах\n\n## Название проекта и параметры\n\n```xml\n<properties>\n    <jetty.port>9990</jetty.port>\n    <jetty.version>9.1.9.v20131115</jetty.version>\n\n    <compiler.version>1.7</compiler.version>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n</properties>\n\n<group.id>ru.yandex.qatools.allure</group.id>\n<artifactId>allure-core</artifactId>\n<version>1.4.4-SNAPSHOT</version>\n\n<packaging>pom</packaging>\n\n<name>Allure Core</name>\n```\n\n## Список модулей\n\n```xml\n<modules>\n    <module>allure-model</module>\n    <module>allure-commons</module>\n    <module>allure-java-annotations</module>\n</modules>\n```\n\n## Информация о проекте\n\n```xml\n<issueManagement>\n    <system>GitHub Issues</system>\n    <url>https://github.com/allure-framework/allure-core/issues</url>\n</issueManagement>\n<ciManagement>\n    <system>TeamCity</system>\n    <url>https://teamcity.qatools.ru</url>\n</ciManagement>\n<developers>\n    <developer>\n        <id>eroshenkoam</id>\n        <name>Artem Eroshenko</name>\n        <email>eroshenko@yandex-team.ru</email>\n        <organization>Yandex</organization>\n    </developer>\n</developers>\n```\n\n## Описание сборки проекта (плагины)\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.0</version>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\n## Зависимости\n\n```xml\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-model</artifactId>\n    <version>${project.version}</version>\n</dependency>\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-commons</artifactId>\n    <version>${project.version}</version>\n</dependency>\n```\n\n## Именование директорий\n\nsrc/ - все исходные коды  \nsrc/main - всё, что касается продукта  \nsrc/test - всё, что касается тестов\n\nsrc/main/java - Java-код продукта  \nsrc/main/resources - ресурсы продукта  \nsrc/main/webapp - файлы веб-приложений продукта (стили, Javascript и т.п.)\n\nsrc/test/java - Java-код тестов  \nsrc/test/resources - ресурсы тестов  \nsrc/test/webapp - файлы веб-приложений тестов\n\n## Жизненные циклы\n\nClean - очищает проект перед сборкой  \nDefault - собирает проект  \nSite - создает сайт проекта со ссылками на зависимости, CI, тикетную систему и т.п.\n\n## Сборка проекта. Команда mvn.\n\n```\n$ mvn clean test\n```\n\nValidate - проверить правильность проекта  \nCompile - скомпилировать исходники  \nTest - скомпилировать и выполнить тесты  \nPackage - упаковать скомпилированный код и исходники в jar, war архив  \nVerify - проверить, что код правильно упакован  \nInstall - установить пакеты в локальный репозиторий  \nDeploy - выгрузить пакеты в удаленный репозиторий  \n\n### Управление зависимостями\n\nНужно добавить блок, описывающий зависимость, в секцию `<dependencies>` и `<dependencyManagement>`\n\nБлок зависимости включает: \n- groupId - идентификатор который описывает группу проектов одного разработчика\n- artifactId - уникальное название проекта\n- version - номер версии\n- scope - на какой стадии сборки используется данная зависисмость\n    Scope может быть: \n    - compile - зависимость нужна на этапе компиляции\n    - test - зависимость не нужна чтобы собрать продукт, но нужна чтобы выполнить тесты\n    - runtime - зависимость не нужна для сборки и тестирования продукта, но нужна при его запуске\n    - provided - зависимость нужна для запуска, но при этом она поставляется кем то еще\n    - system - тоже самое что provided, но с указанием пути; мы можем указать, где на файловой системе лежит данная библиотека\n\n```xml\n<dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n    <version>1.7.7</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\n## Версии пакетов. Релизы и снепшоты\n\nСнепшот - промежуточная версия пакета, используемая в разработке: 1.0-SNAPSHOT(снимок текущей версии), чтобы делиться с другими разработчиками. Может быть бесконечно много снепшотов с одной и той же версией\n\nРелиз - стабильная версия пакета, предназначенная для использования другими проектами: 1.0. Релиз всегда один.\n\nПорядок версий: 1.0-SNAPSHOT, 1.0, 1.1-SNAPSHOT, 1.1, 1.2-SNAPSHOT и т.д.\nСначала мы делаем снепшоты, потом делаем релиз и т.д.\n\n## Конфликт зависимостей. Дерево зависимостей\n\nБывает такая ситуация, когда в проекте используется зависимость, в которой есть зависимость, которая также есть в нашем проекте. И одна зависимость будет перекрывать другую.\n\n```\npom.xml\n├── Log4j-1.2.13\n├── commons-logging-1.1\n    ├── Log4j-1.2.12\n    ├── Servlet-2.3\n```\n\nДля разрешения конфликтов зависимостей нужно построить дерево зависимостей.\nДля построения дерева зависимостей используется команда:\n\n```\n$ mvn dependency:tree\n```\n\n## Исключение зависимостей\n\nДля решения конфликта зависимостей иногда нужно исключить какую то зависимость. Для этого используется exclusions:\n\n```xml\n<dependency>\n    <groupId>ru.yandex.qatools.allure</groupId>\n    <artifactId>allure-report-builder</artifactId>\n    <version>2.0</version>\n    <exclusions>\n        <exclusion>\n            <groupId>ru.yandex.qatools.allure</groupId>\n            <artifactId>allure-model</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n\n### Необязательные зависимости\n\nТакая зависимость не будет скачиваться в проектах, зависящих от данного\nДля того, чтобы пометить необязательную зависимость используется секция optional:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.11</version>\n    <scope>test</scope>\n    <optional>true</optional>\n</dependency>\n```\n\n## Плагины. Настройка билда\n\nИзменение процесса билда - это изменение настроек отдельных плагинов в секции build/plugins.\n\n### Maven Compiler Plugin\n\nКомпилирует java код продукта и его тестов. \nОсновная настройка - версия компилятора.\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\n### Maven Source Plugin\n\nУпаковывает исходные коды проекта чтобы поделиться с другими участниками разработки.\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-source-plugin</artifactId>\n    <version>2.2.1</version>\n    <executions>\n        <execution>\n            <goals>\n                <goal>jar</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n### Maven Dependency Plugin\n\nРазрешение зависимостей, построение дерева зависимостей;\nКопирование, распаковка и другие операции с зависимостями;\n\n### Maven Jar Plugin \n\nУпаковывает файлы в jar-архив;\nМожно сделать испольняемый jar файл и указать класс, который будет запускаться при запуске jar файла.\n\n### Maven Assembly Plugin\n\nСборка дистрибутивов продукта (например, zip-архив c jar, bash скриптами и README)\nНапример, вы хотите собрать свой продукт, а потом взять еще какие то файлы и все это вместе упаковать в архив. \nИ этот плагин требует создание специального файла Assembly.xml в котором будет описываться что он собственно должен делать.\n\n### Maven Release Plugin\n\nАвтоматизирует вырсионирование, выкладку релизов.\n\nДобавляются цели release:prepare и release:perform. Они увеличивают номер версии в pom.xml и отправляет в систему контроля версий.\n\nНастройка:\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-release-plugin</artifactId>\n    <configuration>\n        <autoVersionSubmodules>true</autoVersionSubmodules>\n    </configuration>\n</plugin>\n```\n\n### Maven Surefire Plugin \n\nВыполнение тестов Junit или TestNG\n\n### Maven Site Plugin\n\nПервоначальное назначение - сгенерировать сайт поекта\nОсновное применение - генерация отчетов\n\nНастройка:\n\n```xml\n<reporting>\n    <excludeDefaults>true</excludeDefaults>\n    <plugins>\n        <plugin>\n            <groupId>ru.yandex.qatools.allure</groupId>\n            <artifactId>allure-maven-plugin</artifactId>\n            <version>${allure.version}</version>\n        </plugin>\n    </plugins>\n</reporting>\n```\n\n## Служебные файлы и каталоги\n\nПапка ~/.m2 - локальный репозиторий артефактов.  \nФайлы ~/.m2/settings.xml и /etc/maven/settings/xml, ~/.mavemrc и /etc/mavenrc - конфигурация Maven, можно менять поведение Maven по умолчанию\n\n## Профили. Settings.xml\n\nПрофиль - способ изменить настройки билда, не изменяя pom.xml. Мы можем определить как будет собираться проект при определнных условиях например если выставлена какая то переменная, включить дополнительный тесты и т.п..\n\nПрофиль хранится в pom.xml или в settings.xml(могут указываться пароли так как он не распространяется вместе с продуктом) в секции profiles\n\nИспользование профиля:\n\n```\n$ mvn clean test -P myProfile\n```\n\n```xml\n<profiles>\n    <profile>\n        <id>integration-tests</id>\n        <activation>\n            <activateByDefault>true</activateByDefault>\n        </activation>\n        <modules>\n            <module>allure-e2e</module>\n        </modules>\n    </profile>\n</profiles>\n```\n\n## Центральные репозитории артефактов\n\nУдаленный сервер, все разработчики на который могут отправлять свои разработки, а другие могут их забирать.\nОсновным таким сервером является: Maven Central Repository (http://maven.org)\n\nВ папке репозитория хранится: сами пакеты, которые приходят от разработчиков, их контрольная сумма, некоторая служебная информация в xml и цифровые подписи.\n\n- maven-metadata.xml(служебная информация)\n- jar, javadoc.jar, source.jar, jar.asc (пакеты)\n- jar.md5, javadoc.jar.md5, source.jar.md5, jar.asc.md5 (контрольная сумма)\n- jar.sha1, javadoc.jar.sha1, source.jar.sha1, jar.asc.sha1 (цифровые подписи)\n\nСуществует несколько специализироованных веб-приложений, которые выполняют функцию центральных репозиториев: Sonatype Nexus и Artifactory.\n\n## Локальный репозиторий артефактов \n\nПапка на файловой системе, которая скачивает все зависимости и файлы с центрального репозитория и кеширует у себя и это позвояет ускорять выполнение билдов.\n\nВ папке репозитоория хранятся: файлы pom.xml для каждого проекта, jar файлы, файлы с документацией и исходниками и их контрольные суммы.\n- pom\n- jar\n- javadoc.jar\n- source.jar\n- pom.sha1, jar.sha1, javadoc.jar.sha1, source.jar.sha1\n\n## Архетипы\n\nВозможность создавать шаблоны проектов. Такой возмодности не было в Ant.\nАрхетип - готовый шаблон.\n\nСоздание проекта по шаблону выполняется командой:\n\n```\n$ mvn archetype:generate\n```\n\n## TODO\n\nhttps://www.youtube.com/watch?v=R422m8VTevA","date":"2022-06-16T00:00:00.000Z","path":"/maven/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Название проекта и параметры","anchor":"#название-проекта-и-параметры"},{"value":"Список модулей","anchor":"#список-модулей"},{"value":"Информация о проекте","anchor":"#информация-о-проекте"},{"value":"Описание сборки проекта (плагины)","anchor":"#описание-сборки-проекта-плагины"},{"value":"Зависимости","anchor":"#зависимости"},{"value":"Именование директорий","anchor":"#именование-директорий"},{"value":"Жизненные циклы","anchor":"#жизненные-циклы"},{"value":"Сборка проекта. Команда mvn.","anchor":"#сборка-проекта-команда-mvn"},{"value":"Версии пакетов. Релизы и снепшоты","anchor":"#версии-пакетов-релизы-и-снепшоты"},{"value":"Конфликт зависимостей. Дерево зависимостей","anchor":"#конфликт-зависимостей-дерево-зависимостей"},{"value":"Исключение зависимостей","anchor":"#исключение-зависимостей"},{"value":"Плагины. Настройка билда","anchor":"#плагины-настройка-билда"},{"value":"Служебные файлы и каталоги","anchor":"#служебные-файлы-и-каталоги"},{"value":"Профили. Settings.xml","anchor":"#профилиsettingsxml"},{"value":"Центральные репозитории артефактов","anchor":"#центральные-репозитории-артефактов"},{"value":"Локальный репозиторий артефактов","anchor":"#локальный-репозиторий-артефактов"},{"value":"Архетипы","anchor":"#архетипы"},{"value":"TODO","anchor":"#todo"}]}},{"node":{"id":"bb6cb77e3f322d6d8584b894de59db2a","title":"Система сборки. Ant, Maven, Gradle","content":"\n## Что такое система сборки\n\nСистема сборки – это программное обеспечение, обеспечивающее автоматизацию сборки проекта. Конфигурационный файл для системы сборки описывается в текстовом виде. Как следствие, быстрее можно начать проект, за счет того, что что все типовые задачи заключаются в копировании уже готовых сниппетов. Это гораздо быстрее, более гибко, мобильно, и, главное, читаемо, чем вводить то же самое например, через UI диалоги IDE. Ну и в промышленных проектах это более удобно.\n\n\nИнструменты сборки могут делать\n- компиляцию кода - поддерживают определенный компилятор или несколько\n- запуск тестов и определение покрытия\n- статический анализ\n- сборка архивов с бинарными файлами, исходными кодами, документацией\n- построение отчетов\n- скачивание и обеспечение доступа нужных зависимостей\n\nПольза от инструмента сборки\n- Уменьшение числа рутинных ошибок\n- уменьшение времени сборки проекта\n- можно хранить историю сборок и анализировать ошибки\n- уменьшение затрат на разработку и улучшение качества\n\n## Нет автоматизации сборки\n\nИзначально, когда не было систем сборки, то было неудобно было работать с большим числом файлов, была платформозависимость, не поддерживалась условная логика. \n\n```java\n$ javac MyClass.java\n```\n\n## Shell скрипт\n\nС таким подходом можно большие проекты легко собирать можно использовать условную логику можно разделить сборку на стадии:\nclean.sh, compile.sh, test.sh\n\nНо все также такой способ остается платформозависимым и нет единого подхода к описанию сборки.\n```sh\nif test ! -e .nuget; then\n    mkdir .nuget\n    cp $cachedir/nuget.exe .nuget/nuget.exe\nfi\n```\n\n## Make (1977 год)\n\nТакая утилита появилась под Unix. Make использует специальный формат для описания билда и называется Make-file.\nТипичный Make-file содержит название стадий, зависимость стадий. Но основное содержание это такие же команды операционной системы. \nКоманды выполняются запуском make + название стадии: make install, make noopt и т.д.\n\n```sh\nnoopt:\n    $(MAKE) OPTIMIZATION=\"-O0\"\n\nvalgrind:\n    $(MAKE) OPTIMIZATION=\"-O0\" MALLOC=\"libc\"\n\nsrc/help.h:\n    @../utils/generate-command-help.rb > help.h\n\ninstall: all\n    @mkdir -p $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)\n    $(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)\n```\n\nПреимущества:\n- определяет единый формат сборки\n\nНедостатки:\n- платформозависимый так как внутри также находятся команды операционной системы\n- в makefile используется табуляция и она не видна в текстовых файлах если в такой файл вставить пробел то такой файл становится неправильным и make не может с ним работать\n- нет поддержки нюансов определенного языка: задач, параметров, плагинов)\nmake работает для любого языка\n\n## Apache Ant (2000 год)\n\nПервый инструмент сборки разработанный на java и для java. Имеет конфигурационный файл формата build.xml.\n\nСодержит описание названий стадий, зависимости стадий и могут содержать java - специфичные вещи. Например, как собирать java  код (javac), classpath и т.д.\n\n```java\n<target name=\"compile\" depends=\"init\" description=\"Compile the source\">\n    <javac srcdir=\"${src.main}\" destdir=\"${build.compile}\" classpathref=\"lib.path.id\" includeantruntime=\"true\"/>\n</target>\n\n<target name=\"test-compile\" depends=\"compile\" description=\"Compile tests source\">\n    <javac srcdir=\"${src.test}\" destdir=\"${build.test-compile}\" classpathref=\"lib.path.id\" includeantruntime=\"true\">\n        <classpath>\n            <pathelement location=\"${build.compile}\"/>\n        </classpath>\n    </javac>\n</target>\n```\n\nЗапускается командой:\n```\n$ ant clean compile\n```\n\nПреимущества:\n- поддержка java-специфичных задач\n- переносима между платформами\n- это первая сисетма которая позвоила писать под нее расширения плагины\n- позволяет запускать параметризованные билды\nможно хранить в отдельной секции некоторые параметры; например, версии используемых библиотек и потом замена версии будет означать просто замену библиотеки у вас в билде\n\nНедостатки:\n- нет конвенций версионирования кода\nможно версионировать продукт, как заблагорасудится\n- нет конвенций по расположению кода\nоткрыв проект на ant'e вы можете ожидать, что код будет где угодно;\nобычно их кладут в одну и туже папку, но это не гарантируется;\n- нет автоматического управления зависимостями (их кладут в lib/)\nесли у вас используется какая-нибудь библиотека, то она будет лежать прямо в проекте в папке lib в виде jar файлов, а в большом проекте таких файлов библиотек будет много\n- произвольный набор целей(нет жизненного цикла)\nцели можно называть как угодно и приходится разбираться какая цель что делает\n- императивный стиль описания билда\nбилд состоит из последовательности действий, которые нужно выполнить чтобы собрать проект\nэто плохо\n- ant не поддерживает junit 4\n\n## Apache Ivy (2004 год)\nЭта библиотека решает проблему Ant - авоматическое управление зависимостями. Конфигурационный файл имеет формат ivy.xml. Написан на Java.\n\n```xml\n<ivy-module version=\"1.0\">\n    <info organisation=\"ru.yandex.qatools.allure\" module=\"allure-testng-ant\"/>\n    <dependencies>\n        <dependency org=\"ru.yandex.qatools.allure\" name=\"allure-testng-adaptor\" rev=\"1.4.0\"/>\n        <dependency org=\"org.aspectj\" name=\"aspectjweaver\" rev=\"1.7.4\"/>\n    </dependencies>\n</ivy-module>\n```\n\nМожно в конфигурационном файле указать название зависимости: организация, имя, версия и все библиотеки скачаются с интернета.\n\n## Apache Maven (2004 год)\nИмеет конфигурационный файл pom.xml (Project Object Model). Написан на Java.\n\nЗапускается подобно Ant'у командой:\n```\n$ mvn clean compile\n```\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.0</version>\n    <configuration>\n        <source>${compiler.version}</source>\n        <target>${compiler.version}</target>\n    </configuration>\n</plugin>\n```\n\nПреимущества:\n- Конвенции по расположению кода, тестов, ресурсов\nмы точно знаем где и в какой директории лежат исходные коды, тесты и т.д.\n- четкий жизненый цикл: цели предопределены\nесть цель для компиляции тестирования отчетов а можно и свои цели создавать\n- имеет четкий способ чтобы поделиться кодом с другими - удаленные репозитории зависимостей\nэто сервера на который закачиваются готовые пакеты с скомпилированным кодом, с исходными кодами, документацией и другие участники разработки могут их оттуда забрать\n- понятный механизм хранения зависимостей - локальный репозиторий\nэто каталог у вас на файловой системе в который сохраняются копии скомпилированных бинарных файлов, документации и т.д. - копия удаленного репозитория\n- правила версионирования кода\nМавен вводит понятия релизов и snapshot'ов и как версии должны меняться одна от другой\n- поддерживает многомодульные проекты\nможно разбивать большой проект на небольшие кусочки/модули которые могут собираться по отдельности и распространяться, передаваться версионироваться по отдельности\n- описывает подход декларативно \nговорит не в какой последовательности мы должны выполнить шаги а то что мы хотим получить на выходе\n- модульная структура(поддержка плагинов)\nдаже простые действия делают плагины: есть плагин для компиляции, плагин для тестирования и т.д.\n\n## Gradle (2009 год)\nНаписан на Groovy. Использует в качестве файлов конфигурации файлы использующие DSL(Domain Specific Language) на Groovy. \nФайл называется build.gradle. Команда для запуска аналогична Ant, Maven:\n\n```\n$ gradle clean compile\n```\nВозможности Gradle:\n- поддерживает основные воможности Maven;\n- инкрементальная компиляция\nумеет собирать только те исходные коды которые изменились\n- использует теже удаленные репозитории как и мавен\n- эмулирует жизненный цикл мавена, но можно задавать и свои цели\n- поддерживает плагины, но они не совместимы с Maven \n","date":"2022-06-16T00:00:00.000Z","path":"/sistema-sborki-ant-maven-gradle/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Что такое система сборки","anchor":"#что-такое-система-сборки"},{"value":"Нет автоматизации сборки","anchor":"#нет-автоматизации-сборки"},{"value":"Shell скрипт","anchor":"#shell-скрипт"},{"value":"Make (1977 год)","anchor":"#make-1977-год"},{"value":"Apache Ant (2000 год)","anchor":"#apache-ant-2000-год"},{"value":"Apache Ivy (2004 год)","anchor":"#apache-ivy-2004-год"},{"value":"Apache Maven (2004 год)","anchor":"#apache-maven-2004-год"},{"value":"Gradle (2009 год)","anchor":"#gradle-2009-год"}]}},{"node":{"id":"03f6cb36de6e925d79edb18d08fda8fe","title":"JUnit 5","content":"\nМожно определять тестовые методы без модификатора.\n\n```java\n@Test\nvoid someTest(){\n    assertTrue(true);\n}\n```\n\n## Build tool support\n\n```groovy\ntest {\n    useJUnitPlatform {\n        includeTags 'fast', 'smoke'\n        excludeTags 'slow', 'ci'\n\n        include 'org/foo/**'\n        exclude 'org/boo/**'\n    }\n}\n```\n\nhttps://www.youtube.com/watch?v=RAOAcq97KZM\n\nhttps://www.youtube.com/watch?v=w1ey2zjf3-s\n\nhttps://www.youtube.com/watch?v=DAszLeWMsqU\n\nhttps://www.youtube.com/watch?v=751gMXH-lEE\n\nhttps://www.youtube.com/watch?v=r-8EGXMFJaw\n\nhttps://www.youtube.com/watch?v=ZIkIUCyJBGU\n\nhttps://www.youtube.com/watch?v=3pOjh6O7-cg\n\nhttps://www.youtube.com/watch?v=W1INR0I3FCo&list=PLnh8EajVFTl5AqvBosxUefReW4nC35P0x","date":"2022-06-18T00:00:00.000Z","path":"/j-unit-5/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Build tool support","anchor":"#build-tool-support"}]}},{"node":{"id":"48c283c207cbdefa8f04c2b2cfc15986","title":"JUnit vs TestNG","content":"\n## Добавление метаинформации\n\n### Обозначение тестового метода \n\n- TestNG\n\n```java\n@Test\npublic void regularTest(){\n\n}\n```\n\n- JUnit\n\n> Все импорты без \\*, потому что * в импортах, это не очень хорошо. \nНапример, при review человеку сложно понять, что именно пришло из заимпорченного класса.\n\nВ аннотацию Test не добавляется ничего, там нет дополнительных опций.\n\n```java\n@Test\npublic void regularTest(){\n\n}\n```\n\n### Добавление описания к тесту\n\n- TestNG\n\n```java\n@Test(description = \"Test description\")\npublic void displayNameTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@DisplayName(\"Test description\")\npublic void displayNameTest(){\n\n}\n```\n\n### Способ игнорировать тесты\n\n- TestNG\n\n```java\n@Test(enabled = false)\npublic void ignoredTest(){\n\n}\n```\n\n- JUnit\n\nБудет выброшен exception с указанным описанием. В описание также можно указать номер задачи на исправление.\n\n```java\n@Test\n@Disabled(\"Bad test!!! AE-1\")\npublic void ignoredTest(){\n\n}\n```\n\n### Запуск тестов по группам\n\n> в группу можно добавлять номер issue и тогда можно запускать проверку по задаче\n\n- TestNG\n\n```java\n@Test(groups = {\"web\", \"critical\"})\npublic void taggedTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@Tags({@Tag(\"web\"), @Tag(\"criticla\")})\npublic void taggedTest(){\n\n}\n```\n\n### Тест будет падать, если он идет дольше указанного времени\n\n- TestNG\n\n```java\n@Test(timeOut = 2)\npublic void timeoutTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@Test\n@Timeout(value = 2, unit = TimeUnit.MINUTES)\npublic void timeoutTest(){\n\n}\n```\n\n### Тест запускается несколько раз\n\n- создавать нагрузку :))\n- запуск теста с рандомными данными, при каждом запуске используются новые данные\n\n- TestNG\n\n```java\n@Test(invocationCount = 10)\npublic void repeatedTest(){\n\n}\n```\n\n- JUnit\n\n```java\n@RepeatedTest(10)\npublic void repeatedTest(){\n\n}\n```\n\n### Custom Annotations (JUnit)\n\nМожно создать свою аннотацию для которой задать поределенные параметры и этой аннотацией обозначать нужные тесты.\n\n> Можно изначально добавить свою аннотацию и использовать ее везде, тк в случае добаления каких то опции всем тестам достаточно будет добавить их только для одной кастомной аннотации.\n\n```java\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\npublic class AnnotationsCustomTest{\n\n    @FastTest\n    public void customTagTest(){\n    }\n    \n    @Test\n    @Tag((\"fast\"))\n    @Target({ElementType.TYPE, ElementType.METHOD})\n    @Retention(RetentionPolicy.RUNTIME)\n    public @interface FastTest{\n    }\n}\n```\n\n## Параметризованные тесты \n\n- TestNG\n\n```java\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\nimport org.testng.util.Strings;\n\nimport static org.testng.Assert.assertEquals;\n\npublic class ParamsTest {\n    @DataProvider(name = \"test1\")\n    public static Object[][] primeNumbers(){\n        return new Object[][]{\n            {null, true},\n            {\"\", true},\n            {\" \", true},\n            {\"not blank\", false} \n        };\n    }\n\n    @Test(dataProvider = \"test1\")\n    public void testBlankString(String input, boolean expected){\n        essertEquals(expected, Strings.isNullOrEmpty(input));\n    }\n}\n```\n\n- JUnit\n\nАналог TestNG\n\n```java\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.junit.platform.commons.util.StringUtils;\n\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ParamsTest {\n\n    private static Stream<Arguments> blankStringParameters() {\n        return Stream.of(\n                Arguments.of(null, true),\n                Arguments.of(\"\", true),\n                Arguments.of(\" \", true),\n                Arguments.of(\"not blank\", false)\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"blankStringParameters\")\n    void testBlankString(String input, boolean expected) {\n        assertEquals(expected, StringUtils.isBlank(input));\n    }\n}\n```\n\nи есть другой способ\n\n```java\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.junit.jupiter.params.provider.NullAndEmptySource;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport org.junit.platform.commons.util.StringUtils;\n\nimport java.time.Month;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ParamsTest {\n\n    @ParameterizedTest\n    @NullAndEmptySource\n    @ValueSource(strings = {\" \", \"\\t\", \"\\n\"})\n    void isBlank_ShouldReturnTrueForAllTypesOfBlankStrings(String input){\n        assertTrue(StringUtils.isBlank(input));\n    }\n\n    @ParameterizedTest\n    @EnumSource(value = Month.class,  names = {\"APRIL\", \"JUNE\", \"JULY\"})\n    void someMonths_Are30DaysLong(Month month) {\n        final boolean isALeapYear = false;\n        assertEquals(30, month.length(isALeapYear));\n    }\n    \n    @ParameterizedTest\n    @CsvSource({\"test,TEST\", \"tEst,TEST\", \"Java,JAVA\"})\n    void toUpperCase_ShouldGenerateTheExpectedUppercaseValue(String input, String expected){\n        String actualValue = input.toUpperCase();\n        assertEquals(expected, actualValue);\n    }\n}\n```\n\n## Параметризация через класс\n\n- TestNg\n\n```java\n@Test(dataProvider = \"user\",\n    dataProviderClass = UserDataProvider.class)\npublic void register(User user){\n    assert user.getName().equals(\"Ivan\"); \n}\n```\n\nЛибо через IAnnotationTransformer;\n\n- JUnit\n\n```java\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.ParameterContext;\nimport org.junit.jupiter.api.extension.ParameterResolver;\n\npublic class UserParameterResolver implements ParameterResolver {\n\n\n    @Override\n    public boolean supportsParameter(ParameterContext parameterContext, \n                                     ExtensionContext extensionContext) {\n        return parameterContext.getParameter().getType().equals(User.class);\n    }\n\n    @Override\n    public Object resolveParameter(ParameterContext parameterContext,\n                                   ExtensionContext extensionContext) {\n        return new User(\"Ivan\");\n    }\n}\n```\n\n```java\n\n@ExtendWith(UserParameterResolver.class)\nclass Parametrized{\n    \n    @Test\n    void canRegister(User user){\n        \n    }\n}\n```\n\n## Проверка exception\n\nПроверить, что тест выбрасывает Exception(негативный сценарий);\n\n- TestNG\n\n```java\n@Test(expectedEceptions = ArithmeticException.class)\npublic void divisionWithException(){\n    int i = 1/0;\n}\n```\n\n- JUnit\n\nМетод assertThrows кроме проверки также возвращает сам exception и можно далее с ним делать какие нибудь другие проверки.\n\n```java\n@Test\nvoid exceptionTest(){\n    final Object nullable = null;\n    final NullPointerException exeption =  assertThrows(\n                NullPointerException.class,\n                () -> nullable.toString(),\n                \"Expected toString() to throw, but it didn't\");\n}\n```\n\n## Before/After методы\n\n- TestNG\n\nИмеются аннотации: BeforeSuite, BeforeClass, BeforeTest, BeforeGroup, BeforeMethod, AfterClass, AfterTest, afterGroup, AfterMethod, AfterSuite.\n\n- JUnit \n\nАннотации: BeforeAll, BeforeEach, AfterEach, AfterAll.\n\n## Зависимые тесты и порядок запуска тестов\n\ndependsOnGroups - зависимость от прохождения тестов определенной группы, \ndependsOnMethod - зависимость от определенного тестового метода\n\n```java\n@Test(dependsOnGroups = \"ololo\")\npublic void firstTest(){\n\n}\n\n@Test(dependsOnMethod = \"firstTest\")\npublic void secondTest(){\n\n}\n```\n\n- JUnit\n\nЗапрещает делать зависимые тесты.\n\nМожно задавать порядок тестов:\n\n```java\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class OrderedTest {\n    \n    @Test\n    @Order(1)\n    void firstTest(){}\n    \n    @Test\n    @Order(2)\n    void secondTest(){}\n}\n```\n\nМожно указываеть зависимость от определенных параметров:\n\n```java\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\nimport org.junit.jupiter.api.condition.*;\n\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\npublic class ConditionalTest {\n\n    @Test\n    @EnabledOnOs(OS.MAC)\n    void onlyOnMacOS(){}\n\n    @Test\n    @EnabledForJreRange(min = JRE.JAVA_9)\n    void fromJava9toCurrentJavaFeatureNumber(){}\n    \n    @Test\n    @EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\")\n    void onlyOn64BitArchitectures(){}\n}\n```\n\n## Слушатели (Listeners)\n\n- TestNG\n\nМожно создать свой класс Listener который имплементит заданные интерфейсы, например, ISuiteListener\nи задавать выполнение определенной логика до, после теста и т.д. не используя специальные аннотации.\n\n- JUnit\n\nИспользуются Extensions. Все Extensions имплементируют класс Extension можно в него перейти и посмотреть все что его имплементит, чтобы найти нужный.\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\npublic class ExtensionsTest {\n\n    @Test\n    @ExtendWith(ResourceExtension.class)\n    public void extensionTest(){\n        \n    }\n    \n    public static class ResourceExtension implements BeforeEachCallback, AfterEachCallback{\n        @Override\n        public void beforeEach(ExtensionContext context) throws Exception{\n            System.out.println(\"Starting database...\");\n        }\n        \n        @Override\n        public void afterEach(ExtensionContext context) throws Exception{\n            System.out.println(\"Stopping database...\");\n        }\n    }\n}\n```\n\n## Параллельные тесты\n\n- TestNG\n\nМожно задать в xml параметр parallel = \"methods|tests|classes|instances\" и thread-count=\"5\". \n\n- JUnit \n\nМожно воспользоваться опцией Gradle. Можно распараллелить тесты по агентам. ???\n\n## Soft Assertions\n\n- TestNG\n\n```java\nprivate SoftAssert softAssert = new SoftAssert();\n\n@Test\npublic void testForSoftAssertionsFailure(){\n    softAssert.assertTrue(false);\n    softAssert.assertEquals(1, 2);\n    softAssert.assertAll();\n}\n```\n\n- JUnit\n\nИспользуется метод assertAll;\n\n```java\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SoftAssertionsTest {\n    \n    @Test\n    void testWithSoftAssert(){\n        assertAll(\n                () -> assertTrue(false),\n                () -> assertEquals(1, 2)\n        );\n    }\n}\n```\n\n## Источник информации \n\n❗ [#6 Recheck, Karate, JetBrains Academy. Сравнение TestNG и JUnit 5](https://www.youtube.com/watch?v=_sN6JpVpQ-c)\n\n❗ [TestNG vs JUnit 5 battle (Sergey Pirogov, Ukraine)](https://www.youtube.com/watch?v=vRmVZV0fjK8)","date":"2022-06-18T00:00:00.000Z","path":"/j-unit-vs-test-ng/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Добавление метаинформации","anchor":"#добавление-метаинформации"},{"value":"Параметризованные тесты","anchor":"#параметризованные-тесты"},{"value":"Параметризация через класс","anchor":"#параметризация-через-класс"},{"value":"Проверка exception","anchor":"#проверка-exception"},{"value":"Before/After методы","anchor":"#beforeafter-методы"},{"value":"Зависимые тесты и порядок запуска тестов","anchor":"#зависимые-тесты-и-порядок-запуска-тестов"},{"value":"Слушатели (Listeners)","anchor":"#слушатели-listeners"},{"value":"Параллельные тесты","anchor":"#параллельные-тесты"},{"value":"Soft Assertions","anchor":"#soft-assertions"},{"value":"Источник информации","anchor":"#источник-информации"}]}},{"node":{"id":"112370fc90d39fe48075453d187821e5","title":"Selenium API","content":"\n## Подключение зависимости\n\n```\n// https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java\nimplementation 'org.seleniumhq.selenium:selenium-java:4.2.2'\n```\n\n## Загрузка драйвера через WebDriverManager\n\n1. Нужно импортировать библиотеку\n\n```\nimplementation 'io.github.bonigarcia:webdrivermanager:5.2.0'\n```\n\n2. Перед запуском теста вызвать \n\n- для Chrome\n\n```\nWebDriverManager.chromedriver().setup();\n```\n\n## Открыть и закрыть браузер\n\n- Chrome\n```java\nChromeOptions options = new ChromeOptions();\ndriver = new ChromeDriver(options);\n\ndriver.quit();\n```\n\n- Microsoft Edge\n```java\nEdgeOptions options = new EdgeOptions();\ndriver = new EdgeDriver(options);\n\ndriver.quit();\n```\n\n- Firefox\n```java\nFirefoxOptions options = new FirefoxOptions();\ndriver = new FirefoxDriver(options);\n\ndriver.quit();\n```\n\n- Internet Explorer\n\nРекомендуется использовать 32-bit версию драйвера.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\ndriver = new InternetExplorerDriver(options);\n\ndriver.quit();\n```\n\nMicrosoft Edge можно использовать в режиме совместимости с IE с помощью драйвера IE.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.attachToEdgeChrome();\noptions.withEdgeExecutablePath(\"/path/to/edge/browser\");\n  \ndriver = new InternetExplorerDriver(options);\n  \ndriver.quit();\n```\n\n- Opera\n\nПоскольку драйвер Opera не поддерживает синтаксис w3c, а основан на Chromium, рекомендуется управлять браузером Opera с помощью chromedriver.\n\n```java\nChromeOptions options = new ChromeOptions();\noptions.setBinary(\"/path/to/opera/browser\");\n  \ndriver = new ChromeDriver(options);\n  \ndriver.quit();\n```\n\n- Safari\n\nЧтобы включить автоматизацию в Safari, выполните следующую команду из терминала:\n\n```\nsafaridriver --enable\n```\n\n```java\nSafariOptions options = new SafariOptions();\ndriver = new SafariDriver(options);\n  \ndriver.quit();\n```\n\n## Начало работы\n\n### Старт сессии\n```java\ndriver = new ChromeDriver();\n```\n\n### Переход на страницу\n```java\ndriver.get(\"https://google.com\");\n```\n\n### Получить заголовок страницы\n```java\nString title = driver.getTitle();\n```\n\n### Ожидания \n```java\ndriver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));\n```\n\n### Поиск элементов \n```java\nWebElement searchBox = driver.findElement(By.name(\"q\"));\nWebElement searchButton = driver.findElement(By.name(\"btnK\"));\n```\n\n### Действия на странице\n```java\nsearchBox.sendKeys(\"Selenium\");\nsearchButton.click();\n```\n\n### Запрос информации об элементе\n```java\nString value = searchBox.getAttribute(\"value\");\n```\n\n## Capabilities\n\n#### browserName\nЗадает имя браузера который нужно запустить\n#### browserVersion\nЗадает версию браузера. Можно не указывать.\n#### pageLoadStrategy\nПри переходе на новую страницу через URL, по умолчанию Selenium ждет пока страница будет загружена, выполняется проверка через js: `document.readyStatus` должен равняться `complete`. Однако для некоторых случаев, например для одностраничных сайтов, не имеет смысла ждать пока загрузится вся страница, так как элементы подгружаются динамически. В этом случае можно изменить этот параметр.\n\n> при изменении pageLoadStrategy обратите внимание, что стратегия ожидания (implicit/explicit wait) настроена, чтобы компенсировать нестабильность прогонов;\n\nМожет иметь одно из 3 значений: normal, eager, none;\n\n|Strategy|Ready State|Note|\n|---|---|---|\n|normal|complete|Используется по умолчанию; ждет пока все ресурсы страницы будут загружены|\n|eager|interactive|Доступ к DOM загрузился, но остальные ресурсы например картинки могут еще подгружаться|\n|none| Any| Не делает проверку загрузки ресурсов страницы|\n\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);\nWebDriver driver = new ChromeDriver(chromeOptions);\n```\n\n#### platformName\nЗадает имя операционной системы необходимой для запуска\n\n#### acceptInsecureCerts\nВыполняется проверка сертификата безопасности сайта(TLS Certificate);\n\nесли выбрано `false` - то при наличии на сайте просроченного или невалидного сертификата будет выбрасываться исключение;  \nесли выбрано `true` - все сертификаты даже небезопасные будут считаться валидными\n\nПосле установки опции acceptInsecureCerts будет работать для все сессии.\n\n#### timeouts\nSelenium устанавливает определенные интервалы в течение которого пользователь может взаимодействовать с сайтом;\n\n- script timeout  \nТаймаут выполнения скриптов в текущем контексте. По умолчанию 30_000\n- Page Load Timeout  \nТаймаут загрузки страницы. По умолчанию 300_000. При превышении выбрасывает TimeoutException\n- Implicit Wait Timeout  \nвремя ожидания загрузки элемента страницы. По умолчанию 0.\n\n#### unhandledPromptBehavior\nЗадает поведение когда открывается диалоговое окно системы\nМожет иметь следущие значения:\n- dismiss\n- accept\n- dismiss and notify\n- accept and notify\n- ignore\n\nПо умолчанию dismiss and notify.\n\n#### strictFileInteractability\nЭта опция указывает должна ли применяться строгая проверка видимости поля input с атрибутом type=\"file\". Так как строгая проверка по умолчанию отключена, это может влиять на работу метода element.sendKeys при работе со скрытым элементом управления.\n\n#### proxy\nПрокси-сервер - это посредник для запросов между клиентом и сервером.\nТрафик проходит через прокси-сервер на пути к запрошенному адресу и обратно.\n\n```java\nProxy proxy = new Proxy();\nproxy.setHttpProxy(\"<HOST:PORT>\");\nChromeOptions options = new ChromeOptions();\noptions.setCapability(\"proxy\", proxy);\nWebDriver driver = new ChromeDriver(options);\n```\n\n### Firefox\n \nМожно установить кастомный профиль с нужными настройками\n\n```java\nFirefoxProfile profile = new FirefoxProfile();\nFirefoxOptions options = new FirefoxOptions();\noptions.setProfile(profile);\ndriver = new RemoteWebDriver(options);\n```\n\n### Internet Explorer\n\n#### fileUploadDialogTimeout\nВ некоторых окружениях Internet Explorer может с задержкой открывать окно Загрузка Файла. IEDriver по умолчанию устанавливает timeout ожидания этого окна в 1_000мс, но с помощью опции fileUploadDialogTimeout это время можно увеличить\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.waitForUploadDialogUpTo(Duration.ofSeconds(2));\nWebDriver driver = new RemoteWebDriver(options);\n```\n#### ensureCleanSession\nЕсли установлено в true - то кеш, история браузера и файлы cookie будут очищены для всех экземпляров Internet Explorer(в том числе запущенных вручную). По умолчанию false. При использовании этой опции при запуске браузера, дайвер будет ждать очистки кеша.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.destructivelyEnsureCleanSession();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreZoomSetting\nДрайвер InternetExplorer ожидает, что уровень масштабирования браузера будет равен 100%, иначе драйвер выдаст исключение. Это поведение по умолчанию можно отключить, установив для ignoreZoomSetting значение true.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.ignoreZoomSettings();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreProtectedModeSettings\nЕсли Protected Mode не включен и настройки защищенного режима не одинаковы для всех зон, драйвером будет выдано исключение. \n\nЕсли установлено значение true, драйвер будет игнорировать эту настройку, но тесты могут работать нестабильно, переставать отвечать или браузеры могут зависать. \n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.introduceFlakinessByIgnoringSecurityDomains();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### silent\nЕсли установлено значение true, эта опция игнорирует диагностические выходные данные IEDriverServer.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.setCapability(\"silent\", true);\nWebDriver driver = new InternetExplorerDriver(options);\n```\n\n#### Command-Line Options\nInternet Explorer включает несколько параметров командной строки, которые позволяют устранять неполадки и настраивать браузер. \n\nНиже описаны несколько поддерживаемых параметров командной строки.\n- -private: используется для запуска IE в режиме приватного просмотра. Это работает для IE 8 и более поздних версий. \n- -k : запускает Internet Explorer в режиме киоска. Браузер открывается в развернутом окне, в котором нет адресной строки, кнопок навигации или строки состояния. \n- -extoff : Запускает IE в режиме без дополнений. Этот параметр специально используется для устранения неполадок с надстройками браузера. Работает в IE 7 и более поздних версиях. \n\n> ForceCreateProcessApi должен быть включен для того, чтобы аргументы командной строки работали.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        options.addCommandSwitches(\"-k\");\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n```\n\n#### forceCreateProcessApi\nПринудительно запускает Internet Explorer с помощью API CreateProcess. Значение по умолчанию false. Для IE 8 и более поздних версий этот параметр требует, чтобы для параметра реестра \"TabProcGrowth\" было установлено значение 0.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n``` \n## Работа с браузером\n\n### Получение заголовка\n```java\ndriver.getTitle();\n```\n\n### Получение текущего URL\n\n```java\ndriver.getCurrentUrl();\n```\n\n### Навигация\n\n#### Переход на страницу\n```java\n//Convenient\ndriver.get(\"https://selenium.dev\");\n\n//Longer way\ndriver.navigate().to(\"https://selenium.dev\");\n```\n\n#### Возврат назад\n```java\ndriver.navigate().back();\n```\n\n#### Переход вперед\n```java\ndriver.navigate().forward();\n```\n\n#### Обновить страницу\n```java\ndriver.navigate().refresh();\n```\n\n### JavaScript окна\n#### Ожидание всплавающего окна браузера\n```java\nAlert alert = wait.until(ExpectedConditions.alertIsPresent());\n```\n\n#### Получить текст из всплывающего окна\n```java\nString text = alert.getText();\n```\n\n#### Нажать OK кнопку\n```java\nalert.accept();\n```\n\n#### Отклонить всплывающее окно\n```java\nalert.dismiss();\n```\n\n#### Ввести текст в всплывающем окне\n```java\nalert.sendKeys(\"Selenium\");\n```\n\n### Работа с Cookie\n\n#### Добавить Cookie\nПрежде чем выставлять куки нужно перейти на страницу сайта для которого нужно применить куки. Еслистраница долго грузится можно перейти на какую нибудь легковесную, например, страница с ошибкой 404.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class addCookie {\n    public static void main(String[] args) {\n        WebDriver driver = new ChromeDriver();\n        try {\n            driver.get(\"http://www.example.com\");\n\n            // Adds the cookie into current browser context\n            driver.manage().addCookie(new Cookie(\"key\", \"value\"));\n        } finally {\n            driver.quit();\n        }\n    }\n}\n  \n```\n#### Проверка что Cookie \n#### Получить имя Cookie\n\n#### Получить все Cookie\n\n#### Удалить Cookie\n\n#### Удалить все Cookie\n\n#### Проверка что Cookie отправляются с одного сайта\nПредназначенно для предотвращения подделки межсайтовых запросов (CSRF).\n\n- При установке значения Lax подразумевается, что куки должны отправляться при серфинге по одному сайту или через GET серфинг на ваш сайт с других сайтов. \n- Значение Strict ограничивало cookie запросами, исходящими только от одного сайта.\n\n> Работает только для Chrome(версия 80+) и Firefox(версия 79+) в Selenium 4 и более поздних.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class cookieTest {\n  public static void main(String[] args) {\n    WebDriver driver = new ChromeDriver();\n    try {\n      driver.get(\"http://www.example.com\");\n      Cookie cookie = new Cookie.Builder(\"key\", \"value\").sameSite(\"Strict\").build();\n      Cookie cookie1 = new Cookie.Builder(\"key\", \"value\").sameSite(\"Lax\").build();\n      driver.manage().addCookie(cookie);\n      driver.manage().addCookie(cookie1);\n      System.out.println(cookie.getSameSite());\n      System.out.println(cookie1.getSameSite());\n    } finally {\n      driver.quit();\n    }\n  }\n}\n```\n\n### Работа с iFrame\n\nФреймы — это устаревшее средство создания макета сайта из нескольких документов в одном домене. Вы вряд ли будете работать с ними, если вы не работаете с веб-приложением до HTML5. \n\nФреймы iframe позволяют вставлять документ из совершенно другого домена и до сих пор широко используются. \n\n#### Переключение на фрейм через WebElement\n```java\nWebElement iframe = driver.findElement(By.cssSelector(\"#modal>iframe\"));\n//Switch to the frame\ndriver.switchTo().frame(iframe);\n```\n#### Переключение на фрейм через имя или id\n```java\n//Using the ID\ndriver.switchTo().frame(\"buttonframe\");\n\n//Or using the name instead\ndriver.switchTo().frame(\"myframe\");\n```\n\n#### Переключение на фрейм через index\n```java\n// Switches to the second frame\ndriver.switchTo().frame(1);\n```\n\n#### Возврат на основную страницу\n```java\n// Return to the top level\ndriver.switchTo().defaultContent();\n```\n\n### Работа с окнами и вкладками\n\n#### Получить обработчик текущего окна\n```java\ndriver.getWindowHandle();\n```\n\n#### Переключиться на новое окно или вкладку\n```java\nString originalWindow = driver.getWindowHandle();\n\n//Check we don't have other windows open already\nassert driver.getWindowHandles().size() == 1;\n\n//Click the link which opens in a new window\ndriver.findElement(By.linkText(\"new window\")).click();\n\n//Wait for the new window or tab\nwait.until(numberOfWindowsToBe(2));\n\n//Loop through until we find a new window handle\nfor (String windowHandle : driver.getWindowHandles()) {\n    if(!originalWindow.contentEquals(windowHandle)) {\n        driver.switchTo().window(windowHandle);\n        break;\n    }\n}\n\n//Wait for the new tab to finish loading content\nwait.until(titleIs(\"Selenium documentation\"));\n```\n\n#### Создать(открыть) новое окно или вкладку и переключиться на нее(Selenium 4)\n```java\n// Opens a new tab and switches to new tab\ndriver.switchTo().newWindow(WindowType.TAB);\n\n// Opens a new window and switches to new window\ndriver.switchTo().newWindow(WindowType.WINDOW);\n```\n\n#### Закрыть окно или вкладку\n```java\n//Close the tab or window\ndriver.close();\n\n//Switch back to the old tab or window\ndriver.switchTo().window(originalWindow);\n```\n\n#### Закрыть браузер и закончить сессию\n```java\ndriver.quit();\n```\n\n#### Управление окном\n\n##### Получить размер окна\nВыдает размер в пикселях\n\n```java\n//Access each dimension individually\nint width = driver.manage().window().getSize().getWidth();\nint height = driver.manage().window().getSize().getHeight();\n\n//Or store the dimensions and query them later\nDimension size = driver.manage().window().getSize();\nint width1 = size.getWidth();\nint height1 = size.getHeight();\n```\n\n##### Установить размер окна\n```java\ndriver.manage().window().setSize(new Dimension(1024, 768));\n```\n\n##### Получить положение окна\n```java\n// Access each dimension individually\nint x = driver.manage().window().getPosition().getX();\nint y = driver.manage().window().getPosition().getY();\n\n// Or store the dimensions and query them later\nPoint position = driver.manage().window().getPosition();\nint x1 = position.getX();\nint y1 = position.getY();\n```\n\n#### Переместить окно\n```java\n// Move the window to the top left of the primary monitor\ndriver.manage().window().setPosition(new Point(0, 0));\n```\n\n##### Увеличить окно на максимум\n```java\ndriver.manage().window().maximize();\n```\n\n##### Свернуть окно(Selenium 4)\n```java\ndriver.manage().window().minimize();\n```\n\n##### Развернуть окно на полный экран\n```java\ndriver.manage().window().fullscreen();\n```\n\n##### Сделать скриншот\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.*;\nimport org.openqa.selenium.*;\n\npublic class SeleniumTakeScreenshot {\n    public static void main(String args[]) throws IOException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(\"http://www.example.com\");\n        File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);\n        FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n        driver.quit();\n    }\n}\n```\n\n##### Сделать скриншот элемента\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class SeleniumelementTakeScreenshot {\n  public static void main(String args[]) throws IOException {\n    WebDriver driver = new ChromeDriver();\n    driver.get(\"https://www.example.com\");\n    WebElement element = driver.findElement(By.cssSelector(\"h1\"));\n    File scrFile = element.getScreenshotAs(OutputType.FILE);\n    FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n    driver.quit();\n  }\n}\n```\n\n##### Выполнить скрипт\n```java\n    //Creating the JavascriptExecutor interface object by Type casting\n      JavascriptExecutor js = (JavascriptExecutor)driver;\n    //Button Element\n      WebElement button =driver.findElement(By.name(\"btnLogin\"));\n    //Executing JavaScript to click on element\n      js.executeScript(\"arguments[0].click();\", button);\n    //Get return value from script\n      String text = (String) js.executeScript(\"return arguments[0].innerText\", button);\n    //Executing JavaScript directly\n      js.executeScript(\"console.log('hello world')\");\n```\n\n##### Напечатать страницу\n> Необходимо чтобы Chromium браузер был в режиме headless\n```java\n    import org.openqa.selenium.print.PrintOptions;\n\n    driver.get(\"https://www.selenium.dev\");\n    printer = (PrintsPage) driver;\n\n    PrintOptions printOptions = new PrintOptions();\n    printOptions.setPageRanges(\"1-2\");\n\n    Pdf pdf = printer.print(printOptions);\n    String content = pdf.getContent();\n```\n\n## Элементы\n\n### Локаторы\n\n#### Относительные локаторы (Selenium 4)\n\n##### Above\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).above(By.id(\"password\"));\n```\n\n##### Below\n```java\nBy passwordLocator = RelativeLocator.with(By.tagName(\"input\")).below(By.id(\"email\"));\n```\n\n##### Left of\n```java\nBy cancelLocator = RelativeLocator.with(By.tagName(\"button\")).toLeftOf(By.id(\"submit\"));\n```\n\n##### Right of\n```java\nBy submitLocator = RelativeLocator.with(By.tagName(\"button\")).toRightOf(By.id(\"cancel\"));\n```\n\n##### Near\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).near(By.id(\"lbl-email\"));\n```\n\n### Поиск элементов\n```java\nWebElement vegetable = driver.findElement(By.className(\"tomatoes\"));\n```\n\n#### Поиск дочернего элемента \n```java\n// не оптимальный способ\nWebElement fruits = driver.findElement(By.id(\"fruits\"));\nWebElement fruit = fruits.findElement(By.id(\"tomatoes\"));\n\n// так лучше\nWebElement fruit = driver.findElement(By.cssSelector(\"#fruits .tomatoes\"));\n```\n\n#### Поиск нескольких элементов\n```java\nList<WebElement> plants = driver.findElements(By.tagName(\"li\"));\n```\n\n#### Получить активный элемент\nАктивный элемент - на котором фокус.\n```java\ndriver.switchTo().activeElement()\n```\n\n### Взаимодействие с элеентами\n\n#### Клик - Click\n```java\ndriver.findElement(By.name(\"button\")).click();\n```\n\n#### Ввод символов - Send Keys\n```java\ndriver.findElement(By.name(\"q\")).sendKeys(\"q\" + Keys.ENTER);\n```\n\n#### Очистить поле - Clear\n```java\nWebElement searchInput = driver.findElement(By.name(\"q\"));\nsearchInput.sendKeys(\"selenium\");\n// Clears the entered text\nsearchInput.clear();\n```\n\n### Информация об элементе\n\n#### Видимость\n```java\nboolean isButtonVisible = driver.findElement(By.css(\"[name='login']\")).isDisplayed();\n```\n\n#### Доступность\n```java\nboolean value = driver.findElement(By.name(\"btnK\")).isEnabled();\n```\n\n#### Выбран ли\n```java\nboolean value = driver.findElement(By.cssSelector(\"input[type='checkbox']:first-of-type\")).isSelected();\n```\n\n#### Имя тега\n```java\nString value = driver.findElement(By.cssSelector(\"h1\")).getTagName();\n```\n\n#### Размер и положение\n```java\nRectangle res =  driver.findElement(By.cssSelector(\"h1\")).getRect();\n\n// Rectangle class provides getX,getY, getWidth, getHeight methods\nSystem.out.println(res.getX());\n```\n\n#### Получить CSS свойство\n```java\nString cssValue = driver.findElement(By.linkText(\"More information...\")).getCssValue(\"color\");\n```\n\n#### Получить текст элемента\n```java\nString text = driver.findElement(By.cssSelector(\"h1\")).getText();\n```\n\n### Работа с выпадающим списком\n\n#### Определить элемент выпадающего списка \n```java\nimport org.openqa.selenium.support.ui.Select;\n\nWebElement selectElement = driver.findElement(By.id(\"selectElementID\"));\nSelect selectObject = new Select(selectElement);\n```\n\n#### Выбрать опцию\n- по индексу\n```java\n// Select an <option> based upon the <select> element's internal index\nselectObject.selectByIndex(1);\n```\n\n- по значению\n```java\n// Select an <option> based upon its value attribute\nselectObject.selectByValue(\"value1\");\n```\n  \n- по видимому тексту\n```java\n// Select an <option> based upon its text\nselectObject.selectByVisibleText(\"Bread\");\n```\n\n#### Получить все выбранные опции\n```java\n// Return a List<WebElement> of options that have been selected\nList<WebElement> allSelectedOptions = selectObject.getAllSelectedOptions();\n```\n#### Получить первую выбранную опцию\n```java\n\n// Return a WebElement referencing the first selection option found by walking down the DOM\nWebElement firstSelectedOption = selectObject.getFirstSelectedOption();\n```\n\n#### Получить все опции\n```java\n// Return a List<WebElement> of options that the <select> element contains\nList<WebElement> allAvailableOptions = selectObject.getOptions();\n```\n\n#### Отменить выбор \n- по индексу\n```java\n// Deselect an <option> based upon the <select> element's internal index\nselectObject.deselectByIndex(1);\n```\n\n- по значению\n```java\n// Deselect an <option> based upon its value attribute\nselectObject.deselectByValue(\"value1\");\n```\n\n- по видимому тексту\n```java\n// Deselect an <option> based upon its text\nselectObject.deselectByVisibleText(\"Bread\");\n```\n\n- отменить все\n```java\n// Deselect all selected <option> elements\nselectObject.deselectAll();\n```\n\n#### Поддерживает ли список множественный выбор\n```java\nBoolean doesThisAllowMultipleSelections = selectObject.isMultiple();\n```\n\n## Удаленный браузер\n\n```java\nFirefoxOptions firefoxOptions = new FirefoxOptions();\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), firefoxOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Добавление опций\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setCapability(\"browserVersion\", \"67\");\nchromeOptions.setCapability(\"platformName\", \"Windows XP\");\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), chromeOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Local file detector\nПозволяет загружать файл с клиентской машины на удаленную.\nНужно для загрузки файлов на сайт.\n\n```java\ndriver.setFileDetector(new LocalFileDetector());\n\ndriver.get(\"http://sso.dev.saucelabs.com/test/guinea-file-upload\");\nWebElement upload = driver.findElement(By.id(\"myfile\"));\nupload.sendKeys(\"/Users/sso/the/local/path/to/darkbulb.jpg\");\n  \n```\n\n### ","date":"2022-06-20T00:00:00.000Z","path":"/selenium-api/","icon":"fas fa-robot","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Подключение зависимости","anchor":"#подключение-зависимости"},{"value":"Загрузка драйвера через WebDriverManager","anchor":"#загрузка-драйвера-через-webdrivermanager"},{"value":"Открыть и закрыть браузер","anchor":"#открыть-и-закрыть-браузер"},{"value":"Начало работы","anchor":"#начало-работы"},{"value":"Capabilities","anchor":"#capabilities"},{"value":"Работа с браузером","anchor":"#работа-с-браузером"},{"value":"Удаленный браузер","anchor":"#удаленный-браузер"}]}}]}},"relatedTag":null},"context":{}}