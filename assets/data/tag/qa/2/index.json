{"hash":"02799b688b4cb7ace869e49ff69fbf95eb6f42e6","data":{"tag":{"title":"qa","path":"/tag/qa/","belongsTo":{"totalCount":39,"pageInfo":{"totalPages":4,"currentPage":2},"edges":[{"node":{"id":"a43913d00e0ffd7929efafa9f7fbfb3f","title":"UI/UX и Pixel Perfect","content":"\nhttps://bugza.info/testirovanie-ui-i-verstki/\n\n## UI тестирование\n\nUI (user interface — пользовательский интерфейс) — является точкой взаимодействия человека и продукта. Дизайн кнопок, полей ввода и т.д. — это место, где пользователь взаимодействует с системой. Таким образом, Вы можете сравнить UI с рулем, педалями и приборной панелью автомобиля. Они используются для управления автомобилем так же, как приложение использует UI (пользовательский интерфейс) для управления системой. Короче говоря, дизайн пользовательского интерфейса (UI) — это дизайн точек взаимодействия, через которые пользователь может взаимодействовать с системой.\n\nТестирование интерфейса пользователя осуществляется вместе со следующими видами тестирования (UI):\n- Тестирование на соответствие стандартам графических интерфейсов.\n- Тестирование с различными разрешениями экрана.\n- Тестирование кроссбраузерности или совместимости с разными интернет браузерами и их версиями.\n- Тестирование локализованных версий: точность перевода (мультиязычность, мультивалютность), проверка длины названий элементов интерфейса и т.д..\n- Тестирование графического интерфейса пользователя на целевых устройствах (смартфоны, кпп, планшеты).\n\n### Основные элементы графического интерфейса:\n- Окно (окно браузера, диалоговое окно, модальное окно, плавающее окно).\n- Меню (главное, всплывающее, контекстное, системное).\n- Виджеты/элементы управления/контролы (аккордеон, кнопка, радио-кнопка, чек-бокс, значок (иконка), список, панель инструментов, дерево, полоса прокрутки, ползунок, строка состояния, тултип (подсказка) и др.).\n- Вкладка.\n\nЭлементы взаимодействия: курсор мыши, текстовый курсор, поинтер (“ладошка”), курсор перетаскивания и др.\n\n### Основные проверки при тестировании UI:\n- Расположение, размер, цвет, ширина, длина элементов; возможность ввода букв или цифр.\n- Реализуется ли функционал приложения с помощью графических элементов.\n- размещение всех сообщений об ошибках, уведомленией (а также шрифт, цвет, размер, расположение и орфография текста).\n- Читабелен ли использованный шрифт.\n- Переходит ли курсор из текстового в поинтер при наведении на активные элементы, выделяются ли выбранные элементы.\n- Выравнивание текста и форм.\n- Качество изображений.\n- Проверить расположение и отображение всех элементов при различных разрешениях экрана, а также при изменении размера окна браузера (проверить, появляется ли скролл).\n- Проверить текст на орфографические, пунктуационные ошибки.\n- Появляются ли тултипы (если есть необходимость).\n- Унификация дизайна (цвета, шрифты, текст сообщений, названия кнопок и т.д.).\n\n## Тестирование Pixel Perfect \nПроверка точного (пиксель в пикcель) соответствия сверстанного HTML-шаблона оригиналу (PSD-макету). Другими словами, если наложить “картинку” сверстанного HTML-шаблона на картинку оригинального PSD-макета, то обе картинки должны совпадать. Совместиться должны все элементы картинок: текст, изображения, графические элементы.\n\n## UX тестирование\n\nПри проектировке качественного UI уделяется внимание не только внешнему виду интерфейса, но и его логической структуре, чтобы пользователь мог без лишних усилий, быстро и легко взаимодействовать с ним и добиваться необходимого результата. Но, чтобы четко понимать, как создать качественный пользовательский интерфейс для конкретного продукта, необходимо изучать поведение, эмоции и реакцию пользователей при взаимодействии с данным продуктом, проводить тестирование, собирать данные. Человек, взаимодействуя с какой-либо системой, испытывает ощущения и реагирует определенным образом в процессе ее использования. Это называется опытом взаимодействия, или UX.\n\nUser Experience (пользовательский опыт)— ощущение, испытываемое пользователем во время использования цифрового продукта, в то время как User interface — это инструмент, позволяющий осуществлять интеракцию «пользователь — веб-ресурс». UX — это то, что чувствует и запоминает пользователь в результате использования программы, приложения или сайта. UX учитывается при разработке UI, создании информационной архитектуры, юзабилити тестировании. Определив целевую аудиторию и характеристики основного пользователя можно составить список требований к проекту.\n\nДля простоты усвоения разницы между 2 этими понятиями рассмотрим наглядный пример: предположим, мы едим сэндвич с сыром. Ощущения, получаемые во время поедания сэндвича, это и есть пользовательский опыт. Ингредиенты, составляющие наш воображаемый бутерброд (хлеб, майонез, сыр, сливочное масло и т. д.), могут считаться частью пользовательского интерфейса.\n\nОщущение, что мы получаем, когда едим бутерброд, можно считать UX, а ингредиенты сэндвича ассоциируются с UI\n\nСэндвич, сделанный из белого хлеба и сыра и майонеза с высоким содержанием жиров, на вкус почти также хорош, как бутерброд, состоящий из цельнозернового хлеба, низкокалорийного майонеза и нежирного сыра. Однако люди, стремящиеся к здоровому образу жизни, отвергнут первый сэндвич в пользу второго.\n\nИтак, у нас есть хороший интерфейс в обоих случаях, но мы не провели пользовательское исследование (а это неотъемлемая часть UX), мы не знаем соотношения пользователей, которые будут/не будут использовать наш продукт, в результате чего мы теряем весомую часть целевой аудитории.\n\nПроцесс проектирования UX включает в себя исследование поведенческих паттернов и психологических реакций пользователей, разработку информационной архитектуры, дизайн взаимодействия (interaction design), дизайн пользовательского интерфейса, интерактивное прототипирование макета (interactive prototyping) и тестирование юзабилити (usability testing).\n\nДизайнеры пользовательского интерфейса должны обладать навыками в области визуального дизайна, иконографики и типографики, однако в перечень их служебных обязанностей не обязательно входит проведение пользовательских исследований или построение информационной архитектуры веб-ресурса.\n\nА вот дизайнеры пользовательского опыта должны дополнительно еще и разбираться в исследованиях целевого рынка, information architecture и дизайне взаимодействий (что автоматически подразумевает базовое знание поведенческой психологии) и т. д.\n\n### Тестирование удобства пользования (Usability Testing)\nЮзабилити (usability) - дословно с английского означает: возможность использования или полезность. Юзабилити — это больше мера дружелюбности сайта или интерфейса программы, поскольку оно помогает сделать сайт понятным и естественным для пользователя.\n\nТестирование удобства пользования (Usability Testing) — это метод тестирования, направленный на установление степени удобства использования, обучаемости, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий.\n\n### Этапы тестирования удобства использования пользовательского интерфейса:\n\n1. Исследовательское — проводится после формулирования требований и спецификаций к системе, а также после разработки прототипа интерфейса. Основная цель на этом этапе — выяснить, позволяет ли он с достаточной степенью эффективности решать задачи пользователя.\n\n2. Оценочное — проводится после разработки низкоуровневых требований и детализированного прототипа пользовательского интерфейса. Оценочное тестирование углубляет исследовательское и имеет ту же цель. На данном этапе уже проводятся количественные измерения характеристик пользовательского интерфейса: измеряются количество обращений к системе помощи по отношению к количеству совершенных операций, количество ошибочных операций, время устранения последствий ошибочных операций и т.п.\n\n3. Валидационное — проводится ближе к этапу завершения разработки. На этом этапе проводится анализ соответствия интерфейса программной системы стандартам, регламентирующим вопросы удобства интерфейса, проводится общее тестирование всех компонентов пользовательского интерфейса (с точки зрения конечного пользователя). Под компонентами интерфейса здесь понимается как его программная реализация, так и система помощи и руководство пользователя. Также на данном этапе проверяется отсутствие дефектов удобства использования интерфейса, выявленных на предыдущих этапах.\n\n4. Сравнительное — данный вид тестирования может проводиться на любом этапе разработки интерфейса. В ходе сравнительного тестирования сравниваются два или более вариантов реализации пользовательского интерфейса.\n\nИз этого следует, что UI-тестирование, предполагает под собой тестирование на основании требований к внешнему виду пользовательского интерфейса и формам взаимодействия с пользователем. \n\nНа какие требования стоит обращать внимание при UI-тестировании:\n- Требования к размещению элементов управления на экранных формах.\n- Требования к содержанию и оформлению выводимых сообщений.\n- Требования к форматам ввода.\n- Требования к реакции системы на ввод пользователя.\n- Требования к времени отклика на команды пользователя.\n\nВажно обращать внимание на:\n- Простоту использования сайта или интерфейса.\n- Эффективность использования.\n- Запоминаемость.\n- Ошибки, их количество и серьезность.\n- Удовлетворение пользователя (субъективное).\n\nТестирование пользовательского интерфейса (UI) – тестирование, выполняемое путем взаимодействия с системой через графический интерфейс пользователя.\n\nGUI тестирование включает:\n- навигация;\n- цвета, графика, оформление;\n- содержание выводимой информации;\n- поведение курсора и горячие клавиши;\n- отображение различного количества данных (нет данных, минимальное и максимальное количество);\n- изменение размеров окна или разрешения экрана.\n\n\nТестирование удобства использования (Usability Testing) – тестирование с целью определения степени понятности, легкости в изучении и использовании, привлекательности программного продукта для пользователя при условии использования в заданных условиях эксплуатации:\n- визуальное оформление;\n- навигация;\n- логичность.\n\nCompatibility testing (тестирование совместимости) – процесс тестирования для определения возможности взаимодействия программного продукта, проверка работоспособности приложения в различных средах (браузеры и их версии, операционные системы, их типы, версии и разрядность)\n\nВиды тестов:\n- Кросс-браузерное тестирование (различные браузеры или версии браузеров).\n- Кросс-платформенное тестирование (различные операционные системы или версии операционных систем).\n\n\ntodo  добавить инструменты UI, UX и Pixel Perfect тестирования\n","date":"2022-05-26T00:00:00.000Z","path":"/ui-ux-i-pixel-perfect/","icon":"fas fa-bug","image":"null","order":null,"category":{"title":"web","path":"/category/web/"},"tags":[{"title":"qa","path":"/tag/qa/"},{"title":"UI","path":"/tag/UI/"},{"title":"UX","path":"/tag/UX/"},{"title":"Pixel Perfect","path":"/tag/Pixel%20Perfect/"}],"headings":[{"value":"UI тестирование","anchor":"#ui-тестирование"},{"value":"Тестирование Pixel Perfect","anchor":"#тестирование-pixel-perfect"},{"value":"UX тестирование","anchor":"#ux-тестирование"}]}},{"node":{"id":"6226615cbb0917b5bbc9a6f0a2891bad","title":"Какие веб-элементы бывают","content":"\nЭлемент HTML — это основная структурная единица веб-страницы, написанная на языке HTML. Данный элемент вы можете увидеть в исходном коде для всех веб-страниц после задания типа документа на первой строке на странице. DOCTYPE определяет, какую версию (X) HTML эта страница использует. Элементы страницы находятся между открывающим тегом `<HTML>` и закрывающим `</HTML>`. Элемент `<html>` называется корневым элементом\n\n**Основные элементы**\n\n### Гиперссылки\n`<a href=\"filename\" target=\"_self\">название ссылки</a>`\nАтрибут href задаёт значение адреса документа, на который указывает ссылка.\n\n### Якорь\nТот же элемент используется для создания так называемых «якорей» (anchor), которые могут потом использоваться в гиперссылках, направленных на какой-то определённый элемент страницы. \n\n### Текстовые блоки\n`<H1> … </H1>, <H2> … </H2>, … ,<H6> … </H6>` — заголовки 1, 2, … 6 уровня. Используются для выделения частей текста (заголовок 1 — самый крупный, 6 — самый мелкий).\n`<P>` — новый абзац. Можно в конце абзаца поставить </P>, но это не обязательно.\n`<BR>` — новая строка. Этот тег не закрывается (то есть не существует тега </BR>)\n`<HR>` — горизонтальная линия\n`<BLOCKQUOTE> … </BLOCKQUOTE>`  — цитата. Обычно текст сдвигается вправо.\n`<PRE> … </PRE>`  — режим preview (preformatted text). Пробельные символы остаются там, где они есть в оригинальном документе (в других тегах игнорируются). Внутри могут обрабатываться внутристроковые теги кроме img, object, big, small, sup и sub.\n`<DIV> … </DIV>`  — блок (обычно используется для применения стилей CSS)\n`<SPAN> … </SPAN>`  — строка (обычно используется для применения стилей CSS)\n\n### Форматирование текста\n`<EM> … </EM>`  — логическое ударение (обычно отображается курсивным шрифтом)\n`<STRONG> … </STRONG>`  — усиленное логическое ударение (обычно отображается жирным шрифтом)\n`<I> … </I>`  — выделение текста курсивом\n`<B> … </B>` — выделение текста жирным шрифтом\n`<U> … </U>`  — подчёркивание текста\n`<S> … </S>` (или `<STRIKE> … </STRIKE>` )— зачёркивание текста\n`<BIG> … </BIG>`  — увеличение шрифта\n`<SMALL> … </SMALL>`  — уменьшение шрифта\n`<BLINK> … </BLINK>`  — мигающий текст. Внимание! Этот тег не работает в браузере Internet Explorer версий 5 и ниже без применения JavaScript\n`<MARQUEE> … </MARQUEE>`  — сдвигающийся по экрану текст.\n`<SUB> … </SUB>`  — подстрочный текст. Например, H<SUB>2</SUB>O создаст текст H2O.\n`<SUP> … </SUP>`  — надстрочный текст. Например, E=mc<SUP>2</SUP> создаст текст E=mc2.\n`<FONT параметры> … </FONT>`  — задание параметров шрифта. \n\n### Списки\n\n`<UL><LI>` - неупорядоченный список\n`<OL><LI>` - упорядоченный список\n`<DL><DT><DD>` - список определений\n\n### Объекты\nEMBED — вставка различных объектов: не-HTML документов и media-файлов\nAPPLET — вставка Java-апплетов\nSCRIPT — вставка скриптов.\nIMG — вставка изображения. Этот тег не закрывается.\n\n### Карта изображений\n`<MAP><AREA></MAP>` — создание карты изображений позволяющей хранить в одном изображении несколько ссылок.\n\n### Таблицы\nTABLE — создание таблицы. Параметры тега:\nCAPTION — заголовок таблицы (этот тег необязателен)\nTR — строка таблицы\nTH — заголовок столбца таблицы (этот тег необязателен)\nTD — ячейка таблицы\n\n### Формы\nСоздание форм в HTML является довольно сложным делом. Здесь приводятся только названия основных тегов.\n\nFORM — создание формы\nINPUT — элемент ввода (может иметь разные функции — от ввода текста до отправки формы)\nTEXTAREA — текстовая область (многострочное поле для ввода текста)\nSELECT — список (обычно в виде выпадающего меню)\nOPTION — пункт списка\n","date":"2022-05-26T00:00:00.000Z","path":"/kakie-veb-elementy-byvayut/","icon":"fas fa-bug","image":"null","order":null,"category":{"title":"web","path":"/category/web/"},"tags":[{"title":"qa","path":"/tag/qa/"},{"title":"веб-элементы","path":"/tag/%D0%B2%D0%B5%D0%B1-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B/"}],"headings":[]}},{"node":{"id":"06c239a24c9164817122fef5e8282b28","title":"Тестирование верстки, JS ошибок","content":"\nhttps://quality-lab.ru/blog/layout-testing/\n\nhttps://vc.ru/dev/199130-kak-my-testiruem-frontend-html-verstku-chek-list\n\nhttps://habr.com/ru/post/114256/\n\nhttps://qna.habr.com/q/373556\n\nhttps://www.youtube.com/watch?v=GfPmWGU0vI0\n\nhttps://www.youtube.com/watch?v=vfOEGw-n7mA","date":"2022-05-26T00:00:00.000Z","path":"/testirovanie-verstki-js-oshibok/","icon":"fas fa-bug","image":"null","order":null,"category":{"title":"web","path":"/category/web/"},"tags":[{"title":"qa","path":"/tag/qa/"},{"title":"Тестирование верстки","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B2%D0%B5%D1%80%D1%81%D1%82%D0%BA%D0%B8/"}],"headings":[]}},{"node":{"id":"5a3a1008b926b0a85c26c8c03c8d1402","title":"Работа с Dev Tool","content":"\nhttps://www.youtube.com/watch?v=58_AqypXjG4\n\nhttps://www.youtube.com/watch?v=C8Z-N0y6Sqo ","date":"2022-05-26T00:00:00.000Z","path":"/rabota-s-dev-tool/","icon":"fas fa-bug","image":"null","order":null,"category":{"title":"web","path":"/category/web/"},"tags":[{"title":"qa","path":"/tag/qa/"},{"title":"Dev Tool","path":"/tag/Dev%20Tool/"}],"headings":[]}},{"node":{"id":"3dd0555dcb84ed50931b5c0d9363504e","title":"Ресурсы. Selenium 4","content":"\n## EN version\n\nhttps://www.youtube.com/watch?v=3SaCFLiKoTs\n\nhttps://www.youtube.com/watch?v=2VKeDFmQFVQ\n\n\n## RU version\n\nhttps://www.youtube.com/watch?v=d7aq0aXYEss&t\n\nhttps://www.youtube.com/watch?v=7_Q8x37fPLw","date":"2022-06-08T00:00:00.000Z","path":"/resursy-selenium-4/","icon":"fas fa-bug","image":"null","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"EN version","anchor":"#en-version"},{"value":"RU version","anchor":"#ru-version"}]}},{"node":{"id":"683a344fdf62d3e0bdbf3d79b92601ea","title":"Подготовка к собеседованию на QA Automation Engineer","content":"\n## 1. Теория тестирования\n01. [Тестирование, Quality control, Quality assurance](/testirovanie-quality-control-quality-assurance/)\n02. [Понятие качества, международные стандарты качества](/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/)\n03. [Жизненный цикл дефекта](/zhiznennyj-czikl-defekta/)\n04. [Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)](/zhiznennyj-czikl-razrabotki-po-sdlc-software-development-life-cycle/)\n05. [Модели разработки ПО](/modeli-razrabotki-po/)\n06. [Методологии разработки ПО: Scrum, Kanban, RUP, DSDM, RAD, XP](/metodologii-razrabotki-po-scrum-kanban-rup-dsdm-msf-xp)\n07. [Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)](zhiznennyj-czikl-testirovaniya-prilozhenij-stlc-software-testing-life-cycle/)\n08. [Принципы тестирования, Agile принципы тестирования](/princzipy-testirovaniya-agile-princzipy-testirovaniya/)\n09. [Практики и подходы тестирования](/praktiki-i-podhody-testirovaniya/\")\n10. [Виды тестирования](/vidy-testirovaniya/)\n11. [Уровни тестирования](/urovni-testirovaniya/)\n12. [Техники тест-дизайна](/tehniki-test-dizajna/)\n13. [Тестовая документация](/testovaya-dokumentacziya/)\n  - [Тестовая политика и стратегия](/testovaya-politika-i-strategiya/) \n  - [Международные стандарты тестовой документации](/mezhdunarodnye-standarty-testovoj-dokumentaczii/)\n  - [Master Test Plan и тестовые планы для каждого уровня](/master-test-plan-i-testovye-plany-dlya-kazhdogo-urovnya/)\n  - [Понятие Test Case и Test Suite](/ponyatie-test-case-i-test-suite/)\n  - [Понятие Test Basis, Test Condition и Test Procedure](/ponyatie-test-basis-test-condition-i-test-procedure/)\n  - [Checl-list, как представитель Experience-Based](/checl-list-kak-predstavitel-experience-based/)\n  - [Bug Report](/bug-report/)\n  - [Summary Report](/summary-report/)\n  - [Requirements Tracebility Matrix](/requirements-tracebility-matrix/)\n  - [Test Data Tables](/test-data-tables/)\n  - [Test Scenario](/test-scenario/)\n  - [External Test Reports](/external-test-reports/)\n  - [Критерии приемки](/kriterii-priemki)\n  - [Метрики тестирования](/metriki-testirovaniya/)\n  - [Требования](/trebovaniya/)\n  - [Тестовый оракул](/testovyj-orakul/)\n\n\n## 2. Тестирование WEB приложений\n- 01. [Понимание DOM модели](/ponimanie-dom-modeli/)\n- 02. [Какие веб-элементы бывают](/kakie-veb-elementy-byvayut/)\n- 03. Веб-формы и веб-сервера\n- 04. [UI(UX) и Pixel Perfect](/ui-ux-i-pixel-perfect/)\n- 05. [Тестирование верстки, JS ошибок](/testirovanie-verstki-js-oshibok/)\n- 06. Тестирование мобильной верстки\n- 07. Тестирование функций безопасности SSL\n- 08. [Работа с Dev Tool](/rabota-s-dev-tool/)\n- 09. Подходы к тестированию веб приложений\n- 10. Тестирование кросбраузерности, масштабируемости\n- 11. Тестирование кодировок\n- 12. Тестирование локализации, интернационализации\n- 13. Конфигурационное тестирование\n- 14. Работа с Cookie\n\n## 3. Тестирование API\n- [Понимание клиент-серверной архитектуры](/ponimanie-klient-servernoj-arhitektury/)\n- [Взаимодействие сервера, клиента и БД](/vzaimodejstvie-servera-klienta-i-bd/)\n- [REST и SOAP](/rest-i-soap/)\n- JSON vs XML vs WSDL\n- [Response codes](/response-codes/)\n- HTTP/HTTPS структура и методы\n- [Аутентификация и авторизация](/autentifikacziya-i-avtorizacziya/)\n- Mock servers\n- Написание тестов, assertions, запуск коллекций\n- Уровни переменных и работа с ними\n- Токены, pre-request scripts, debugging API\n- Monitoring and reports\n- Работа со Swagger\n- Описение Rest запросов (Open API)\n- Что такое Open API\n- Типы авторизации (basic auth, oAuth, jwt что-то типо того)\n- GET vs POST, POST vs PUT + идемпотентность\n- http 1.1 vs http 2\n- CSRF token\n\n## 4. Тестирование Mobile\n- Особенности тестирования мобильных приложений\n- Требования AppStore и PlayMarket к релизу\n- Классификация мобильных устройств и расширений\n- Виды мобильных устройств\n- Уровни тестирования mobile\n- Виды тестирования mobile\n- Симуляторы и эмуляторы\n- составление юзабио=лити тестов\n- Тестирование утечки памяти\n- Тестирование энергопотребления\n- Тестирование прерываний и человеческого фактора\n- Эвристики и мнемоники\n- Типичные баги\n- Тестирование игр на мобильных устройствах\n\n## 5. Нагрузочное тестирование\n- Load testing vs Perfomance vs Volume vs Stress\n- Метрики нагрузочного тестирования\n- Инструменты нагрузочного тестирования\n- Администрирование с настройкой мониторинга\n- Работа со скриптами, парсерами и заглушками\n- Основные методики и отчеты\n- Понятие настройки генератора нагрузки\n\n## 6. Системы контроля версий\n- Что такое система контроля версий, цель и виды\n- Основные команды GIT\n- Работа с тегами\n- Просмотр коммитов\n- Ветвление в GIT и работа с ветками\n- Установка GIT на сервер\n\n## 7. Основы HTML & CSS\n- Что такое HTML\n- Что такое CSS\n- Структура веб страницы\n- Основные элементы (html, head, title, meta, style, body, link)\n- Атрибуты\n- Работа с таблицами, тегами\n- Применение стилей и CSS-правил\n\n## 8. SQL и NoSQL базы данных\n- Что такое базы данных и их классификация\n- Формы нормализации баз данных\n- Понятие СУБД\n- 12 правил Кодда\n- Базовые запросы с использованием LIKE, BETWEEN, ORDER BY, ALIASES, IN, TOP/LIMIT, DISTINCT\n- Понятие NULL\n- CREATE, DROP, DELETE, UPDATE, INSERT, ALTER\n- Объединение таблиц(вложенные запросыб джойны и т.д.)\n- Работа с агрегатными функциями GROUP BY, HAVING\n- Представления, хранимые процедуры, триггеры и функции\n- Работа с индексами\n- Constraints\n- Понятие и виды NoSWL баз данных\n\n## 9. Компьютерные сети\n- Классификация и топология сетей\n- [Модель OSI vs стек протоколов TCP/IP](/model-osi-vs-stek-protokolov-tcp-ip/)\n- Основные стандарты\n- Протоколы по уровням и их особенности\n- HTTP, FTP, POP3, SMTP, UDP, TCP, ARP, IPv4 vs IPv6, PPP, ICMP\n- Ethernet, WI-FI, IP, MAC, Маска подсети, VLAN\n- DHCP и DNS\n- Типы данных(сегменты, датаграммы, пакеты, биты, кадры)\n- Сетевое оборудование\n\n## 10. Основы тест менеджмента\n- Метрики тестирования\n- Понятие ROI. Формула, расчеты, примеры\n- Модели улучшения тестовго процесса (TMMi, CTP, STEP, TPI NEXT и другие) Особенности их применения\n- Виды моделей Risk-Based testing. Решение практических кейсов.\n- Основы управления QA командой. Основные показатели\n- Оценка трудозатрат на тестирование\n- Оценка качества продукта\n- TEST MANAGEMENT TOOLS\n\n## 11. Основы автоматизированного тестирования\n- Понятие автоматизированного тестирования. Когда стоит применять, а когда нет\n- Базовые основы программирования(типы данных, классы, методы, конструкторы, интерфесы, принципы ООП)\n- Xpath, CSS-селекторы, локаторы\n- Работа с Selenium WebDriver\n- Написаниеи запуск примитивных автотестов, работа с отчетами об их прохождении\n- Понятие BDD, Gherkin\n- Работа со средой разработки + GIT\n\n## 12. Основы тестирования безопасности\n- Основы тестирования безопасности\n- OWASP TOP-10\n- классификация видов уязвимостей\n- Понятие XSS, INJECTIONS, Authorization Bypass\n- Опыт работы с 2-3 инструментами (OWASP ZAP, Nmap, Metasploit, SQLmap, BeFF и др)\n- Суметь протестировать сайт на наличие SQL-инъекций\n- Базовое представление о Kali Linux\n\n## 13. Виртуализация\n- Понятие и настройка виртуализации\n- Паравиртуализация\n- Работа с VIRTUAL BOX\n- Работа с VMWare\n- Установка и работа с различными ОС\n- Команды Linux. Работа в терминале Mac OS\n- Суметь поднять виртуальную машину и подключиться к ней\n\n## 14. Основы работы со снифферами\n- Понятие и виды снифферов\n- Опыт работы с Fiddler\n- Опыт работы с Charles\n- Опыт работы с Wireshark\n- Суметь перехватить пакет и проанализировать трафик\n\n## 15. Инструменты для тестирования\n- Postman, SOAP UI, CURL, Katalon Studio\n- Jmeter, Grafana, Apigee, Browserstacks, Genymotion\n- PowerShell, Redmine, Jira, HP ALM, IBM Rational Quality Manager, MSTeam Foundation Server, TestRail, TestLink\n- Notepad++, PSPad, Snagit, ScreenHunter, Snipping tool, Monosnap, Sitechco, FakeFiller, PICT, Mackaroo, Lipsum\n- DiffChecker, Intellij IDEA, Eclipse и т.д.\n\n","date":"2022-06-21T00:00:00.000Z","path":"/podgotovka-k-sobesedovaniyu-na-qa-automation-engineer/","icon":"fas fa-bug","image":"null","order":1,"category":{"title":"interview","path":"/category/interview/"},"tags":[{"title":"qa","path":"/tag/qa/"},{"title":"собеседование","path":"/tag/%D1%81%D0%BE%D0%B1%D0%B5%D1%81%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/"},{"title":"interview","path":"/tag/interview/"}],"headings":[{"value":"1. Теория тестирования","anchor":"#1-теория-тестирования"},{"value":"2. Тестирование WEB приложений","anchor":"#2-тестирование-web-приложений"},{"value":"3. Тестирование API","anchor":"#3-тестирование-api"},{"value":"4. Тестирование Mobile","anchor":"#4-тестирование-mobile"},{"value":"5. Нагрузочное тестирование","anchor":"#5-нагрузочное-тестирование"},{"value":"6. Системы контроля версий","anchor":"#6-системы-контроля-версий"},{"value":"7. Основы HTML & CSS","anchor":"#7-основы-html--css"},{"value":"8. SQL и NoSQL базы данных","anchor":"#8-sql-и-nosql-базы-данных"},{"value":"9. Компьютерные сети","anchor":"#9-компьютерные-сети"},{"value":"10. Основы тест менеджмента","anchor":"#10-основы-тест-менеджмента"},{"value":"11. Основы автоматизированного тестирования","anchor":"#11-основы-автоматизированного-тестирования"},{"value":"12. Основы тестирования безопасности","anchor":"#12-основы-тестирования-безопасности"},{"value":"13. Виртуализация","anchor":"#13-виртуализация"},{"value":"14. Основы работы со снифферами","anchor":"#14-основы-работы-со-снифферами"},{"value":"15. Инструменты для тестирования","anchor":"#15-инструменты-для-тестирования"}]}},{"node":{"id":"cd3c1f0d4c8b2334c668d7cce4626219","title":"Изоляция компонентов","content":"\nПри выполнении теста с полным флоу можно встретить несколько проблем:\n- в интернет-магазине иногда нужно будет совершить оплату, чтобы закончить тест\n- задействовать реальную сервисную службу (чтобы собрать заказ)\n- зарезервировать ресурсы\n- долгая обратная связь тк нужно выполнить весь набор действий\n\nРешением этих проблем может стать идея тестирования приложения по частям.\n\n\n## Модульные(unit) тесты\n\n- Как правило тесты на функции или методы классов.\n- Для этих тестов не нужна сборка приложения.\n- Высокая скорость исполнения.\n\nСреди unit тестов выделяют:\n- Sociable - тесты, которые используют реальные модули приложения; \n- Solitary - тесты, которые используют подставные объекты или тестовые дублеры.\n\n### Тестовые дублеры\n\n#### Dummy\nКогда требуется передать в функцию объект, который в дальнейшем в тесте не будет использоваться. \nВ этом случае передается, например, пустая строка или пустой объект.\n\n#### Fake\nМожет иметь реальную реализацию, но не может использоваться в продакшене.\nНапример, использование In Memory DataBase вместо ORM(Object-Relational Mapping), которую скорее всего не получится использовать в продакшене.\n\n#### Stub\nВсегда возвращает статичный ответ по заданному запросу.\nЕсли нужно протестировать взаимодействие с внешним API, которое может быть недоступно, то его можно заменить stub'ом.\n\n#### Spy\nПохоже на stub, но еще может следить за вашим приложением.\nНапример, вы тестируете функцию в результате, которой происходит отправка письма пользователю, но в тестах не нужно рассылать настоящие письма, поэтому в функцию можно встроить \"шпиона\", который будет следить был ли вызвов отправки письма пользователю или нет, но при этом сам он отправлять письмо не будет. Такие тесты больше на поведение, чем на состояние.\n\n#### Mock\nВключает преимущества всех предыдущих дублеров. Это заранее запрограммированный объект который может принимать на вход различные значения и иметь некоторые ожидания. В зависимости от этих ожиданий, он возвращает ответ. ","date":"2022-08-28T00:00:00.000Z","path":"/izolyacziya-komponentov/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Модульные(unit) тесты","anchor":"#модульныеunit-тесты"}]}},{"node":{"id":"87dd301e329d0403ae18a8438ba060c7","title":"Мобильная автоматизация","content":"\n## Сложности мобильной автоматизации\n\nОсновные сложности при автоматизации тестирования мобильных приложений:\n\n1. существует несколько платформ: Android, iOs;\n2. у Android есть разные лаунчеры, обертки, которые также хотелось бы покрыть;\n3. сложный деплой, сложнее чем на вебе, тк прежде чем запустить тесты нужно собрать билды (их нужно где то собирать и как то передавать в тесты).\nТакже сложные хот фиксы, их не так просто сделать  как в вебе, например, нужно проходить процесс ревью перед заливом в маркет;\n4. сложность в масштабировании (параллелизации и многопоточном запуске), т. к. используется много ресурсов для запуска мобильных тестов( и для эмуляторов, и для реальных устройств)\nзапустить всё во много потоков не так просто и дорого;\n5. дорогостоящая инфраструктура - есть простой вариант, использование cloud ферм для запуска тестов, но цена у них очень высокая. А для запуска на реальном железе - для iOs нужны Mac устройства, \nс хорошими ресурсами и это тоже дорого.\n6. нестабильные тесты - т.к. в моб приложении ограниченная зона видимости, мы видим только те элементы, которые отображаются на экране. Могут быть разнообразные popup, push сообщения, нотификации, которые перекрывают элементы.\n\nОднако, в автоматизации моб приложений мы используем тот же паттерн Page Objects, Selenium под капотом и тот же подход к написанию тестов (Arrange(подготавливаем данные) - Act(выполняем действие) - Assert(проверяем)).\n\n## Инструменты для мобильной автоматизации\n\n|                       |Appium     |Espresso         |XCUITest   |Detox     |Selendroid|\n|-----------------------|-----------|-----------------|-----------|----------|----------|\n|**iOS**                |+          |-                |+          |+         |+         |\n|**Android**            |+          |+                |-          |+         |+         |\n|**Type**               |Balck box  |White box        |Black box  |Grey box  |Black box |\n|**Programming Lang**   |Almost any |Kotlin           |Swift      |JavaScript|Java      |\n|**Cost**               |Free       |Free             |Free       |Free      |Free      |\n|**Community**          |Very active|Google           |Apple      |Wix       |Average   |\n|**Speed**              |Slow       |Fast             |Fast       |Fast      |Slow      |\n|**Web, native, hybrid**| +         |Hybrid and native|Only native|Only      |+         |\n\n\nSelendroid - достаточно старый инструмент, используется скорее теми компаниями которые взяли его еще давно, неизвестно поддерживается ли он на текущий день.\n\nDetox - подходит только для приложений на react native, нативные моб приложения им не получится автоматизировать.\n\nEspresso, XCUITest - нативные инструменты, заточные под свою платформу.\n\n\n## Преимущества Appium\n\n1. Возможность писать кросс платформенные тесты. \nНаписав один раз тест под одну платформу, нужно минимальное количество действий чтобы адаптировать его под другую (добавить соответсвующие локаторы и обработать индивидуальные особенности платформы);\n2. Позволяет писать тесты на практически любом языке программирования;\n3. Нет необходимости модифицировать код приложения. Appium - полный Black box и нам ненужно модифицировать код самого приложения;\n4. Работает на основе Selenium JSON wire protocol;\n5. Open source фреймворк с активным комьюнити. Спонсируется souce lab которая также предоставляет cloud решения;\n6. Поддержка параллельного запуска используя Selenium Grid;\n\n## Архитектура Appium\n\nAppium - это http сервер.\n\nУ нас есть тестовый скрипт, мы передаем его в Appium и Appium транслирует его на мобильные устройства, с помощью json wire protocol. \n\nAppium - это обертка над теми же нативными инструментами(XCUITest и UIAutomator, Expresso), т.к. он все свои команды дальше ретранслирует в команды понятные нативным инструментам.\n\nДля iOS используется XCUITest, для Android можно выбрать между UIAutomator и Expresso. \n\nДля Expresso добавили поддержку примерно в 2020 г, он на 20% быстрее, чем UIAutomator. Плюс Expresso делает Appium немного Grey box'ом, потому что есть возможность сделать backdoor к приложению и в целом делает немного более открытым код приложения.\n\nJSONWP(JSON wire protocol) - механизм, созданный командой разработчиков WebDriver. Этот протокол представляет собой набор четко определенных стандартизированных endpoints, открытых через RESTfull API.\n\n`AppiumDriver.getPageSource();` - этот метод вызовет HTTP-запрос, и получит ответ от API. Назад вернется page source в формате строки.\n\n`/session/:sessionId/source` - эндпоинт, который обрабатывает метод getPageSource.\n\n\n## Appium + Android\n\nAppium работает с Android через Espresso и UIAutomator. Поддерживается Google.\nEspresso быстрее чем UIAutomator. \n\n## Appium + iOS\n\nНесколько лет назад под капотом использовался не XCUITests, а другой фреймворк. Но Apple решила прекратить его поддержку и выпустила XCUITests. А XCUITests на тот момент противоречил философии Appium, в том что нам не нужно модифицировать код, т.к. XCUITests нужно было собирать вместе с приложением. \n\nИ некоторое время, Appium нельзя было использовать для iOS приложений. На помощь пришел Facebook и сделал WebDriverAgent Server. При запуске тестов на Appium'e на моб устройство также ставится WebDriverAgent и он транслирует команды от Appium к XCUITests.\n\n## Способы запуска\n\n- на реальных устройствах;\n\nЭто самый надежный вариант. Но построить свою ферму дорого и сложно поддерживать, тк устройства всегда были подключены к сети и нужно выполнять настройки, чтобы не всплывали всяки popup сообщения и если они всегда в сети, то нужно будет часто менять батарейку и собрать парк из разных девайсов будет дорого  и сложно.\n\n- на симуляторах/эмуляторах;\n\nОптимальный вариант. Не так много кейсов, которые репродьюсятся только на реальных устройствах. Они есть но их не много.\n\nдля iOS - используются симуляторы, на Android поднимаются эмуляторы. \n\nИспользуются стандартные эмуляторы, которые предоставляет Android Studio и симуляторы от XCode для iOS.\n\n- на cloud фермах \n    - Browser Stack (2 параллельных запуска ~ 400$ в месяц, 5 параллельных запусков ~ 1000$ в месяц)\n    - Sauce Labs\n    - AWS Device Farm\n    \nСамые удобные, тк просто указываем url на хост в ферме и запускаем. Но это очень дорого, плюс вопрос к секьюрности для запусков тестов. \n\n## Запуск тестов\n\n- для iOS\n\nПри запуске на реальном устройстве:\n1. собираем .ipa файл, подписанный сертификатом организации\n2. берем девайс, добавленный в провижен организации\n3. используется аккаунт с сертификатом разработчика\n\nПри запуске на симуляторе просто собираем через XCode .app файл.\nНа симуляторе нельзя установить файл с расширением .ipa, потому что там другая архитектура и он там не запустится.\n\n- для Android\n\nСобираем apk через Gradle и Android Studio на эмулятор и на реальное устройство и можно работать.\n\n## Что нужно чтобы начать?\n\n### Android\n- JDK (Java Development Kit)\n- Android SDK\n- Appium\n\n### iOS\n- Mac OS\n- XCode\n- JDK (Java Development Kit)\n- Homebrew\n- Node and npm\n\nhttps://qa-automation.git-doc.evo.dev/mobile/ubuntu.html\n\n## Стек инструментов\n\n- Appium\n- Java/Kotlin\n- TestNg\n- Maven\n- Allure REport\n- AssertJ\n- Log4J\n\n## Инструменты чтобы находить локаторы\n\n### Android\n\n- UIAutomatorViewer (Android)\n- Appium Inspector - делает скриншот текущего экрана и показывает состояние выбранного элемента.\n\nМожно искать элементы по id и по xPath:\n\n- Id\n\nresource-id = id\n```java\n@AndroidFindBy(id = \"tvProSalePay\")\n```\n\n- xPath\n```java\n@AndroidFindBy(xpath = \"//android.widget.TextView[@text = 'XL']\")\n```\n\n### iOS\n\nМожно использовать только Appium Inspector, так как нет других инструментов для этой цели.\n\nМожно искать по id, iOSClassChain, iOS predicate string (в порядке снижения скорости). \n\nПо xPath тоже можно но крайне не рекомендуется так как это происходит очень медленно из за того что в iOS приложениях нет xml дерева и appium его вычисляет самостоятельно а на это тратится время.\n\n- Id\n```java\n@iOSXCUITFindBy(id=\"client name\")\n```\n\n- iOSClassChain\nАналог xPath.\n\n```java\n@iOSXCUITFindBy(iOSClassChain=\"**/XCUIElementTypeButton[`name == 'icRatingStar'`]\")\n```\n\n- iOS predicate string\n\nСвой тип локаторов.\n\n```java\nString selector = \"type == 'XCUIElementTypeButton' AND value BEGINSWITH[c] 'bla' AND visible == 1\"\n```\n\n## Боли Appium \n\n### Недоступные элементы\n\nНекоторые объекты не имеют выделенного элемента в DOM дереве и сложно с ними взаимодействовать отдельно, например взять текст. Встречается в сообщениях об ошибке, тост сообщениями, поп-апами.\n\n**Решение:**\n\n1. Можно использовать библиотеку tesseract - для распознавания текста на изображении.\n2. Клики по координатам.  \nЕсли нужно кликнуть на элемент, которого нет в дом дереве.  \nВ этом случае лучше брать не координаты этого элемента, а стараться брать соотношение по экрану (находить центр и т.д.), потому что если мы поменяем устройство, на котором будем прогонять и там расширение экрана другое, то мы столкнемся с трудностями.\n\n### Ограниченная зона видимости\n\nКогда мы делаем скриншот в Appium, мы видим дерево только тех элементов, которые есть сейчас на экране, то что вне мы не видим. \n\n**Решение:**\n\nДойти до элементов вне зоны видимости мы можем только проскролив.\n\n- iOS\n\n```java\nHashMap<String, String> scrollObject = new HashMap<>();\nscrollObject.put(\"element\", element.getId());\nscrollObject.put(\"toVisible\", \"true\");\n\ndriver.executeScript(\"mobile:scroll\", scrollObject);\n```\n\n- Android\n\n```java\nprotected void scrollToElementAndroid(String scrollableListId, String selectionText){\n    ((AndroidDriver) driver).findElementByAndroidUIAutomator(\"new UiScrollable(new UiSelector().scrollable(true)\"\n    + \".resourceId(\\\"\" + scrollableListId + \"\\\"))\"\n    + \".setAsHorizontalList().scrollIntoView(new UiSelector().text(\\\"\" + selectionText + \"\\\"))\").click();\n}\n```\n\n**Универсальный скролл**\n\n```java\npublic void swipeUpToFindElement(By by, int maxSwipes){\n    int alreadySwiped = 0;\n    while(driver.findElements(by).size() == 0){\n        if (alreadySwiped > maxSwipes){\n            waitForElementToBePresent(by, \"Невозможно найти элемент по свайпу\", Constants.SMALL_TIMEOUT);\n            return;\n        }\n        swipeUpQuick();\n        Log.info(\"Выполнен свайп\");\n        ++alreadySwiped;\n    }\n}\n```\n\n### Платформозависимость\n\nУ Android и iOS есть свои особенности.\n\n- Разные атрибуты у элементов\niOS - value, android - text\niOs - visible, android - displayed\niOS - enabled, android - checked, checkable, enabled\n\n- Различия в основных флоу приложения на Android и на iOS\n\n- Часто при работе с веб вью на разных версиях Android у элементов разный xPath\n\n```java\n@AndroidFindAll(\n\n)\n```\n\nwatch?v=zp0qC6JT0rE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","date":"2022-09-02T00:00:00.000Z","path":"/mobilnaya-avtomatizacziya/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Сложности мобильной автоматизации","anchor":"#сложности-мобильной-автоматизации"},{"value":"Инструменты для мобильной автоматизации","anchor":"#инструменты-для-мобильной-автоматизации"},{"value":"Преимущества Appium","anchor":"#преимущества-appium"},{"value":"Архитектура Appium","anchor":"#архитектура-appium"},{"value":"Appium + Android","anchor":"#appium--android"},{"value":"Appium + iOS","anchor":"#appium--ios"},{"value":"Способы запуска","anchor":"#способы-запуска"},{"value":"Запуск тестов","anchor":"#запуск-тестов"},{"value":"Что нужно чтобы начать?","anchor":"#что-нужно-чтобы-начать"},{"value":"Стек инструментов","anchor":"#стек-инструментов"},{"value":"Инструменты чтобы находить локаторы","anchor":"#инструменты-чтобы-находить-локаторы"},{"value":"Боли Appium","anchor":"#боли-appium"}]}},{"node":{"id":"409a47c4437edeb463348b8ada720d11","title":"Инструменты тестирования мобильных приложений","content":"\n## Симулятор vs Эмулятор\n\n### Симулятор \nОбычно используется для iOS.\n\n- Железо не эмулируется, только софтверная часть\n- Работает быстрее реальных устройстви мы не можем гарантировать что на реальном устройстве будет работать также\n- Невозможно установить телефонные приложений и работать с Siri\n- Невозможно проверить \"железные\" фичи: Bluetooth, NFC, звонки\n\nБаги возникающие на симуляторе в любом случае нужно править так как рано или поздно они могут появиться и на реальном устройстве:\n- Краш на симуляторе/девайсе\n- Разъезжается верстка\n\n### Эмулятор\nИспользуется для Android.\n\n- Имеется и Software и Hardware, можно задавать параметры памяти и т.д.\n- Работает медленно\n- Нет покупок внутри приложений\n- Google сервисы\n\nБаги:\n- Device-specific\n- Ошибки в транзакции\n- Библиотеки не под x86\n\nДостоинства:\n- Можно задавать различные разрешения\n- Можно работать с памятью\n- Тестировать GPS\n- Перехват и шейпинг(проверка траффика)\n\n## Реальные устройства\n\nОсновная проблема что не всегда есть возможность создать собственную ферму устройств\n\n- медленный Debug\n- iOS: разметка\n- Работа с памятью, сложно сэмулировать нужно забивать память вручную\n- Android: перехват трафика\n- Многообразие устройств\n\n## Среда разработки\n\nAndroid SDK, XCode\n\nADB - Android Debug Bridge - устанавливается вместе с Android SDK, и позволяет управлять устройством на базе Android. \n\nADB позволяет:\n- аосмотреть какие устройства подключены и могут работать с ADB\n- просматривать логи\n- копировать файлы с/на аппарат\n- устанавливать/удалять приложения\n- выполнять различные скрипты управления\n\n## Логи\n\nVerbose - вся информация с приложения\nDebug - логи для дебаг режима\nInfo - информация о состоянии\nWarn - предупреждение о нештатных ситуациях\nError - ошибка в приложении\n\nЕсли баг возникает у пользователя на проде, то проверяются логи в Fabric или Firebase Crashlitics.\n\nВ Firebase Crashlitics можно смотреть статистику работы без сбоев - какой процент пользователей работает без сбоев, список ошибок которые произошли и т.д.\n\nCrashlytics отображает:\n- Период возникновени ошибки\n- Тип ошибки\n    - Crash\n    - Warning\n- Версия приложения\n- Устройство\n- Операционная система\n- Идентификатор пользователя\n\n\n## Developer Console. Ошибки ANR и сбои\n\n1. Период возникновения ошибки\n2. Версия Android\n3. Версия приложения\n\nМинусы:\n1. Нет поиска по устройству\n2. Убрали поиск по отчетам пользователей\n\n## Перехват трафика\n\n- Charles\n- Fidler\n\nПроверяются запросы и ответы на клиенте и сервере.\n\nЕсли приходит ответ в зашифрованном виде то можно селать следущее чтобы его расшифровать\n\n1. Настроить прокси на устройстве или эмуляторе\n2. Установить SSL сертификат для HTTPS на устройстве с которого считываются запросы\n3. Выполнить действия с устройства\n4. Изучать необходимую информацию\n\n## Тестирование API\n\n- Postman\n    - Проверка сервера без клиента\n    - Проверка получаемых данных от сервера\n\n## Аналитика\n\n- Firebase - Firebase Debug View\n\nAndroid  \nadb shell setprop debug.firebase.analytics.app <package_name>\n\niOS  \nв командной строке Xcode:\n-FIRDebugEnabled\n\n- Google Analytics\n\nadb shell setprop log.tag.GAv4 DEBUG\n\nadb logcat -v time -s GAv4\n\nОтправляемые события будут отображаться в консоли но в самом Google Analytics нет реал тайм борда\nи в лучшем случае через сутки можно будет проверить что события дошли.\n\n- Яндекс AppMetrica\n\nВ самом кабинете можно указать устройство версию и не нужно никаких команд запускать.\n\n## Push уведомления\n\n- Firebase - Firebase Debug View\n\n- Яндекс AppMetrica\n\nМожно настраивать уведомления.\nНо иногда можно случайно отправить push на продакшен.\n\nНужно попросить разработчиков чтобы написали метод testPush.json, который будет отправлять push только на тестовое устройство. \n\n## Мнемоники\n\nПомогают выполнять важные проверки. \n\n### I SLICED UP FUN\n\n![I SLICED UP FUN](https://hsto.org/getpro/habr/upload_files/8f6/5c8/0c9/8f65c80c9c2cf5cf89c417c2240364be.png)\n\n## Автоматизация\n\n### Monkey UI/Application Exerciser Monkey\n\n```\nadb shell monkey\n-p your.package.name -v 500\n```\n\nhttps://developer.android.com/studio/test/monkey\n\nМожно указать ограничения по скорости, оганичить действия только внутри вашего приложения, можно указать id  и если приложение упадет можно по этом id воспроизвести действия, а также другие парамтры.\n\n\nИсточник:\n\n1. ❗ [«Инструменты тестирования мобильных приложений», Ксения Апачиди](https://www.youtube.com/watch?v=DH2XI5q1eUE)\n2. ❗ [Тестирование мобильных приложений: tips & tricks](https://habr.com/ru/company/badoo/blog/269189/)","date":"2022-09-06T00:00:00.000Z","path":"/instrumenty-testirovaniya-mobilnyh-prilozhenij/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Симулятор vs Эмулятор","anchor":"#симулятор-vs-эмулятор"},{"value":"Реальные устройства","anchor":"#реальные-устройства"},{"value":"Среда разработки","anchor":"#среда-разработки"},{"value":"Логи","anchor":"#логи"},{"value":"Developer Console. Ошибки ANR и сбои","anchor":"#developer-console-ошибки-anr-и-сбои"},{"value":"Перехват трафика","anchor":"#перехват-трафика"},{"value":"Тестирование API","anchor":"#тестирование-api"},{"value":"Аналитика","anchor":"#аналитика"},{"value":"Push уведомления","anchor":"#push-уведомления"},{"value":"Мнемоники","anchor":"#мнемоники"},{"value":"Автоматизация","anchor":"#автоматизация"}]}},{"node":{"id":"f28f426da5d71fef613a05a31b514709","title":"Особенности тестирования мобильных приложений","content":"\n## Виды мобильных приложений, их плюсы и минусы\n\n### Web приложения\n\nВеб-приложения представляют собой адаптированные веб-сайты, которые открываются через браузеры. \n\nПользователь не скачивает приложение и не хранит его на своем устройстве. Если его «скачивают», скорее всего, речь идет о том, что оно добавляется в закладки браузера. \n\nОдним из самых распространенных подвидов считают PWA — прогрессивные веб-приложения, которые, по сути, являются нативными приложениями внутри браузера. \n\nСложно выделить примеры, чтобы не ошибиться. Разные источники приводят в пример Google Maps, программы Microsoft Office.\n\n#### Плюсы\n- Не требуют настроек под операционную систему, что делает разработку быстрой и менее дорогой.\n- Не требуют загрузки, установки и не занимают место на устройстве пользователя.\n- Не требуют обновлений, поэтому в теории их проще поддерживать со стороны разработчика и, опять же, пользователю не надо устанавливать никакие обновления, чтобы работать с площадкой.\n\n#### Минусы\n- Веб-приложения зависят от браузера. И функции, которые доступны в одном браузере, могут не поддерживаться в другом. Это означает, что пользовательский опыт будет отличаться. \n- Веб-приложения не работают без подключения к интернету. \n- Не имеют доступа к ресурсам мобильного устройства, в связи с этим имеют ограниченную функциональность.\n\n### Нативные приложения\n\nНативные мобильные приложения — самый распространенный и дорогой в разработке вид, так как создается отдельно для каждой ОС (iOS, Android или другие). \n\nКогда мы говорим о мобильных приложениях, чаще всего имеем в виду именно нативные. Pokemon Go, Spotify и многие другие являются именно нативными приложениями.\n\n#### Плюсы\n- Высокая производительность (скорость работы и надежность). Это связано с тем, что приложение создается для каждого ОС с учетом его особенностей. В итоге это обеспечивает пользователю позитивный опыт взаимодействия.\n- Доступ к аппаратной части устройства (геолокации, камере, микрофону, акселерометру, датчикам освещенности, календарю, push-уведомлениям) и широкий функционал за счет этого; Это тоже упрощает и улучшает пользовательский опыт.\n- Adjust упоминает, что нативные приложения еще и более безопасны с точки зрения защиты данных пользователя.\n- Нет ограничения функционала скоростью и качеством Интернет-соединения, приложение может работать без выхода в сеть;\n- Можно распространять через магазин проложений.\n\n#### Минусы\n- Стоимость разработки. Нативное приложение нужно разрабатывать отдельно для каждой ОС, а потом поддерживать его. Все это требует расходов. \n- Нативные приложения занимают место в памяти устройства пользователя, причем с каждым новым обновлением это занятое место может расти.\n\n### Гибридные приложения\n\nНазвание говорит само за себя: это веб-приложения, которые выглядят как нативные и имеют их признаки. \n\nВ частности, иконки на рабочем столе мобильного устройства пользователя, хорошую производительность и возможность работать в автономном режиме. \n\nСреди гибридных приложений выделяют Uber, Evernote. Некоторые источники относят к гибридам и Instagram.\n\n#### Плюсы\n- Более бюджетная и быстрая разработка по сравнению с нативными. \n- Более быстрая загрузка — это хорошее преимущество для пользователя и возможность улучшения пользовательского опыта. \n- Возможность взаимодействия с ОС устройства. \n- Есть встроенный браузер.\n- Можно распространять через магазин прилодений.\n- Мультиплатформенные.\n\n#### Минусы\n- Все равно не такая хорошая производительность, как у нативных приложений.\n- Ограниченный доступ к ресурсам мобильного устройства.\n- Не полностью автономны, нужно подключение к интернету.\n\n## Отличия web и mobile тестирования\n\n1. Мобильные устройства можно переносить, в связи с этим появляются свои особенности, меняется геолокация и т.д.\n2. У мобильных устройств  высокая фрагментация (много устройств на которых можно использовать приложение) и больше пользователей\n3. Мобильные прилодения имеют ограничения в ресурсах (оперативной и постоянной памяти)\n4. Разное взаимодействие в отлечие от web'a (tap, swipe и т.д.)\n5. Разное поведение с подкючением к интернету и без подключения.\n\n## Тестирование mobile приложений\n\n1. Выбор устройств.\nИз всего зоопарка устройств нужно выбратьустройства для тестирования. Для этого можно обратиться к статистике и аналитике по использованию вашего приложения, если такой статистики нет то моно обратиться к статистике google илии apple.\n\n2. Размеры экрана и touch интерфейс\n- Элементы должны быть определенного размера чтобы пользователь смог попасть и не было мискликов.\n- Все сценарии в приложении не должны вести на пустые экраны.\n- В touch интерфейсе нужно проверять многократное нажатие на элементы, мультитач[^«множественное касание» — функция сенсорных систем ввода, осуществляющая одновременное определение координат двух и более точек касания.] и нативные жесты которые могут использоваться.\n- скорость отклика элементов (высокая; нажатая клавиша должна визуально отличаться)\n\n3. Ресурсы устройства\n- кейсы с утечкой памяти;\n    - можно проверить с помощью программы Instruments (стандартное приложение MacOS). Может быть не более 30мб на 2г айфон/айпод, примерно 70мб для всех девайсов до 2-го айпада\n    - уделить внимание окнам с большим количеством информации, при длительном пребывании пользователя в приложении\n- кейсы, когда не хватает памяти для установки и работы приложения;\n- кейсы, когда не хватает памяти для обновления и работы приложения;\n- кейсы, когда переносим или устанавливает приложение на sd карту;\n\n4. Разрешения экрана и версии ОС\n- можно столкнуться с ошибками верстки;\n- на разных разрешениях приложение зачастую выглядит по разному;\n- кейсы с портретной и альбомной ориентацией устройства;\n\nЕсли приложение работает с разными форматами файлов то нужно проверять все эти форматы, чтобы приложеине корректно работало с каждым.\n\n5. Реакция на внешнее прерывание\nВнешние прерывания:\n- входящие/исходящие звонки/сообщения/смс/ммс/напоминание/нотификацию ;\n- уведомления от других приложений;\n- разрядка устройства, переход устройства в энергосберегающий режим, переход устройства в режим ожидания, смена ориентации в режиме ожидания;\n- кейсы с разными подключениями (с разными сетями: wi-fi, 3G);\n- при включенной/отключенной функции bluetooth, геопозиция, режим полета, функции где используется камера;\n- кейсы с потерей связи;\n- кейсы с зарядкой устройства(разряд/изъятие батареи);\n- с извлечением/подключением sd карты/кабеля/зарядки;\n- закрыть приложение для того, чтобы открыть какое-то другое на некоторое время и вернуться к вашему приложению позже;\n- послать девайс в сон на некоторое время.\n\n6. Доступ к связи\n- позитивный кейс (наличие отличной постоянной связи);\n- наличие постоянной неотличной связи;\n- отсутствие связи;\n- потеря связи;\n\n7. Постоянная мобильность\n- Крэш в приложении при попытке восстановить приложение из бэкграунда с предварительной сменой ориентации экрана;\n- Крэш в приложении при “потряхивании” девайса в момент совершения этим девайсом фотосъёмки (приложение изначально создавалось для создания фото);\n\n8. Проверка работы приложений на ретина экранах и различных версия OS\n- корректное отображение различных элементов на экранах ретина/не ретина\n- установка приложения на корректную версию OS\n- проверить установку на все возможные девайсы\n- различные функции на девайсах: отсутствие/наличие камеры(ipad) (автофокуса), отсутствие/наличие GPS\n\n9. Проверка типа покупок (восстанавливаемые, не восстанавливаемые)\n- проверка соответствия фактической/заявленной стоимости приложения\n- проверка восстановления покупки независимо от девайса, а с привязкой к учетной записи\n\n10. Проверка работы обратной связи\n- сообщения при загрузке контента/прогресс\n- сообщения при ошибке доступа к сети\n- наличие сообщений при попытке удалить важную информацию\n- наличие экрана/сообщения при окончании процесса/игры (экран Game over)\n\n11. Проверка работы обновлений\n- проверка различных путей установки обновлений (wifi, bluetooth, usb)\n- проверка работы установленных изменений, мест, куда они вносились\n- убедиться в поддерживаемости обновлений более старыми операционками, чтобы элементы которые на новой системе работают хорошо не падали на более старых версиях.\n\n12. Реклама в мобильном приложении\n- реклама не должна перекрывать кнопки управления приложением\n- реклама должна иметь доступную кнопку закрытия, потому что чаще всего пользователь ее не ищет, а просто удаляет приложение с концами\n\n13. Проверка локализации\n- на другом языке на экране должно хватить места для текста\n- даты должны соответствовать формату установленного региона\n- временные настройки должны быть соблюдены\n\n14. Проверка энергопотребления\n- необходимо проверять насколько сильно ваше мощное приложение опустошает батарею устройства. Скорее всего пользователь удалит его, если из-за него мобилку придется под заряжать слишком часто.\n\n## Жизненный цикл приложения\n\nКогда мы тестируем кейсы на прерывание мы проверяем как правильно приложение работает с жизненным циклом.\n\n![Жизненный цикл приложения](https://metanit.com/java/android/pics/life_cycle.png)\n\n## Обратная связь с пользователем\n\nУ всех элементов нажатых пользователем должно быть соответсвующее состояние благодаря этому пользователь видит действительно ли нажатие случилось или нет.\n\nТакже нужно смотреть на отклик(реакция на нажатие), есть ли какая то скорость отклика она не должна быть достаточно быстрой и не должна быть достаточно медленной. При таком тестировании желательно использовать не самые топовые устройства(девайсы).\n\nКогда загружаем какой нибудь контент нужно использовать прогресс бар чтобы пользователь видел что идет загрузка. \n\nВсе сценарии должны иметь завершающий success экран, чтобы пользователь также видел что его кейс завершился и можно пойти на другой экран.  \n\nДолжны быть четкие и понятные сообщения об ошибках. Чтобы пользователь понимал чтоо ему нажимать, вдруг он удаляет какую то важную информацию. Текст сообщения должен быть крайне понятным и простым. \n\nТакже если используются уведомления на экране, например о покупках, можно использовать звуки и вибрацию. Звуки, вибрация и уведомления должны быть синхронизированы между собой, такой кейс тоже надо проверять. \n\n## Настройки разработчика в Android\n\nВ Android и iOS есть специальный режим разработчика, это список настроек/параметров которые мы можем использовать при тестировании.\n\nНапример:\n\n- **Профиль обработки GPU** - показывает насколько быстро рисуется интерфейс нашего приложения. Если будет выше зеленой линии значит не все так гладко с интерфейсом.\n\n- **Показывать ограничения макета** - показывает как все элементы расположены относительно друг друга.\nЕсли мы тестируем верстку можно включить этот режим и сравнить с макетом.\n\n- **Параметр \"Отладка\"** - используется при дебаге.\n\n- **Параметр \"Конфигурация USB\"** - как подключаться для отадки, для зарядки, для передачи файлов.\n\n- **Параметр \"Не сохранять операции\"(\"Do not keep activities\")** - используется для тестирования жизненого цикла. При включении этого параметра при навигации в новый экран предыдущий экран уничтожается, если мы снавигируемся назад то приложение падает. \n\nдля iOS есть такой же режим:\n\n- **Параметр \"Network Link Conditioner\"** - для тестирования с разным качеством связи(3G, LTE и т.д.) и с возможностью задавать собственные профайлы, кастомные со своими параметрами какая нам сеть нужна.\n\n## Помощь при релизах \n\n### Beta версии\n\n#### iOS\nПеред релизами можно использовать beta версии.\nДля iOS для этих целей можно использовать TestFlight, релиз выкладываетя и пояляется в TestFlight и далее смотрится как поведет себя приложение.\n\n#### Android\nНечто похожее также имеется и на Android.\nТакже используется Beta testing версии для внутреннего тестирования.\n\n### Выпуск автоматических обновлений\n\n#### iOS\nТакже в iOS есть функция поэтапного выпуска автоматических обновлений. Если включается этот параметр то в течение недели наше обновление будет выкатываться с 1% пользователей до 100%, каждый день постепенно увеличиваясь.\n\n#### Android\nВ Android также можно делать выпуск автоматических обновлений, но здесь есть больше контроля на этим процессом. \n\nЕсли мы желаем поэтапный релиз для iOS то мы можем его только остановить но не поменять проценты или другие настройки, в Google Play можно указать процент - сколько пользователей нужно от общего количества, в любой момент остановить и в любой момент продолжить, в любой момент поменять этот процент. \n\n### Отчеты о тестировании\n\nТакже в Google Play есть отчеты о тестировании. Когда вы загружаете свой apk файл и публикуете, через некоторое время там появится отчет о тестировании этой версии. \n\nGoogle на своей фабрике устройств тестирует нашу apk, в течении ~ 10 минут и в итоге выдает отчет по разным параметрам: по безопасности, будут видны краши если они были, видно на каких устройствах тестировалось, видно скриншоты и запись видео в том случае если что то пошло не так.  \n\n## Чек-лист тестирования мобильных приложений:\n\n- Геолокация.\n- Работа приложения в разных режимах: portrait/landscape, split screen.\n- Поля ввода.\n- Пуш уведомления.\n- Прерывания — входящие звонки, СМС, доступ к интернету, предупреждение о низком заряде батареи, внезапное отключение устройства и другие.\n- Поддержка платежных систем (если присутствуют платежные транзакции).\n- Соответствие гайдлайнам операционных систем.\n- Влияние на производительность устройства.\n\nТакже необходимо проанализировать сетевой трафик: обрыв сети и слабый интернет, исходящие запросы и полученные ответы. Для этого используют снифферы Charles/Fiddler, Proxyman и другие.\n\nПри необходимости выполняют тестирование API. Для этой задачи используют специализированные инструменты: Swagger, Postman, SOAPUI. Они помогают документировать запросы и выполнять их интерактивную проверку. Подробнее их мы рассмотрим дальше.\n\nДля тестирования на различных устройствах используют эмуляторы вроде Genymotion, BlueStacks. Однако успешные тесты на эмуляторе не гарантируют, что приложение будет работать без сбоев на реальных устройствах. Чтобы подключиться к реальным мобильным устройствам и интегрировать туда автотесты, используют фермы BrowserStack, Xamarin или AWS. Либо можно поднять собственную ферму на базе OpenSTF — это позволит всем сотрудникам иметь равный доступ к тестовым устройствам, что особо важно в условиях распределенных команд и удаленной работы.\n\nДля автоматизации UI тестирования мобильных приложений используют Appium, Detox, Ranorex — инструменты автоматизации для запуска сценариев и тестирования приложений на Android или iOS с помощью веб-драйвера. Подробнее инструменты для автоматизации тестирования мы рассмотрим ниже.\n\nКогда ваш проект имеет большое количество автотестов, будет полезно автоматизировать их запуск при каждой сборке нового билда. Чтобы настроить этот процесс, используйте системы CI/CD — Jenkins/TeamCity.\n\nИсточник:\n\n1. ❗ [«Особенности тестирования мобильных приложений», Игорь Плотников](https://www.youtube.com/watch?v=Vy_6hfmk34E)\n2. ❗ [Мобильное тестирование, автоматизация и тестирование API: С чем нужно уметь работать тестировщику в 2021 году](https://habr.com/ru/company/reksoft/blog/541344/)","date":"2022-09-05T00:00:00.000Z","path":"/osobennosti-testirovaniya-mobilnyh-prilozhenij/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Виды мобильных приложений, их плюсы и минусы","anchor":"#виды-мобильных-приложений-их-плюсы-и-минусы"},{"value":"Отличия web и mobile тестирования","anchor":"#отличия-web-и-mobile-тестирования"},{"value":"Тестирование mobile приложений","anchor":"#тестирование-mobile-приложений"},{"value":"Жизненный цикл приложения","anchor":"#жизненный-цикл-приложения"},{"value":"Обратная связь с пользователем","anchor":"#обратная-связь-с-пользователем"},{"value":"Настройки разработчика в Android","anchor":"#настройки-разработчика-в-android"},{"value":"Помощь при релизах","anchor":"#помощь-при-релизах"},{"value":"Чек-лист тестирования мобильных приложений:","anchor":"#чек-лист-тестирования-мобильных-приложений"}]}}]}},"relatedTag":{"id":"4b276a3a6b99e78392dc449c5d9ba01b","title":"qa","path":"/tag/qa/","related":[{"id":"java","path":"/tag/java/","title":"java"}]}},"context":{}}