{"hash":"03f7058ba488a165454bf4fd228c446ef5a28a6f","data":{"tag":{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/","belongsTo":{"totalCount":15,"pageInfo":{"totalPages":2,"currentPage":1},"edges":[{"node":{"id":"8bfce5a332aadaa672688c23bd6a02a4","title":"Виды тестирования","content":"\nТип тестирования (test type): Совокупность тестирующих действий, которая фокусируется на определенных показателях качества. (ГОСТ 56920) Прим.: в русскоязычной среде это “вид”.\n\n1. [Классификация по запуску кода на исполнение](/vidy-testirovaniya-po-zapusku-koda-na-ispolnenie/)\n\n2. [Классификация по доступу к коду и архитектуре приложения](/vidy-testirovaniya-po-dostupu-k-kodu-i-arhitekture-prilozheniya/)\n\n3. [Классификация по степени автоматизации](/vidy-testirovaniya-po-stepeni-avtomatizaczii/)\n\n4. [Классификация по уровню деталиции приложения (по уровню тестирования)](/vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/)\n\n5. [Классификация по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)](/vidy-testirovaniya-po-ubyvaniyu-stepeni-vazhnosti-testiruemyh-funkczij-po-urovnyu-funkczionalnogo-testirovaniya/)\n\n6. [Классификация по принципам работы с приложением](/vidy-testirovaniya-po-princzipam-raboty-s-prilozheniem/)\n\n7. [Классифкация по природе приложения](/vidy-testirovaniya-po-prirode-prilozheniya/)\n\n8. [Классификация по фокусировке на уровне архитектуры приложения](/vidy-testirovaniya-po-fokusirovke-na-urovne-arhitektury-prilozheniya/)\n\n9. [Классификация по привлечению конечных пользователей](/vidy-testirovaniya-po-privlecheniyu-konechnyh-polzovatelej/)\n\n10. [Классификация по степени формализации](/vidy-testirovaniya-po-stepeni-formalizaczii/)\n\n11. [Классификация по целям и задачам](/vidy-testirovaniya-po-czelyam-i-zadacham/)\n\n12. [Классификация по техникам и подходам](/vidy-testirovaniya-po-tehnikam-i-podhodam/)\n\n13. [Классификация по моменту выполнения (хронологии)](/vidy-testirovaniya-po-momentu-vypolneniya-hronologii/)\n\n14. [Другие виды тестирования](/drugie-vidy-testirovaniya/)\n\n![Виды тестирования](https://ic.pics.livejournal.com/qualityplan/44671565/741/741_900.png)\n","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[]}},{"node":{"id":"a22be1b08dc7c658521fd8be36704b6a","title":"Виды тестирования по запуску кода на исполнение","content":"\n## Статическое тестирование (Static testing)\nПроизводится без запуска программного кода продукта.\n\nВ рамках этого подхода тестированию могут подвергаться:\n  - Документы (требования, спецификация, документация, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).\n  - Графические прототипы(например, эскизы пользовательского интерфейса).\n  - Код приложения (что часто выполняется самими программистами в рамках аудита кода (code review), являющегося специфической вариацией взаимного просмотра в применении к исходному коду). Код приложения также можно проверять с использованием техник тестирования на основе структур кода.\n  - Параметры(настройки) среды исполнения приложения.\n  - Подготовленные тестовые данные.\n\n## Динамическое тестирование (Dynamic testing)\nТестирование с запуском кода на исполнение. \n\nЗапускаться на исполнение может как код всего приложения целиком (системное тестирование), так и код нескольких взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) и даже отдельные участки кода. \n\nОсновная идея этого вида тестирования состоит в том, что проверяется реальное поведение (части) приложения.","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-zapusku-koda-na-ispolnenie/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Статическое тестирование (Static testing)","anchor":"#статическое-тестирование-static-testing"},{"value":"Динамическое тестирование (Dynamic testing)","anchor":"#динамическое-тестирование-dynamic-testing"}]}},{"node":{"id":"1c4dc01fe3e21cdc1d74b81e0569a0b8","title":"Виды тестирования по степени формализации","content":"\n## Тестирование на основе тест-кейсов (Scripted testing, Test case based testing)\nФормализованный подход, в котором тестирование производится на основе заранее подготовленных тест-кейсов, наборов тест-кейсов и иной документации. \n\nЭто самый распространённый способ тестирования, который также позволяет достичь максимальной полноты исследования приложения за счёт строгой систематизации процесса, удобства применения метрик и широкого набора выработанных за десятилетия и проверенных на практике рекомендаций.\n\n## Исследовательское тестирование (Exploratory testing)\nЧастично формализованный подход, в рамках которого тестировщик выполняет работу с приложением по выбранному сценарию, который, в свою очередь, дорабатывается в процессе выполнения с целью более полного исследования приложения. \n\nКлючевым фактором успеха при выполнении исследовательского тестирования является именно работа по сценарию, а не выполнение разрозненных бездумных операций. Существует даже специальный сценарный подход, называемый сессионным тестированием (session-based testing). \n\nВ качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы, и тогда этот вид тестирования называют тестированием на основе чек-листов (checklist-based testing).\n\n## Свободное (интуитивное) тестирование (Ad hoc testing)\nПолностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев — тестировщик полностью опирается на свой профессионализм и интуицию (experience-based testing) для спонтанного выполнения с приложением действий, которые, как он считает, могут обнаружить ошибку. \n\nЭтот вид тестирования используется редко и исключительно как дополнение к полностью или частично формализованному тестированию в случаях, когда для исследования некоторого аспекта поведения приложения (пока?) нет тест-кейсов.\n\nНи в коем случае не стоит путать исследовательское и свободное тестирование. Это разные техники исследования приложения с разной степенью формализации, разными задачами и областями применения.","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-stepeni-formalizaczii/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Тестирование на основе тест-кейсов (Scripted testing, Test case based testing)","anchor":"#тестирование-на-основе-тест-кейсов-scripted-testing-test-case-based-testing"},{"value":"Исследовательское тестирование (Exploratory testing)","anchor":"#исследовательское-тестирование-exploratory-testing"},{"value":"Свободное (интуитивное) тестирование (Ad hoc testing)","anchor":"#свободное-интуитивное-тестирование-ad-hoc-testing"}]}},{"node":{"id":"fa6ab5603ef4a246c3b2032ef671cd3a","title":"Виды тестирования по техникам и подходам","content":"\n## Классификация по принципам работы с приложением\n- Позитивное\n- Негативное\n\n## Тестирование на основе опыта тестировщика, сценариев, чек-листов\n- Исследовательское\n- Свободное(интуитивное)\n\n## Классификация по степени вмешательства в работу приложения\n### Инвазивное тестирование (Intrusive testing)\nТестирование, выполнение которого может повлиять на функционирование приложения в силу работы инструментов тестирования (например, будут искажены показатели производительности) или в силу вмешательства (level of intrusion) в сам код приложения (например, для анализа работы приложения было добавлено дополнительное протоколирование, включён вывод отладочной информации и т.д.) \n\nНекоторые источники рассматривают инвазивное тестирование как форму негативного или даже стрессового тестирования.\n\n### Неинвазивное тестирование (Nonintrusive testing)\nТестирование, выполнение которого незаметно для приложения и не влияет на процесс его обычной работы.\n\n## Классификация по техникам автоматизации:\n### Тестирование под управлением данными ( Data-driven testing)\nCпособ разработки автоматизированных тест-кейсов, в котором входные данные и ожидаемые результаты выносятся за пределы тест-кейса и хранятся вне его — в файле, базе данных и т. д.\n\n### Тестирование под управлением ключевыми словами (Keyword-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором за пределы тест-кейса выносится не только набор входных данных и ожидаемых результатов, но и логика поведения тест-кейса, которая описывается ключевыми словами (командами).\n\n### Тестирование под управлением поведением (Behavior-driven testing)\nСпособ разработки автоматизированных тест-кейсов, в котором основное внимание уделяется корректности работы бизнес-сценариев, а не отдельным деталям функционирования приложения.\n\n## Классификация на основе(знания) источников ошибок\n### Тестирование предугадыванием ошибок (Error guessing)\nТехника тестирования, в которой тесты разрабатываются на основе опыта тестировщика и его знаний о том, какие дефекты типичны для тех или иных компонентов или областей функциональности приложения. \n\nМожет комбинироваться с техникой т.н. «ошибкоориентированного» тестирования (failure-directed testing), в котором новые тесты строятся на основе информации о ранее обнаруженных в приложении проблемах.\n\n### Эвристическая оценка (Heuristic evaluation)\nТехника тестирования удобства использования, направленная на поиск проблем в интерфейсе пользователя, представляющих собой отклонение от общепринятых норм.\n\n### Мутационное тестирование (Mutation testing)\n Nехника тестирования, в которой сравнивается поведение нескольких версий одного и того же компонента, причём часть таких версий может быть специально разработана с добавлением ошибок (что позволяет оценить эффективность тест-кейсов — качественные тесты обнаружат эти специально добавленные ошибки). \n\nМожет комбинироваться со следующим в этом списке видом тестирования (тестированием добавлением ошибок).\n\n### Тестирование добавлением ошибок (Error seeding)\nТехника тестирования, в которой в приложение специально добавляются заранее известные, специально продуманные ошибки с целью мониторинга их обнаружения и устранения и, таким образом, формирования более точной оценки показателей процесса тестирования. \n\nМожет комбинироваться с предыдущим в этом списке видом тестирования (мутационным тестированием).\n\n## Классификация на основе выбора входных данных или спецификаций\n### Тестирование на основе классов эквивалентности (Equivalence partitioning)\nТехника тестирования, направленная на сокращение количества разрабатываемых и выполняемых тест-кейсов при сохранении достаточного тестового покрытия. \n\nСуть техники состоит в выявлении наборов эквивалентных тест-кейсов (каждый из которых проверяет одно и то же поведение приложения) и выборе из таких наборов небольшого подмножества тест-кейсов, с наибольшей вероятностью обнаруживающих проблему.\n\n### Тестирование на основе граничных условий (Boundary value analysis)\nИнструментальная техника тестирования на основе классов эквивалентности, позволяющая выявить специфические значения исследуемых параметров, относящиеся к границам классов эквивалентности. \n\nЭта техника значительно упрощает выявление наборов эквивалентных тест-кейсов и выбор таких тест-кейсов, которые обнаружат проблему с наибольшей вероятностью.\n\n### Доменное тестирование (Domain analysis, Domain testing)\nТехника тестирования на основе классов эквивалентности и граничных условий, позволяющая эффективно создавать тест-кейсы, затрагивающие несколько параметров (переменных) одновременно (в том числе с учётом взаимозависимости этих параметров). \n\nДанная техника также описывает подходы к выбору минимального множества показательных тест-кейсов из всего набора возможных тест-кейсов.\n\n### Попарное тестирование (Pairwise testing)\nТехника тестирования, в которой тест-кейсы строятся по принципу проверки пар значений параметров (переменных) вместо того, чтобы пытаться проверить все возможные комбинации всех значений всех параметров. Эта техника является частным случаем N-комбинационного тестирования (n-wise testing) и позволяет существенно сократить трудозатраты на тестирование (а иногда и вовсе сделать возможным тестирование в случае, когда количество «всех комбинаций всех значений всех параметров» измеряется миллиардами).\n\nПопарное тестирование (pairwise testing) — это НЕ парное тестирование (pair testing)!\n\n### Тестирование на основе ортогональных массивов (Orthogonal array testing)\nИнструментальная техника попарного и N-комбинационного тестирования, основанная на использовании т.н. «ортогональных массивов» (двумерных массивов, обладающих следующим свойством: если взять две любые колонки такого массива, то получивший- ся «подмассив» будет содержать все возможные попарные комбинации значений, представленных в исходном массиве).\n\n## Классификация на основе среды выполнения\n### Тестирование в процессе разработки (Development testing)\nТестирование, выполняемое непосредственно в процессе разработки приложения и/или в среде выполнения, отличной от среды реального использования приложения. Как правило, выполняется самими разработчиками.\n\n### Операционное тестирование\n\n## Тестирование на основе кода (Code based testing)\nВ различных источниках эту технику называют по-разному (чаще всего — тестированием на основе структур, причём некоторые авторы смешивают в один набор тестирование по потоку управления и по потоку данных, а некоторые строго разделяют эти стратегии). \n\nПодвиды этой техники также организуют в разные комбинации, но наиболее универсально их можно классифицировать так:\n\n- **_Тестирование по потоку управления (Control flow testing)_**\nСемейство техник тестирования, в которых тест-кейсы разрабатываются с целью активации и проверки выполнения различных последовательностей событий, которые определяются посредством анализа исходного кода приложения. \n\n- **_Тестирование по потоку данных (Data-flow testing)_**\nСемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных.\n\n- **_Тестирование по диаграмме или таблице состояний (State transition testing)_**\nТехника тестирования, в которой тест-кейсы разрабатываются для проверки переходов приложения из одного состояния в другое. Состояния могут быть описаны диаграммой состояний (state diagram) или таблицей состояний (state table).\n\nИногда эту технику тестирования также называют «тестированием по принципу конечного автомата» (finite state machine testing). \nВажным преимуществом этой техники является возможность применения в ней теории конечных автоматов (которая хорошо формализована), а также возможность использования автоматизации для генерации комбинаций входных данных.\n\n- **_Инспекция (аудит) кода (Code review, Code inspection)_**\nСемейство техник повышения качества кода за счёт того, что в процессе создания или совершенствования кода участвуют несколько человек. Степень формализации аудита кода может варьироваться от достаточно беглого просмотра до тщательной формальной инспекции. \n\nВ отличие от техник статического анализа кода (по потоку управления и потоку данных) аудит кода также улучшает такие его характеристики, как понятность, поддерживаемость, соответствие соглашениям об оформлении и т.д. Аудит кода выполняется в основном самими программистами.\n\n## Тестирование на основе структур кода (Structure-based techniques)\nПредполагает возможность исследования логики выполнения кода в зависимости от различных ситуаций и включает в себя:\n\n- **_Тестирование на основе выражений (Statement testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется корректность (и сам факт) выполне- ния отдельных выражений в коде.\n\n- **_Тестирование на основе ветвей (Branch testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных ветвей кода (под ветвью понимается атомарная часть кода, выполнение которой происходит или не происходит в зависимости от истинности или ложности некоторого условия).\n\n- **_Тестирование на основе условий (Condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение отдельных условий (условием считается выражение, которое может быть вычислено до значения «истина» или «ложь»).\n\n- **_Тестирование на основе комбинаций условий(Multiple condition testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных (составных) условий.\n\n- **_Тестирование на основе отдельных условий, порождающих ветвление («решающих условий») (Modified condition decision coverage testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение таких отдельных условий в составе сложных условий, которые в одиночку определяют результат вычисления всего сложного условия.\n\n- **_Тестирование на основе решений (decision testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение сложных ветвлений (с двумя и более возможными вариантами). Несмотря на то что «два варианта» сюда также подходит, формально такую ситуацию стоит отнести к тестированию на основе условий.\n\n- **_Тестирование на основе путей (path testing)_**\nТехника тестирования (по методу белого ящика), в которой проверяется выполнение всех или некоторых специально выбранных путей в коде приложения.\n\nЕсли говорить строго научно, то определения большинства видов тестирования на основе структур кода должны звучать чуть-чуть иначе, т.к. в программировании условием считается выражение без логических операторов, а решением — выражение с логическими операторами. Но глоссарий ISTQB не делает на этом акцента, а потому приведённые выше определения можно считать корректными.\n\n## Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)\n### Тестирование по таблице принятия решений (Decision table testing)\nтехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе т.н. таблицы принятия решений, в которой отражены входные данные (и их комбинации) и воздействия на приложение, а также соответствующие им выходные данные и реакции приложения.\n\n### Тестирование по диаграмме или таблице состояний\n\n### Тестирование по спецификациям (Specification-based testing, black box testing)\n\n### Тестирование по моделям поведения приложения (Model-based testing)\nТехника тестирования, в которой исследование приложения (и разработка тест-кейсов) строится на некой модели: таблице принятия решений, таблице или диаграмме состояний, пользовательских сценариев, модели нагрузки и т. д.\n\n### Тестирование на основе вариантов использования (Use case testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе вариантов использования. Варианты использования выступают в основном источником информации для шагов тест-кейса, в то время как наборы входных данных удобно разрабатывать с помощью техник выбора входных данных. \n\nВ общем случае источником информации для разработки тест-кейсов в этой технике могут выступать не только варианты использования, но и другие пользовательские требования в любом их виде. \n\nВ случае если методология разработки проекта подразумевает использование пользовательских историй, этот вид тестирования может быть заменён тестированием на основе пользовательских историй (user story testing).\n\n### Параллельное тестирование (Parallel testing)\nТехника тестирования, в которой поведение нового (или модифицированного) приложения сравнивается с поведением эталонного приложения (предположительно работающего верно). \n\nТермин «параллельное тестирование» также может использоваться для обозначения способа проведения тестирования, когда несколько тестировщиков или систем автоматизации выполняют работу одновременно, т. е. параллельно. Очень редко (и не совсем верно) под парал- лельным тестированием понимают мутационное тестирование.\n\n### Тестирование на основе случайных данных (Random testing)\nТехника тестирования (по методу чёрного ящика), в которой входные данные, действия или даже сами тест-кейсы выбираются на основе (псевдо)случайных значений так, чтобы соответствовать операционному профилю (operational profile) — подмножеству действий, соответствующих некоей ситуации или сценарию работы с приложением. Не стоит пу- тать этот вид тестирования с т.н. «обезьяньим тестированием» (monkey testing).\n\n### A/B-тестирование (A/B testing, Split testing)\nТехника тестирования, в которой исследуется влияние на результат выполнения операции изменения одного из входных параметров. Однако куда чаще можно встретить трактовку A/B-тестирования как технику тестирования удобства использования, в которой пользователям случайным образом предлагаются разные варианты элементов интерфейса, после чего оценивается разница в реакции пользователей.\n\n## Тестирование на основе дерева классификаций(Classification tree method)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе иерархически организованных наборов эквивалентных входных и выходных данных.\n\n## Тестирование на основе синтаксиса (Syntax testing)\nТехника тестирования (по методу чёрного ящика), в которой тест-кейсы создаются на основе определения наборов входных и выходных данных.\n\n## Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)\nСпособ выбрать подходящий набор комбинаций тестовых данных для достижения установленного уровня тестового покрытия в случае, когда проверка всех возможных наборов значений тестовых данных невозможна за имеющееся время. \n\nСуществуют следующие комбинаторные техники:\n- Тестирование всех комбинаций (All combinations testing)\nтестирование всех воз- можных комбинаций всех значений всех тестовых данных (например, всех параметров функции).\n\n- Попарное тестирование\n\n- Тестирование с выбором значений-представителей (Each choice testing)\nтестирование, при котором по одному значению из каждого набора тестовых данных должно быть использовано хотя бы в одном тест-кейсе.\n\n- Тестирование с выбором базового набора значений (Base choice testing)\nтестирование, при котором выделяется набор значений (базовый набор), который используется для проведения тестирования в первую очередь, а далее тест-кейсы строятся на основе выбора всех базовых значений, кроме одного, которое заменяется значением, не входящим в базовый набор.\n\n## Тестирование по графу причинно-следственных связей (Cause-effect graphing)\nтех- ника тестирования (по методу чёрного ящика), в которой тест-кейсы разрабатываются на основе графа причинно-следственных связей (графического представления входных дан- ных и воздействий со связанными с ними выходными данными и эффектами).\n\n## Тестирование по потоку данных (Data-flow testing)\nсемейство техник тестирования, основанных на выборе отдельных путей из потока управления с целью исследования событий, связанных с изменением состояния переменных. \n\nЭти техники позволяют обнаружить такие ситуации, как: \n- переменная определена, но нигде не используется;\n- переменная используется, но не определена; \n- переменная определена несколько раз до того, как она используется;\n- переменная удалена до последнего случая использования.\n\nЗдесь придётся немного погрузиться в теорию. Над переменной в общем случае может выполняться несколько действий (покажем на примере переменной x):\n- объявление (declaration): `int x;`\n- определение (definition, d-use): `x = 99;`\n- использование в вычислениях (computation use, c-use): `z = x + 1;` \n- использование в условиях (predicate use, p-use): `if (x > 17) { ... }; - удаление (kill, k-use): x = null;`\n\nТеперь можно рассмотреть техники тестирования на основе потока данных.\n\n- **_Проверка использования всех объявлений (All-definitions testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от её определения к её использованию в вычислениях или условиях.\n\n- **_Проверка всех вычислений на основе всех объявлений (All-c-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в вычислениях.\n\n- **_Проверка всех ветвлений на основе всех объявлений (All-p-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует путь от каждого её определения к её использованию в условиях.\n\n- **_Проверка всех вычислений и ветвлений на основе всех объявлений (All-uses testing)_**\nТестовым набором проверяется, что для каждой переменной существует хотя бы один путь от каждого её определения к каждому её использованию в вычислениях и в условиях.\n\n- **_Проверка использования всех объявлений и всех путей без переобъявлений (без циклов или с однократными повторениями циклов) (All-du-paths testing)_**\nТестовым набором для каждой переменной проверяются все пути от каждого её определения к каждому её использованию в вычислениях и в условиях (самая мощная стратегия, которая в то же время требует наибольшего количества тест-кейсов).","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-tehnikam-i-podhodam/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Классификация по принципам работы с приложением","anchor":"#классификация-по-принципам-работы-с-приложением"},{"value":"Тестирование на основе опыта тестировщика, сценариев, чек-листов","anchor":"#тестирование-на-основе-опыта-тестировщика-сценариев-чек-листов"},{"value":"Классификация по степени вмешательства в работу приложения","anchor":"#классификация-по-степени-вмешательства-в-работу-приложения"},{"value":"Классификация по техникам автоматизации:","anchor":"#классификация-по-техникам-автоматизации"},{"value":"Классификация на основе(знания) источников ошибок","anchor":"#классификация-на-основезнания-источников-ошибок"},{"value":"Классификация на основе выбора входных данных или спецификаций","anchor":"#классификация-на-основе-выбора-входных-данных-или-спецификаций"},{"value":"Классификация на основе среды выполнения","anchor":"#классификация-на-основе-среды-выполнения"},{"value":"Тестирование на основе кода (Code based testing)","anchor":"#тестирование-на-основе-кода-code-based-testing"},{"value":"Тестирование на основе структур кода (Structure-based techniques)","anchor":"#тестирование-на-основе-структур-кода-structure-based-techniques"},{"value":"Тестирование на основе (моделей) поведения приложения (Application behavior/model-based testing)","anchor":"#тестирование-на-основе-моделей-поведения-приложения-application-behaviormodel-based-testing"},{"value":"Тестирование на основе дерева классификаций(Classification tree method)","anchor":"#тестирование-на-основе-дерева-классификацийclassification-tree-method"},{"value":"Тестирование на основе синтаксиса (Syntax testing)","anchor":"#тестирование-на-основе-синтаксиса-syntax-testing"},{"value":"Комбинаторные техники или комбинаторное тестирование (Combinatorial testing)","anchor":"#комбинаторные-техники-или-комбинаторное-тестирование-combinatorial-testing"},{"value":"Тестирование по графу причинно-следственных связей (Cause-effect graphing)","anchor":"#тестирование-по-графу-причинно-следственных-связей-cause-effect-graphing"},{"value":"Тестирование по потоку данных (Data-flow testing)","anchor":"#тестирование-по-потоку-данных-data-flow-testing"}]}},{"node":{"id":"87e6479b2012383b83d0a579ff55f68e","title":"Виды тестирования по моменту выполнения (хронологии)","content":"\nНесмотря на многочисленные попытки создать единую хронологию тестирования, предпринятые многими авторами, по-прежнему можно смело утверждать, что общепринятого решения, которое в равной степени подходило бы для любой методологии управления проектами, любого отдельного проекта и любой его стадии, просто не существует.\n\nЕсли попытаться описать хронологию тестирования одной общей фразой, то можно сказать, что происходит постепенное наращивание сложности самих тест-кейсов и сложности логики их выбора.\n\n## Общая универсальная логика последовательности тестирования \nСостоит в том, чтобы начинать исследование каждой задачи с простых позитивных тест-кейсов, к которым постепенно добавлять негативные (но тоже достаточно простые). Лишь после того, как наиболее типичные ситуации покрыты простыми тест-кейсами, следует переходить к более сложным (опять же, начиная с позитивных). \n\nТакой подход — не догма, но к нему стоит прислушаться, т. к. углубление на начальных этапах в негативные (к тому же — сложные) тест-кейсы может привести к ситуации, в которой приложение отлично справляется с кучей неприятностей, но не работает на элементарных повседневных задачах.\n\nЕщё раз суть универсальной последовательности:\n1) простое позитивное тестирование; \n2) простое негативное тестирование; \n3) сложное позитивное тестирование; \n4) сложное негативное тестирование.\n\n## Последовательность тестирования, построенная по иерархии компонентов\n### Восходящее тестирование (Bottom-up testing)\nинкрементальный подход к интеграционному тестированию, в котором в первую очередь тестируются низкоуровневые компоненты, после чего процесс переходит на всё более и более высокоуровневые\nкомпоненты.\n\n### Нисходящее тестирование (Top-down testing)\nинкрементальный подход к интеграционному тестированию, в котором в первую очередь тестируются высокоуровневые компоненты, после чего процесс переходит на всё более и более низкоуровневые компоненты.\n\n### Гибридное тестирование (hybrid testing)\nкомбинация восходящего и нисходящего тестирования, позволяющая упростить и ускорить получение результатов оценки приложения.\n\nПоскольку термин «гибридное» является синонимом «комбинированное», под «гибридным тестированием» может пониматься практически любое сочетание двух и более видов, техник или подходов к тестированию. Всегда уточняйте, о гибриде чего именно идёт речь.\n\n## Последовательность тестирования, построенная по концентрации внимания на требованиях и их составляющих\n\n1) Тестирование требований, которое может варьироваться от беглой оценки в стиле «всё ли нам понятно» до весьма формальных подходов, в любом случае первично по отношению к тестированию того, как эти требования реализованы.\n\n2) Тестирование реализации функциональных составляющих требований логично прово- дить до тестирования реализации нефункциональных составляющих, т. к. если что-то просто не работает, то проверять производительность, безопасность, удобство и прочие нефункциональные составляющие бессмысленно, а чаще всего и вовсе невозможно.\n\n3) Тестирование реализации нефункциональных составляющих требований часто ста- новится логическим завершением проверки того, как реализовано то или иное требование.\n\n## Типичные общие сценарии \nиспользуются в том случае, когда не существует явных пред-посылок к реализации иной стратегии. Такие сценарии могут видоизменяться и комбинироваться (например, весь «типичный общий сценарий 1» можно повторять на всех шагах «типичного общего сценария 2»).\n\n- Типичный общий сценарий 1\n1) Дымовое тестирование.\n2) Тестирование критического пути.\n3) Расширенное тестирование.\n\n- Типичный общий сценарий 2:\n1) Модульное тестирование.\n2) Интеграционное тестирование. \n3) Системное тестирование.\n\n- Типичный общий сценарий 3:\n1) Альфа-тестирование. \n2) Бета-тестирование. \n3) Гамма-тестирование.","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-momentu-vypolneniya-hronologii/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Общая универсальная логика последовательности тестирования","anchor":"#общая-универсальная-логика-последовательности-тестирования"},{"value":"Последовательность тестирования, построенная по иерархии компонентов","anchor":"#последовательность-тестирования-построенная-по-иерархии-компонентов"},{"value":"Последовательность тестирования, построенная по концентрации внимания на требованиях и их составляющих","anchor":"#последовательность-тестирования-построенная-по-концентрации-внимания-на-требованиях-и-их-составляющих"},{"value":"Типичные общие сценарии","anchor":"#типичные-общие-сценарии"}]}},{"node":{"id":"70e0d151c7184eae567a2d2834d89139","title":"Другие виды тестирования","content":"\nВообще виды тестирования можно классифицировать по самым разным критериям, поэтому можно встретить и такие схемы:\n\n![](http://habrastorage.org/files/bd6/dcb/bb7/bd6dcbbb7d7c44a485b65ae29b4c0ae4.png)\n\n![](https://camo.githubusercontent.com/ed9d0730f15e3d205bb59eb8fdb36312587304818cb39f519a4ee1c2fc1cdc36/68747470733a2f2f7777772e65766b6f76612e6f72672f65766b6f766175706c6f61642f6a6f622f3134343437362f322e706e67)\n\n![](https://camo.githubusercontent.com/742df04d9e28c9d20777e09e08413a16b2757a94b945b41cd84692ff1d16bce1/68747470733a2f2f7374617469632e74696c646163646e2e636f6d2f74696c64333133372d363336342d343833342d623733382d3335333536353632363433382f70686f746f2e706e67)\n","date":"2022-05-16T00:00:00.000Z","path":"/drugie-vidy-testirovaniya/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[]}},{"node":{"id":"717bdc01f4e7bb344e50326f8240fcd0","title":"Виды тестирования по целям и задачам","content":"\n## Классификация\n\n- Функциональное(«Что?» - проверяет весь функционал продукта)\n  - Тестирование данных\n  - Приемочное тестирование\n  - Операционное тестирование\n  - Тестирование пользовательского интерфейса (GUI Testing)\n\n- Нефункциональное(«Как?»)\n  - Тестирование производительности\n  - Нагрузочное тестирование\n  - Стрессовое тестирование\n  - Тестирование масштабируемости\n  - Объемное тестирование\n  - Тестирование надежности\n  - Тестирование восстанавливаемости\n  - Тестирование отказоустойчивости\n  - Тестирование безопасности\n  - Тестирование удобства использования\n  - Тестирование доступности -\n  - Тестирование совместимости\n  - Тестирование интернационализации\n  - Тестирование локализации\n  - Инсталяционное (тестирование установки)\n  - Конфигурационное тестирование -\n  - Конкурентное тестирование - \n  - Тестирование использоваиня ресурсов - \n  - Сравнительное тестирование - \n\n- Связанные с изменениями \n  - Дымовое\n  - Регрессионное\n  - Тестирвание сборки\n  - Санитарное тестирование\n  - Повторное тестирование\n\n## Функциональное тестирование (Functional/Behavioral testing)\nВид тестирования, направленный на проверку корректности работы функциональности приложения (корректность реализации функциональных требований). \n\nЧасто функциональное тестирование ассоциируют с тестированием по методу чёрного ящика, однако и по методу белого ящика вполне можно проверять корректность реализации функциональности.\n\nЧасто возникает вопрос, в чём разница между функциональным тестированием (functional testing) и тестированием функциональности (functionality testing).\n\nЕсли вкратце, то:\n- **_функциональное тестирование_** (как антоним нефункционального) направлено на проверку того, какие функции приложения реализованы, и что они работают верным образом;\n- **_тестирование функциональности_** направлено на те же задачи, но акцент смещён в сторону исследования приложения в реальной рабочей среде, после локализации и в тому подобных ситуациях.\n\n**Для функционального тестирования принято использовать две техники**:\n\n* Тестирование на основе требований: содержит все функциональные спецификации, которые составляют основу для всех тестов, которые будут проводиться;\n* Тестирование на основе бизнес-сценариев: содержит информацию о том, как система будет восприниматься с точки зрения бизнес-процесса;\n\n**Основные виды функционального тестирования**:\n\n- Юнит тестирование (Unit Testing)\n- Дымовое тестирование (Smoke Testing)\n- Санитарное тестирование (Sanity Testing)\n- Интеграционное тестирование (Integration Tests),\n- Бета тестирование (Beta Testing)\n- Системное тестирование (System testing)\n- End to end testing\n- Тестирование пользовательского интерфейса (GUI Testing)\n\n### Регрессионное тестирование (Regression testing)\nТестирование, направленное на проверку того факта, что в ранее работоспособной функциональности не появились ошибки, вызванные изменениями в приложении или среде его функционирования. \n\nФредерик Брукс в своей книге «Мифический человеко-месяц» писал: «Фундаментальная проблема при сопровождении программ состоит в том, что исправление одной ошибки с большой вероятностью (20–50 %) влечёт появление новой». Потому регрессионное тестирование является неотъемлемым инструментом обеспечения качества и активно используется практически в любом проекте.\n\n### Повторное тестирование (Re-testing, confirmation testing)\nВыполнение тест-кейсов, которые ранее обнаружили дефекты, с целью подтверждения устранения дефектов. \n\nФактически этот вид тестирования сводится к действиям на финальной стадии жизненного цикла отчёта о дефекте, направленным на то, чтобы перевести дефект в состояние «проверен» и «закрыт».\n\n### Приёмочное тестирование (Acceptance testing)\nФормализованное тестирование, направленное на проверку приложения с точки зрения конечного пользователя/заказчика и вынесения решения о том, принимает ли заказчик работу у исполнителя (проектной команды).\n\nМожно выделить следующие подвиды приёмочного тестирования (хотя упоминают их крайне редко, ограничиваясь в основном общим термином «приёмочное тестирование»):\n\n- **_Производственное приёмочное тестирование (Factory acceptance testing)_**  \nВыполняемое проектной командой исследование полноты и качества реализации приложения с точки зрения его готовности к передаче заказчику. Этот вид тестирования часто рассматривается как синоним альфа-тестирования.\n\n- **_Операционное приёмочное тестирование (Operational acceptance testing, production acceptance testing)_** \nОперационное тестирование, выполняемое с точки зрения выполнения инсталляции, потребления приложением ресурсов, совместимости с про- граммной и аппаратной платформой и т. д.\n\n- **_Итоговое приёмочное тестирование (Site acceptance testing)_**  \nТестирование конечными пользователями (представителями заказчика) приложения в реальных условиях эксплуатации с целью вынесения решения о том, требует ли приложение доработок или может быть принято в эксплуатацию в текущем виде.\n\n### Операционное тестирование (Operational testing)\nТестирование, проводимое в реальной или приближенной к реальной операционной среде (operational environment), включающей операционную систему, системы управления базами данных, серверы приложений, веб-серверы, аппаратное обеспечение и т. д.\n\n### Тестирование интерфейса (Interface testing)\nТестирование, направленное на проверку интерфейсов приложения или его компонентов. \n\nПо определению ISTQB-глоссария этот вид тестирования относится к интеграционному тестированию, и это вполне справедливо для таких его вариаций как тестирование интерфейса прикладного программирования (API testing182) и интерфейса командной строки (CLI testing), хотя последнее может выступать и как разновидность тестирования пользовательского интерфейса, если через командную строку с приложением взаимодействует пользователь, а не другое приложение. Однако многие источники предлагают включить в состав тестирования интерфейса и тестирование непосредственно интерфейса пользователя (GUI testing).\n\n## Нефункциональное тестирование (Non-Functional testing)\n\nВид тестирования, направленный на проверку нефункциональных особенностей приложения (корректность реализации нефункциональных требований), таких как удобство использования, совместимость, производительность, безопасность и т.д.\n\nВ большинстве случаев это выполняется методом black box testing. Оно проверяет, соответствует ли поведение системы требованиям по всем аспектам, не охваченные функциональным тестированием. \n\nВ нашем повседневном тестировании много внимания уделяется функциональному тестированию и функциональным требованиям и клиенты также заинтересованы в выполнении функциональных требований, которые напрямую связаны с функциональностью приложения, но когда ПО выходит на рынок и используется реальными конечными пользователями, у них есть шансы столкнуться с проблемами. Эти проблемы не связаны с функциональностью системы, но могут негативно повлиять на пользовательский опыт.\n\n**Нефункциональные требования могут быть отражены как**:\n\n* Пользовательские / Технические истории (User /Technical Stories): запись нефункциональных требований в виде пользовательской истории такая же, как и запись любых других требований. Единственная разница между пользователем и технической историей заключается в том, что пользовательская история требует обсуждения и имеет видимость (? visibility);\n* В критериях приемки (Acceptance criteria): это точка, которая определяется для принятия продукта заказчиком. Нефункциональное требование должно быть включено в критерии приемки, но иногда невозможно проверить нефункциональные требования с каждой историей, то есть с каждой итерацией. Следовательно, требования следует добавлять или тестировать только с соответствующей итерацией;\n* В артефактах (Artifact): для нефункциональных требований следует подготовить отдельный артефакт, это, в свою очередь, поможет лучше понять, что нужно тестировать и как это можно делать в итерациях;\n\n### Инсталляционное тестирование (Installation testing, Installability testing)\nТестирование, направленное на выявление дефектов, влияющих на протекание стадии инсталляции (установки) приложения. \n\nВ общем случае такое тестирование проверяет множество сценариев и аспектов работы инсталлятора в таких ситуациях, как:\n- новая среда исполнения, в которой приложение ранее не было инсталлировано;\n- обновление существующей версии(«апгрейд»);\n- изменение текущей версии на более старую(«даунгрейд»);\n- повторная установка приложения с целью устранения возникших проблем («переинсталляция»);\n- повторный запуск инсталляции после ошибки, приведшей к невозможности продолжения инсталляции;\n- удаление приложения;\n- установка нового приложения из семейства приложений;\n- автоматическая инсталляция без участия пользователя.\n\n### Тестирование удобства использования (Usability testing)\nТестирование, направленное на исследование того, насколько конечному пользователю понятно, как работать с продуктом (understandability, learnability, operability), а также на то, насколько ему нравится использовать продукт (attractiveness). И это не оговорка — очень часто успех продукта зависит именно от эмоций, которые он вызывает у пользователей. \n\nДля эффективного проведения этого вида тестирования требуется реализовать достаточно серьёзные исследования с привлечением конечных пользователей, проведением маркетинговых исследований и т. д.\n\nТестирование удобства использования (usability testing) и тестирование интерфейса пользователя (GUI testing) — не одно и то же! \nНапример, корректно работающий интерфейс может быть неудобным, а удобный может работать некорректно.\n\n### Тестирование доступности (Accessibility testing)\nТестирование, направленное на исследование пригодности продукта к использованию людьми с ограниченными возможностями (слабым зрением и т.д.)\n\n### Тестирование безопасности (Security testing)\nТестирование, направленное на проверку способности приложения противостоять злонамеренным попыткам получения доступа к данным или функциям, права на доступ к которым у злоумышленника нет.\n\nПроверяется:\n\n* Аутентификация (Authentication): только достоверный пользователь может войти в систему;\n* Авторизация (Authorized): пользователь должен иметь возможность входить в те модули, для которых он авторизован или к которым пользователю был предоставлен доступ;\n* Пароль: Требование пароля должно быть подтверждено, т.е. пароль должен соответствовать тому, как это требование определяется, то есть длине, специальным символам, числам и т. д.;\n* Тайм-аут: если приложение неактивно, оно должно истечь по таймауту в указанное время;\n* Резервное копирование данных: резервное копирование данных должно быть выполнено в указанное время и данные должны быть скопированы в безопасное место;\n* Внутренние ссылки на веб-приложение не должны быть доступны, если размещены непосредственно в браузере;\n* Вся коммуникация должна быть зашифрована;\n\n### Тестирование интернационализации (Internationalization testing, I18n testing, Globalization testing, Localizability testing)\nТестирование, направленное на проверку готовности продукта к работе с использованием различных языков и с учётом различных национальных и культурных особенностей. \n\nЭтот вид тестирования не подразумевает проверки качества соответствующей адаптации (этим занимается тестирование локализации, см. следующий пункт), оно сфокусировано именно на проверке возможности такой адаптации (например: что будет, если открыть файл с иероглифом в имени; как будет работать интерфейс, если всё перевести на японский; может ли приложение искать данные в тексте на корейском и т. д.).\n\n### Тестирование локализации (Localization testing, L10n)\nТестирование, направленное на проверку корректности и качества адаптации продукта к использованию на том или ином языке с учётом национальных и культурных особенностей. \n\nЭто тестирование следует за тестированием интернационализации (см. предыдущий пункт) и проверяет корректность перевода и адаптации продукта, а не готовность продукта к таким действиям.\n\n### Тестирование совместимости (Compatibility testing, Interoperability testing)\nТестирование, направленное на проверку способности приложения работать в указанном окружении. \n\nЗдесь, например, может проверяться:\n- Совместимость с аппаратной платформой, операционной системой и сетевой инфраструктурой (конфигурационное тестирование, configuration testing).\n- Совместимость с браузерами и их версиями (кросс-браузерное тестирование, cross-browser testing).\n- Совместимость с мобильными устройствами (mobile testing).\n- И так далее.\n\nВ некоторых источниках к тестированию совместимости добавляют (хоть и подчёркивая, что это — не его часть) т.н. тестирование соответствия (compliance testing, conformance testing, regulation testing).\n\n### Тестирование данных (Data quality testing) и баз данных (Database integrity testing)\nДва близких по смыслу вида тестирования, направленных на исследование таких характеристик данных, как полнота, непротиворечивость, целостность, структурированность и т. д. \n\nВ контексте баз данных исследованию может подвергаться адекватность модели предметной области, способность модели обеспечивать целостность и консистентность данных, корректность работы триггеров, хранимых процедур и т.д.\n\n### Тестирование использования ресурсов (Resource utilization testing, Efficiency testing, Storage testing)\nСовокупность видов тестирования, проверяющих эффективность использования приложением доступных ему ресурсов и зависимость результатов работы приложения от количества доступных ему ресурсов. Часто эти виды тестирования прямо или косвенно примыкают к техникам тестирования производительности.\n\n### Сравнительное тестирование (Comparison testing)\nТестирование, направленное на сравнительный анализ преимуществ и недостатков разрабатываемого продукта по отношению к его основным конкурентам.\n\n### Демонстрационное тестирование (Qualification testing)\nФормальный процесс демонстрации заказчику продукта с целью подтверждения, что продукт соответствует всем заявленным требованиям. В отличие от приёмочного тестирования этот процесс более строгий и всеобъемлющий, но может проводиться и на промежуточных стадиях разработки продукта.\n\n### Избыточное тестирование (Exhaustive testing)\nТестирование приложения со всеми возможными комбинациями всех возможных входных данных во всех возможных условиях выполнения. Для сколь бы то ни было сложной системы нереализуемо, но может применяться для проверки отдельных крайне простых компонентов.\n\n### Тестирование надёжности (Reliability testing)\nТестирование способности приложения выполнять свои функции в заданных условиях на протяжении заданного времени или заданного количества операций.\n\n### Тестирование восстанавливаемости (Recoverability testing)\nТестирование способности приложения восстанавливать свои функции и заданный уровень производительности, а также восстанавливать данные в случае возникновения критической ситуации, приводящей к временной (частичной) утрате работоспособности приложения.\n\n### Тестирование отказоустойчивости (Failover testing)\nТестирование, заключающееся в эмуляции или реальном создании критических ситуаций с целью проверки способности приложения задействовать соответствующие механизмы, предотвращающие нарушение работоспособности, производительности и повреждения данных.\n\n### Тестирование производительности (Performance testing)\nИсследование показателей скорости реакции приложения на внешние воздействия при различной по характеру и интенсивности нагрузке. \n\nПроверяется:\n* Время отклика (The response time) приложения, то есть сколько времени требуется для загрузки приложения, за какое время любой ввод, предоставленный приложению, обеспечивает вывод, время обновления браузера и т. д.;\n* Пропускную способность (Throughput) следует проверять по количеству транзакций, завершенных во время нагрузочного теста;\n* Настройка среды (Environment) должна быть такой же, как и в реальной среде, иначе результаты не будут такими же;\n* Время процесса (Process time) - такие действия, как импорт и экспорт Excel, любые вычисления в приложении должны быть протестированы;\n* Совместимость (Interoperability) должна быть проверена, т.е. программное обеспечение должно иметь возможность взаимодействовать с другим программным обеспечением или системами;\n* Необходимо проверить время ETL, то есть время, затраченное на извлечение, преобразование и загрузку данных из одной базы данных в другую;\n* Необходимо проверить возрастающую нагрузку (Load) на приложение;\n\nВ рамках тестирования производительности выделяют следующие подвиды:\n\n- **_Нагрузочное тестирование (Load testing, Capacity testing)_**\nИсследование способности приложения сохранять заданные показатели качества при нагрузке в допустимых пределах и некотором превышении этих пределов (определение «запаса прочности»).\n\n- **_Тестирование масштабируемости (Scalability testing)_**\nИсследование способности приложения увеличивать показатели производительности в соответствии с увеличением количества доступных приложению ресурсов.\n\n- **_Объёмное тестирование (Volume testing)_**\nИсследование производительности приложения при обработке различных (как правило, больших) объёмов данных.\n\n- **_Стрессовое тестирование (Stress testing)_**\nИсследование поведения приложения при нештатных изменениях нагрузки, значительно превышающих расчётный уровень, или в ситуациях недоступности значительной части необходимых приложению ресурсов. Стрессовое тестирование может выполняться и вне контекста нагрузочного тестирования: тогда оно, как правило, называется «тестированием на разрушение» (destructive testing) и представляет собой крайнюю форму негативного тестирования.\n\n- **_Конкурентное тестирование (Concurrency testing)_**\nИсследование поведения приложения в ситуации, когда ему приходится обрабатывать большое количество одновре- менно поступающих запросов, что вызывает конкуренцию между запросами за ресурсы (базу данных, память, канал передачи данных, дисковую подсистему и т. д.) \n\nИногда под конкурентным тестированием понимают также исследование работы многопоточных приложений и корректность синхронизации действий, производимых в разных потоках.\n\nВ качестве отдельных или вспомогательных техник в рамках тестирования производительности могут использоваться тестирование использования ресурсов, тестирование надёжности, тестирование восстанавливаемости, тестирование отказоустойчиво-сти и т. д.","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-czelyam-i-zadacham/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Классификация","anchor":"#классификация"},{"value":"Функциональное тестирование (Functional/Behavioral testing)","anchor":"#функциональное-тестирование-functionalbehavioral-testing"},{"value":"Нефункциональное тестирование (Non-Functional testing)","anchor":"#нефункциональное-тестирование-non-functional-testing"}]}},{"node":{"id":"8c93d8f92645182fdf93180f355bf262","title":"Виды тестирования по доступу к коду и архитектуре приложения","content":"\n## Метод белого ящика (White box testing, open box testing, clear box testing, glass box testing)\n\nУ тестировщика есть доступ к внутренней структуре и коду приложения, а также есть достаточно знаний для понимания увиденного. \n\nВыделяют даже сопутствующую тестированию по методу белого ящика глобальную технику — тестирование на основе дизайна (design-based testing). Для более глубокого изучения сути метода белого ящика рекомендуется ознакомиться с техниками исследования потока управления или потока данных, использования диаграмм состояний. \n\nНекоторые авторы склонны жёстко связывать этот метод со статическим тестированием, но ничто не мешает тестировщику запустить код на выполнение и при этом периодически обращаться к самому коду (а модульное тестирование и вовсе предполагает запуск кода на исполнение и при этом работу именно с кодом, а не с «приложением целиком»).\n\n### Преимущества\n- Показывает скрытые проблемы и упрощает их диагностику.\n- Допускает достаточно простую автоматизацию тест-кейсов и их выполнение на самых ранних стадиях развития проекта.\n- Обладает развитой системой метрик, сбор и анализ которых легко автоматизируется.\n- Стимулирует разработчиков к написанию качественного кода.\n- Многие техники этого метода являются проверенными, хорошо себя зарекомендовавшими решениями, базирующимися на строгом техническом подходе.\n\n### Недостатки\n- Не может выполняться тестировщиками, не обладающими достаточными знаниями в области программирования.\n- Тестирование сфокусировано на реализованной функциональности, что повышает вероятность пропуска нереализованных требований.\n- Поведение приложения исследуется в отрыве от реальной среды выполнения и не учитывает её влияние.\n- Поведение приложения исследуется в отрыве от реальных пользовательских сценариев.\n\n## Метод чёрного ящика (black box testing, closed box testing, specification-based testing)\n\nУ тестировщика либо нет доступа к внутренней структуре и коду приложения, либо недостаточно знаний для их понимания, либо он сознательно не обращается к ним в процессе тестирования. При этом абсолютное большинство видов тестирования работают по методу чёрного ящика, идею которого в альтернативном определении можно сформулировать так: тестировщик оказывает на приложение воздействия (и проверяет реакцию) тем же способом, каким при реальной эксплуатации приложения на него воздействовали бы пользователи или другие приложения. \n\nВ рамках тестирования по методу чёрного ящика основной информацией для создания тест-кейсов выступает документация (особенно — требования (requirements-based testing)) и общий здравый смысл (для случаев, когда поведение приложения в некоторой ситуации не регламентировано явно; иногда это называют «тестированием на основе неявных требований», но канонического определения у этого подхода нет).\n\n### Преимущества\n- Тестировщик не обязан обладать (глубокими) знаниями в области программирования.\n- Поведение приложения исследуется в контексте реальной среды выполнения и учитывает её влияние.\n- Поведение приложения исследуется в контексте реальных пользовательских сценариев.\n- Тест-кейсы можно создавать уже на стадии появления стабильных требований.\n- Процесс создания тест-кейсов позволяет выявить дефекты в требованиях.\n- Допускает создание тест-кейсов, которые можно многократно использовать на разных проектах.\n\n### Недостатки\n- Возможно повторение части тест-кейсов, уже выполненных разработчиками.\n- Высока вероятность того,что часть возможных вариантов поведения приложения останется непротестированной.\n- Для разработки высокоэффективных тест-кейсов необходима качественная\nдокументация.\n- Диагностика обнаруженных дефектов более сложна в сравнении с техниками метода белого ящика.\n- В связи с широким выбором техник и подходов затрудняется планирование и оценка трудозатрат.\n- В случае автоматизации могут потребоваться сложные дорогостоящие инструментальные средства.\n\n## Метод серого ящика (gray box testing) \n\nКомбинация методов белого ящика и чёрного ящика, состоящая в том, что к части кода и архитектуры у тестировщика доступ есть, а к части — нет. Обычно говорят о методах белого или чёрного ящика в применении к тем или иным частям приложения, при этом понимая, что «приложение целиком» тестируется по методу серого ящика.\n\nНекоторые авторы определяют метод серого ящика как противопоставление методам белого и чёрного ящика, особо подчёркивая, что при работе по методу серого ящика внутренняя структура тестируемого объекта известна частично и выясняется по мере исследования. Этот подход, бесспорно, имеет право на существование, но в своём предельном случае он вырождается до состояния «часть системы мы знаем, часть — не знаем», т. е. до всё той же комбинации белого и чёрного ящиков.\n\nСочетает преимущества и недостатки методов белого и чёрного ящика.\n\n\n\n|Вид тестирования (русскоязычное название)| Вид тестирования (англоязычное название)|Белый ящик|Чёрный ящик|\n|---|---|---|---|   \n|Статическое тестирование|Static testing|Да|Нет|\n|Динамическое тестирование|Dynamic testing|Изредка|Да|\n|Ручное тестирование|Manual testing|Мало|Да|\n|Автоматизированное тестирование|Automated testing|Да|Да|\n|Модульное (компонентное) тестирование|Unit testing, Module testing, Component testing|Да|Нет|\n|Интеграционное тестирование|Integration testing|Да|Да|\n|Системное тестирование|System testing|Мало|Да|\n|Дымовое тестирование|Smoke test, Intake test, Build verification test|Мало|Да|\n|Тестирование критического пути|Critical path test|Мало|Да|\n|Расширенное тестирование|Extended test|Мало|Да|\n|Позитивное тестирование|Positive testing|Да|Да|\n|Негативное тестирование|Negative testing, Invalid testing|Да|Да|\n|Тестирование веб-приложений|Web-applications testing|Да|Да|\n|Тестирование мобильных приложений|Mobile applications testing|Да|Да|\n|Тестирование настольных приложений|Desktop applications testing|Да|Да|\n|Тестирование уровня представления|Presentation tier testing|Мало| Да|\n|Тестирование уровня бизнес-логики|Business logic tier testing|Да |Да|\n|Тестирование уровня данных|Data tier testing|Да |Мало|\n|Альфа-тестирование|Alpha testing|Мало |Да|\n|Бета-тестирование|Beta testing|Почти никогда |Да|\n|Гамма-тестирование|Gamma testing|Почти никогда |Да|\n|Тестирование на основе тест-кейсов|Scripted testing, Test case based testing|Да |Да|\n|Исследовательское тестирование|Exploratory testing|Нет |Да|\n|Свободное (интуитивное) тестирование|Ad hoc testing|Нет |Да|\n|Функциональное тестирование|Functional testing|Да |Да|\n|Нефункциональное тестирование|Non-functional testing|Да |Да|\n|Инсталляционное тестирование|Installation testing|Изредка |Да|\n|Регрессионное тестирование|Regression testing|Да| Да|\n|Повторное тестирование|Re-testing, Confirmation testing|Да |Да|\n|Приёмочное тестирование|Acceptance testing|Крайне редко |Да|\n|Операционное тестирование|Operational testing|Крайне редко |Да|\n|Тестирование удобства использования|Usability testing|Крайне редко|Да|\n|Тестирование доступности|Accessibility testing|Крайне редко |Да|\n|Тестирование интерфейса|Interface testing|Да| Да|\n|Тестирование безопасности|Security testing|Да |Да|\n|Тестирование интернационализации|Internationalization testing|Мало|Да|\n|Тестирование локализации|Localization testing|Мало| Да|\n|Тестирование совместимости|Compatibility testing|Мало |Да|\n|Конфигурационное тестирование|Configuration testing|Мало| Да|\n|Кросс-браузерное тестирование|Cross-browser testing|Мало |Да|\n|Тестирование данных и баз данных|Data quality testing and Database integrity testing|Да |Мало|\n|Тестирование использования ресурсов|Resource utilization testing|Крайне редко |Да|\n|Сравнительное тестирование|Comparison testing|Нет| Да|\n|Демонстрационное тестирование|Qualification testing|Нет| Да|\n|Избыточное тестирование|Exhaustive testing|Крайне редко| Нет|\n|Тестирование надёжности|Reliability testing|Крайне редко|Да|\n|Тестирование восстанавливаемости|Recoverability testing|Крайне редко|Да|\n|Тестирование отказоустойчивости|Failover testing|Крайне редко|Да|\n|Тестирование производительности|Performance testing|Крайне редко|Да|\n|Нагрузочное тестирование|Load testing, Capacity testing|Крайне редко|Да|\n|Тестирование масштабируемости|Scalability testing|Крайне редко|Да|\n|Объёмное тестирование|Volume testing|Крайне редко|Да|\n|Стрессовое тестирование|Stress testing|Крайне редко|Да|\n|Конкурентное тестирование|Concurrency testing|Крайне редко|Да|\n|Инвазивное тестирование|Intrusive testing|Да|Да|\n|Неинвазивное тестирование|Nonintrusive testing|Да|Да|\n|Тестирование под управлением данными|Data-driven testing|Да|Да|\n|Тестирование под управлением ключевыми словами|Keyword-driven testing|Да|Да|\n|Тестирование предугадыванием ошибок|Error guessing|Крайне редко|Да|\n|Эвристическая оценка|Heuristic evaluation|Нет|Да|\n|Мутационное тестирование|Mutation testing|Да|Да|\n|Тестирование добавлением ошибок|Error seeding|Да|Да|\n|Доменное тестирование|Domain testing, Domain analysis|Да|Да|\n|Попарное тестирование|Pairwise testing|Да|Да|\n|Тестирование в процессе разработки|Development testing|Да|Да|\n|Тестирование на основе классов эквивалентности|Equivalence partitioning|Да|Да|\n|Тестирование на основе граничных условий|Boundary value analysis|Да|Да|\n|Тестирование на основе ортогональных массивов|Orthogonal array testing|Да|Да|\n|Тестирование по потоку управления|Control flow testing|Да|Нет|\n|Тестирование по потоку данных|Data flow testing|Да|Нет|\n|Тестирование по диаграмме или таблице состояний|State transition testing|Да|Нет|\n|Инспекция (аудит) кода|Code review, code inspection|Да|Нет|\n|Тестирование на основе выражений|Statement testing|Да|Нет|\n|Тестирование на основе ветвей|Branch testing|Да|Нет|\n|Тестирование на основе условий|Condition testing|Да|Нет|\n|Тестирование на основе комбинаций условий|Multiple condition testing|Да|Нет|\n|Тестирование на основе отдельных условий, порождающих ветвление («решающих условий»)|Modified condition decision coverage testing|Да|Нет|\n|Тестирование на основе решений|Decision testing|Да|Нет|\n|Тестирование на основе путей|Path testing|Да|Нет|\n|Тестирование по таблице принятия решений|Decision table testing|Да|Да|\n|Тестирование по моделям поведения приложения|Model-based testing|Да|Да|\n|Тестирование на основе вариантов использования|Use case testing|Да|Да|\n|Параллельное тестирование|Parallel testing|Да|Да|\n|Тестирование на основе случайных данных|Random testing|Да|Да|\n|A/B-тестирование|A/B testing, Split testing|Нет|Да|\n|Восходящее тестирование|Bottom-up testing|Да|Да|\n|Нисходящее тестирование|Top-down testing|Да|Да|\n|Гибридное тестирование|Hybrid testing|Да|Да|\n|Тестирование на основе дерева классификаций|Classification tree method|Да|Да|\n|Тестирование на основе синтаксиса|Syntax testing|Да|Да|\n|Комбинаторные техники (комбинаторное тестирование)|Combinatorial testing|Да|Да|\n|Тестирование всех комбинаций|All combinations testing|Да|Нет|\n|Тестирование с выбором значений-представителей|Each choice testing|Да|Нет|\n|Тестирование с выбором базового набора значений|Base choice testing|Да|Нет|\n|Тестирование по графу причинно-следственных связей|Cause-effect graphing|Мало|Да|\n|Проверка использования всех объявлений|All-definitions testing|Да|Нет|\n|Проверка всех вычислений на основе всех объявлений|All-c-uses testing|Да|Нет|\n|Проверка всех ветвлений на основе всех объявлений|All-p-uses testing|Да|Нет|\n|Проверка всех вычислений и ветвлений на основе всех объявлений|All-uses testing|Да|Нет|\n|Проверка использования всех объявлений и всех путей без переобъявлений (без циклов или с однократными повторениями циклов)|All-du-paths testing|Да|Нет|","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-dostupu-k-kodu-i-arhitekture-prilozheniya/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Метод белого ящика (White box testing, open box testing, clear box testing, glass box testing)","anchor":"#метод-белого-ящика-white-box-testing-open-box-testing-clear-box-testing-glass-box-testing"},{"value":"Метод чёрного ящика (black box testing, closed box testing, specification-based testing)","anchor":"#метод-чёрного-ящика-black-box-testing-closed-box-testing-specification-based-testing"},{"value":"Метод серого ящика (gray box testing)","anchor":"#метод-серого-ящика-gray-box-testing"}]}},{"node":{"id":"4787c5dccd95feb09dad169cb6279467","title":"Виды тестирования по степени автоматизации","content":"\n## Ручное тестирование (Manual testing)\nТестирование, в котором тест-кейсы выполняются человеком вручную без использования средств автоматизации. Несмотря на то что это звучит очень просто, от тестировщика в те или иные моменты времени требуются такие качества, как терпеливость, наблюдательность, креативность, умение ставить нестандартные эксперименты, а также умение видеть и понимать, что происходит «внутри системы», т. е. как внешние воздействия на приложение трансформируются в его внутренние про- цессы.\n\n## Автоматизированное тестирование (Automated testing, test automation)\nНабор техник, подходов и инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования. Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка тест-кейсов, подготовка данных, оценка результатов выполнения, написания отчётов об обнаруженных дефектах — всё это и многое другое по-прежнему делает человек.\n\n### Преимущества\n- Скорость выполнения тест-кейсов может в разы и на порядки превосходить возможности человека.\n- Отсутствие влияния человеческого фактора в процессе выполнения тест-кейсов (усталости, невнимательности и т. д.)\n- Минимизация затрат при многократном выполнении тест-кейсов (участие человека здесь требуется лишь эпизодически).\n- Способность средств автоматизации выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов.\n- Способность средств автоматизации собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.\n- Способность средств автоматизации выполнять низкоуровневые действия с приложением, операционной системой, каналами передачи данных и т. д.\n\n### Недостатки\n- Необходим высококвалифицированный персонал в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, кодом и т. д.)\n- Высокие затраты на сложные средства автоматизации, разработку и сопровождение кода тест-кейсов.\n- Автоматизация требует более тщательного планирования и управления рисками, т. к. в противном случае проекту может быть нанесён серьёзный ущерб.\n- Средств автоматизации крайне много, что усложняет проблему выбора того или иного средства и может повлечь за собой финансовые затраты (и риски), необходимость обучения персонала (или поиска специалистов).\n- В случае ощутимого изменения требований, смены технологического домена, переработки интерфейсов (как пользовательских, так и программных) многие тест-кейсы становятся безнадёжно устаревшими и требуют создания заново.\n\n\nНекоторые авторы говорят отдельно о «полуавтоматизированном» тестировании как варианте ручного с частичным использованием средств автоматизации и отдельно об «автоматизированном» тестировании (относя туда области тестирования, в которых компьютер выполняет ощутимо большой процент задач). Но т.к. без участия человека всё равно не обходится ни один из этих видов тестирования, не станем усложнять набор терминов и ограничимся одним понятием «автоматизированное тестирование».","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-stepeni-avtomatizaczii/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Ручное тестирование (Manual testing)","anchor":"#ручное-тестирование-manual-testing"},{"value":"Автоматизированное тестирование (Automated testing, test automation)","anchor":"#автоматизированное-тестирование-automated-testing-test-automation"}]}},{"node":{"id":"be63b1908e8b0d387151ddea9164dd99","title":"Виды тестирования по уровню деталиции приложения (по уровню тестирования)","content":"\n## Модульное (компонентное) тестирование (Unit testing, Module testing, Component testing)\nНаправлено на проверку отдельных небольших частей приложения, которые (как правило) можно исследовать изолированно от других подобных частей. \n\nПри выполнении данного тестирования могут проверяться отдельные функции или методы классов, сами классы, взаимодействие классов, небольшие библиотеки, отдельные части приложения. Часто данный вид тестирования реализуется с использованием специальных технологий и инструментальных средств автоматизации тестирования, значительно упрощающих и ускоряющих разработку соответствующих тест-кейсов.\n\n«Юнит-тестирование», как правило, направлено на тестирование атомарных участков кода, «Модульное» — на тестирование классов и небольших библиотек, «Компонентное» — на тестирование библиотек и структурных частей приложения. Но эта классификация не стандартизирована, и у различных авторов можно встретить совершенно разные взаимоисключающие трактовки.\n\n## Интеграционное тестирование (Integration testing, Component integration testing, Pairwise integration testing, System integration testing, Incremental testing, Interface testing, Thread testing) \nНаправлено на проверку взаимодействия между несколькими частями приложения (каждая из которых, в свою очередь, проверена отдельно на стадии модульного тестирования). К сожалению, даже если мы работаем с очень качественными отдельными компонентами, «на стыке» их взаимодействия часто возникают проблемы. Именно эти проблемы и выявляет интеграционное тестирование. (См. также техники вос- ходящего, нисходящего и гибридного тестирования в хронологической классификации по иерархии компонентов.)\n\nПодходы к интеграционному тестированию:\n\n- Снизу вверх (Bottom Up Integration)\n\nВсе низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.\n\n- Сверху вниз (Top Down Integration)\n\nВначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.\n\n- Большой взрыв («Big Bang» Integration)\n\nВсе или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.\n\n## Системное тестирование (System testing) \nНаправлено на проверку всего приложения как единого целого, собранного из частей, проверенных на двух предыдущих стадиях. Здесь не только выявляются дефекты «на стыках» компонентов, но и появляется возможность полноценно взаимодействовать с приложением с точки зрения конечного пользователя, применяя множество других видов тестирования, перечисленных в данной главе.\n\n---\n\nС классификацией по уровню детализации приложения связан интересный печальный факт: если предыдущая стадия обнаружила проблемы, то на следующей стадии эти проблемы точно нанесут удар по качеству; если же предыдущая стадия не обнаружила проблем, это ещё никоим образом не защищает нас от проблем на следующей стадии.\n\nЕсли обратиться к словарю ISTQB и прочитать определение уровня тестирования (test level), то можно увидеть, что аналогичное разбиение на модульное, интеграционное и системное тестирование, к которым добавлено ещё и приёмочное тестирование, используется в контексте разделения областей ответственности на проекте. Но такая классификация больше относится к вопросам управления проектом, чем к тестированию в чистом виде, а потому выходит за рамки рассматриваемых нами вопросов.\n\n- Приемочное\n","date":"2022-05-16T00:00:00.000Z","path":"/vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/","icon":"fas fa-bug","image":"null","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Модульное (компонентное) тестирование (Unit testing, Module testing, Component testing)","anchor":"#модульное-компонентное-тестирование-unit-testing-module-testing-component-testing"},{"value":"Интеграционное тестирование (Integration testing, Component integration testing, Pairwise integration testing, System integration testing, Incremental testing, Interface testing, Thread testing)","anchor":"#интеграционное-тестирование-integration-testing-component-integration-testing-pairwise-integration-testing-system-integration-testing-incremental-testing-interface-testing-thread-testing"},{"value":"Системное тестирование (System testing)","anchor":"#системное-тестирование-system-testing"}]}}]}},"relatedTag":null},"context":{}}