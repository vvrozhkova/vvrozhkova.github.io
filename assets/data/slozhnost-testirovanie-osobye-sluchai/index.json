{"hash":"02799b688b4cb7ace869e49ff69fbf95eb6f42e6","data":{"post":{"title":"Сложность, тестирование, особые случаи","content":"\n## Сложность\n\nДля тренировки нужно написать 10000 строк кода.\nДля этого можно использовать сайты leetcode.com, codeforces.com\n\n**Сложность алгоритма** - это порядок количества действий, которые выполняет алгоритм.\n\nЕсли сложность $O(N)$ - это значит, что скорость алгоритма зависит напрямую от количества данных и такую сложность называют **линейной**. \nНапример, обычный цикл от $1$ до $N$.\n\nЕсли в программе два вложенных цикла, каждый от $1$ до $N$, тогда сложность составит $O(N^2)$.\n\n$O$ никак не зависит от константы.  \n$100*N = O(N), 2*N=O(N)$. Здесь 2 и 100 - константы, не зависящие от размера входных данных.  Константы не так сильно влияют на скорость алгоритма при больших параметрах.\n\nНапример, алгоритм, который работает за $O(100*N)$ будет работать лучше, чем $O(1*N^2)$, поэтому константа не так принципиальна.\n\nТ.е. если в алгоритме выполняется цикл, то не важно сколько действий выполняется внутри цикла, важно сколько вхождений выполнится.\n\n$O$(O-большое) означает, что наш алгоритм работает не более, чем за столько действий сколько указано в скобках, например $O(N) = 10 * N$ - означает что найдется такое число, в нашем случае 10, что наш алгоритм гарантировано совершит не больше, чем 10 * N  действий. Чем асимптотическая сложность ниже, тем лучше, тем быстрее решается.\n\nСравнение алгоритмов по асимптотической сложности имеет смысл проводить только для больших значений параметров, пока он маленький там может произойти, что угодно :). \n\nЕще существует **\"пространственная сложность\"** - количество использованной памяти, сколькдополнительной памяти потребляет наш алгоритм.\nПамяти алгортим не может потребить больше чем он потратил времяБ потому что чтобы что то положить в ячейку памяти это тоже элементарная операция. \nНо иногда алгоритмы отличаются и по дополнительной памяти которую они употребляют. \n\n### Задача №1. Условие.\nДана строка в кодировке UTF-8.  \nНайти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.\n\n### Задача №1. Решение 1.\n\nПереберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n--- \n\nЗаводим внешние переменные для максимального количества повторений и для значения символа. \n\nВнешний цикл сначала выбирает первый символ и далее проходит по строке и ищет сколько раз этот символ в ней встречается, запоминаем значение символа и количество повторений и сохраняем их во внешнюю переменную. \n\nЗатем переходим ко второму символу и также проверяем сколько раз он встретился, если количество его повторений больше, чем во внешней переменной, то обновляем значения для максимального количества повторений и для значения символа во внешних переменных и так далее до конца строки.\n\n**_Сложность алгоритма: _**$O(N^2)$, тк 2 вложенных цикла.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    int ansCount = 0;\n    char ans = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char nowChar = s.charAt(i);\n        int nowCount = 0;\n\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == nowChar) {\n                nowCount += 1;\n            }\n        }\n\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = nowChar;\n        }\n    }\n    return ans;\n}\n```\n\nНо есть более эффективное решение. \n\n### Задача №1. Решение 2.\n\nПереберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n---\n\nПолучаем список уникальных букв через Set. \n\nПроходим по нему в цикле и для каждой из букв запускаем цикл, который подсчитывает количество повторений для этой буквы. \n\nЗаписываем в счетчик и возвращаем искомый символ.\n\n**_Сложность алгоритма: _**$O(N*K)$, где K - количество уникальных букв, цикл по ним чтобы узнать, сколько каждая из них встречалась раз, N - общее количество букв, цикл по N, чтобы найти количество повторений для каждой из уникальных букв.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    Set<Character> str = s.chars().mapToObj(e -> (char) e).collect(Collectors.toSet());\n\n    char ans = 0;\n    int ansCount = 0;\n\n    for (Character now : str) {\n        int nowCount = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == now) {\n                nowCount += 1;\n            }\n        }\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = now;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача №1. Решение 3.\n\nЗаведем словарь, где ключом является символ, а значением - сколько раз он встретился. \n\nПроходим в цикле по всем символам строки и если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Далее для текущего символа в словаре прибавляем к элементу словаря с ключом, совпадающим с этим символом единицу. \n\nПосле выполнения прохода по всем символам, запускаем цикл прохода по ключам словаря и сравниваем значение по ключу с текущим максимальным повторением, если значение больше то переписываем символ в ответе и макимальное количество повторений.\n\n**_Сложность алгоритма: _**$O(N + K) = O(N)$, N - количество проходов пока формировали словарь, K - количество прохода только по (уникальным) ключам. Но так как K обычно меньше N то можно сказать что алгоритм выполняется за $O(N)$.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    char ans = 0;\n    int ansCount = 0;\n    Map<Character, Integer> dict = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char now = s.charAt(i);\n        if (!dict.containsKey(now)) {\n            dict.put(now, 0);\n        }\n        dict.put(now, dict.get(now) + 1);\n    }\n\n    for (Character key : dict.keySet()) {\n        if (dict.get(key) > ansCount) {\n            ansCount = dict.get(key);\n            ans = key;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Сравниваем затраченное время и память (дополнительную)\n\n|Решение|Время|Память|\n|---|---|---|\n|#1 Проход по строке для каждого символа|$O(N^2)$|$O(N)$ - так как храним только саму строку|\n|#2 Проход по строке для каждого символа в множестве|$O(N*K)$|$O(N+K) = O(N)$ - храним строку и множество ($K$)|\n|#3 Использование словаря|$O(N)$|$O(K)$ - храним только словарь из K элементов|\n\n## Особые случаи\n\n### Сумма последовательности\n\nВ данном алгоритме не обязательно делать проверку на пустую строку так как и без этой проверки у нас выведется ноль.\n\n```java\npublic static int sequenceSum(String s) {\n    int[] sequence = s.chars().toArray();\n    int sequenceSum = 0;\n    for (int i = 0; i < sequence.length; i++) {\n        sequenceSum += sequence[i];\n    }\n    \n    return sequenceSum;\n}\n```\n\n### Максимум последовательности\n\nВ этом алгоритме мы не можем задать начальное значение нулем, тк в массиве могут быть еще и отрицательные значения, поэтому необходимо добавить ночальную проверку на пустую строку и при выполнении алгоритма стартовому значению присвоить первое значение в массиве.\n\n```java\npublic static double sequenceMax(String s) {\n    int[] sequence = s.chars().toArray();\n    if (sequence.length == 0) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        int sequenceMax = sequence[0];\n        for (int i = 0; i < sequence.length; i++) {\n            if (sequence[i] > sequenceMax) {\n                sequenceMax = sequence[i];\n            }\n        }\n        return sequenceMax;\n    }\n}\n```\n\n## Тестирование\n\nПри тестировании алгоритма нужно проверить:\n\n- тесты из условия (если есть)\n- общие случаи\n- особые случаи (все числа отрицательные, пустая последовательность)\n\nТесты для алгоритма на поиск максимума последовательности:\n\n- 1 3 2 - общий случай (максимум в середине)\n- 1 2 3, 3 2 1 - максимум по краям \n- 1 1 1 - все элементы одинаковы\n- 1 - один элемент\n- _ - пустая последовательность\n- -2 -1 -3 - все числа отрицательные\n\n### Советы по составлению тестов\n\n- Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу;\n- Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить;\n- Проверь последовательность из одного элемента и пустую последовательность;\n- \"Краевые эффекты\" - проверь что программа работает корректно в начале и конце последовательности сделай тесты чтоы ответ находился на первом и на последнем месте последовательности;\n- Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else;\n- Подбери тесты чтобы не было ни одного входа в цикл;\n- Один тест - одна возможная ошибка;\n\n## Вопросы\n\n1. **_Что приоритетней оптимизация по памяти или по времени исполнения?_**\n\nЧаще всего по времени исполнения, а если есть несколько алгориитмов с одинаковым временем то уже по памяти.\nНо бывают редкие задачи, где память играет решающее значение.\n\n2. **_Почему в решение №3 мы использовали Set но не считали его асимптотическую сложность?_**\n\nДобавление в Set происходит за $O(1)$ времени. Объяснение будет в следующих лекциях.\n\n3. **_Как проверить алгоритм, если не знаешь где может быть ошибка?_**\n\n    1. пишем самый простой базовый алгоритм для решения задачи\n    2. пишем генератор маленьких массивов из случайных чисел\n    3. запускаем цикл и сравниваем ответ нашего алгоритма с ответом примитивного алгоритма","description":"Сложность, тестирование, особые случаи","image":"null","category":null,"date":"24/07/2022","path":"/slozhnost-testirovanie-osobye-sluchai/","links":[{"title":"","items":[{"title":"Алгоритмы (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Сложность, тестирование, особые случаи","link":"/slozhnost-testirovanie-osobye-sluchai/"},{"title":"Линейный поиск","link":"/linejnyj-poisk/"},{"title":"Множества","link":"/mnozhestva/"},{"title":"Словари и сортировка подсчётом","link":"/slovari-i-sortirovka-podschyotom/"},{"title":"Префиксные суммы и два указателя","link":"/prefiksnye-summy-i-dva-ukazatelya/"},{"title":"Бинарный поиск","link":"/binarnyj-poisk/"},{"title":"Сортировка событий","link":"/sortirovka-sobytij/"},{"title":"Деревья","link":"/derevya/"}]}],"headings":[{"value":"Сложность","anchor":"#сложность"},{"value":"Особые случаи","anchor":"#особые-случаи"},{"value":"Тестирование","anchor":"#тестирование"},{"value":"Вопросы","anchor":"#вопросы"}],"subtitles":[{"depth":2,"value":"Сложность","anchor":"#сложность"},{"depth":3,"value":"Задача №1. Условие.","anchor":"#задача-1-условие"},{"depth":3,"value":"Задача №1. Решение 1.","anchor":"#задача-1-решение-1"},{"depth":3,"value":"Задача №1. Решение 2.","anchor":"#задача-1-решение-2"},{"depth":3,"value":"Задача №1. Решение 3.","anchor":"#задача-1-решение-3"},{"depth":3,"value":"Сравниваем затраченное время и память (дополнительную)","anchor":"#сравниваем-затраченное-время-и-память-дополнительную"},{"depth":2,"value":"Особые случаи","anchor":"#особые-случаи"},{"depth":3,"value":"Сумма последовательности","anchor":"#сумма-последовательности"},{"depth":3,"value":"Максимум последовательности","anchor":"#максимум-последовательности"},{"depth":2,"value":"Тестирование","anchor":"#тестирование"},{"depth":3,"value":"Советы по составлению тестов","anchor":"#советы-по-составлению-тестов"},{"depth":2,"value":"Вопросы","anchor":"#вопросы"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"алгоритмы","title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}]},"comments":{"edges":[]}},"context":{}}