{"hash":"84ff211b7c6d9fc18dc1380cbe0fca5225ead0ae","data":{"post":{"title":"Модели разработки ПО","content":"\n## 1. Code and fix - Модель кодирования и устранения ошибок\n\nСовершенно простая модель, характерная для студентов ВУЗов. Именно по этой модели большинство студентов разрабатывают, например лабораторные работы. \n\n![Code and fix - Модель кодирования и устранения ошибок](https://leonardo.osnova.io/611da7e3-32e5-0dd5-8198-cb6d23d19310/-/preview/2100/-/format/webp/)\n\nЭто одна из самых старых моделей разработки: она очень проста и подойдет стартапам, где команда невелика, нет особых конфликтов, вы знаете, что хотите сделать и имеете представление, как это сделать.\n\nКак работает Code-and-Fix: у нас есть понимание, что мы хотим сделать. Начинаем программировать, затем смотрим, что получилось. Выявляем баги, правим их и снова смотрим — и так, пока наш продукт не начнет работать.\n\nДанная модель имеет следующий алгоритм:\n\n1. Постановка задачи\n2. Выполнение\n3. Проверка результата\n4. При необходимости переход к первому пункту\n\n### Преимущества\n- не нужно тратить время на планы, документацию, митинги.\n\n### Недостатки\n- иногда исправление одной ошибки приводит к тому, что у вас ломается вся система. В итоге приходится переделывать — снова и снова. Поэтому когда-то давно программисты, которые мучились с этой моделью разработки, решили уйти от ее мнимой простоты и изобрести другую.\n\nМодель ужасно устаревшая. Характерна для 1960-1970 гг., поэтому преимуществ перед следующими моделями практически не имеет, а недостатки на лицо.\n\n## 2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")\n\nПроцесс создания программного обеспечения представляет собой поток, последовательно проходящий фазы анализа, проектирования, реализации, тестирования, интеграции и поддержки.\n\nКаждая следующая стадия начинается только после того, как заканчивается предыдущая. Так обычно строится работа над крупными проектами с длительным сроком внедрения.\n\n![Каскадная модель (waterfall)](https://habrastorage.org/r/w1560/files/6e2/e05/23f/6e2e0523f58d4d74816ae0bcf46e2fa2.jpg)\n![Каскадная модель (waterfall)](https://leonardo.osnova.io/0e330a8b-7f21-f8fb-872c-986314b4d7da/-/preview/2100/-/format/webp/)\n![Каскадная модель (waterfall)](https://evergreens.com.ua/assets/images/articles/systems/waterfall.png)\n\nИмеет ряд преимуществ перед алгоритмом предыдущей модели, но также имеет и ряд весомых недостатков. \n\n### Преимущества\n- Последовательное выполнение этапов проекта в строгом фиксированном порядке;\n- высокий уровень формализации процессов => высокая прозрачность разработки и фаз проекта;\n- большое количество документации;\n- Разработку просто контролировать. Заказчик всегда знает, чем сейчас заняты программисты, может управлять сроками и стоимостью;\n- Стоимость проекта определяется на начальном этапе. Все шаги запланированы уже на этапе согласования договора, ПО пишется непрерывно «от и до»;\n- Позволяет оценивать качество продукта на каждом этапе;\n- Не нужно нанимать тестировщиков с серьёзной технической подготовкой. Тестировщики смогут опираться на подробную техническую документацию;\n\n\n### Недостатки\n- Жесткая последовательность этапов жизненного цикла без возможности возврата на предыдущий этап;\n- Заказчик видит готовый продукт в конце разработки и только тогда может дать обратную связь. Велика вероятность, что результат его не устроит.\n- Все требования должны быть известны в начале жизненного цикла проекта;\n- Разработчики пишут много технической документации, что задерживает работы. Чем обширнее документация у проекта, тем больше изменений нужно вносить и дольше их согласовывать.\n- Тестирование начинается на последних этапах разработки. Если в требованиях к продукту была допущена ошибка, то исправить её будет стоить дорого. Тестировщики обнаружат её, когда разработчик уже написал код, а технические писатели — документацию.\n- Возникает необходимость в жёстком управлении и регулярном контроле, иначе проект быстро выйдет из графиков\n- Отсутствует возможность учесть переделку, весь проект делается за один раз\n- Не соответствует реальным условиям разработки программного продукта\n\n«Водопад» подходит для разработки проектов в медицинской и космической отрасли, где уже сформирована обширная база документов (СНиПов и спецификаций), на основе которых можно написать требования к новому ПО. \n\nПри работе с каскадной моделью основная задача — написать подробные требования к разработке. На этапе тестирования не должно выясниться, что в них есть ошибка, которая влияет на весь продукт.\n\n### «Водоворот» или каскадная модель с промежуточным контролем\n\nВ этой модели предусмотрен промежуточный контроль за счет обратных связей. Но это достоинство порождает и недостатки. Затраты на реализацию проекта при таком подходе возрастают практически в 10 раз. Эта модель, как вы уже поняли, является незначительной модификацией предыдущей.\n\n![«Водоворот» или каскадная модель с промежуточным контролем](https://intuit.ru/EDI/08_01_19_2/1546899581-11707/tutorial/145/objects/2/files/02_04.gif)\n\nПри реальной работе в соответствии с моделью, допускающей движение только в одну сторону, обычно возникают проблемы при обнаружении недоработок и ошибок, сделанных на ранних этапах. Но еще более тяжело иметь дело с изменениями окружения, в котором разрабатывается ПО (это могут быть изменения требований, смена подрядчиков, изменения политик разрабатывающей или эксплуатирующей организации, изменения отраслевых стандартов, появление конкурирующих продуктов и пр.).\n\n## 3. V-model (V-образная модель, разработка через тестирование)\n\nЭто усовершенствованная каскадная модель, в которой заказчик с командой программистов одновременно составляют требования к системе и описывают, как будут тестировать её на каждом этапе. \n\nИстория этой модели начинается в 1980-х. Имеет обратные связи с каждым этапом жизненного цикла, при этом порождает очень весомый недостаток: 10-ти кратное увеличение затрат на разработку.\n\nЯвляется одной из основных практик экстремального программирования и предполагает регулярное тестирование продукта во время разработки.\n\n![V модель — разработка через тестирование](https://habrastorage.org/r/w1560/files/22d/21f/18f/22d21f18ffb244d082e181c813d4ff15.jpg)\n![V модель — разработка через тестирование](https://leonardo.osnova.io/4a602e4f-745f-b2cc-18de-bd9cdd148b55/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- **Минимизация рисков:**  \nV-образная модель делает проект более прозрачным и повышает качество контроля проекта путём стандартизации промежуточных целей и описания соответствующих им результатов и ответственных лиц. Это позволяет выявлять отклонения в проекте и риски на ранних стадиях и улучшает качество управления проектов, уменьшая риски.\n- **Повышение и гарантии качества:**  \nV-Model — стандартизованная модель разработки, что позволяет добиться от проекта результатов желаемого качества. Промежуточные результаты могут быть проверены на ранних стадиях. Универсальное документирование облегчает читаемость, понятность и проверяемость.\n- **Уменьшение общей стоимости проекта:**  \nРесурсы на разработку, производство, управление и поддержку могут быть заранее просчитаны и проконтролированы. Получаемые результаты также универсальны и легко прогнозируются. Это уменьшает затраты на последующие стадии и проекты.\n- **Повышение качества коммуникации между участниками проекта:**  \nУниверсальное описание всех элементов и условий облегчает взаимопонимание всех участников проекта. Таким образом, уменьшаются неточности в понимании между пользователем, покупателем, поставщиком и разработчиком.\n\n### Недостатки\n- Если при разработке архитектуры была допущена ошибка, то вернуться и исправить её будет стоить дорого, как и в «водопаде».\n\nV-модель подходит для проектов, в которых важна надёжность и цена ошибки очень высока. Например, при разработке подушек безопасности для автомобилей или систем наблюдения за пациентами в клиниках. \n\n## 4. Incremental Model - Инкрементная модель\n\nМодель приращения продукта позволяет параллельно выполнять ряд задач с непрерывным анализом результатов и корректировкой предыдущих этапов работы. Это более «скоростная» разработка для большого штата квалифицированных программистов.\n\nЭто модель разработки по частям (increment в переводе с англ. — приращение) уходит корнями в 1930-е. Рассмотрим её на примере создания социальной сети.\n\nЗаказчик решил, что хочет запустить соцсеть, и написал подробное техническое задание. Программисты предложили реализовать основные функции — страницу с личной информацией и чат. А затем протестировать на пользователях, «взлетит или нет».\n\nКоманда разработки показывает продукт заказчику и выпускает его на рынок. Если и заказчику, и пользователям социальная сеть нравится, работа над ней продолжается, но уже по частям.\n\nПрограммисты параллельно создают функциональность для загрузки фотографий, обмена документами, прослушивания музыки и других действий, согласованных с заказчиком. Инкремент за инкрементом они совершенствуют продукт, приближаясь к описанному в техническом задании.\n\n![Incremental Model - Инкрементная модель](https://habrastorage.org/r/w1560/files/8b7/4e2/a86/8b74e2a8640d4ad59e7ac82b991be970.jpg)\n![Incremental Model - Инкрементная модель](https://leonardo.osnova.io/5a2d52b7-7a12-f7d5-9f09-4054d8192694/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- Не нужно вкладывать много денег на начальном этапе. Заказчик оплачивает создание основных функций, получает продукт, «выкатывает» его на рынок — и по итогам обратной связи решает, продолжать ли разработку.\n- Можно быстро получить фидбэк от пользователей и оперативно обновить техническое задание. Так снижается риск создать продукт, который никому не нужен.\n- Ошибка обходится дешевле. Если при разработке архитектуры была допущена ошибка, то исправить её будет стоить не так дорого, как в «водопаде» или V-образной модели.\n\n### Недостатки\n\n- Каждая команда программистов разрабатывает свою функциональность и может реализовать интерфейс продукта по-своему. Чтобы этого не произошло, важно на этапе обсуждения техзадания объяснить, каким он будет, чтобы у всех участников проекта сложилось единое понимание. \n- Разработчики будут оттягивать доработку основной функциональности и «пилить мелочёвку». Чтобы этого не случилось, менеджер проекта должен контролировать, чем занимается каждая команда.\n\nИнкрементная модель подходит для проектов, в которых точное техзадание прописано уже на старте, а продукт должен быстро выйти на рынок.\n\n## 5. Iterative Model - Итеративная (или итерационная) модель\n\nЭто модель, при которой заказчик не обязан понимать, какой продукт хочет получить в итоге, и может не прописывать сразу подробное техзадание.\n\nРассмотрим на примере создания мессенджера, как эта модель работает.\n\nЗаказчик решил, что хочет создать мессенджер. Разработчики сделали приложение, в котором можно добавить друга и запустить чат на двоих.\nМессенджер «выкатили» в магазин приложений, пользователи начали его скачивать и активно использовать. Заказчик понял, что продукт пользуется популярностью, и решил его доработать.\n\nПрограммисты добавили в мессенджер возможность просмотра видео, загрузки фотографий, записи аудиосообщений. Они постепенно улучшают функциональность приложения, адаптируют его к требованиям рынка.\n\n![Iterative Model - Итеративная (или итерационная) модель](https://habrastorage.org/r/w1560/files/880/01d/a78/88001da784ab41ec880f84a7bb204a0b.jpg)\n![Iterative Model - Итеративная (или итерационная) модель](https://leonardo.osnova.io/ba33e029-3df5-ec0c-35b0-3b6060f93f81/-/preview/2100/-/format/webp/)\n![Iterative Model - Итеративная (или итерационная) модель](https://evergreens.com.ua/assets/images/articles/systems/iteration%20mod.png)\n\n### Преимущества\n\n- Быстрый выпуск минимального продукта даёт возможность оперативно получать обратную связь от заказчика и пользователей. А значит, фокусироваться на наиболее важных функциях ПО и улучшать их в соответствии с требованиями рынка и пожеланиями клиента.\n- Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки.\n\n### Недостатки\n\n- Использование на начальном этапе баз данных или серверов — первые сложно масштабировать, а вторые не выдерживают нагрузку. Возможно, придётся переписывать большую часть приложения.\n- Отсутствие фиксированного бюджета и сроков. Заказчик не знает, как выглядит конечная цель и когда закончится разработка.\n- Становится сложнее адекватно оценить текущее состояние проекта и спланировать долгосрочное развитие событий, а также предсказать сроки и ресурсы, необходимые для обеспечения определенного качества результата.\n\nИтеративная модель подходит для работы над большими проектами с неопределёнными требованиями, либо для задач с инновационным подходом, когда заказчик не уверен в результате. \n\nНа основе итеративной модели была создана Agile — не модель и не методология, а скорее подход к разработке.\n\n![](https://s.dou.ua/storage-files/dev-cycle-iter.gif)\n\n## 6. Spiral Model — спиральная модель\n\nСпиральная модель представляет собой процесс разработки программного обеспечения, сочетающий в себе как проектирование, так и постадийное прототипирование с целью сочетания преимуществ восходящей и нисходящей концепции. \n\nРассмотрим, как функционирует эта модель, на примере разработки системы «Умный дом». \n\nЗаказчик решил, что хочет сделать такую систему, и заказал программистам реализовать управление чайником с телефона. Они начали действовать по модели «водопад»: выслушали идею, провели анализ предложений на рынке, обсудили с заказчиком архитектуру системы, решили, как будут её реализовывать, разработали, протестировали и «выкатили» конечный продукт.\n\nЗаказчик оценил результат и риски: насколько нужна пользователям следующая версия продукта — уже с управлением телевизором. Рассчитал сроки, бюджет и заказал разработку. \n\nПрограммисты действовали по каскадной модели и представили заказчику более сложный продукт, разработанный на базе первого.\n\nЗаказчик подумал, что пора создать функциональность для управления холодильником с телефона. Но, анализируя риски, понял, что в холодильник сложно встроить Wi-Fi-модуль, да и производители не заинтересованы в сотрудничестве по этому вопросу. Следовательно, риски превышают потенциальную выгоду.\n\nНа основе полученных данных заказчик решил прекратить разработку и совершенствовать имеющуюся функциональность, чтобы со временем понять, как развивать систему «Умный дом».\n\nСпиральная модель похожа на инкрементную, но здесь гораздо больше времени уделяется оценке рисков. С каждым новым витком спирали процесс усложняется. Эта модель часто используется в исследовательских проектах и там, где высоки риски. \n\n![Spiral Model — спиральная модель](https://leonardo.osnova.io/595fed17-42da-c48b-1f17-f314f31301a4/-/preview/2100/-/format/webp/)\n![Spiral Model — спиральная модель](https://evergreens.com.ua/assets/images/articles/systems/spinner%20model.png)\n### Преимущества\n\n- Быстрое получение результата\n- Повышение конкурентоспособности\n- При изменении требований, не придется начинать все с «нуля».\n- Большое внимание уделяется проработке рисков\n\n### Недостатки\n\n- Отсутствие регламентации стадий\n- Есть риск застрять на начальном этапе — бесконечно совершенствовать первую версию продукта и не продвинуться к следующим.\n- Разработка длится долго и стоит дорого.\n\nИспользуя эту модель, заказчик и команда разработчиков серьёзно анализируют риски проекта и выполняют его итерациями. Последующая стадия основывается на предыдущей, а в конце каждого витка — цикла итераций — принимается решение, продолжать ли проект. Эту модель начали использовать в 1988 году.\n\n## 7. Chaos model — модель хаоса\n\nВкратце Стратегия хаоса — это стратегия разработки программного обеспечения основанная на модели хаоса. Главное правило — это,всегда решать наиболее важную задачу первой.\n\nЕё создатель Л.Б.С.Ракун отмечает, что такие модели управления проектами, как спиральная модель и каскадная модель, хотя и хороши в управлении расписаниями и персоналом, не обеспечивают методами устранения ошибок и решениями других технических задач, не помогают ни в управлении конечными сроками, ни в реагировании на запросы клиентов. Модель хаоса — это инструмент пытающийся помочь понять эти ограничения и восполнить пробелы.\n\n### Преимущества\n- учитывает взаимодействие между членами команды при внесении изменений в код;\n- ограничивает риск чрезмерного проектирования решения\n- прозрачность между желаниями руководства высокого уровня и пониманием командой разработчиков проблем и приоритетов.\n\n### Недостатки\n- критическая необходимость включить единый дизайн на уровне кода, который необходимо выполнить для удовлетворения требований на уровне программы.\n\n## 8. Prototype Model — прототипная модель\n\nДанная модель основывается на разработке прототипов и прототипирования продукта.\n\nПрототипирование используется на ранних стадиях жизненного цикла программного обеспечения:\n- Прояснить не ясные требования (прототип UI)\n- Выбрать одно из ряда концептуальных решений (реализация сцинариев)\n- Проанализировать осуществимость проекта\n\n### Классификация протопипов\n- Горизонтальные прототипы — моделирует исключительно UI не затрагивая логику обработки и базу данных.\n- Вертикальные прототипы — проверка архитектурных решений.\n- Одноразовые прототипы — для быстрой разработки.\n- Эволюционные прототипы — первое приближение эволюционной системы.\n\n## 9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений\n\n![RAD-Model, или Rapid Application Development Model - Модель быстрой разработки](https://leonardo.osnova.io/69673b21-a423-772e-3a1e-aca50d529348/-/preview/2100/-/format/webp/)\n\nРазновидность инкрементной модели. Появилась в конце 80-х годов и стала одной из попыток создания гибкого процесса разработки.\n\nRAD предусматривает небольшие команды разработки,сроки до 4 месяцев и активное привлечение заказчика с ранних этапов. Данная методология опирается на требования, но также существует возможность их изменений в период разработки системы. Обязательное требование этой модели — проект должен легко разбиваться на небольшие части, которые при необходимости могут создаваться параллельно друг другу несколькими командами. Такой подход позволяет сократить расходы и свести время разработки к минимуму.\n\n### Преимущества\n- быстрое развитие продукта;\n- разработка многоразовых мелких компонентов;\n- повторный обзор в процессе разработки;\n- интеграция повторно используемых компонентов на начальном уровне, следовательно, экономит усилия, несмотря на то, что не добавляются более крупные модули;\n- конструктивная реакция.\n\n### Недостатки\n- требуется много усилий для сбора всех требований на начальном этапе.\n- навыки моделирования имеют много зависимостей.\n- не подходит для малобюджетного проекта.\n\n## 10. Модель Большого Взрыва (Big Bang Model)\n\nBig Bang Model не имеет определенного процесса. Деньги и усилия объединяются, поскольку вход и выход представляют собой разработанный продукт, который может совпадать, а может и не совпадать с тем, что нужно заказчику. Модель Большого Взрыва не требует особого планирования и составления графиков. Разработчик выполняет анализ требований и кодирование, а также разрабатывает продукт в соответствии с его пониманием. Эта модель используется только для небольших проектов. Нет команды тестирования и формального тестирования не проводится, и это может быть причиной провала проекта.\n\n### Преимущества\n- Это очень простая модель. \n- Требуется меньше планирования и составления графиков. \n- Разработчик может создавать собственное программное обеспечение.\n\n### Недостатки\n- Модели Большого взрыва нельзя использовать для крупных, текущих и сложных проектов. \n- Высокий риск и неопределенность.\n\n## 11. Agile\n\nГибкая модель разработки, по которой сегодня работает большинство ИТ-проектов. Вы получаете определенный результат после каждой итерации, можете вносить изменения в первоначальное видение продукта практически в любой момент работы — исходя из того, какой функционал больше нравится пользователям вашего продукта.\n\n### Преимущества\n- чтобы начать работать над продуктом не нужно иметь детальное представление о том, что вы хотите получить в конце. Не нужно иметь весь бюджет и просчитывать все риски\n\n### Недостатки\n- готовый продукт может на рынок так никогда и не выйти, вы постоянно будете заниматься его усовершенствованиями, дополнениями, тем временем бюджет может закончиться\n\nAgile имеет множество вариаций и фреймворков. Среди самых известных: Scrum, Kanban, экстремальное программирование (XP), Lean.","description":"Модели разработки ПО","image":"null","category":{"id":"manual","title":"manual","path":"/category/manual/"},"date":"21/05/2022","path":"/modeli-razrabotki-po/","links":[{"title":"","items":[{"title":"1. Тестирование, Quality control, Quality assurance","link":"/testirovanie-quality-control-quality-assurance/"},{"title":"2. Понятие качества, международные стандарты качества","link":"/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/"},{"title":"3. Жизненный цикл дефекта","link":"/zhiznennyj-czikl-defekta/"},{"title":"4. Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)","link":"/zhiznennyj-czikl-razrabotki-po-sdlc-software-development-life-cycle/"},{"title":"5. Модели разработки ПО","link":"/modeli-razrabotki-po/"},{"title":"6. Методологии разработки ПО (Scrum, Kanban, RUP, DSDM, MSF, XP)","link":"/metodologii-razrabotki-po-scrum-kanban-rup-dsdm-msf-xp"},{"title":"7. Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)","link":"/zhiznennyj-czikl-testirovaniya-prilozhenij-stlc-software-testing-life-cycle/"},{"title":"8. Принципы тестирования, Agile принципы тестирования","link":"/princzipy-testirovaniya-agile-princzipy-testirovaniya/"},{"title":"9. Практики и подходы тестирования","link":"/praktiki-i-podhody-testirovaniya/"},{"title":"10. Виды тестирования","link":"/vidy-testirovaniya/"},{"title":"11. Уровни тестирования","link":"/urovni-testirovaniya/"},{"title":"12. Техники тест-дизайна","link":"/tehniki-test-dizajna/"},{"title":"13. Тестовая документация","link":"/testovaya-dokumentacziya/"}]}],"headings":[{"value":"1. Code and fix - Модель кодирования и устранения ошибок","anchor":"#1-code-and-fix---модель-кодирования-и-устранения-ошибок"},{"value":"2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")","anchor":"#2-waterfall-model---каскадная-или-поэтапная-разработка-водопад"},{"value":"3. V-model (V-образная модель, разработка через тестирование)","anchor":"#3-v-model-v-образная-модель-разработка-через-тестирование"},{"value":"4. Incremental Model - Инкрементная модель","anchor":"#4-incremental-model---инкрементная-модель"},{"value":"5. Iterative Model - Итеративная (или итерационная) модель","anchor":"#5-iterative-model---итеративная-или-итерационная-модель"},{"value":"6. Spiral Model — спиральная модель","anchor":"#6-spiral-model--спиральная-модель"},{"value":"7. Chaos model — модель хаоса","anchor":"#7-chaos-model--модель-хаоса"},{"value":"8. Prototype Model — прототипная модель","anchor":"#8-prototype-model--прототипная-модель"},{"value":"9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений","anchor":"#9-rad-model-или-rapid-application-development-model---модель-быстрой-разработки-приложений"},{"value":"10. Модель Большого Взрыва (Big Bang Model)","anchor":"#10-модель-большого-взрыва-big-bang-model"},{"value":"11. Agile","anchor":"#11-agile"}],"subtitles":[{"depth":2,"value":"1. Code and fix - Модель кодирования и устранения ошибок","anchor":"#1-code-and-fix---модель-кодирования-и-устранения-ошибок"},{"depth":3,"value":"Преимущества","anchor":"#преимущества"},{"depth":3,"value":"Недостатки","anchor":"#недостатки"},{"depth":2,"value":"2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")","anchor":"#2-waterfall-model---каскадная-или-поэтапная-разработка-водопад"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-1"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-1"},{"depth":3,"value":"«Водоворот» или каскадная модель с промежуточным контролем","anchor":"#водоворот-или-каскадная-модель-с-промежуточным-контролем"},{"depth":2,"value":"3. V-model (V-образная модель, разработка через тестирование)","anchor":"#3-v-model-v-образная-модель-разработка-через-тестирование"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-2"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-2"},{"depth":2,"value":"4. Incremental Model - Инкрементная модель","anchor":"#4-incremental-model---инкрементная-модель"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-3"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-3"},{"depth":2,"value":"5. Iterative Model - Итеративная (или итерационная) модель","anchor":"#5-iterative-model---итеративная-или-итерационная-модель"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-4"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-4"},{"depth":2,"value":"6. Spiral Model — спиральная модель","anchor":"#6-spiral-model--спиральная-модель"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-5"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-5"},{"depth":2,"value":"7. Chaos model — модель хаоса","anchor":"#7-chaos-model--модель-хаоса"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-6"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-6"},{"depth":2,"value":"8. Prototype Model — прототипная модель","anchor":"#8-prototype-model--прототипная-модель"},{"depth":3,"value":"Классификация протопипов","anchor":"#классификация-протопипов"},{"depth":2,"value":"9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений","anchor":"#9-rad-model-или-rapid-application-development-model---модель-быстрой-разработки-приложений"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-7"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-7"},{"depth":2,"value":"10. Модель Большого Взрыва (Big Bang Model)","anchor":"#10-модель-большого-взрыва-big-bang-model"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-8"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-8"},{"depth":2,"value":"11. Agile","anchor":"#11-agile"},{"depth":3,"value":"Преимущества","anchor":"#преимущества-9"},{"depth":3,"value":"Недостатки","anchor":"#недостатки-9"}],"tags":[{"id":"Модели разработки ПО","title":"Модели разработки ПО","path":"/tag/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D0%9F%D0%9E/"}]},"comments":{"edges":[]}},"context":{}}