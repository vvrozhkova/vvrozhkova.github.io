{"hash":"74078440e78cf7eff9cd218b18924da13af0a419","data":{"post":{"title":"Линейный поиск","content":"\n## Классические задачи линейного поиска\n\nЛинейный поиск - способ поиска, когда перебираются все элементы.\n\nСложность линейного поиска - линейная, т.е. $O(N)$.\n\nОбычно ищут \"подходящий\" элемент или \"наиболее подходящий элемент\".\n\n### Задача 1. Найти первое вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию.\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (ans == -1 && seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 2. Найти последнее вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию (без проверки что текущая позиция равна -1).\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 3. Найти максимальное число в последовательности.\nДана последовательность чисел длиной N (N>0). Найти максимальное число в последовательности.\n\nРешение:\n\nСначала положим в ответ нулевой элемент последовательности (он точно существует, тк N>0), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент.\n\n```java\npublic static int findMax(int[] seq) {\n    int ans = seq[0];\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i] > ans) {\n            ans = seq[i];\n        }\n    }\n\n    return ans;\n}\n```\n\nЕсли условие допускает пустую последовательность то этот случай нужно обрабатывать отдельно через if.\n\nСтроки сравниваются по символьно и когда символы начинают отличаться можно сказать какая строка меньше или больше. Если строки длинные то сравнение будет идти долго, время равно длине строки. \n\nЛексикографический порядок - это сравнение с учетом регистра.\nАлфавитный порядок - это сравннеие, как в словаре, без учета регистра.\n\nРешение задачи не подойдет для строк, так как будет постоянно перезаписываться значение ans, а для строк это требует больше времени, строки могут быть длинные.\n\nНужно запоминать не значение, а индекс максимального элемента. \n\n```java\npublic static String findMax(String[] seq) {\n    int ans = 0;\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i].compareTo(seq[ans]) == 0) {\n            ans = i;\n        }\n    }\n\n    return seq[ans];\n}\n```\n\n### Задача 4. Найти максимальное число в последовательности и второе по величине число.\nДана последовательность чисел длиной N (N>1). \nНайти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число).\n\nРешение:\n\nЗаведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого макисмума, а меньшее - для второго. Пройдем по всей последовательности. Если очередное число больше первого максимума, то запишем во второй макисмум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй макисмум.\n\n```java\npublic static int[] findMax2(int[] seq) {\n        int max1, max2;\n        if (seq[0] > seq[1]) {\n            max1 = seq[0];\n            max2 = seq[1];\n        } else {\n            max1 = seq[1];\n            max2 = seq[0];\n        }\n        for (int i = 2; i < seq.length; i++) {\n            if (seq[i] > max1) {\n                max2 = max1;\n                max1 = seq[i];\n            } else if (seq[i] > max2) {\n                max2 = seq[i];\n            }\n        }\n        return new int[]{max1, max2};\n    }\n```\n\n### Задача 5. Найти минимальное четное число в последовательности.\nДана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого не существует.\n\nРешение:\n\nВ переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.\n\nУниверсальный способ для решения это завести boolean переменную с признаком встречали ли мы четное число или нет. Изначально она равна fasle, а как встретили четное число делаем ее true.\n\n```java\npublic static int findMinEven(int[] seq) {\n    int ans = 0;\n    boolean isFound = false;\n\n    for (int i = 0; i < seq.length; i++) {\n        int now = seq[i];\n        if (now % 2 == 0 && (!isFound || now < ans)) {\n            ans = now;\n            isFound = true;\n        }\n    }\n    return ans;\n}\n```\n\n## Два прохода\n\n### Задача 6. Вывести все самые короткие слова через пробел.\n\nДана последовательность слов. Вывести все самые короткие слова через пробел.\n\nЕсли решать задачу за один проход, то есть сохранять количество символов в строке и саму строку и при нахождении еще более меньшей обновлять ее, это будет медленно и будет лишняя память заниматься. Так как мы будем накапливать слова, и хороше если добавление слова будет занимать $O(1)$, но может быть и больше, если копировать сами объекты. В Java лучше использовать для этих целей StringBuilder или StringBuffer.\n\n```java\npublic static String shortWords(String[] words) {\n    int minLength = words[0].length();\n    for (String word : words) {\n        if (word.length() < minLength) {\n            minLength = word.length();\n        }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (String word : words) {\n        if (word.length() == minLength) {\n            ans.append(word).append(\" \");\n        }\n    }\n\n    return ans.toString();\n}\n```\n\n### Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.\n\nИгра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окруженный морем. Над островом прошел сильный дождь, который затопил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень.\n\nПо ландшафту острова определить, скоолько блоков воды осталось после дождя в низинах острова.\n\n**_Решение:_**\n\nПосле того как вода нальется наш остров примет форму ступенек. Давайте найдем самый высокий столбик(вершину) и до этой вершины будут ступеньки на подъем, вся вода будет сливаться влево от вершины, а все что справа от вершины будет утекать вправо. \n\nРазделим задачу на две задачи по вершине острова и решим сначала для левой а потом по аналогии для правой.\n\nБудем идти и запоминать максимальную высоту столбика который нам встретился, если следующий столбик меньше то добавляем разность высот между этими столбиками которая зальется водой, если же произошло обновление максимума, то количество воды не добавляем.\n\n```java\npublic static int isleFlood(int[] h) {\n    int maxPos = 0;\n    for (int i = 0; i < h.length; i++) {\n        if (h[i] > h[maxPos]) {\n            maxPos = i;\n        }\n    }\n\n    int ans = 0;\n    int nowMax = 0;\n    for (int i = 0; i < maxPos; i++) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n\n    nowMax = 0;\n    for (int i = h.length - 1; i > maxPos; i--) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n    return ans;\n}\n```\n\n## Задача с собеседования\n\n### Задача 8 - RLE\n\nДана строка (возможно пустая), состоящая из букв A-Z: AAAABBBCCХYZDDDВEEEFFFAAAAAABBBBBBBBBBBBBBBBBB}\nНужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3F3A6B18. И сгенерирует ошибку если на вход пришла невалидная строка.\n\nЕсли символ встречался один раз, он остается без изменений; Если символ повторяется более 1 раза, к нему добавляется количество повторений.\n\n\nПопробуем упростить задачу и написать сначала функцию которая выдаст в ответе строку ABCXYZDEFAB.  \nКладем изначально в переменную значение первого символа, далее проходим по всей строки и проверяем если символ не соответсвует предыдущему то добавляем предыдущий символ и обновляем его. В конце добавляем оставшийся последний символ.\n\n```java\npublic static String easyPeasy(String s){\n    StringBuilder ans = new StringBuilder();\n    char lastCh = s.charAt(0);\n    for (int i = 1; i < s.length(); i++) {\n        if(s.charAt(i) != lastCh){\n            ans.append(lastCh);\n            lastCh = s.charAt(i);\n        }\n    }\n    ans.append(lastCh);\n\n    return ans.toString();\n}\n```\n\nДля полноценного выполнения задачи чтобы посчитать сколько раз символ подряд встретился в строке нужно добавить разность между последней позицией текщего повторяющегося символа и позицией последнего отличающегося символа. Добавим анонимную функцию для вычисления.\n\n```java\npublic static String rle(String s) {\n    StringBuilder ans = new StringBuilder();\n    int lastPos = 0;\n    char lastCh = s.charAt(0);\n\n    BiFunction<StringBuilder, Integer, StringBuilder> pack =\n            (str, cnt) -> {\n                if (cnt > 1) {\n                    return str.append(cnt);\n                }\n                return str;\n            };\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) != lastCh) {\n            ans.append(lastCh);\n            pack.apply(ans, i - lastPos);\n            lastCh = s.charAt(i);\n            lastPos = i;\n        }\n    }\n\n    ans.append(lastCh);\n    pack.apply(ans, s.length() - lastPos);\n\n    return ans.toString();\n}\n```\n## Вопросы\n\n1. _**Алгоритмы линейного поиска это про алгоритмы Рабина Карпа?**_\nАлгоритм Рабина Карпа - это алгоритм поиска подстроки в строке и его с большой натяжкой можно назвать алгоритмом линейного поиска. Это довольно умный алгоритм.\n\n2. **_Волнует ли вопрос оптимизации в алгоритме линейного поиска?_**\nДа, волнует, но бывают такие последовательности которые не обладают никаким свойством и задачи поиска максимума или поиска значения в последовательности про которую ничего не известно, никак быстрее не сделать мы так или иначе должны посмотреть каждое значение. ","description":"Линейный поиск","image":"null","category":null,"date":"24/07/2022","path":"/linejnyj-poisk/","links":[{"title":"","items":[{"title":"Алгоритмы (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Сложность, тестирование, особые случаи","link":"/slozhnost-testirovanie-osobye-sluchai/"},{"title":"Линейный поиск","link":"/linejnyj-poisk/"},{"title":"Множества","link":"/mnozhestva/"},{"title":"Словари и сортировка подсчётом","link":"/slovari-i-sortirovka-podschyotom/"},{"title":"Префиксные суммы и два указателя","link":"/prefiksnye-summy-i-dva-ukazatelya/"},{"title":"Бинарный поиск","link":"/binarnyj-poisk/"},{"title":"Сортировка событий","link":"/sortirovka-sobytij/"},{"title":"Деревья","link":"/derevya/"}]}],"headings":[{"value":"Классические задачи линейного поиска","anchor":"#классические-задачи-линейного-поиска"},{"value":"Два прохода","anchor":"#два-прохода"},{"value":"Задача с собеседования","anchor":"#задача-с-собеседования"},{"value":"Вопросы","anchor":"#вопросы"}],"subtitles":[{"depth":2,"value":"Классические задачи линейного поиска","anchor":"#классические-задачи-линейного-поиска"},{"depth":3,"value":"Задача 1. Найти первое вхождение положительного числа.","anchor":"#задача-1-найти-первое-вхождение-положительного-числа"},{"depth":3,"value":"Задача 2. Найти последнее вхождение положительного числа.","anchor":"#задача-2-найти-последнее-вхождение-положительного-числа"},{"depth":3,"value":"Задача 3. Найти максимальное число в последовательности.","anchor":"#задача-3-найти-максимальное-число-в-последовательности"},{"depth":3,"value":"Задача 4. Найти максимальное число в последовательности и второе по величине число.","anchor":"#задача-4-найти-максимальное-число-в-последовательности-и-второе-по-величине-число"},{"depth":3,"value":"Задача 5. Найти минимальное четное число в последовательности.","anchor":"#задача-5-найти-минимальное-четное-число-в-последовательности"},{"depth":2,"value":"Два прохода","anchor":"#два-прохода"},{"depth":3,"value":"Задача 6. Вывести все самые короткие слова через пробел.","anchor":"#задача-6-вывести-все-самые-короткие-слова-через-пробел"},{"depth":3,"value":"Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.","anchor":"#задача-7-определить-сколько-блоков-воды-осталось-после-дождя-в-низинах-острова"},{"depth":2,"value":"Задача с собеседования","anchor":"#задача-с-собеседования"},{"depth":3,"value":"Задача 8 - RLE","anchor":"#задача-8---rle"},{"depth":2,"value":"Вопросы","anchor":"#вопросы"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"алгоритмы","title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}]},"comments":{"edges":[]}},"context":{}}