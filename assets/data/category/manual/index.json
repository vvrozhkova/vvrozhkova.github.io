{"hash":"aa5a7ff62b399012289acf12f7cc1503ba4e22e5","data":{"category":{"title":"manual","path":"/category/manual/","belongsTo":{"totalCount":44,"pageInfo":{"totalPages":5,"currentPage":1},"edges":[{"node":{"id":"4004b2e972ad55a09e6121f380403fc3","title":"Ресурсы. Тест дизайн","content":"\nhttps://www.youtube.com/watch?v=LcTymHYm1MM\n\nhttps://www.youtube.com/watch?v=SO3o43A4jVw\n\nhttps://www.youtube.com/watch?v=yzOiGpLA0Jc\n\nhttps://www.youtube.com/watch?v=hBl5pV2xnQg\n\nhttps://www.youtube.com/watch?v=Bqmuw3ZJ75g\n\nhttps://www.youtube.com/watch?v=EGtUFuZmaQ8","date":"2022-06-10T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-test-dizajn/","order":null,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[]}},{"node":{"id":"5b2f35cd39a557d147d58071eed7e641","title":"Тестирование, Quality control, Quality assurance","content":"\nПроцесс Тестирование является частью Quality Control, а Quality Control частью Quality Assurance.\n\n## Обеспечение качества (Quality Assurance)\n\nАктивности, направленные на обеспечение уверенности в том, что требования к качеству будут выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9E%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QA (Quality Assurance, обеспечение качества)** – это, собственно, весь комплекс процессов, обеспечивающих качество, наиболее обширное понятие. QA интегрировано во все этапы разработки: от описания проекта до тестирования, релиза и даже пост-релизного обслуживания.\n\nЭто уже проактивная работа, т.к. **_основная задача  обеспечения качества_** – это выстроить систему, которая будет превентивно работать на качество продукта, чтобы при тестировании количество дефектов было минимальным. \n\nВ зависимости от специфики проекта сюда может включаться тестирование документации, подготовка и установка стандартов, анализ качества, выбор инструментов, ревью кода на соответствие стандартам, внедрение каких-то методик по работе с качеством, коммуникационные активности и проч. \n\nЗанимаются Lead специалисты либо менеджеры.\n\n## Контроль качества (Quality Control)\n\nНабор действий, предназначенных для оценивания качества компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QC (Quality Control, контроль качества)** – это часть комплекса QA, которая отвечает за анализ результатов тестирования, поиск ошибок и их устранение. В него входят различные процессы, такие как анализ кода, технические обзоры, анализ дизайна, тестирование и прочее.\n\nQuality Control обеспечивает не только проверку продукта на соответствие требованиям, но и соответствие заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшен. \nЭто совокупность действий, проводимых над продуктом в процессе разработки, для получения информации о его актуальном состоянии в разрезах:\n- готовность продукта к выпуску,\n- соответствие зафиксированным требованиям,\n- соответствие заявленному уровню качества продукта. \n\n**_Основная задача контроля качества_** – предоставить объективную картину того, что происходит с качеством продукта на разных этапах разработки. \n\nЗанимаются middle специалисты.\n\n## Тестирование программного обеспечения\n\nПроцесс, содержащий все активности жизненного цикла, как динамические, так и статические, касающиеся планирования, подготовки и оценки компонента или системы и связанных с этим результатов работ с целью определить, что они соответствуют описанным требованиям, показать, что они пригодны для заявленных целей и для определения дефектов. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)]\n\n**Testing (Тестирование)** – это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям. А тестировщик — это специалист, который занимается такой проверкой. Он тестирует компоненты продукта или весь продукт целиком на предмет ошибок или неточностей разработки. Тестирование — один из ключевых процессов в системе обеспечения качества.\n\nПо факту это реактивная работа (выдали – проверил – описал дефекты – исправили), которая может помочь исправить дефекты в уже созданном программном обеспечении, но не более того. Это не значит, что тестирование – это просто (наоборот, профессиональные тестировщики – какие-то сверхлюди, по-моему), но это самая база и минимум, без которого выпускать продукт в принципе нельзя.\n\n**_Основная задача тестирования_** – выявить и зафиксировать дефекты.  \nМогут заниматься junior специалисты.\n\n\n## Пример\n\n**Требование**: В поставляемых тестовых документах должны отсутсвовать персональные данные сотрудников (фамилия и имя)\n\n**_Тестирование_**: Перед окончательным этапом поставки проверяем документацию на отсутсвие персональных данных по заранее составленному списку\n\nНо что делать, если вдруг сотрудник поменял Фамилию или пришел новый сотрудник? \n\n**_Контроль качества_**: Меняем процессы таким образом чтобы в случае если сотрудник поменял Фамилию или пришел новый сотрудник, эти данные добавлялись в текущий список\n\n**_Обеспечение качества_**: Для того чтобы предотвратить попадание ФИО наших сотрудников в тестовые данные мы переходим на процедурную генерацию ФИО. Тестировщикам больше не надо придумывать ФИО для заполнения полей, за них это сделает процедура. Более того, тестировщикам запрещено использовать данные полученные не из процедуры.\n\nВсе эти меры обеспечивают нам уверенность в том, что требование «В поставляемых тестах отсутствуют персональные данные» будет выполнено. Но важно понимать, что это никак не отменяет тестирования выходных данных на наличие ПД.\n\n## Цели тестирования\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет работать правильно при любых обстоятельствах.\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет соответствовать всем описанным требованиям.\n- Предоставление актуальной информации о состоянии продукта на данный момент.\n\n#### Источники информации\n\n1. ❗ [Artsiom Rusau QA Life: Тестировщик с нуля / Урок 3. QA, QC, тестирование. Верификация и валидация](https://youtu.be/f3Yjzjsh0aM)\n2. ❗ [Профессия тестировщик: разбираемся в QA, QC и testing](https://tproger.ru/blogs/qa-qc-tester-career/)\n3. ❗ [Что такое качество. Разбираемся в иерархии терминов «QA», «QC» и «тестирование»](https://habr.com/ru/company/rostelecom/blog/647963/)","date":"2022-05-24T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/testirovanie-quality-control-quality-assurance/","order":1,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"тестирование","path":"/tag/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/"},{"title":"Quality control","path":"/tag/Quality%20control/"},{"title":"Quality assurance","path":"/tag/Quality%20assurance/"}],"headings":[{"value":"Обеспечение качества (Quality Assurance)","anchor":"#обеспечение-качества-quality-assurance"},{"value":"Контроль качества (Quality Control)","anchor":"#контроль-качества-quality-control"},{"value":"Тестирование программного обеспечения","anchor":"#тестирование-программного-обеспечения"},{"value":"Пример","anchor":"#пример"},{"value":"Цели тестирования","anchor":"#цели-тестирования"}]}},{"node":{"id":"dd0aca15e54bf0155faa620df1fe9e71","title":"Понятие качества, международные стандарты качества","content":"\n## Качество программного обеспечения (Software Quality) по ISTQB\n\nСтепень того, насколько компонент или система соответствует сформулированным и подразумеваемым потребностям различных заинтересованных лиц. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE)]\n\n## Типы стандартов\n\n**Международные стандарты:**\n- ISO(International Organization for Standardization)/IEC(International Electrotechnical Commission)\n- IEEE(Institute of Electrical and Electronic Engineers.)\n- CMM(Capability Maturity Model - Модель Зрелости Процессов)/CMMI(Capability Maturity Model Integration - Интегрированная Модель Зрелости Процессов)\n\n**Национальные**\n- ГОСТ (применяется на уровне СНГ)\n- ГОСТ Р(РФ), СТБ(Беларуссия), ДСТУ(Украина)\n- BS (British Standard - применяются в Европе)\n\n**Отраслевые** (межнациональные)\n- DO-178B\n\n**Псевдостандарты - \"Стандарты де-факто\"** - стандарты которые были разработаны некоторыми организациями, а потом широко распространились среди какой то отрасли и(или) среди какой-то группы специалистов.\n- PMBOK - Project Menegement Body Of Knoledge, SWEBOK - SoftWare Enginering Body Of Knoledge\nНе имеют юридической силы. Могут иногда использоваться для сертификации, но эта сертификация не очень формальная и держится на уважении к какой-то организации.\n\n**Локальные стандарты внутри организации**\n- регламенты, правила, методики\n\nИмеют для отдельно взятой организации такую же силу как и внешние стандарты. Чаще всего разрабатываются на основе какого-то общепринятого стандарта, модифицированного под нужды конкретной организации.\n\n**Модели**\n- MSF, RUP, XP\n\n**Стандарты для людей**\n- ISTQB - International Software Testing Qualifications Board - подтверждает, что человек(специалист) обладает нужными характеристиками.\n\n## Определение качества ПО по международным стандартам\n\n### ISO/IEC 25010:2011 (ГОСТ Р ИСО/МЭК 25010-2015) Systems and software Quality Requirements and Evaluation (SQuaRE) - Продуктовый стандарт\n#### Требования и оценка качества систем и программного обеспечения (SQuaRE). Модели качества систем и программных продуктов\n\nСерия международных стандартов **_ISO/IEC 25000_**, также известных как _SQuaRE (System and Software Quality Requirements and Evaluation)_, определяет характеристики, по которым оценивается качество программного продукта.\n\nОбновленный стандарт **_ISO/IEC 25010_** содержит терминологию для определения, измерения и оценки качества систем и программных продуктов.  \nОн представляет восемь характеристик качества программного обеспечения, среди которых:   \n- функциональная пригодность\n- уровень производительности\n- совместимость \n- удобство использования\n- надежность\n- безопасность\n- удобство сопровождения\n- портативность\n\nСтандарт _ISO/IEC 25010_ является серьезным пересмотром стандарта _ISO/IEC 9126_. В новый стандарт добавлены дополнительные характеристики и подхарактеристики, которые более подробно описывают процесс качества программного продукта, а также введены уточнения и перегруппировка характеристик для более ясного их понимания.\n\n**Качество программного обеспечения (software quality)**: Степень удовлетворения программным продуктом заявленных и подразумеваемых потребностей при использовании в указанных условиях.\n\n### 1061-1998 IEEE Standard for Software Quality Metrics Methodology\nКачество программного обеспечения - это степень, в которой ПО обладает требуемой комбинацией свойств.\n\n\n### ISO 9000:2000 Quality Management and Quality Assurance\nКачество программного обеспечения - совокупность свойств и характеристик продукции или услуги, которые придают им способность удовлетворять обусловленные или предполагаемые потребности потребителя.\n\n## Характеристики качества ПО по стандарту ISO/IEC 25010\n\n1. **Функциональная Пригодность (Functional Suitability)**\n\nСтепень, в которой продукт или система обеспечивают выполнение функции в соответствии с заявленными и подразумеваемыми потребностями при использовании в указанных условиях.\n\n- **_функциональная полнота (functional completeness)_**: Степень покрытия совокупностью функций всех определенных задач и целей пользователя.\n- **_функциональная корректность (functional correctness)_**: Степень обеспечения продуктом или системой необходимой степени точности корректных результатов.\n- **_функциональная целесообразность (functional appropriateness)_**: Степень функционального упрощения выполнения определенных задач и достижения целей.\n\n_Пример:_ Для решения задачи пользователю предоставляется возможность выполнять только необходимые шаги, исключая любые ненужные.\n\n2. **Уровень Производительности (Performance Efficiency)**\n\nПроизводительность относительно суммы использованных при определенных условиях ресурсов[^Ресурсы могут включать в себя другие программные продукты, конфигурацию программного и аппаратного обеспечения системы и материалы (например, бумагу для печати, носители)].\n\n- **_временные характеристики (time behaviour)_**: Степень соответствия требованиям по времени отклика, времени обработки и показателей пропускной способности продукта или системы.\n- **_использование ресурсов (resource utilization)_**: Степень удовлетворения требований по потреблению объемов и видов ресурсов продуктом или системой при выполнении их функций.\n- **_потенциальные возможности (capacity)_**: Степень соответствия требованиям предельных значений параметров[^В качестве параметров могут быть возможное количество сохраняемых элементов, количество параллельно работающих пользователей, емкость канала, пропускная способность по транзакциям и размер базы данных] продукта или системы.\n\n3. **Совместимость (Compatibility)**\n\nСпособность продукта, системы или компонента обмениваться информацией с другими продуктами, системами или компонентами, и/или выполнять требуемые функции при совместном использовании одних и тех же аппаратных средств или программной среды.\n\n- **_сосуществование (совместимость) (co-existence)_**: Способность продукта совместно функционировать с другими независимыми продуктами в общей среде с разделением общих ресурсов и без отрицательного влияния на любой другой продукт.\n- **_функциональная совместимость (интероперабельность) (interoperability)_**: Способность двух или более систем, продуктов или компонент обмениваться информацией и использовать такую информацию.\n\n4. **Удобство Использования (Usability)**\n\nСтепень, в которой продукт или система могут быть использованы определенными пользователями для достижения конкретных целей с эффективностью, результативностью и удовлетворенностью в заданном контексте использования.\n\n- **_определимость пригодности (appropriateness recognizability)_**: Возможность пользователей понять, подходит ли продукт или система для их потребностей, сравним ли с функциональной целесообразностью (functional appropriateness).\nОпределимость пригодности зависит от возможности распознать уместность продукта или функций системы от первоначальных впечатлений о продукте или системе и/или от какой-либо связанной с ними документации.\n- **_изучаемость (learnability)_**: Возможность использования продукта или системы определенными пользователями для достижения конкретных целей обучения для эксплуатации продукта или системы с эффективностью, результативностью, свободой от риска и в соответствии с требованиями в указанном контексте использования.\n- **_управляемость (operability)_**: Наличие в продукте или системе атрибутов, обеспечивающих простое управление и контроль.\n- **_защищенность от ошибки пользователя (user error protection)_**: Уровень системной защиты пользователей от ошибок.\n- **_эстетика пользовательского интерфейса (user interface aesthetics)_**: Степень \"приятности\" и \"удовлетворенности\" пользователя интерфейсом взаимодействия с пользователем.\n- **_доступность (accessibility)_**: Возможность использования продукта или системы для достижения определенной цели в указанном контексте использования широким кругом людей с самыми разными возможностями[^В диапазон возможностей входят ограничения возможностей, связанные с возрастом].\n\n5. **Надежность (Reliability)**\n\nСтепень выполнения системой, продуктом или компонентом определенных функций при указанных условиях в течение установленного периода времени.\nВ программном обеспечении износа не происходит. Проблемы с надежностью возникают из-за недостатков в требованиях, при разработке и реализации или из-за изменений условий использования.\n\n- **_завершенность (maturity)_**: Степень соответствия системы, продукта или компонента при нормальной работе требованиям надежности.\n- **_готовность (availability)_**: Степень работоспособности и доступности системы, продукта или компонента.\nВ общем, готовность можно оценить как долю общего времени, в течение которого система, продукт или компонент находятся в работающем состоянии. Готовность, таким образом, определяется сочетанием завершенности, которая определяет частоту отказов, отказоустойчивости и восстанавливаемости, которая, в свою очередь, определяет продолжительность времени бездействия после каждого отказа.\n- **_отказоустойчивость (fault tolerance)_**: Способность системы, продукта или компонента работать как предназначено, несмотря на наличие дефектов программного обеспечения или аппаратных средств.\n- **_восстанавливаемость (recoverability)_**: Способность продукта или системы восстановить данные и требуемое состояние системы в случае прерывания или сбоя.\nВ некоторых случаях после сбоя вычислительная система находится в нерабочем состоянии некоторое время, продолжительность которого определяется ее восстанавливаемостью.\n\n6. **Защита, защищенность (Security)**\n\nСтепень защищенности информации и данных, обеспечиваемая продуктом или системой путем ограничения доступа людей, других продуктов или систем к данным в соответствии с типами и уровнями авторизации.\n\nЗащищенность применима также и к данным при передаче в случаях, когда данные сохраняются непосредственно в продукте или системе или вне их.\n\n_Жизнестойкость (survivability)_ (степень, в которой продукт или система продолжают выполнять свою миссию, предоставляя основные услуги своевременно, несмотря на присутствие атак) обеспечивается восстанавливаемостью.\n\n_Защищенность, иммунитет (immunity)_ (степень устойчивости продукта или системы к атакам) обеспечивается целостностью.\n\n_Защищенность (security)_ вносит свой вклад в доверие (trust).\n\n\n- **_конфиденциальность (confidentiality)_**: Обеспечение продуктом или системой ограничения доступа к данным только для тех, кому доступ разрешен.\n- **_целостность (integrity)_**: Степень предотвращения системой, продуктом или компонентом несанкционированного доступа или модификации компьютерных программ или данных.\n- **_неподдельность (non-repudiation)_**: Степень, с которой может быть доказан факт события или действия таким образом, что этот факт не может быть отвергнут когда-либо позже.\n- **_отслеживаемость (accountability)_**: Степень, до которой действия объекта могут быть прослежены однозначно.\n- **_подлинность (authenticity)_**: Степень достоверности тождественности объекта или ресурса требуемому объекту или ресурсу.\n\n7. **Сопровождаемость, модифицируемость (Maintainability)**\n\nРезультативность и эффективность, с которыми продукт или система могут быть модифицированы предполагаемыми специалистами по обслуживанию.\n\nМодификация может включать в себя исправления, улучшения или адаптацию программного обеспечения к изменениям в условиях использования, в требованиях и функциональных спецификациях. Модификации могут быть выполнены как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\n\nСопровождаемость включает в себя установку разного рода обновлений.\n\nСопровождаемость можно интерпретировать либо как присущее продукту или системе свойство, упрощающее процесс обслуживания, либо как качество при использовании, проверенное на практике специалистами по обслуживанию в целях поддержки продукта или системы.\n\n- **_модульность (modularity)_**: Степень представления системы или компьютерной программы в виде отдельных блоков таким образом, чтобы изменение одного компонента оказывало минимальное воздействие на другие компоненты.\n- **_возможность многократного использования (reusability)_**: Степень, в которой актив может быть использован в нескольких системах или в создании других активов.\n- **_анализируемость (analysability)_**: Степень простоты оценки влияния изменений одной или более частей на продукт или систему или простоты диагностики продукта для выявления недостатков и причин отказов, или простоты идентификации частей, подлежащих изменению.\n Конкретная реализация продукта или системы может включать в себя механизмы анализа собственных дефектов и формирования отчетов об отказах и других событиях.\n- **_модифицируемость (modifiabiIity)_**: Степень простоты эффективного и рационального изменения продукта или системы без добавления дефектов и снижения качества продукта.\n  - Реализация модификации включает в себя кодирование, разработку, документирование и проверку изменений.\n  - Модульность и анализируемость могут оказывать влияние на модифицируемость.\n  - Модифицируемость - это сочетание изменяемости и устойчивости.\n- **_тестируемость (testability)_**: Степень простоты эффективного и рационального определения для системы, продукта или компонента критериев тестирования, а также простоты выполнения тестирования с целью определения соответствия этим критериям.\n\n8. **Переносимость, мобильность (Portability)**\n\nСтепень простоты эффективного и рационального переноса системы, продукта или компонента из одной среды (аппаратных средств, программного обеспечения, операционных условий или условий использования) в другую.\n\nПереносимость можно интерпретировать либо как присущее продукту или системе свойство продукта или системы, упрощающее процесс переноса, либо как качество при использовании, предназначенное для переноса продукта или системы.\n\n- **_адаптируемость (adaptability)_**: Степень простоты эффективной и рациональной адаптации для отличающихся или усовершенствованных аппаратных средств, программного обеспечения, других операционных сред или условий использования.\nВ адаптируемость входит и масштабируемость внутренних потенциальных возможностей (например, экранных полей, таблиц, объемов транзакции, форматов отчетов и т.д.).\nАдаптация может быть выполнена как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\nЕсли система должна быть адаптирована конечным пользователем, то адаптируемость соответствует пригодности для индивидуализации, как это определено в ИСО 9241-110.\n- **_устанавливаемость (installability)_**: Степень простоты эффективной и рациональной, успешной установки и/или удаления продукта или системы в заданной среде.\nВ случае если продукт или система должны устанавливаться конечным пользователем, устанавливаемость может повлиять на результирующие функциональную целесообразность и управляемость.\n- **_взаимозаменяемость (replaceability)_**: Способность продукта заменить другой конкретный программный продукт для достижения тех же целей в тех же условиях.\nВзаимозаменяемость новой версии программного продукта важна для пользователя при обновлении продукта.\nВо взаимозаменяемость могут быть включены атрибуты как устанавливоемости, так и адаптируемости. Понятие было введено как отдельная подхарактеристика из-за ее важности.\nВзаимозаменяемость снижает риск блокировки таким образом, что, например, при стандартизации форматов файлов допускается применение других программных продуктов вместо используемого.\n\n\n\n#### Источники информации\n\n1. ❗ [ГОСТ Р ИСО/МЭК 25010-2015](https://docs.cntd.ru/document/1200121069)\n\n2. ❗ [Тестирование ПО: Стандарты в области тестирования и их применение на практике](https://youtu.be/kUvPuJuPI-g)\n\n#### Дополнительно можно посмотреть:\n\n❗ [Computer Science Center: Лекция 13. Качество ПО](https://youtu.be/zAxGTb0FFR0)\n","date":"2022-05-25T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/","order":2,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"качество","path":"/tag/%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE/"},{"title":"международные стандарты качества","path":"/tag/%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D1%8B%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0/"}],"headings":[{"value":"Качество программного обеспечения (Software Quality) по ISTQB","anchor":"#качество-программного-обеспечения-software-quality-по-istqb"},{"value":"Типы стандартов","anchor":"#типы-стандартов"},{"value":"Определение качества ПО по международным стандартам","anchor":"#определение-качества-по-по-международным-стандартам"},{"value":"Характеристики качества ПО по стандарту ISO/IEC 25010","anchor":"#характеристики-качества-по-по-стандарту-isoiec-25010"}]}},{"node":{"id":"822d205271646bbe20b041eff72f9287","title":"Жизненный цикл дефекта","content":"\nhttps://www.youtube.com/watch?v=6YrgKBTzb5o\n\n## Дефекты и ошибки (error/defect(bug)/failure)\n\n### Дефект/Баг (Bug)\n\nНесовершенство или недостаток рабочего продукта, проявляющееся в несоответствии требованиям или спецификациям. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82)]\n\n### Ошибка (Error)\n\nДействие человека, которое приводит к неправильному результату. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)]  \n_Пример: пользователь вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.)._\n\n### Отказ (Failure)\n\nСобытие, при котором компонент или система не выполняют требуемую функцию в соответствии со спецификацией. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%82%D0%BA%D0%B0%D0%B7)]  \n_Примет: аппаратный сбой, который не связан с работой самого продукта но приводящий к его не корректной работе._\n\nТак что же такое баг на практике? Когда мы имеем ситуацию “1 требование = 1 тест-кейс”, то вопрос отпадает сам собой - тест-кейс не прошёл, значит требование реализовано не правильно, значит баг. Но обычно вариантов куда больше:\n\n* работало, но вдруг перестало;\n* работает, но неправильно;\n* реализация не соответствует описанию и в задаче в явном виде не зафиксированы корректировки;\n* нужно изменить название кнопки/страницы/раздела, потому что в них есть опечатка или “Отменить отмену” (классика!);\n* опечатки в принципе (легко может иметь разный приоритет в зависимости от целей и задач проекта);\n* после сохранения информация не появляется на странице, даже если в консоли 200 ОК;\n* не все указанные при сохранении поля отображаются на странице, но поля неизменно показываются при редактировании;\n* при нажатии на кнопку “УДАЛИТЬ ВООБЩЕ ВСЕ ДАННЫЕ КЛИЕНТА” нет модального окна с подтверждением Да/Нет, да и сделать это может любой пользователь без авторизации, который нашел ссылку;\n* по переходу по прямой ссылке на услугу не проверяется какой пользователь сейчас авторизован и таким образом можно посмотреть чужие профили или детали услуг, если подобран валидный id;\n* можно cURL’ом заказать услугу другому клиенту или в Elements через DevTools изменить стоимость в корзине (не проворачивайте такие сценарии не на своих рабочих проектах);\n* информация торчит за границами своего блока или “наслаивается” на другой (ж-ж-ж-жуть, но на некоторых проектах этим можно легко пренебречь);\n* страница очень долго открывается, ну о-о-очень долго - секунд 30 на стабильном интернете (взбешенный клиент гарантирован);\n* система делает что-то, что она не должна делать согласно изначальной задумке. Например, закрытие аккаунта не только переводит его в статус “Закрыто”, но и возвращает клиенту все деньги, которые он принес проекту за всё время сотрудничества за уже оказанные услуги (о-о-ой!);\n* неудобно пользоваться. Например, чтобы посмотреть детали услуги клиента, нужно зайти на три вкладки вглубь аккаунта, а смотреть нужно 2-3 раза в день. Или неудобно копировать информацию со страницы, а по рабочим вопросам это нужно делать несколько раз в день - это баг интерфейса и он должен быть исправлен.\n\nПри этом часто может возникнуть извечный вопрос “баг или фича?”, когда баг-репорт заводить не нужно. Это фича-реквест, если:\n\n* нужно изменить название кнопки/страницы/раздела, потому что есть ощущение, что оно не отражает действительности;\n* фичу сделали, но после использования видно, что есть простор для существенных улучшений. Например, по услуге не хватает мониторинга или статистических данных по использованию, а за перерасход может взиматься дополнительная плата - клиент точно будет несчастлив в неведении;\n* знаете как улучшить ту или иную часть системы, чтобы было удобней. Например, меню необоснованно занимает 30% ширины экрана, а полезная информация ютится на оставшихся 70%;\n* пользователь регулярно делает рутинные монотонные действия, которые можно автоматизировать. Например, копировать однотипную информацию с 12 страниц пагинации, когда простая выгрузка бы решила проблему;\n* изобретаете велосипед из действующих фич продукта, чтобы добиться желаемого результата;\n* на странице не хватает какой-то информации или возможности её добавить;\n* на странице не хватает фильтров и пагинации, когда информации много и трудно найти нужное или отображение 1000+ элементов существенно сказывается на скорости загрузки страницы;\n* пользователь ведет дополнительную отчетность в блокноте/экселе, когда проблему можно решить выводом ID на странице и несколькими фильтрами.\n\nХорошо если в команде есть UX/UI дизайнер, а если нет? Тестировщику стоит различать что в дизайне баг, который может привести к печальным последствиям, а что запрос на улучшение, который сделает взаимодействие пользователей с системой более гладким и удобным, но может быть реализован позднее.\n\n**Классификация дефектов**\n\nДефекты можно классифицировать по-разному. Для организации важно следовать единой схеме классификации и применять ее ко всем проектам. Некоторые дефекты можно отнести к нескольким классам или категориям. Из-за этой проблемы разработчики, тестировщики и сотрудники SQA должны стараться быть максимально последовательными при записи данных о дефектах.\n\n**Классы дефектов**:\n\n*   **Дефекты требований и спецификаций** (Requirements and Specifications Defects): Начало жизненного цикла программного обеспечения важно для обеспечения высокого качества разрабатываемого программного обеспечения. Дефекты, введенные на ранних этапах, очень трудно устранить на более поздних этапах. Поскольку многие документы с требованиями написаны с использованием представления на естественном языке, они могут стать\n\n    * Двусмысленными;\n    * Противоречивыми;\n    * Непонятными;\n    * Избыточными;\n    * Неточными.\n\n    Некоторые специфические дефекты требований / спецификаций:\n\n    * Дефекты функционального описания: Общее описание того, что делает продукт и как он должен себя вести (входы / выходы), неверно, двусмысленно и / или неполно;\n    * Дефекты функций: описываются как отличительные характеристики программного компонента или системы. Дефекты функций связаны с отсутствием, неправильным, неполным или ненужным описанием функций;\n    * Дефекты взаимодействия функций: это происходит из-за неправильного описания того, как функции должны взаимодействовать друг с другом;\n    * Дефекты описания интерфейсов: это дефекты, которые возникают в описании взаимодействия целевого программного обеспечения с внешним программным обеспечением, оборудованием и пользователями.\n* **Дефекты дизайна**: Дефекты дизайна возникают когда неправильно спроектированы: Системные компоненты, Взаимодействие между компонентами системы, Взаимодействие между компонентами и внешним программным / аппаратным обеспечением или пользователями. Они включают дефекты в конструкции алгоритмов, управления, логики, элементов данных, описаний интерфейсов модулей и описаний внешнего программного обеспечения / оборудования / пользовательского интерфейса. К дефектам дизайна относятся:\n  * Алгоритмические дефекты и дефекты обработки: это происходит, когда этапы обработки в алгоритме, описанном псевдокодом, неверны;\n  * Дефекты управления, логики и последовательности: Дефекты управления возникают, когда логический поток в псевдокоде неверен;\n  * Дефекты данных: Они связаны с неправильным дизайном структур данных;\n  * Дефекты описания интерфейсов модулей: эти дефекты возникают из-за неправильного или непоследовательного использования типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * Дефекты функционального описания: к дефектам этой категории относятся неправильные, отсутствующие или неясные элементы дизайна;\n  * Дефекты описания внешних интерфейсов: они возникают из-за неправильных описаний дизайна интерфейсов с компонентами COTS, внешними программными системами, базами данных и аппаратными устройствами.\n* **Дефекты кода**: Дефекты кодирования возникают из-за ошибок при реализации кода. Классы дефектов кодирования аналогичны классам дефектов дизайна. Некоторые дефекты кодирования возникают из-за непонимания конструкций языка программирования и недопонимания с разработчиками.\n  * Алгоритмические дефекты и дефекты обработки:\n    * Непроверенные условия overflow and underflow;\n    * Сравнение несоответствующих типов данных;\n    * Преобразование одного типа данных в другой;\n    * Неправильный порядок арифметических операторов;\n    * Неправильное использование или пропуск круглых скобок;\n    * Потеря точности (Precision loss);\n    * Неправильное использование знаков.\n  * Дефекты управления, логики и последовательности: этот тип дефектов включает неправильное выражение операторов case, неправильное повторение циклов и пропущенные пути;\n  * Типографические дефекты: в основном это синтаксические ошибки, например неправильное написание имени переменной, которые обычно обнаруживаются компилятором, self-reviews, or peer reviews;\n  * Дефекты инициализации: этот тип дефектов возникает, когда операторы инициализации пропущены или неверны. Это может произойти из-за недопонимания или отсутствия связи между программистами или программиста и дизайнера, небрежности или непонимания среды программирования;\n  * Дефекты потока данных: дефекты потока данных возникают, когда код не следует необходимым условиям потока данных;\n  * Дефекты данных: на это указывает неправильная реализация структур данных;\n  * Дефекты интерфейса модуля: возникают из-за использования неправильных или несовместимых типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * Дефекты документации кода: когда документация по коду не описывает, что программа на самом деле делает, либо является неполной или двусмысленной;\n  * Внешнее оборудование, дефекты программных интерфейсов: эти дефекты возникают из-за проблем, связанных с Системными вызовами, Ссылками на базы данных, Последовательностью ввода / вывода, Использованием памяти, Использованием ресурсов, Обработкой прерываний и исключений, Обменом данными с оборудованием, Протоколами, Форматами, Интерфейсами с файлами сборки, Временными последовательностями.\n* **Дефекты тестирования**: Планы тестирования, тестовые наборы, средства тестирования и процедуры тестирования также могут содержать дефекты. Эти дефекты называются дефектами тестирования. Дефекты в планах тестирования лучше всего обнаруживать с помощью методов review.\n  * Дефекты тестовой обвязки: Для тестирования программного обеспечения на уровне модулей и интеграции необходимо разработать вспомогательный код. Это называется Test Harness или scaffolding code. Test Harness должен быть тщательно спроектирован, реализован и протестирован, поскольку это рабочий продукт, и этот код можно повторно использовать при разработке новых версий программного обеспечения;\n  * Дизайн тестового случая и дефекты процедуры тестирования: сюда входят неправильные, неполные, отсутствующие, несоответствующие тестовые примеры и процедуры тестирования.\n\n\n## Жизненный цикл дефекта (Defect/Bug Life Cycle)\n\nЖизненный цикл дефекта - это представление различных состояний дефекта, в которых он пребывает от начального до конечного этапа своего существования. Он может варьироваться от компании к компании и настраиваться под процессы конкретного проекта.\n\n![https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png](https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png)\n\n**Статусы дефекта**:\n\n* **Новый** (New): когда новый дефект регистрируется и публикуется впервые;\n* **Назначен** (Assigned): после публикации бага тестировщиком руководитель тестировщика утверждает ошибку и передает ее команде разработчиков;\n* **Открыт** (Open): разработчик начинает анализ и работает над исправлением бага;\n* **Исправлен** (Fixed): разработчик внес необходимое изменение в код и проверил его;\n* **Ожидает повторного тестирования** (Pending retest): как только дефект будет исправлен, разработчик предоставляет тестировщику конкретный код для повторного тестирования кода. Поскольку тестирование программного обеспечения остается незавершенным со стороны тестировщиков, ему присваивается статус «ожидает повторного тестирования»;\n* **Повторное тестирование** (Retest): на этом этапе тестировщик выполняет повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком;\n* **Проверен** (Verified): тестировщик повторно тестирует баг после его исправления разработчиком. Если баг исправлен, то присваивается статус «проверено»;\n* **Переоткрыт** (Reopen): если баг сохраняется даже после того, как разработчик исправил баг, тестировщик меняет статус на «повторно открыт». И снова баг проходит жизненный цикл.\n* **Закрыт** (Closed): если баг больше не существует, тестировщик присваивает статус «Закрыто».\n* **Дубль** (Duplicate): если дефект повторяется дважды или дефект соответствует той же концепции ошибки, статус изменяется на «дублировать».\n* **Отклонен** (Rejected): если разработчик считает, что дефект не является таковым, он меняет статус на «отклонен»;\n* **Отложен** (Deferred): если текущий баг не является приоритетным и ожидается, что он будет исправлен ​​в следующем выпуске, таким багам присваивается статус «Отложено»;\n* **Не является багом** (Not a bug): если это не влияет на функциональность приложения, то багу присваивается статус «Не является багом».\n\n![https://www.guru99.com/images/defectcyclechart.png](https://www.guru99.com/images/defectcyclechart.png)\n\n**Утечка дефектов и релиз бага (Bug Leakage & Bug Release)**\n\nУтечка бага (Bug Leakage): возникает когда пропускается баг в билде, который вышел в Production. Если баг был обнаружен конечным пользователем или заказчиком, мы называем это утечкой ошибок.\n\nВыпуск бага (Bug release): выпуск программного обеспечения в Production с некоторыми известными багами. Эти известные баги следует включить в примечания к выпуску (release notes). Другой вариант - передача программного обеспечения группе тестирования с некоторыми известными багами, серьезность и приоритет которых невысоки. Эти ошибки можно исправить перед выпуском в Production.\n\n**Основное отличие отладки от тестирования (**[**Debugging**](https://www.youtube.com/watch?v=URH45Vx08n4) **Vs. Testing)**\n\nПосле того, как разработчик получил баг-репорт, он приступает к исправлению бага. Но, прежде чем ошибку исправить, нужно ее воспроизвести, понять, как она происходит и где ее найти в коде. Дебаг, буквально “de”+”bug” - это и есть процесс поиска и устранения ошибок в коде. Специальная debug-версия билда приложения может иметь расширенный вывод для более информативных логов или любые другие модификации для упрощения понимания проблемы. Тактика отладки может включать интерактивную отладку, анализ потока управления, модульное тестирование, интеграционное тестирование, анализ логов, мониторинг на уровне приложения или системы, дампы памяти и профилирование. Многие языки программирования и инструменты разработки программного обеспечения также предлагают программы для помощи в отладке, известные как отладчики/дебаггеры.\n\n**Маскировка дефектов (Defect masking)**\n\n_Маскирование дефектов (defect masking): Случай, когда один дефект препятствует нахождению другого. (IEEE 610)_\n\n**Скрытый дефект (Latent defect)**\n\nДефект, который является существующим дефектом в системе, но еще не вызывал сбоев, поскольку подходящий набор входных данных для его проявления не был введен или его проявлению мешает другой дефект (Defect masking).\n\n**Сортировка дефектов (Bug triage)**\n\nЭто формальный процесс определения серьезности и приоритета дефектов в зависимости от их severity, риска, повторяемости и т. д. во время Defect Triage Meeting. Такая встреча полезна в условиях ограниченных ресурсов, когда нужно разобраться с множеством ошибок и тем, какие из них приоритетные.\n\nПонятие сортировки пришло из медицины, где это процесс быстрого обследования пациентов, доставленных в больницу, чтобы решить, какие из них наиболее серьезно больны и нуждаются в лечении в первую очередь. В тестировании мы используем ту же концепцию к ошибкам, обнаруженным на этапе тестирования.\n\n**Подсев недочетов (fault seeding)**\n\n_Процесс намеренного внесения дефектов в дополнение к тем, что уже существуют в компоненте или в системе, для целей отслеживания уровня обнаружения и устранения, а также оценивания количества оставшихся в системе дефектов. Подсев недочетов обычно является частью процесса тестирования разработки и может применяться на любом уровне тестирования (компонентном, интеграционном или системном). (IEEE 610)_\n\n## Валидация vs верификация \n\n### Верификация (Verification)\n\nДоказанное объективными результатами исследования подтверждение того, что определенные требования (спецификации, формальные требования) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Валидация (Validation)\n\nДоказанное объективными результатами исследования подтверждение того, что требования для ожидаемого конкретного использования приложения (соответствие ожиданиям и требованиям пользователей) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Пример:\nЕсли попробовать привести очень упрощенный пример, представим блюдо в ресторане. Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.\n\n## Priority vs Severity\n\n### Приоритет (Priority)\n\nСтепень важности, присваеваемая объекту. Например, дефекту или задаче. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82)]  \nУказывает на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект. Выставляется менеджером, тимлидом или заказчиком.\n\n**Градация Приоритета дефекта (Priority):**\n- **_P1 Высокий (High)_**  \nОшибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.\n- **_P2 Средний (Medium)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.\n- **_P3 Низкий (Low)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.\n\n### Критичность/Серьезность (Severity)\n\nВажность воздействия конкретного дефекта на разработку или функционирование компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)]  \nХарактеризует влияние дефекта на работоспособность приложения. Выставляется тестировщиком.\n\n**Градация Критичности дефекта (Severity)**\n\n- **_S1 Блокирующая (Blocker)_**  \nБлокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.\n\n- **_S2 Критическая (Critical)_**  \nКритическая ошибка, неправильно работающая ключевая бизнес логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с ключевыми функциями тестируемой системой.\n\n- **_S3 Значительная (Major)_**  \nЗначительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.\n\n- **_S4 Незначительная (Minor)_**  \nНезначительная ошибка, не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.\n\n- **_S5 Тривиальная (Trivial)_**  \nТривиальная ошибка, не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.\n\n\n### Сочетания Severity и Priority\n\n- **High Priority and High Severity**  \nЛюбой Critical/major сбой бизнес-модели, критическая проблема, при которой полностью не работает большая часть функциональности или основной компонент системы:\n  - нажатие на определенную кнопку не запускает саму функцию, например, не работает кнопка отправки на странице входа, и клиенты не могут войти в приложение;\n  - выполнение определенной функции постоянно приводит к 500 ошибке сервера и потере данных;\n  - система дает сбой после того, как вы совершили платеж или когда вы не можете добавить товары в корзину;\nфункция банкомата, при которой после ввода правильного имени пользователя и пароля автомат не выдает деньги, но списывает их с вашего счета;\n  - на веб-сайте банка появляется сообщение об ошибке, когда клиент нажимает кнопку перевода денег.\n\n- **High Priority and Low Severity**  \nЛюбые minor severity дефекты, которые влияют на взаимодействие с пользователями / репутацию:\n  - ожидается, что функция покажет пользователю конкретную ошибку по коду ответа. В этом случае функционально код выдает ошибку, но сообщение должно быть более релевантным коду;\n  - ошибка в логотипе или названии компании на главной странице, или опечатки, бросающиеся в глаза и способные повлиять на репутацию компании;\n  опечатки в контактных данных;\n  - важные ошибки в соглашениях и юридических документах.\n\n- **Low Priority and High Severity**  \nПроблема, которая пока не повлияет на бизнес, но имеет большое влияние с точки зрения функциональности:\n  - присутствует серьезный баг, но есть workaround и исправление уже может быть запланировано в следующем релизе или функция будет удалена;\n  - функция генерации годового отчета, которая будет использована только через полгода;\n  - редкость проявления дефекта/сложность воспроизведения для юзеров.\n\n- **Low Priority and Low Severity**  \nЛюбые орфографические ошибки / начертание / несовпадение шрифта в абзаце 3-й или 4-й страницы заявки, а не на главной или титульной странице / заголовке. Эти дефекты возникают, когда это не влияет на функциональность, но все же в небольшой степени не соответствует стандартам. Обычно сюда классифицируются косметические ошибки или, скажем, размеры ячейки в таблице пользовательского интерфейса:\n  - в политике конфиденциальности веб-сайта есть орфографическая ошибка;\n  - страница часто задаваемых вопросов загружается очень долго;\n  - семейство шрифтов, размер шрифта, цвет или орфографическая ошибка в приложении или отчетах.","date":"2022-05-23T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/zhiznennyj-czikl-defekta/","order":3,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Жизненный цикл дефекта","path":"/tag/%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%86%D0%B8%D0%BA%D0%BB%20%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[{"value":"Дефекты и ошибки (error/defect(bug)/failure)","anchor":"#дефекты-и-ошибки-errordefectbugfailure"},{"value":"Жизненный цикл дефекта (Defect/Bug Life Cycle)","anchor":"#жизненный-цикл-дефекта-defectbug-life-cycle"},{"value":"Валидация vs верификация","anchor":"#валидация-vs-верификация"},{"value":"Priority vs Severity","anchor":"#priority-vs-severity"}]}},{"node":{"id":"546a780c3e156190529c370901539222","title":"Жизненный цикл дефекта","content":"\n## Дефекты и ошибки (error/defect(bug)/failure)\n\n### Дефект/Баг (Bug)\n\nНесовершенство или недостаток рабочего продукта, проявляющееся в несоответствии требованиям или спецификациям. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82)]\n\n### Ошибка (Error)\n\nДействие человека, которое приводит к неправильному результату. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B0)]  \n_Пример: пользователь вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.)._\n\n### Отказ (Failure)\n\nСобытие, при котором компонент или система не выполняют требуемую функцию в соответствии со спецификацией. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BE%D1%82%D0%BA%D0%B0%D0%B7)]  \n_Примет: аппаратный сбой, который не связан с работой самого продукта но приводящий к его не корректной работе._\n\nТак что же такое баг на практике? Когда мы имеем ситуацию “1 требование = 1 тест-кейс”, то вопрос отпадает сам собой - тест-кейс не прошёл, значит требование реализовано не правильно, значит баг. Но обычно вариантов куда больше:\n\n* работало, но вдруг перестало;\n* работает, но неправильно;\n* реализация не соответствует описанию и в задаче в явном виде не зафиксированы корректировки;\n* нужно изменить название кнопки/страницы/раздела, потому что в них есть опечатка или “Отменить отмену” (классика!);\n* опечатки в принципе (легко может иметь разный приоритет в зависимости от целей и задач проекта);\n* после сохранения информация не появляется на странице, даже если в консоли 200 ОК;\n* не все указанные при сохранении поля отображаются на странице, но поля неизменно показываются при редактировании;\n* при нажатии на кнопку “УДАЛИТЬ ВООБЩЕ ВСЕ ДАННЫЕ КЛИЕНТА” нет модального окна с подтверждением Да/Нет, да и сделать это может любой пользователь без авторизации, который нашел ссылку;\n* по переходу по прямой ссылке на услугу не проверяется какой пользователь сейчас авторизован и таким образом можно посмотреть чужие профили или детали услуг, если подобран валидный id;\n* можно cURL’ом заказать услугу другому клиенту или в Elements через DevTools изменить стоимость в корзине (не проворачивайте такие сценарии не на своих рабочих проектах);\n* информация торчит за границами своего блока или “наслаивается” на другой (ж-ж-ж-жуть, но на некоторых проектах этим можно легко пренебречь);\n* страница очень долго открывается, ну о-о-очень долго - секунд 30 на стабильном интернете (взбешенный клиент гарантирован);\n* система делает что-то, что она не должна делать согласно изначальной задумке. Например, закрытие аккаунта не только переводит его в статус “Закрыто”, но и возвращает клиенту все деньги, которые он принес проекту за всё время сотрудничества за уже оказанные услуги (о-о-ой!);\n* неудобно пользоваться. Например, чтобы посмотреть детали услуги клиента, нужно зайти на три вкладки вглубь аккаунта, а смотреть нужно 2-3 раза в день. Или неудобно копировать информацию со страницы, а по рабочим вопросам это нужно делать несколько раз в день - это баг интерфейса и он должен быть исправлен.\n\nПри этом часто может возникнуть извечный вопрос “баг или фича?”, когда баг-репорт заводить не нужно. Это фича-реквест, если:\n\n* нужно изменить название кнопки/страницы/раздела, потому что есть ощущение, что оно не отражает действительности;\n* фичу сделали, но после использования видно, что есть простор для существенных улучшений. Например, по услуге не хватает мониторинга или статистических данных по использованию, а за перерасход может взиматься дополнительная плата - клиент точно будет несчастлив в неведении;\n* знаете как улучшить ту или иную часть системы, чтобы было удобней. Например, меню необоснованно занимает 30% ширины экрана, а полезная информация ютится на оставшихся 70%;\n* пользователь регулярно делает рутинные монотонные действия, которые можно автоматизировать. Например, копировать однотипную информацию с 12 страниц пагинации, когда простая выгрузка бы решила проблему;\n* изобретаете велосипед из действующих фич продукта, чтобы добиться желаемого результата;\n* на странице не хватает какой-то информации или возможности её добавить;\n* на странице не хватает фильтров и пагинации, когда информации много и трудно найти нужное или отображение 1000+ элементов существенно сказывается на скорости загрузки страницы;\n* пользователь ведет дополнительную отчетность в блокноте/экселе, когда проблему можно решить выводом ID на странице и несколькими фильтрами.\n\nХорошо если в команде есть UX/UI дизайнер, а если нет? Тестировщику стоит различать что в дизайне баг, который может привести к печальным последствиям, а что запрос на улучшение, который сделает взаимодействие пользователей с системой более гладким и удобным, но может быть реализован позднее.\n\n## Классификация дефектов\n\nДефекты можно классифицировать по-разному. Для организации важно следовать единой схеме классификации и применять ее ко всем проектам. Некоторые дефекты можно отнести к нескольким классам или категориям. Из-за этой проблемы разработчики, тестировщики и сотрудники SQA должны стараться быть максимально последовательными при записи данных о дефектах.\n\n### Дефекты требований и спецификаций (Requirements and Specifications Defects)\nНачало жизненного цикла программного обеспечения важно для обеспечения высокого качества разрабатываемого программного обеспечения. Дефекты, введенные на ранних этапах, очень трудно устранить на более поздних этапах. Поскольку многие документы с требованиями написаны с использованием представления на естественном языке, они могут стать\n\n* Двусмысленными;\n* Противоречивыми;\n* Непонятными;\n* Избыточными;\n* Неточными.\n\nНекоторые специфические дефекты требований / спецификаций:\n\n* **Дефекты функционального описания:** Общее описание того, что делает продукт и как он должен себя вести (входы / выходы), неверно, двусмысленно и / или неполно;\n* **Дефекты функций:** описываются как отличительные характеристики программного компонента или системы. Дефекты функций связаны с отсутствием, неправильным, неполным или ненужным описанием функций;\n* **Дефекты взаимодействия функций:** это происходит из-за неправильного описания того, как функции должны взаимодействовать друг с другом;\n* **Дефекты описания интерфейсов:** это дефекты, которые возникают в описании взаимодействия целевого программного обеспечения с внешним программным обеспечением, оборудованием и пользователями.\n\n### Дефекты дизайна\nДефекты дизайна возникают когда неправильно спроектированы: Системные компоненты, Взаимодействие между компонентами системы, Взаимодействие между компонентами и внешним программным / аппаратным обеспечением или пользователями. Они включают дефекты в конструкции алгоритмов, управления, логики, элементов данных, описаний интерфейсов модулей и описаний внешнего программного обеспечения / оборудования / пользовательского интерфейса. К дефектам дизайна относятся:\n  * **Алгоритмические дефекты и дефекты обработки:** это происходит, когда этапы обработки в алгоритме, описанном псевдокодом, неверны;\n  * **Дефекты управления, логики и последовательности:** Дефекты управления возникают, когда логический поток в псевдокоде неверен;\n  * **Дефекты данных:** Они связаны с неправильным дизайном структур данных;\n  * **Дефекты описания интерфейсов модулей:** эти дефекты возникают из-за неправильного или непоследовательного использования типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * **Дефекты функционального описания:** к дефектам этой категории относятся неправильные, отсутствующие или неясные элементы дизайна;\n  * **Дефекты описания внешних интерфейсов:** они возникают из-за неправильных описаний дизайна интерфейсов с компонентами COTS, внешними программными системами, базами данных и аппаратными устройствами.\n\n### Дефекты кода\nДефекты кодирования возникают из-за ошибок при реализации кода. Классы дефектов кодирования аналогичны классам дефектов дизайна. Некоторые дефекты кодирования возникают из-за непонимания конструкций языка программирования и недопонимания с разработчиками.\n  * **Алгоритмические дефекты и дефекты обработки:**\n    * Непроверенные условия overflow and underflow;\n    * Сравнение несоответствующих типов данных;\n    * Преобразование одного типа данных в другой;\n    * Неправильный порядок арифметических операторов;\n    * Неправильное использование или пропуск круглых скобок;\n    * Потеря точности (Precision loss);\n    * Неправильное использование знаков.\n  * **Дефекты управления, логики и последовательности:** этот тип дефектов включает неправильное выражение операторов case, неправильное повторение циклов и пропущенные пути;\n  * **Типографические дефекты:** в основном это синтаксические ошибки, например неправильное написание имени переменной, которые обычно обнаруживаются компилятором, self-reviews, or peer reviews;\n  * **Дефекты инициализации:** этот тип дефектов возникает, когда операторы инициализации пропущены или неверны. Это может произойти из-за недопонимания или отсутствия связи между программистами или программиста и дизайнера, небрежности или непонимания среды программирования;\n  * **Дефекты потока данных:** дефекты потока данных возникают, когда код не следует необходимым условиям потока данных;\n  * **Дефекты данных:** на это указывает неправильная реализация структур данных;\n  * **Дефекты интерфейса модуля:** возникают из-за использования неправильных или несовместимых типов параметров, неправильного количества параметров или неправильного порядка параметров;\n  * **Дефекты документации кода:** когда документация по коду не описывает, что программа на самом деле делает, либо является неполной или двусмысленной;\n  * **Внешнее оборудование, дефекты программных интерфейсов:** эти дефекты возникают из-за проблем, связанных с Системными вызовами, Ссылками на базы данных, Последовательностью ввода / вывода, Использованием памяти, Использованием ресурсов, Обработкой прерываний и исключений, Обменом данными с оборудованием, Протоколами, Форматами, Интерфейсами с файлами сборки, Временными последовательностями.\n\n### Дефекты тестирования\nПланы тестирования, тестовые наборы, средства тестирования и процедуры тестирования также могут содержать дефекты. Эти дефекты называются дефектами тестирования. Дефекты в планах тестирования лучше всего обнаруживать с помощью методов review.\n  * **Дефекты тестовой обвязки:** Для тестирования программного обеспечения на уровне модулей и интеграции необходимо разработать вспомогательный код. Это называется Test Harness или scaffolding code. Test Harness должен быть тщательно спроектирован, реализован и протестирован, поскольку это рабочий продукт, и этот код можно повторно использовать при разработке новых версий программного обеспечения;\n  * **Дизайн тестового случая и дефекты процедуры тестирования:** сюда входят неправильные, неполные, отсутствующие, несоответствующие тестовые примеры и процедуры тестирования.\n\n## Жизненный цикл дефекта (Defect/Bug Life Cycle)\n\n**Жизненный цикл дефекта** - это представление различных состояний дефекта, в которых он пребывает от начального до конечного этапа своего существования. Он может варьироваться от компании к компании и настраиваться под процессы конкретного проекта.\n\n![https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png](https://www.guru99.com/images/1-2015/012715\\_0802\\_BugLifeCycl1.png)\n\n### Статусы дефекта\n\n* **Новый** (New): когда новый дефект регистрируется и публикуется впервые;\n* **Назначен** (Assigned): после публикации бага тестировщиком руководитель тестировщика утверждает ошибку и передает ее команде разработчиков;\n* **Открыт** (Open): разработчик начинает анализ и работает над исправлением бага;\n* **Исправлен** (Fixed): разработчик внес необходимое изменение в код и проверил его;\n* **Ожидает повторного тестирования** (Pending retest): как только дефект будет исправлен, разработчик предоставляет тестировщику конкретный код для повторного тестирования кода. Поскольку тестирование программного обеспечения остается незавершенным со стороны тестировщиков, ему присваивается статус «ожидает повторного тестирования»;\n* **Повторное тестирование** (Retest): на этом этапе тестировщик выполняет повторное тестирование кода, чтобы проверить, исправлен ли дефект разработчиком;\n* **Проверен** (Verified): тестировщик повторно тестирует баг после его исправления разработчиком. Если баг исправлен, то присваивается статус «проверено»;\n* **Переоткрыт** (Reopen): если баг сохраняется даже после того, как разработчик исправил баг, тестировщик меняет статус на «повторно открыт». И снова баг проходит жизненный цикл.\n* **Закрыт** (Closed): если баг больше не существует, тестировщик присваивает статус «Закрыто».\n* **Дубль** (Duplicate): если дефект повторяется дважды или дефект соответствует той же концепции ошибки, статус изменяется на «дублировать».\n* **Отклонен** (Rejected): если разработчик считает, что дефект не является таковым, он меняет статус на «отклонен»;\n* **Отложен** (Deferred): если текущий баг не является приоритетным и ожидается, что он будет исправлен ​​в следующем выпуске, таким багам присваивается статус «Отложено»;\n* **Не является багом** (Not a bug): если это не влияет на функциональность приложения, то багу присваивается статус «Не является багом».\n\n![https://www.guru99.com/images/defectcyclechart.png](https://www.guru99.com/images/defectcyclechart.png)\n\n### Утечка дефектов и релиз бага (Bug Leakage & Bug Release)\n\nУтечка бага (Bug Leakage): возникает когда пропускается баг в билде, который вышел в Production. Если баг был обнаружен конечным пользователем или заказчиком, мы называем это утечкой ошибок.\n\nВыпуск бага (Bug release): выпуск программного обеспечения в Production с некоторыми известными багами. Эти известные баги следует включить в примечания к выпуску (release notes). Другой вариант - передача программного обеспечения группе тестирования с некоторыми известными багами, серьезность и приоритет которых невысоки. Эти ошибки можно исправить перед выпуском в Production.\n\n### Основное отличие отладки от тестирования (Debugging) Vs. Testing\n\nПосле того, как разработчик получил баг-репорт, он приступает к исправлению бага. Но, прежде чем ошибку исправить, нужно ее воспроизвести, понять, как она происходит и где ее найти в коде. Дебаг, буквально “de”+”bug” - это и есть процесс поиска и устранения ошибок в коде. Специальная debug-версия билда приложения может иметь расширенный вывод для более информативных логов или любые другие модификации для упрощения понимания проблемы. Тактика отладки может включать интерактивную отладку, анализ потока управления, модульное тестирование, интеграционное тестирование, анализ логов, мониторинг на уровне приложения или системы, дампы памяти и профилирование. Многие языки программирования и инструменты разработки программного обеспечения также предлагают программы для помощи в отладке, известные как отладчики/дебаггеры.\n\n❗ [see video](https://www.youtube.com/watch?v=URH45Vx08n4)\n\n### Маскировка дефектов (Defect masking)\n\n_Маскирование дефектов (defect masking): Случай, когда один дефект препятствует нахождению другого. (IEEE 610)_\n\n### Скрытый дефект (Latent defect)\n\nДефект, который является существующим дефектом в системе, но еще не вызывал сбоев, поскольку подходящий набор входных данных для его проявления не был введен или его проявлению мешает другой дефект (Defect masking).\n\n### Сортировка дефектов (Bug triage)\n\nЭто формальный процесс определения серьезности и приоритета дефектов в зависимости от их severity, риска, повторяемости и т. д. во время Defect Triage Meeting. Такая встреча полезна в условиях ограниченных ресурсов, когда нужно разобраться с множеством ошибок и тем, какие из них приоритетные.\n\nПонятие сортировки пришло из медицины, где это процесс быстрого обследования пациентов, доставленных в больницу, чтобы решить, какие из них наиболее серьезно больны и нуждаются в лечении в первую очередь. В тестировании мы используем ту же концепцию к ошибкам, обнаруженным на этапе тестирования.\n\n### Подсев недочетов (fault seeding)\n\n_Процесс намеренного внесения дефектов в дополнение к тем, что уже существуют в компоненте или в системе, для целей отслеживания уровня обнаружения и устранения, а также оценивания количества оставшихся в системе дефектов. Подсев недочетов обычно является частью процесса тестирования разработки и может применяться на любом уровне тестирования (компонентном, интеграционном или системном). (IEEE 610)_\n\n## Валидация vs верификация \n\n### Верификация (Verification)\n\nДоказанное объективными результатами исследования подтверждение того, что определенные требования (спецификации, формальные требования) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B5%D1%80%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Валидация (Validation)\n\nДоказанное объективными результатами исследования подтверждение того, что требования для ожидаемого конкретного использования приложения (соответствие ожиданиям и требованиям пользователей) были выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F)]\n\n### Пример\nЕсли попробовать привести очень упрощенный пример, представим блюдо в ресторане. Верификация будет включать проверку технологической карты, оценку процесса приготовления (температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.\n\n## Priority vs Severity\n\n### Приоритет (Priority)\n\nСтепень важности, присваеваемая объекту. Например, дефекту или задаче. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82)]  \nУказывает на очередность выполнения задачи или устранения дефекта. Можно сказать, что это инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект. Выставляется менеджером, тимлидом или заказчиком.\n\n**Градация Приоритета дефекта (Priority):**\n- **_P1 Высокий (High)_**  \nОшибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.\n- **_P2 Средний (Medium)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.\n- **_P3 Низкий (Low)_**  \nОшибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.\n\n### Критичность/Серьезность (Severity)\n\nВажность воздействия конкретного дефекта на разработку или функционирование компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D1%80%D0%B8%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C)]  \nХарактеризует влияние дефекта на работоспособность приложения. Выставляется тестировщиком.\n\n**Градация Критичности дефекта (Severity)**\n\n- **_S1 Блокирующая (Blocker)_**  \nБлокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна. Решение проблемы необходимо для дальнейшего функционирования системы.\n\n- **_S2 Критическая (Critical)_**  \nКритическая ошибка, неправильно работающая ключевая бизнес логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, без возможности решения проблемы, используя другие входные точки. Решение проблемы необходимо для дальнейшей работы с ключевыми функциями тестируемой системой.\n\n- **_S3 Значительная (Major)_**  \nЗначительная ошибка, часть основной бизнес логики работает некорректно. Ошибка не критична или есть возможность для работы с тестируемой функцией, используя другие входные точки.\n\n- **_S4 Незначительная (Minor)_**  \nНезначительная ошибка, не нарушающая бизнес логику тестируемой части приложения, очевидная проблема пользовательского интерфейса.\n\n- **_S5 Тривиальная (Trivial)_**  \nТривиальная ошибка, не касающаяся бизнес логики приложения, плохо воспроизводимая проблема, малозаметная посредствам пользовательского интерфейса, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта.\n\n\n### Сочетания Severity и Priority\n\n- **High Priority and High Severity**  \nЛюбой Critical/major сбой бизнес-модели, критическая проблема, при которой полностью не работает большая часть функциональности или основной компонент системы:\n  - нажатие на определенную кнопку не запускает саму функцию, например, не работает кнопка отправки на странице входа, и клиенты не могут войти в приложение;\n  - выполнение определенной функции постоянно приводит к 500 ошибке сервера и потере данных;\n  - система дает сбой после того, как вы совершили платеж или когда вы не можете добавить товары в корзину;\nфункция банкомата, при которой после ввода правильного имени пользователя и пароля автомат не выдает деньги, но списывает их с вашего счета;\n  - на веб-сайте банка появляется сообщение об ошибке, когда клиент нажимает кнопку перевода денег.\n\n- **High Priority and Low Severity**  \nЛюбые minor severity дефекты, которые влияют на взаимодействие с пользователями / репутацию:\n  - ожидается, что функция покажет пользователю конкретную ошибку по коду ответа. В этом случае функционально код выдает ошибку, но сообщение должно быть более релевантным коду;\n  - ошибка в логотипе или названии компании на главной странице, или опечатки, бросающиеся в глаза и способные повлиять на репутацию компании;\n  опечатки в контактных данных;\n  - важные ошибки в соглашениях и юридических документах.\n\n- **Low Priority and High Severity**  \nПроблема, которая пока не повлияет на бизнес, но имеет большое влияние с точки зрения функциональности:\n  - присутствует серьезный баг, но есть workaround и исправление уже может быть запланировано в следующем релизе или функция будет удалена;\n  - функция генерации годового отчета, которая будет использована только через полгода;\n  - редкость проявления дефекта/сложность воспроизведения для юзеров.\n\n- **Low Priority and Low Severity**  \nЛюбые орфографические ошибки / начертание / несовпадение шрифта в абзаце 3-й или 4-й страницы заявки, а не на главной или титульной странице / заголовке. Эти дефекты возникают, когда это не влияет на функциональность, но все же в небольшой степени не соответствует стандартам. Обычно сюда классифицируются косметические ошибки или, скажем, размеры ячейки в таблице пользовательского интерфейса:\n  - в политике конфиденциальности веб-сайта есть орфографическая ошибка;\n  - страница часто задаваемых вопросов загружается очень долго;\n  - семейство шрифтов, размер шрифта, цвет или орфографическая ошибка в приложении или отчетах.","date":"2022-05-23T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/zhiznennyj-czikl-defekta/","order":3,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Жизненный цикл дефекта","path":"/tag/%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%86%D0%B8%D0%BA%D0%BB%20%D0%B4%D0%B5%D1%84%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[{"value":"Дефекты и ошибки (error/defect(bug)/failure)","anchor":"#дефекты-и-ошибки-errordefectbugfailure"},{"value":"Классификация дефектов","anchor":"#классификация-дефектов"},{"value":"Жизненный цикл дефекта (Defect/Bug Life Cycle)","anchor":"#жизненный-цикл-дефекта-defectbug-life-cycle"},{"value":"Валидация vs верификация","anchor":"#валидация-vs-верификация"},{"value":"Priority vs Severity","anchor":"#priority-vs-severity"}]}},{"node":{"id":"de75a3ca11b3f91dd1ba8a6024f63973","title":"Жизненный цикл разработки ПО, SDLC (Software Development LifeCycle)","content":"\nЖизненный цикл программного обеспечения — это период времени, который начинается с момента принятия решения о создании программного продукта и заканчивается в момент его полного изъятия из эксплуатации.\n\nЖизненный цикл разработки ПО представляет собой несколько этапов (или фаз), которые проходит любое ПО. По сути, это подробный план, показывающий, как разрабатывать программное обеспечение, поддерживать его, изменять, улучшать.\n\nВ жизненном цикле разработки ПО можно выделить 6 основных этапов.\n\n## Этапы жизненного цикла ПО\n\n### 1. Анализ, составление требований к продукту\nНа этом этапе необходимо получить обратную связь и поддержку от соответствующих внутренних и внешних заинтересованных сторон и ответить на вопрос «Какие проблемы требуют решений?» Определяем и документируем требования конечного пользователя системы. Какие ожидания есть у нашего потребителя и как мы можем их осуществить? Можем ли мы это сделать вообще?\n\n### 2. Планирование\nНужно ответить на вопрос «Что мы хотим сделать?» Этот вопрос может вдохновить на понимание юнит-экономики плана (затраты и выгоды), факторов снижения рисков и ожидаемых стоимостей. По аналогии с планированием отпуска, нужно будет разложить вещи и подумать о том, что следует взять с собой. Определяем, что делаем и какие проблемы решаем. Ставим цели, выясняем, какие ресурсы нам нужны для реализации проекта. Изучаем рынок и конкурентов, прорабатываем альтернативные варианты разработки продукта.\n\n### 3. Проектирование и дизайн\nК этому этапу уже нужно знать требования продукта и в целом понимать чего вы хотите, и прежде чем приступить к написанию кода, этого понимания должно быть достаточно для ответа на следующий вопрос: «Как мы добьемся наших целей?» Иначе говоря, вам необходимо понять, что именно вы оптимизируете и проектировать соответствующе. Определяем элементы системы, ее компоненты, уровень безопасности, архитектуру, интерфейсы, типы данных. Рисуем дизайн, обсуждаем, проектируем.\n\n### 4. Разработка ПО\nЭтап процесса создания продукта. На этом этапе вы стремитесь не столько отвечать на вопросы, сколько произвести результаты, или, говоря точнее, вам необходимо склоняться к действиям и создать прототип или систему, испытать которую смогут другие. Пишем код, настраиваем систему под определенные требования и функции. К концу фазы система готова к установке и запуску.\n\n### 5. Тестирование\nЭтот этап регулирует обеспечение качественной работы продукта. По завершению этого этапа вы должны будете в состоянии обеспечить рабочее состояние продукта. Отслеживайте ошибки и неточности, выслушивайте чужие точки зрения, и глубоко погружайтесь в вопрос с целью поиска тормозящих выход финального продукта ошибок. Проверяем, получили мы в итоге то, что хотели, или же результаты работы оказались другими. Тестируем продукт автоматизированными тестами, командой, предлагаем поработать с системой потенциальным пользователям. Определяем дефекты и недостатки в работе системы и устраняем их.\n\n### 6. Развертывание\nЭтап использования финального продукта. Возьмите ваш продукт и пользуйтесь им. Предложите заинтересованным сторонам из первого этапа пользоваться вашим продуктом в естественных условиях. одготовка и выпуск обновлений, оценка производительности системы, замена/деактивация устаревших компонентов.\n\n## Стадии разработки ПО\nСтадии разработки ПО — это этапы, которые проходят команды разработчиков ПО, прежде чем программа станет доступной для широко круга пользователей. Разработка ПО начинается с первоначального этапа разработки (стадия «пре-альфа») и продолжается стадиями, на которых продукт дорабатывается и модернизируется. Финальным этапом этого процесса становится выпуск на рынок окончательной версии программного обеспечения («общедоступного релиза»).\n\nКаждой стадии разработки ПО присваивается определенный порядковый номер. Также каждый этап имеет свое собственное название, которое характеризует готовность продукта на этой стадии:\n- Пре-альфа\n- Альфа\n- Бета\n- Релиз-кандидат\n- Релиз\n- Пост-релиз","date":"2022-05-22T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/zhiznennyj-czikl-razrabotki-po-sdlc-software-development-life-cycle/","order":4,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Жизненный цикл разработки ПО","path":"/tag/%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%86%D0%B8%D0%BA%D0%BB%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D0%9F%D0%9E/"},{"title":"SDLC","path":"/tag/SDLC/"}],"headings":[{"value":"Этапы жизненного цикла ПО","anchor":"#этапы-жизненного-цикла-по"},{"value":"Стадии разработки ПО","anchor":"#стадии-разработки-по"}]}},{"node":{"id":"6f229c1409ab080c6ef8309da5dd689c","title":"Модели разработки ПО","content":"\n## 1. Code and fix - Модель кодирования и устранения ошибок\n\nСовершенно простая модель, характерная для студентов ВУЗов. Именно по этой модели большинство студентов разрабатывают, например лабораторные работы. \n\n![Code and fix - Модель кодирования и устранения ошибок](https://leonardo.osnova.io/611da7e3-32e5-0dd5-8198-cb6d23d19310/-/preview/2100/-/format/webp/)\n\nЭто одна из самых старых моделей разработки: она очень проста и подойдет стартапам, где команда невелика, нет особых конфликтов, вы знаете, что хотите сделать и имеете представление, как это сделать.\n\nКак работает Code-and-Fix: у нас есть понимание, что мы хотим сделать. Начинаем программировать, затем смотрим, что получилось. Выявляем баги, правим их и снова смотрим — и так, пока наш продукт не начнет работать.\n\nДанная модель имеет следующий алгоритм:\n\n1. Постановка задачи\n2. Выполнение\n3. Проверка результата\n4. При необходимости переход к первому пункту\n\n### Преимущества\n- не нужно тратить время на планы, документацию, митинги.\n\n### Недостатки\n- иногда исправление одной ошибки приводит к тому, что у вас ломается вся система. В итоге приходится переделывать — снова и снова. Поэтому когда-то давно программисты, которые мучились с этой моделью разработки, решили уйти от ее мнимой простоты и изобрести другую.\n\nМодель ужасно устаревшая. Характерна для 1960-1970 гг., поэтому преимуществ перед следующими моделями практически не имеет, а недостатки на лицо.\n\n## 2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")\n\nПроцесс создания программного обеспечения представляет собой поток, последовательно проходящий фазы анализа, проектирования, реализации, тестирования, интеграции и поддержки.\n\nКаждая следующая стадия начинается только после того, как заканчивается предыдущая. Так обычно строится работа над крупными проектами с длительным сроком внедрения.\n\n![Каскадная модель (waterfall)](https://habrastorage.org/r/w1560/files/6e2/e05/23f/6e2e0523f58d4d74816ae0bcf46e2fa2.jpg)\n![Каскадная модель (waterfall)](https://leonardo.osnova.io/0e330a8b-7f21-f8fb-872c-986314b4d7da/-/preview/2100/-/format/webp/)\n![Каскадная модель (waterfall)](https://evergreens.com.ua/assets/images/articles/systems/waterfall.png)\n\nИмеет ряд преимуществ перед алгоритмом предыдущей модели, но также имеет и ряд весомых недостатков. \n\n### Преимущества\n- Последовательное выполнение этапов проекта в строгом фиксированном порядке;\n- высокий уровень формализации процессов => высокая прозрачность разработки и фаз проекта;\n- большое количество документации;\n- Разработку просто контролировать. Заказчик всегда знает, чем сейчас заняты программисты, может управлять сроками и стоимостью;\n- Стоимость проекта определяется на начальном этапе. Все шаги запланированы уже на этапе согласования договора, ПО пишется непрерывно «от и до»;\n- Позволяет оценивать качество продукта на каждом этапе;\n- Не нужно нанимать тестировщиков с серьёзной технической подготовкой. Тестировщики смогут опираться на подробную техническую документацию;\n\n\n### Недостатки\n- Жесткая последовательность этапов жизненного цикла без возможности возврата на предыдущий этап;\n- Заказчик видит готовый продукт в конце разработки и только тогда может дать обратную связь. Велика вероятность, что результат его не устроит.\n- Все требования должны быть известны в начале жизненного цикла проекта;\n- Разработчики пишут много технической документации, что задерживает работы. Чем обширнее документация у проекта, тем больше изменений нужно вносить и дольше их согласовывать.\n- Тестирование начинается на последних этапах разработки. Если в требованиях к продукту была допущена ошибка, то исправить её будет стоить дорого. Тестировщики обнаружат её, когда разработчик уже написал код, а технические писатели — документацию.\n- Возникает необходимость в жёстком управлении и регулярном контроле, иначе проект быстро выйдет из графиков\n- Отсутствует возможность учесть переделку, весь проект делается за один раз\n- Не соответствует реальным условиям разработки программного продукта\n\n«Водопад» подходит для разработки проектов в медицинской и космической отрасли, где уже сформирована обширная база документов (СНиПов и спецификаций), на основе которых можно написать требования к новому ПО. \n\nПри работе с каскадной моделью основная задача — написать подробные требования к разработке. На этапе тестирования не должно выясниться, что в них есть ошибка, которая влияет на весь продукт.\n\n### «Водоворот» или каскадная модель с промежуточным контролем\n\nВ этой модели предусмотрен промежуточный контроль за счет обратных связей. Но это достоинство порождает и недостатки. Затраты на реализацию проекта при таком подходе возрастают практически в 10 раз. Эта модель, как вы уже поняли, является незначительной модификацией предыдущей.\n\n![«Водоворот» или каскадная модель с промежуточным контролем](https://intuit.ru/EDI/08_01_19_2/1546899581-11707/tutorial/145/objects/2/files/02_04.gif)\n\nПри реальной работе в соответствии с моделью, допускающей движение только в одну сторону, обычно возникают проблемы при обнаружении недоработок и ошибок, сделанных на ранних этапах. Но еще более тяжело иметь дело с изменениями окружения, в котором разрабатывается ПО (это могут быть изменения требований, смена подрядчиков, изменения политик разрабатывающей или эксплуатирующей организации, изменения отраслевых стандартов, появление конкурирующих продуктов и пр.).\n\n## 3. V-model (V-образная модель, разработка через тестирование)\n\nЭто усовершенствованная каскадная модель, в которой заказчик с командой программистов одновременно составляют требования к системе и описывают, как будут тестировать её на каждом этапе. \n\nИстория этой модели начинается в 1980-х. Имеет обратные связи с каждым этапом жизненного цикла, при этом порождает очень весомый недостаток: 10-ти кратное увеличение затрат на разработку.\n\nЯвляется одной из основных практик экстремального программирования и предполагает регулярное тестирование продукта во время разработки.\n\n![V модель — разработка через тестирование](https://habrastorage.org/r/w1560/files/22d/21f/18f/22d21f18ffb244d082e181c813d4ff15.jpg)\n![V модель — разработка через тестирование](https://leonardo.osnova.io/4a602e4f-745f-b2cc-18de-bd9cdd148b55/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- **Минимизация рисков:**  \nV-образная модель делает проект более прозрачным и повышает качество контроля проекта путём стандартизации промежуточных целей и описания соответствующих им результатов и ответственных лиц. Это позволяет выявлять отклонения в проекте и риски на ранних стадиях и улучшает качество управления проектов, уменьшая риски.\n- **Повышение и гарантии качества:**  \nV-Model — стандартизованная модель разработки, что позволяет добиться от проекта результатов желаемого качества. Промежуточные результаты могут быть проверены на ранних стадиях. Универсальное документирование облегчает читаемость, понятность и проверяемость.\n- **Уменьшение общей стоимости проекта:**  \nРесурсы на разработку, производство, управление и поддержку могут быть заранее просчитаны и проконтролированы. Получаемые результаты также универсальны и легко прогнозируются. Это уменьшает затраты на последующие стадии и проекты.\n- **Повышение качества коммуникации между участниками проекта:**  \nУниверсальное описание всех элементов и условий облегчает взаимопонимание всех участников проекта. Таким образом, уменьшаются неточности в понимании между пользователем, покупателем, поставщиком и разработчиком.\n\n### Недостатки\n- Если при разработке архитектуры была допущена ошибка, то вернуться и исправить её будет стоить дорого, как и в «водопаде».\n\nV-модель подходит для проектов, в которых важна надёжность и цена ошибки очень высока. Например, при разработке подушек безопасности для автомобилей или систем наблюдения за пациентами в клиниках. \n\n## 4. Incremental Model - Инкрементная модель\n\nМодель приращения продукта позволяет параллельно выполнять ряд задач с непрерывным анализом результатов и корректировкой предыдущих этапов работы. Это более «скоростная» разработка для большого штата квалифицированных программистов.\n\nЭто модель разработки по частям (increment в переводе с англ. — приращение) уходит корнями в 1930-е. Рассмотрим её на примере создания социальной сети.\n\nЗаказчик решил, что хочет запустить соцсеть, и написал подробное техническое задание. Программисты предложили реализовать основные функции — страницу с личной информацией и чат. А затем протестировать на пользователях, «взлетит или нет».\n\nКоманда разработки показывает продукт заказчику и выпускает его на рынок. Если и заказчику, и пользователям социальная сеть нравится, работа над ней продолжается, но уже по частям.\n\nПрограммисты параллельно создают функциональность для загрузки фотографий, обмена документами, прослушивания музыки и других действий, согласованных с заказчиком. Инкремент за инкрементом они совершенствуют продукт, приближаясь к описанному в техническом задании.\n\n![Incremental Model - Инкрементная модель](https://habrastorage.org/r/w1560/files/8b7/4e2/a86/8b74e2a8640d4ad59e7ac82b991be970.jpg)\n![Incremental Model - Инкрементная модель](https://leonardo.osnova.io/5a2d52b7-7a12-f7d5-9f09-4054d8192694/-/preview/2100/-/format/webp/)\n\n### Преимущества\n\n- Не нужно вкладывать много денег на начальном этапе. Заказчик оплачивает создание основных функций, получает продукт, «выкатывает» его на рынок — и по итогам обратной связи решает, продолжать ли разработку.\n- Можно быстро получить фидбэк от пользователей и оперативно обновить техническое задание. Так снижается риск создать продукт, который никому не нужен.\n- Ошибка обходится дешевле. Если при разработке архитектуры была допущена ошибка, то исправить её будет стоить не так дорого, как в «водопаде» или V-образной модели.\n\n### Недостатки\n\n- Каждая команда программистов разрабатывает свою функциональность и может реализовать интерфейс продукта по-своему. Чтобы этого не произошло, важно на этапе обсуждения техзадания объяснить, каким он будет, чтобы у всех участников проекта сложилось единое понимание. \n- Разработчики будут оттягивать доработку основной функциональности и «пилить мелочёвку». Чтобы этого не случилось, менеджер проекта должен контролировать, чем занимается каждая команда.\n\nИнкрементная модель подходит для проектов, в которых точное техзадание прописано уже на старте, а продукт должен быстро выйти на рынок.\n\n## 5. Iterative Model - Итеративная (или итерационная) модель\n\nЭто модель, при которой заказчик не обязан понимать, какой продукт хочет получить в итоге, и может не прописывать сразу подробное техзадание.\n\nРассмотрим на примере создания мессенджера, как эта модель работает.\n\nЗаказчик решил, что хочет создать мессенджер. Разработчики сделали приложение, в котором можно добавить друга и запустить чат на двоих.\nМессенджер «выкатили» в магазин приложений, пользователи начали его скачивать и активно использовать. Заказчик понял, что продукт пользуется популярностью, и решил его доработать.\n\nПрограммисты добавили в мессенджер возможность просмотра видео, загрузки фотографий, записи аудиосообщений. Они постепенно улучшают функциональность приложения, адаптируют его к требованиям рынка.\n\n![Iterative Model - Итеративная (или итерационная) модель](https://habrastorage.org/r/w1560/files/880/01d/a78/88001da784ab41ec880f84a7bb204a0b.jpg)\n![Iterative Model - Итеративная (или итерационная) модель](https://leonardo.osnova.io/ba33e029-3df5-ec0c-35b0-3b6060f93f81/-/preview/2100/-/format/webp/)\n![Iterative Model - Итеративная (или итерационная) модель](https://evergreens.com.ua/assets/images/articles/systems/iteration%20mod.png)\n\n### Преимущества\n\n- Быстрый выпуск минимального продукта даёт возможность оперативно получать обратную связь от заказчика и пользователей. А значит, фокусироваться на наиболее важных функциях ПО и улучшать их в соответствии с требованиями рынка и пожеланиями клиента.\n- Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки.\n\n### Недостатки\n\n- Использование на начальном этапе баз данных или серверов — первые сложно масштабировать, а вторые не выдерживают нагрузку. Возможно, придётся переписывать большую часть приложения.\n- Отсутствие фиксированного бюджета и сроков. Заказчик не знает, как выглядит конечная цель и когда закончится разработка.\n- Становится сложнее адекватно оценить текущее состояние проекта и спланировать долгосрочное развитие событий, а также предсказать сроки и ресурсы, необходимые для обеспечения определенного качества результата.\n\nИтеративная модель подходит для работы над большими проектами с неопределёнными требованиями, либо для задач с инновационным подходом, когда заказчик не уверен в результате. \n\nНа основе итеративной модели была создана Agile — не модель и не методология, а скорее подход к разработке.\n\n![](https://s.dou.ua/storage-files/dev-cycle-iter.gif)\n\n## 6. Spiral Model — спиральная модель\n\nСпиральная модель представляет собой процесс разработки программного обеспечения, сочетающий в себе как проектирование, так и постадийное прототипирование с целью сочетания преимуществ восходящей и нисходящей концепции. \n\nРассмотрим, как функционирует эта модель, на примере разработки системы «Умный дом». \n\nЗаказчик решил, что хочет сделать такую систему, и заказал программистам реализовать управление чайником с телефона. Они начали действовать по модели «водопад»: выслушали идею, провели анализ предложений на рынке, обсудили с заказчиком архитектуру системы, решили, как будут её реализовывать, разработали, протестировали и «выкатили» конечный продукт.\n\nЗаказчик оценил результат и риски: насколько нужна пользователям следующая версия продукта — уже с управлением телевизором. Рассчитал сроки, бюджет и заказал разработку. \n\nПрограммисты действовали по каскадной модели и представили заказчику более сложный продукт, разработанный на базе первого.\n\nЗаказчик подумал, что пора создать функциональность для управления холодильником с телефона. Но, анализируя риски, понял, что в холодильник сложно встроить Wi-Fi-модуль, да и производители не заинтересованы в сотрудничестве по этому вопросу. Следовательно, риски превышают потенциальную выгоду.\n\nНа основе полученных данных заказчик решил прекратить разработку и совершенствовать имеющуюся функциональность, чтобы со временем понять, как развивать систему «Умный дом».\n\nСпиральная модель похожа на инкрементную, но здесь гораздо больше времени уделяется оценке рисков. С каждым новым витком спирали процесс усложняется. Эта модель часто используется в исследовательских проектах и там, где высоки риски. \n\n![Spiral Model — спиральная модель](https://leonardo.osnova.io/595fed17-42da-c48b-1f17-f314f31301a4/-/preview/2100/-/format/webp/)\n![Spiral Model — спиральная модель](https://evergreens.com.ua/assets/images/articles/systems/spinner%20model.png)\n### Преимущества\n\n- Быстрое получение результата\n- Повышение конкурентоспособности\n- При изменении требований, не придется начинать все с «нуля».\n- Большое внимание уделяется проработке рисков\n\n### Недостатки\n\n- Отсутствие регламентации стадий\n- Есть риск застрять на начальном этапе — бесконечно совершенствовать первую версию продукта и не продвинуться к следующим.\n- Разработка длится долго и стоит дорого.\n\nИспользуя эту модель, заказчик и команда разработчиков серьёзно анализируют риски проекта и выполняют его итерациями. Последующая стадия основывается на предыдущей, а в конце каждого витка — цикла итераций — принимается решение, продолжать ли проект. Эту модель начали использовать в 1988 году.\n\n## 7. Chaos model — модель хаоса\n\nВкратце Стратегия хаоса — это стратегия разработки программного обеспечения основанная на модели хаоса. Главное правило — это,всегда решать наиболее важную задачу первой.\n\nЕё создатель Л.Б.С.Ракун отмечает, что такие модели управления проектами, как спиральная модель и каскадная модель, хотя и хороши в управлении расписаниями и персоналом, не обеспечивают методами устранения ошибок и решениями других технических задач, не помогают ни в управлении конечными сроками, ни в реагировании на запросы клиентов. Модель хаоса — это инструмент пытающийся помочь понять эти ограничения и восполнить пробелы.\n\n### Преимущества\n- учитывает взаимодействие между членами команды при внесении изменений в код;\n- ограничивает риск чрезмерного проектирования решения\n- прозрачность между желаниями руководства высокого уровня и пониманием командой разработчиков проблем и приоритетов.\n\n### Недостатки\n- критическая необходимость включить единый дизайн на уровне кода, который необходимо выполнить для удовлетворения требований на уровне программы.\n\n## 8. Prototype Model — прототипная модель\n\nДанная модель основывается на разработке прототипов и прототипирования продукта.\n\nПрототипирование используется на ранних стадиях жизненного цикла программного обеспечения:\n- Прояснить не ясные требования (прототип UI)\n- Выбрать одно из ряда концептуальных решений (реализация сцинариев)\n- Проанализировать осуществимость проекта\n\n### Классификация протопипов\n- Горизонтальные прототипы — моделирует исключительно UI не затрагивая логику обработки и базу данных.\n- Вертикальные прототипы — проверка архитектурных решений.\n- Одноразовые прототипы — для быстрой разработки.\n- Эволюционные прототипы — первое приближение эволюционной системы.\n\n## 9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений\n\n![RAD-Model, или Rapid Application Development Model - Модель быстрой разработки](https://leonardo.osnova.io/69673b21-a423-772e-3a1e-aca50d529348/-/preview/2100/-/format/webp/)\n\nРазновидность инкрементной модели. Появилась в конце 80-х годов и стала одной из попыток создания гибкого процесса разработки.\n\nRAD предусматривает небольшие команды разработки,сроки до 4 месяцев и активное привлечение заказчика с ранних этапов. Данная методология опирается на требования, но также существует возможность их изменений в период разработки системы. Обязательное требование этой модели — проект должен легко разбиваться на небольшие части, которые при необходимости могут создаваться параллельно друг другу несколькими командами. Такой подход позволяет сократить расходы и свести время разработки к минимуму.\n\n### Преимущества\n- быстрое развитие продукта;\n- разработка многоразовых мелких компонентов;\n- повторный обзор в процессе разработки;\n- интеграция повторно используемых компонентов на начальном уровне, следовательно, экономит усилия, несмотря на то, что не добавляются более крупные модули;\n- конструктивная реакция.\n\n### Недостатки\n- требуется много усилий для сбора всех требований на начальном этапе.\n- навыки моделирования имеют много зависимостей.\n- не подходит для малобюджетного проекта.\n\n## 10. Модель Большого Взрыва (Big Bang Model)\n\nBig Bang Model не имеет определенного процесса. Деньги и усилия объединяются, поскольку вход и выход представляют собой разработанный продукт, который может совпадать, а может и не совпадать с тем, что нужно заказчику. Модель Большого Взрыва не требует особого планирования и составления графиков. Разработчик выполняет анализ требований и кодирование, а также разрабатывает продукт в соответствии с его пониманием. Эта модель используется только для небольших проектов. Нет команды тестирования и формального тестирования не проводится, и это может быть причиной провала проекта.\n\n### Преимущества\n- Это очень простая модель. \n- Требуется меньше планирования и составления графиков. \n- Разработчик может создавать собственное программное обеспечение.\n\n### Недостатки\n- Модели Большого взрыва нельзя использовать для крупных, текущих и сложных проектов. \n- Высокий риск и неопределенность.\n\n## 11. Agile\n\nГибкая модель разработки, по которой сегодня работает большинство ИТ-проектов. Вы получаете определенный результат после каждой итерации, можете вносить изменения в первоначальное видение продукта практически в любой момент работы — исходя из того, какой функционал больше нравится пользователям вашего продукта.\n\n### Преимущества\n- чтобы начать работать над продуктом не нужно иметь детальное представление о том, что вы хотите получить в конце. Не нужно иметь весь бюджет и просчитывать все риски\n\n### Недостатки\n- готовый продукт может на рынок так никогда и не выйти, вы постоянно будете заниматься его усовершенствованиями, дополнениями, тем временем бюджет может закончиться\n\nAgile имеет множество вариаций и фреймворков. Среди самых известных: Scrum, Kanban, экстремальное программирование (XP), Lean.","date":"2022-05-21T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/modeli-razrabotki-po/","order":5,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Модели разработки ПО","path":"/tag/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D0%9F%D0%9E/"}],"headings":[{"value":"1. Code and fix - Модель кодирования и устранения ошибок","anchor":"#1-code-and-fix---модель-кодирования-и-устранения-ошибок"},{"value":"2. Waterfall Model - Каскадная или поэтапная разработка (\"Водопад\")","anchor":"#2-waterfall-model---каскадная-или-поэтапная-разработка-водопад"},{"value":"3. V-model (V-образная модель, разработка через тестирование)","anchor":"#3-v-model-v-образная-модель-разработка-через-тестирование"},{"value":"4. Incremental Model - Инкрементная модель","anchor":"#4-incremental-model---инкрементная-модель"},{"value":"5. Iterative Model - Итеративная (или итерационная) модель","anchor":"#5-iterative-model---итеративная-или-итерационная-модель"},{"value":"6. Spiral Model — спиральная модель","anchor":"#6-spiral-model--спиральная-модель"},{"value":"7. Chaos model — модель хаоса","anchor":"#7-chaos-model--модель-хаоса"},{"value":"8. Prototype Model — прототипная модель","anchor":"#8-prototype-model--прототипная-модель"},{"value":"9. RAD-Model, или Rapid Application Development Model - Модель быстрой разработки приложений","anchor":"#9-rad-model-или-rapid-application-development-model---модель-быстрой-разработки-приложений"},{"value":"10. Модель Большого Взрыва (Big Bang Model)","anchor":"#10-модель-большого-взрыва-big-bang-model"},{"value":"11. Agile","anchor":"#11-agile"}]}},{"node":{"id":"2548503037f1d37960e1893daa3fd4cb","title":"Жизненный цикл тестирования приложений, STLC (Software Testing LifeCycle)","content":"\n**STLC, или жизненный цикл тестирования** — это последовательность действий, проводимых в процессе тестирования, с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям. STLC включает действия по верификации и валидации. Тестирование состоит из серии действий, выполняемых по методике, с целью гарантирования качества продукта.\n\n![STLC, или жизненный цикл тестирования](https://testengineer.ru/wp-content/uploads/2021/08/zhiznennyj-cikl-testirovaniya-prilozhenij.svg)\n\nhttps://www.youtube.com/watch?v=bImOPDuXXiQ\n\n## Этапы STLC-цикла\n\nЦикл состоит из шести основных этапов:\n\n### 1. Анализ требований\n\nТестирование на этапе оценки требований (или анализа требований). На этом этапе отдел QA оценивает требования с точки зрения тестирования, ищет требования к софту, которые нужно предварительно оценить. Для этого QA-команда может обращаться к представителям заказчика. Требования могут быть «функциональными» или «нефункциональными», то есть касаться или не касаться функциональной составляющей софта. Также на этом этапе проводится оценка возможности применения автоматизированного тестирования.\n\n**Критерии входа:**\n- Есть документ о требованиях (как функциональных, так и нефункциональных).\n- Описаны критерии приемлемости.\n- Есть документ, описывающий архитектуру приложения.\n\n**Действия на этапе оценки требований:**\n- Анализ планируемой функциональности приложения.\n- Определение ролей пользователей.\n- Сбор требований о пользовательских интерфейсах, аутентификации, локализации и других особенностях.\n- Определение типов тестирования\n- Сбор информации о приоритетах в тестировании\n- Подготовка матрицы отслеживания требований (RTM — Requirement Traceability Matrix)\n- Определение тестового окружения\n- Анализ возможности автоматизации тестирования (если нужно)\n\n**Критерии выхода:**\n- Заполнена RTM-матрица.\n- Подготовлен и согласован отчет о возможности автоматизации\n\n**Результаты этапа оценки требований:**\n- Матрица отслеживания требований (RTM)\n- Отчет о возможности автоматизации (если нужно)\n\n### 2. Планирование тестирования\n\nНа этапе планирования руководитель команды QA определяет стратегию тестирования и оценивает трудозатраты. Также оцениваются ресурсы, тестовое окружение, возможные ограничения и график тестирования. На этом же этапе готовится и финализируется план тестирования.\n\n**Критерии входа:**\n- Есть документы с требованиями.\n- Есть RTM-матрица.\n- Есть документ о возможности автоматизации тестирования\n\n**Действия на этапе планирования:**\n- Анализ возможности различных методов тестирования.\n- Финализация наиболее подходящего метода тестирования.\n- Подготовка стратегии (или плана тестирования)\n- Выбор инструментов тестирования\n- Оценка трудозатрат\n- Планирование ресурсов, определение ролей и ответственности\n- Дополнительное обучение команды (если нужно)\n\n**Критерии выхода:**\n- Готов и согласован документа со стратегией тестирования.\n- Одобрен документ по оценке трудозатрат.\n\n**Результаты:**\n- Документ со стратегией тестирования\n- Документ с оценкой ресурсов\n\n### 3. Создание тест-кейсов\n\nНа этом этапе происходит подготовка тестовых данных и создаются тест-кейсы.\n\n**Критерии входа:**\n- Есть документы с требованиями.\n- Есть RTM-матрица и план тестирования.\n- Есть отчет о возможности автоматизации\n\n**Действия:**\n- Создание тест-кейсов (и автотестов, если будет применяться автоматизация)\n- Обновление тест-кейсов и автоматизированных тестов.\n- Подготовка исходных данных для тестирования\n\n**Критерии выхода:**\n- Готовы тест-кейсы и скрипты.\n- Готовы тестовые данные.\n\n**Результаты:**\n- Тест-кейсы и/или скрипты\n- Тестовые данные\n\n### 4. Настройка тестового окружения\n\nЭто настройка харда и софта, в которых будет осуществляться процесс тестирования. Это один из критически важных аспектов процесса, он может проходить параллельно этапу создания тест-кейсов. QA-команда может и не включаться в этот процесс, если тестовое окружение ей обеспечит команда разработки. QA-команда должна будет проверить работоспособность окружения (хотя бы smoke-тестом).\n\n**Критерии входа:**\n- Готовы документы по дизайну системы и ее архитектуре.\n- Есть план по настройке окружения.\n\n**Действия:**\n- Оценка архитектуры.\n- Создание списка требований к аппаратной и программной части окружения\n- Подготовка задач по настройке окружения.\n- Настройка тестового окружения и тестовых данных.\n- Провести smoke-тест окружения\n- Подготовка и проведение smoke-тестов билда приложения.\n\n**Критерии выхода:**\n- Окружение работает согласно списка требований.\n- Завершена подготовка тестовых данных.\n\n**Результаты:**\n- Настроенное окружение для проведения тестирования\n- Результаты smoke-тестирования окружения\n\n### 5. Выполнение тестирования\n\nНа этапе выполнения тестов QA проводит тестирование, выполняя подготовленные тест-кейсы. Процесс состоит из выполнения тестовых скриптов (при необходимости эти скрипты могут корректироваться). Далее идет создание баг-репортов. Если найдены баги, информация о них передается команде разработки для исправления и повторного тестирования QA-командой.\n\n**Критерии входа:**\n- Есть базовая RTM-матрица, план тестирования, тест-кейсы и/или автоматизированные скрипты.\n- Готово тестовое окружение.\n- Завершена настройка тестовых данных.\n\n**Действия:**\n- Выполнение тестирования в соответствии с планом\n- Получение и документирование результатов тестирования\n- Создание баг-репортов\n- Обновление тест-плана и тест-кейсов (если нужно).\n- Обновление RTM-матрицы (тест-кейсы из RTM-матрицы связываются с найденными багами)\n- Повторное тестирование исправленных багов\n- Регрессионное тестирование приложения.\n- Отслеживание проблемных мест, до закрытия тестирования.\n\n**Критерии выхода:**\n- Все запланированные тесты проведены.\n- Созданы баг-репорты.\n\n**Результаты:**\n- Завершенная RTM-матрица\n- Обновленные тест-кейсы\n- Найденные и описанные баги\n\n### 6. Завершение цикла тестирования\n\nНа этапе завершения тестирования создается отчет о результатах тестирования. QA-команда обсуждает и анализирует баги, делает выводы из возникших проблем, чтобы избежать подобных проблем в будущем.\n\n**Критерии входа:**\n- Тестирование завершено.\n- Есть результаты тестирования.\n- Есть баг-репорты.\n\n**Действия:**\n- Оценка критериев завершения цикла (основывается на времени, трудозатратах, покрытии тестами)\n- Подготовка метрик тестов\n- Подготовка документа с выводами, сделанными во время тестирования\n- Подготовка отчета о завершении тестирования\n- Подготовка отчета для клиента с количественными и качественными характеристиками тестируемой системы\n- Анализ результатов тестирования\n\n**Критерии выхода:**\n- Отчет о завершении тестирования утвержден клиентом.\n\n**Результаты:**\n- Отчет о завершении тестирования\n\n---\n\n**Этапы тестирования:**\n\n1. Анализ продукта\n2. Работа с требованиями\n3. Разработка стратегии тестирования\nи планирование процедур контроля качества\n4. Создание тестовой документации\n5. Тестирование прототипа\n6. Основное тестирование\n7. Стабилизация\n8. Эксплуатация","date":"2022-05-19T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/zhiznennyj-czikl-testirovaniya-prilozhenij-stlc-software-testing-life-cycle/","order":7,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Жизненный цикл тестирования приложений","path":"/tag/%D0%96%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%86%D0%B8%D0%BA%D0%BB%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/"},{"title":"STLC","path":"/tag/STLC/"}],"headings":[{"value":"Этапы STLC-цикла","anchor":"#этапы-stlc-цикла"}]}},{"node":{"id":"954baa0f0eb1da98d2855edc2e195de7","title":"Принципы тестирования, Agile принципы тестирования","content":"\n## Принципы тестирования\n\nподробнее см [7 принципов тестирования по книге «Foundations of Software Testing: ISTQB Certification» by Dorothy Graham, Erik van Veenendaal, Isabel Evans & Rex Black](https://ibs-training.ru/about/news/7_printsipov_testirovaniya_CHast_1/)\n\n### 1. Тестирование демонстрирует наличие дефектов (Testing shows presence of defects).\nТестирование может показать, что дефекты присутствуют, но не может доказать, что дефектов больше нет.\nСколько бы успешных тестов вы не провели, вы не можете утверждать, что нет таких тестов, которые не нашли бы ошибку.\n\n### 2. Исчерпывающее тестирование невозможно (Exhaustive testing is impossible).\nПолное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо (исключение — тривиальные случаи).\n\nДля проведения исчерпывающего тестирования придется протестировать все возможные входные значения и все пути выполнения программы, в большинстве случаев число таких вариаций стремится к бесконечности или просто на порядки превосходит отведенное время и бюджет. \n\nВместо попыток «протестировать все» нам нужен некий подход к тестированию (стратегия), который обеспечит правильный объем тестирования для данного проекта, данных заказчиков (и других заинтересованных лиц) и данного продукта. \n\nПри определении, какой объем тестирования достаточен, необходимо учитывать уровень риска, включая технические риски и риски, связанные с бизнесом, и такие ограничения проекта как время и бюджет. Оценка и управление рисками - одна из наиболее важных активностей в любом проекте.\n\n### 3. Раннее тестирование (Early testing).\nСледует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.\n\nТестовые активности должны начинаться как можно раньше в SDLC, а именно когда сформированы требования.\n\nЭтот принцип связан с понятием «цена дефекта» (cost of defect). Цена дефекта существенно растет на протяжении жизненного цикла разработки ПО. Чем раньше обнаружен дефект, тем быстрее, проще и дешевле его исправить. Дефект, найденный в требованиях, обходится дешевле всего.\n\nЕще одно важное преимущество раннего тестирования - экономия времени. Тестовые активности могут начинаться еще до того, как написана первая строчка кода. По мере того, как готовятся требования и спецификации, тестировщики могут приступать к разработке и ревью тест-кейсов. И когда появится первая тестовая версия, можно будет сразу приступать к выполнению тестов.\n\n### 4. Скопление дефектов (Defects clustering).\nБольшая часть дефектов находится в ограниченном количестве модулей.\n\nНебольшое количество модулей содержит большинство дефектов, обнаруженных на этапе предрелизного тестирования, или же демонстрируют наибольшее количество отказов на этапе эксплуатации.\n\nМногие тестировщики наблюдали такой эффект - дефекты «_кучкуются_». Это может происходить потому, что определенная область кода особенно сложна и запутана, или потому, что внесение изменений производит «_эффект домино_». Это знание часто используется для оценки рисков при планировании тестов - тестировщики фокусируются на известных «_проблемных зонах_». Также полезно проводить анализ _первопричин (root cause analysis)_, чтобы предотвратить повторное появление дефектов, обнаружить причины возникновения скоплений дефектов и спрогнозировать потенциальные скопления дефектов в будущем.\n\n### 5. Парадокс пестицида (Pesticide paradox).\nЕсли повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты.\n\nBoris Beizer в своей книге Software Testing Techniques объяснил парадокс пестицида как феномен, согласно которому чем больше вы тестируете ПО, тем более невосприимчивым оно становится к имеющимся тестам, т.е.\n- каждый метод и набор тестов, который используется для предотвращения или поиска ошибок, может оставлять часть не найденных ошибок, против которых эти методы и тесты неэффективны;\n- имеющиеся тесты устаревают после исправления дефекта и не могут обнаружить новые;\n\nИз чего следует, что набор тестов, тестовых данных и подходов нужно постоянно пересматривать и улучшать для выявления не найденных ошибок, а также необходимо обновлять тесты и тестовые данные после исправления уже найденных дефектов.\n\n### 6. Тестирование зависит от контекста (Testing is context depending). \nТестирование выполняется по-разному, в зависимости от контекста. Например, тестирование систем, критических с точки зрения безопасности, проводится иначе, чем тестирование сайта интернет-магазина.\n\nЭтот принцип тесно связан с понятием риска. Что такое риск? Риск - это потенциальная проблема. У риска есть вероятность (likelihood) - она всегда выше 0 и ниже 100% - и есть влияние (impact) - те негативные последствия, которых мы опасаемся. Анализируя риски, мы всегда взвешиваем эти два аспекта: вероятность и влияние.\n\nТо же можно сказать и о мире ПО: разные системы связаны с различными уровнями риска, влияние того или иного дефекта также сильно варьируется. Одни проблемы довольно тривиальны, другие могут дорого обойтись и привести к большим потерям денег, времени, деловой репутации, а в некоторых случаях даже привести к травмам и смерти.\n\nУровень риска влияет на выбор методологий, техник и типов тестирования.\n\n### 7. Заблуждение об отсутствии ошибок (Absence-of-errors fallacy). \nОтсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.\n\nНахождение и исправление дефектов бесполезно, если построенная система неудобна для использования и не соответствует нуждам и ожиданиям пользователей.\n\nЗаказчики ПО - люди и организации, которые покупают и используют его, чтобы выполнять свои повседневные задачи - на самом деле совершенно не интересуются дефектами и их количеством, кроме тех случаев, когда они непосредственно сталкиваются с нестабильностью продукта. Им также неинтересно, насколько ПО соответствует формальным требованиям, которые были задокументированы. Пользователи ПО более заинтересованы в том, чтобы оно помогало им эффективно выполнять задачи. ПО должно отвечать их потребностям, и именно с этой точки зрения они его оценивают.\nДаже если вы выполнили все тесты и ошибок не обнаружили, это еще не гарантия того, что ПО будет соответствовать нуждам и ожиданиям пользователей.\nИначе говоря, верификация не равна валидации.\n\n## Гибкое тестирование\n\n**Гибкое тестирование (agile testing):** Способ тестирования для проектов, использующих гибкие\nметодологии разработки программного обеспечения, включающий такие техники и методы, как\nэкстремальное программирование, и рассматривающий процесс разработки как потребителя\nпроцесса тестирования и делающий упор на парадигму раннего тестирования.\n\n## Принципы Agile тестирования  \n\nпо книге [E. Hendrickson - Agile Testing Nine Principles and Six Concrete Practies for Testing on Agile Teams](http://testobsessed.com/wp-content/uploads/2011/04/AgileTestingOverview.pdf)\n\n### 1. Тестирование продвигает проект вперед\nВ традиционных проектах тестирование обычно рассматривается как контроль качества, а QA/Test группа часто служит привратником качества. Предотвращение выход плохого программного обеспечения в поле, считается обязанностью\nтестирования. Результат этого подхода долгие, затяжные встречи по поиску ошибок, на которых мы спорим о приоритете ошибок, обнаруженных в ходе тестирования, и достаточно ли они важны и/или серьезные, чтобы задержать релиз.\n\nВ Agile-командах мы с самого начала хорошо создаем продукт, используя тестирование для предоставления обратной связи на постоянной основе о том, насколько хорошо новый продукт удовлетворяет потребности бизнеса.\nЭто выглядит как небольшое изменение, но оно имеет глубокие последствия. \n\nВраждебные отношения, которые некоторые организации поддерживают между тестировщиками и разработчиками, должны быть заменен духом сотрудничества. Это совершенно другое мышление.\n\n### 2. Тестирование — это НЕ один из этапов…\n…в Agile-командах тестирование — это образ жизни.\n\nAgile-команды постоянно тестируют. Это единственный способ убедиться, что функции реализованные во время данной итерации или спринта, фактически выполняются.\nНепрерывное тестирование — единственный способ обеспечить непрерывный прогресс.\n\n### 3. Все тестируют\nВ традиционных проектах независимые тестировщики несут ответственность за все действия по тестированию.\n\nВ Agile за проведение тестирования отвечает вся команда. Да, тестеры выполняют тесты. Разработчики тоже.\n\nНеобходимость провести все тесты за одну итерацию может означать, что команда просто не сможет сделать в каждом спринте столько, сколько они изначально думали. Если это так, то Agile сделал видимым несоответствие импеданса между тестом и разработчиком, которое уже\nсуществовал. А это значит, что команда двигалась не так быстро, как они думали. \n\nИм казалось, все идет быстро, потому что разработчики шли быстро. Но если тестирование не сделано, фичи не сделаны, и у команды просто нет той скорости о которой они думают.\n\nДругая точка зрения на эту идею состоит в том, что тестирование — это «травка» в команде. Теория ограничений гласит, что вся команда может только идти так быстро, как идет самая медленная часть. \nЧтобы работать быстрее, команда должна увеличить пропускную способность самой медленной часть процесса. Устранить узкое место; все тестируют.\n\n### 4. Сокращение оборотов обратной связи\n\nКак долго команда должна ждать информацию о том, как ведет себя программное обеспечение? Измерьте время между написанием программистом строки кода, и тем, когда кто-то или что-то выполняет этот код и предоставляет информацию о том, как он себя ведет. Это обратная связь.\n\nЕсли программное обеспечение не протестировано до самого конца длинного релиза, циклы обратной связи будут увеличены и могут измеряться месяцами. Это слишком долго.\n\nБолее короткие петли обратной связи повышают гибкость. К счастью, на Agile-проектах программное обеспечение готово к тестированию практически с самого начала. А Agile-команды обычно используют несколько уровней тестирования для выявления разных типов информации.\n\nАвтоматизированные модульные тесты проверяют поведение отдельных функций/методов и взаимодействие объектов. Они запускаются часто и предоставляют обратную связь в считанные минуты. Автоматизированные приемочные тесты обычно проверяют поведение системы от начала до конца. (Хотя иногда они обходят графический интерфейс, проверяя лежащую в основе бизнес-логику.) Как правило, они запускаются на зарегистрированном коде на постоянной основе, предоставляя обратную связь примерно через час. Гибкие проекты предпочитают автоматизированные тесты из-за быстрой обратной связи, которую они обеспечивают.\n\nРучные регрессионные тесты занимают больше времени и, поскольку человек должен быть доступен, могут начаться не сразу. Время обратной связи увеличивается до дней или недель.\n\nРучное тестирование, особенно ручное исследовательское тестирование, по-прежнему важно. Однако Agile-команды обычно обнаруживают, что быстрая обратная связь, обеспечиваемая автоматической регрессией, является ключом к быстрому обнаружению проблем, что снижает риск и количество доработок.\n\n### 5. Держите код в чистоте\nЭтот принцип является примером дисциплины Agile-команд. Требуется огромная внутренняя дисциплина, чтобы исправлять ошибки по мере их обнаружения. \n\nЕсли это настоящая ошибка, а не новая фича, она исправляется в ходе итерации. \n\nВ противном случае это все равно, что готовить на грязной кухне: для приготовления пищи требуется больше времени, чтобы пробраться через беспорядок, и полученная еда может быть съедобной, а может и не быть.\n\n### 6. Легкая документация\nВместо того, чтобы писать многословную исчерпывающую тестовую документацию, Agile-тестировщики:\n\n- Используют многоразовые чек листы, чтобы предлагать тесты\n- Сосредоточиваются на сути теста, а не на второстепенных деталях\n- Используют упрощенные стили/инструменты для документации.\n- Фиксируют идеи тестирования в чартерах для исследовательского тестирования\n- Используют документы для различных целей\n\n### 7. Использование одного тестового артефакта для ручных и автоматических тестов\nВместо того, чтобы вкладывать средства в обширные, тяжеловесные пошаговые сценарии ручного тестирования в Word или инструмент управления тестированием, мы фиксируем ожидания в формате, поддерживаемом системы автоматизированного тестирования, такие как FIT/Fitnesse. \n\nТест может быть выполнен вручную, но что более важно, тот же тестовый артефакт становится автоматическим тестом, когда программисты пишут приспособление для подключения теста к тестируемому программному обеспечению.\n\n### 8. «Сделано Сделано», а не просто Сделано\nВ традиционных средах со строгим разделением между разработкой и тестированием разработчики обычно говорят, что они «закончили» работу с функцией после ее реализации, но до ее тестирования.\n\nКонечно, функция не «готова», пока она не будет протестирована и не будут исправлены все ошибки. Вот почему в отрасли существует давняя шутка о том, что данный выпуск программного обеспечения обычно «готов на 90%» для 90% проекта. (Или, другими словами, последние 10 % усилий занимают 90 % времени.)\n\nAgile-команды не считают что-то «сделанным» и готовым к принятию владельцем продукта или заказчиком до тех пор, пока оно не будет реализовано и протестировано.\n\n### 9. Test-Last v. Test-Driven\nВ традиционных средах тесты создаются на основе артефактов проекта, таких как документы с требованиями. \n\nТребования и дизайн на первом месте, а затем тесты. И выполнение этих тестов происходит в конце проекта. Это подход «testlast».\n\nТем не менее, тесты предоставляют конкретные примеры того, что означает для нового программного обеспечения соответствие требованиям. \n\nФормирование тестов вместе с требованиями, а не после, и использование этих тестов для управления усилиями по разработке дает нам гораздо более четкие критерии выполнения и общее внимание к цели. \n\nЭтот подход, основанный на тестировании, можно увидеть в практиках TDD и ATDD.\n \n \n \n ---\n \nПринцип 1 — Тестирование демонстрирует наличие дефектов (Testing shows presence of defects)\nТестирование может показать, что дефекты присутствуют, но не может доказать, что их нет. Тестирование снижает вероятность наличия дефектов, находящихся в программном обеспечении, но, даже если дефекты не были обнаружены, это не доказывает его корректности.\n\nПринцип 2 — Исчерпывающее тестирование недостижимо (Exhaustive testing is impossible)\nПолное тестирование с использованием всех комбинаций вводов и предусловий физически невыполнимо, за исключением тривиальных случаев. Вместо исчерпывающего тестирования должны использоваться анализ рисков и расстановка приоритетов, чтобы более точно сфокусировать усилия по тестированию.\n\nПринцип 3 — Раннее тестирование (Early testing)\nЧтобы найти дефекты как можно раньше, активности по тестированию должны быть начаты как можно раньше в жизненном цикле разработки программного обеспечения или системы, и должны быть сфокусированы на определенных целях.\n\nПринцип 4 — Скопление дефектов (Defects clustering)\nУсилия тестирования должны быть сосредоточены пропорционально ожидаемой, а позже реальной плотности дефектов по модулям. Как правило, большая часть дефектов, обнаруженных при тестировании или повлекших за собой основное количество сбоев системы, содержится в небольшом количестве модулей.\n\nПринцип 5 — Парадокс пестицида (Pesticide paradox)\nЕсли одни и те же тесты будут прогоняться много раз, в конечном счете этот набор тестовых сценариев больше не будет находить новых дефектов. Чтобы преодолеть этот «парадокс пестицида», тестовые сценарии должны регулярно рецензироваться и корректироваться, новые тесты должны быть разносторонними, чтобы охватить все компоненты программного обеспечения,\nили системы, и найти как можно больше дефектов.\n\nПринцип 6 — Тестирование зависит от контекста (Testing is concept depending)\nТестирование выполняется по-разному в зависимости от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем сайт электронной коммерции.\nПринцип 7 — Заблуждение об отсутствии ошибок (Absence-of-errors fallacy)\nОбнаружение и исправление дефектов не помогут, если созданная система не подходит пользователю и не удовлетворяет его ожиданиям и потребностям.\n\n \n \n ","date":"2022-05-18T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/princzipy-testirovaniya-agile-princzipy-testirovaniya/","order":8,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Принципы тестирования","path":"/tag/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"},{"title":"Agile принципы тестирования","path":"/tag/Agile%20%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Принципы тестирования","anchor":"#принципы-тестирования"},{"value":"Гибкое тестирование","anchor":"#гибкое-тестирование"},{"value":"Принципы Agile тестирования","anchor":"#принципы-agile-тестирования"}]}},{"node":{"id":"d13e3fa447fa349811117982db906130","title":"Практики и подходы тестирования","content":"\n## TDD - Test Driven Development\nРазработка на основе тестов основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест. Затем проводится рефакторинг написанного кода с постоянной проверкой прохождения тестов. \n\nЕсть два уровня TDD:\n\n- Acceptance TDD (ATDD): вы пишете один приемочный тест. Этот тест удовлетворяет требованиям спецификации или удовлетворяет поведению системы. После этого пишете достаточно производственного / функционального кода, чтобы выполнить этот приемочный тест. Приемочный тест фокусируется на общем поведении системы. ATDD также известен как BDD - Behavior Driven Development;\n- Developer TDD: вы пишете один тест разработчика, то есть модульный тест, а затем просто достаточно производственного кода для выполнения этого теста. Модульное тестирование фокусируется на каждой небольшой функциональности системы. Это называется просто TDD. Основная цель ATDD и TDD - определить подробные, выполнимые требования для вашего решения точно в срок (JIT). JIT означает принятие во внимание только тех требований, которые необходимы в системе, что повышает эффективность.\n\n## BDD - Behaviour Driven Development\nЭто разработка, основанная на описании поведения. Определенный человек(или люди) пишет описания вида \"я как пользователь хочу когда нажали кнопку пуск тогда показывалось меню как на картинке\" (там есть специально выделенные ключевые слова). Программисты давно написали специальные тулы, которые подобные описания переводят в тесты (иногда совсем прозрачно для программиста). А дальше классическая разработка с тестами (TDD);\n\n## TDD - Type Driven Development\nПри разработке на основе типов ваши типы данных и сигнатуры типов являются спецификацией программы. Типы также служат формой документации, которая гарантированно обновляется. Типы представляют из себя небольшие контрольные точки, благодаря которым, мы получаем множество мини-тестов по всему нашему приложению;\n\n## DDD - Domain Driven Design\nПредметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD - это набор правил, которые позволяют принимать правильные проектные решения. Это набор принципов и схем, направленных на создание оптимальных систем объектов. Процесс разработки сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом;\n\n## FDD - Features Driven Development\nПредставляет собой попытку объединить наиболее признанные в индустрии разработки программного обеспечения методики, принимающие за основу важную для заказчика функциональность (свойства) разрабатываемого программного обеспечения. Основной целью данной методологии является разработка реального, работающего программного обеспечения систематически, в установленные сроки;\n\n## MDD - Model Driven Development\nРазработка, управляемая моделями - это стиль разработки программного обеспечения, когда модели становятся основными артефактами разработки, из которых генерируется код и другие артефакты;\n\n## PDD - Panic Driven Development\nЭто своеобразный антипаттерн разработки, который, к сожалению, мы все время от времени практикуем. По сути это то, что получается, когда процессы плохо налажены и команда импровизирует в условиях горящих сроков (новые задачи приоритетнее старых, код решает конкретные срочные задачи, но копится технический долг, тестирование в конце и т.д.);\n\n## ADD - API Driven Development\nРазработка на основе API - это практика сначала проектирования и создания API, а затем создания на их основе остальной части приложения;\n\n## BDT - Behavior Driven Testing\nВ тестировании на основе поведения ваши тесты основаны на user stories, которые описывают некоторые конкретные ожидаемые действия приложения. Вместо проверки деталей реализации вы фактически проверяете то, что важно больше всего: правильно ли приложение выполняет user stories. Еще одним преимуществом является понятность тестов для менеджеров, аналитиков и т.п.;\n\n## MDT - Model Driven Testing\nТестирование на основе моделей - это метод тестирования черного ящика, при котором поведение тестируемого программного обеспечения во время выполнения проверяется на основе прогнозов, сделанных моделями. Модель - это описание поведения системы. Поведение может быть описано в виде наглядной схемы, Data Flow, Control Flow, Dependency Graphs, Decision Tables, State transition machines или mind map. Простой аналогией модели в тестировании является электрическая схема при разработке электроприбора. Этот подход к тестированию требуется, когда высока цена ошибки в большом продукте и нужно как можно раньше попытаться ее предотвратить;\n\n## DDT - Data Driven Testing (table-driven testing or parameterized testing)\nВ тестировании на основе данных тестовые данные хранятся в виде таблицы. Оно позволяет одним скриптом выполнять тесты для всех тестовых данных из таблицы и ожидать результатов теста в той же таблице;\n\n## VDT - Value Driven Testing\nТестирование на основе ценности - это подход, в основе которого лежит анализ ценности и экономической целесообразности тестирования.\n\n## Подход к тестированию (Test Approach)\n\n_Подход к тестированию (test approach): Реализация стратегии тестирования для определенного проекта. Обычно включает в себя заключения, сделанные на основе цели (тестирования) проекта и анализе рисков, стартовые точки процесса тестирования, применяемые методики разработки тестов, критерии выхода, типы тестирования, которые должны быть произведены. (ISTQB)_\n\n_Оценка риска (risk assessment): Процесс идентификации и последующего анализа определенного риска проекта или продукта с целью определить его уровень. Обычно состоит из назначения рейтинга вероятности и влияния. (ISTQB)_\n\n_Цель тестирования (test target): Набор критериев выхода. (ISTQB)_\n\nПодход к тестированию - это реализация стратегии тестирования для конкретного проекта.\n\nПодход к тестированию определяется и уточняется в test plans and test designs. Подход к тестированию обычно включает решения, принимаемые на основе цели (тестового) проекта и оценки рисков (risk assessment). Подход к тестированию является отправной точкой для планирования процесса тестирования, для выбора применяемых методов проектирования тестов и типов тестов, а также для определения критериев начала и окончания тестирования. Выбранный подход зависит от контекста и может учитывать риски, опасности и безопасность, доступные ресурсы и навыки, технологии, характер системы (например, [custom built](https://en.wikipedia.org/wiki/Custom\\_software) vs. [commercially available off-the-shelf (COTS)](https://en.wikipedia.org/wiki/Commercial\\_off-the-shelf)), цели тестирования (test objectives) и правила.\n\nПодход к тестированию включает две техники:\n\n* Упреждающий (Proactive) - подход, при котором test design process запускается как можно раньше, чтобы найти и исправить дефекты до создания сборки (build);\n* Реактивный (Reactive) - подход, при котором тестирование не начинается до завершения проектирования и разработки.\n\nРазличные подходы к тестированию:\n\n* **Аналитические подходы (Analytical approaches)**, такие как risk-based testing, когда тестирование направлено на области наибольшего риска;\n* **Подходы на основе моделей (Model-based approaches)**, такие как стохастическое тестирование с использованием статистической информации о частоте отказов (например, модели роста надежности) или использовании (например, рабочие профили);\n* **Методические подходы (Methodical approaches)**, такие как основанные на отказах (failure-based) (включая error guessing and fault attacks), основанные на опыте, на основе чек-листов и на основе характеристик качества (experience-based, checklist-based, and quality characteristic-based);\n* **Подходы, соответствующие процессам или стандартам (Process- or standard-compliant approaches)**, например, указанные в отраслевых стандартах или различных гибких методологиях;\n* **Динамические и эвристические подходы (Dynamic and heuristic approaches)**, такие как exploratory testing, при котором тестирование более реагирующее (reactive) на события, чем при запланированном заранее (pre-planned), и где выполнение и оценка (execution and evaluation) являются параллельными задачами;\n* **Консультативные подходы (Consultative approaches)** - подходы, при которых test coverage определяется в первую очередь советами и руководством экспертов в области технологий и / или бизнеса, не входящих в группу тестирования;\n* **Подходы против регрессии (Regression-averse approaches)** - подходы, которые включают повторное использование существующего тестового материала, обширную автоматизацию функциональных регрессионных тестов и стандартные наборы тестов.\n\nМожно комбинировать разные подходы, например, динамический подход, основанный на оценке риска.\n\n","date":"2022-05-17T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/praktiki-i-podhody-testirovaniya/","order":9,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Практики тестирования","path":"/tag/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"},{"title":"Подходы тестирования","path":"/tag/%D0%9F%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"TDD - Test Driven Development","anchor":"#tdd---test-driven-development"},{"value":"BDD - Behaviour Driven Development","anchor":"#bdd---behaviour-driven-development"},{"value":"TDD - Type Driven Development","anchor":"#tdd---type-driven-development"},{"value":"DDD - Domain Driven Design","anchor":"#ddd---domain-driven-design"},{"value":"FDD - Features Driven Development","anchor":"#fdd---features-driven-development"},{"value":"MDD - Model Driven Development","anchor":"#mdd---model-driven-development"},{"value":"PDD - Panic Driven Development","anchor":"#pdd---panic-driven-development"},{"value":"ADD - API Driven Development","anchor":"#add---api-driven-development"},{"value":"BDT - Behavior Driven Testing","anchor":"#bdt---behavior-driven-testing"},{"value":"MDT - Model Driven Testing","anchor":"#mdt---model-driven-testing"},{"value":"DDT - Data Driven Testing (table-driven testing or parameterized testing)","anchor":"#ddt---data-driven-testing-table-driven-testing-or-parameterized-testing"},{"value":"VDT - Value Driven Testing","anchor":"#vdt---value-driven-testing"},{"value":"Подход к тестированию (Test Approach)","anchor":"#подход-к-тестированию-test-approach"}]}}]}},"relatedCategory":{"id":"603a2c0d964c5170463a1125f6911641","title":"manual","path":"/category/manual/","related":[{"id":"mobile","path":"/category/mobile/","title":"mobile"},{"id":"api","path":"/category/api/","title":"api"}]}},"context":{}}