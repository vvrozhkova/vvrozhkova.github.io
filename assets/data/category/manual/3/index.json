{"hash":"03f7058ba488a165454bf4fd228c446ef5a28a6f","data":{"category":{"title":"manual","path":"/category/manual/","belongsTo":{"totalCount":45,"pageInfo":{"totalPages":5,"currentPage":3},"edges":[{"node":{"id":"be63b1908e8b0d387151ddea9164dd99","title":"Виды тестирования по уровню деталиции приложения (по уровню тестирования)","content":"\n## Модульное (компонентное) тестирование (Unit testing, Module testing, Component testing)\nНаправлено на проверку отдельных небольших частей приложения, которые (как правило) можно исследовать изолированно от других подобных частей. \n\nПри выполнении данного тестирования могут проверяться отдельные функции или методы классов, сами классы, взаимодействие классов, небольшие библиотеки, отдельные части приложения. Часто данный вид тестирования реализуется с использованием специальных технологий и инструментальных средств автоматизации тестирования, значительно упрощающих и ускоряющих разработку соответствующих тест-кейсов.\n\n«Юнит-тестирование», как правило, направлено на тестирование атомарных участков кода, «Модульное» — на тестирование классов и небольших библиотек, «Компонентное» — на тестирование библиотек и структурных частей приложения. Но эта классификация не стандартизирована, и у различных авторов можно встретить совершенно разные взаимоисключающие трактовки.\n\n## Интеграционное тестирование (Integration testing, Component integration testing, Pairwise integration testing, System integration testing, Incremental testing, Interface testing, Thread testing) \nНаправлено на проверку взаимодействия между несколькими частями приложения (каждая из которых, в свою очередь, проверена отдельно на стадии модульного тестирования). К сожалению, даже если мы работаем с очень качественными отдельными компонентами, «на стыке» их взаимодействия часто возникают проблемы. Именно эти проблемы и выявляет интеграционное тестирование. (См. также техники вос- ходящего, нисходящего и гибридного тестирования в хронологической классификации по иерархии компонентов.)\n\nПодходы к интеграционному тестированию:\n\n- Снизу вверх (Bottom Up Integration)\n\nВсе низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.\n\n- Сверху вниз (Top Down Integration)\n\nВначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.\n\n- Большой взрыв («Big Bang» Integration)\n\nВсе или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.\n\n## Системное тестирование (System testing) \nНаправлено на проверку всего приложения как единого целого, собранного из частей, проверенных на двух предыдущих стадиях. Здесь не только выявляются дефекты «на стыках» компонентов, но и появляется возможность полноценно взаимодействовать с приложением с точки зрения конечного пользователя, применяя множество других видов тестирования, перечисленных в данной главе.\n\n---\n\nС классификацией по уровню детализации приложения связан интересный печальный факт: если предыдущая стадия обнаружила проблемы, то на следующей стадии эти проблемы точно нанесут удар по качеству; если же предыдущая стадия не обнаружила проблем, это ещё никоим образом не защищает нас от проблем на следующей стадии.\n\nЕсли обратиться к словарю ISTQB и прочитать определение уровня тестирования (test level), то можно увидеть, что аналогичное разбиение на модульное, интеграционное и системное тестирование, к которым добавлено ещё и приёмочное тестирование, используется в контексте разделения областей ответственности на проекте. Но такая классификация больше относится к вопросам управления проектом, чем к тестированию в чистом виде, а потому выходит за рамки рассматриваемых нами вопросов.\n\n- Приемочное\n","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-urovnyu-detaliczii-prilozheniya-po-urovnyu-testirovaniya/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Модульное (компонентное) тестирование (Unit testing, Module testing, Component testing)","anchor":"#модульное-компонентное-тестирование-unit-testing-module-testing-component-testing"},{"value":"Интеграционное тестирование (Integration testing, Component integration testing, Pairwise integration testing, System integration testing, Incremental testing, Interface testing, Thread testing)","anchor":"#интеграционное-тестирование-integration-testing-component-integration-testing-pairwise-integration-testing-system-integration-testing-incremental-testing-interface-testing-thread-testing"},{"value":"Системное тестирование (System testing)","anchor":"#системное-тестирование-system-testing"}]}},{"node":{"id":"9d2df53edb3e4f5b29b515bdbc25e32d","title":"Виды тестирования по (убыванию) степени важности тестируемых функций (по уровню функционального тестирования)","content":"\nВ некоторых источниках эту разновидность классификации также называют «по глубине тестирования».\n\n## Дымовое тестирование (Smoke test, Intake test, Build verification test) \nНаправлено на проверку самой главной, самой важной, самой ключевой функциональности, неработоспособность которой делает бессмысленной саму идею использования приложения (или иного объекта, подвергаемого дымовому тестированию).\n\nДымовое тестирование проводится после выхода нового билда, чтобы определить общий уровень качества приложения и принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного тестирования. \n\nПоскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но при этом очень часто повторяются, они являются хорошими кандидатами на автоматизацию. В связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто выставляется равным 100 % или близким к 100 %.\n\n## Тестирование критического пути (Critical path test) \nНаправлено на исследование функциональности, используемой типичными пользователями в типичной повседневной деятельности. \n\nСуществует большинство пользователей, которые чаще всего используют некое подмножество функций приложения. Именно эти функции и нужно проверить, как только мы убедились, что приложение «в принципе работает» (дымовой тест прошёл успешно). Если по каким-то причинам приложение не выполняет эти функции или выполняет их некорректно, очень многие пользователи не смогут достичь множества своих целей. \n\nПороговое значение метрики успешного прохождения «теста критического пути» уже немного ниже, чем в дымовом тестировании, но всё равно достаточно высоко (как пра- вило, порядка 70–80–90 % — в зависимости от сути проекта).\n\n## Расширенное тестирование (Extended test)\nНаправлено на исследование всей заявленной в требованиях функциональности — даже той, которая низко проранжирована по степени важности. При этом здесь также учитывается, какая функциональность является более важной, а какая — менее важной. Но при наличии достаточного количества времени и иных ресурсов тест-кейсы этого уровня могут затронуть даже самые низкоприоритетные требования.\n\nЕщё одним направлением исследования в рамках данного тестирования являются нетипичные, маловероятные, экзотические случаи и сценарии использования функций и свойств приложения, затронутых на предыдущих уровнях. \n\nПороговое значение метрики успешного прохождения расширенного тестирования существенно ниже, чем в тестировании критического пути (иногда можно увидеть даже значения в диапазоне 30–50 %, т.к. подавляющее большинство найденных здесь дефектов не представляет угрозы для успешного использова- ния приложения большинством пользователей).\n\nК сожалению, часто можно встретить мнение, что дымовое тестирование, тестирование критического пути и расширенное тестирование напрямую связаны с позитивным тестированием и негативным тестированием, и негативное появляется только на уровне тестирования критического пути. Это не так. Как позитивные, так и негативные тесты могут (а иногда и обязаны) встречаться на всех перечисленных уровнях. Например, деление на ноль в калькуляторе явно должно относиться к дымовому тестирова- нию, хотя это яркий пример негативного тест-кейса.","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-ubyvaniyu-stepeni-vazhnosti-testiruemyh-funkczij-po-urovnyu-funkczionalnogo-testirovaniya/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Дымовое тестирование (Smoke test, Intake test, Build verification test)","anchor":"#дымовое-тестирование-smoke-test-intake-test-build-verification-test"},{"value":"Тестирование критического пути (Critical path test)","anchor":"#тестирование-критического-пути-critical-path-test"},{"value":"Расширенное тестирование (Extended test)","anchor":"#расширенное-тестирование-extended-test"}]}},{"node":{"id":"48a2cbf9f6a2e3be841b2f6a6c6796b1","title":"Виды тестирования по принципам работы с приложением","content":"\n## Позитивное тестирование (Positive testing) \nНаправлено на исследование приложения в ситуации, когда все действия выполняются строго по инструкции без каких бы то ни было ошибок, отклонений, ввода неверных данных и т.д. \n\nЕсли позитивные тест-кейсы завершаются ошибками, это тревожный признак — приложение работает неверно даже в идеальных условиях (и можно предположить, что в неидеальных условиях оно работает ещё хуже). \n\nДля ускорения тестирования несколько позитивных тест-кейсов можно объединять (например, перед отправкой заполнить все поля формы верными значениями) — иногда это может усложнить диагностику ошибки, но существенная экономия времени компенсирует этот риск.\n\n## Негативное тестирование (Negative testing, Invalid testing)\nНаправлено на исследование работы приложения в ситуациях, когда с ним выполняются (некорректные) операции и/или используются данные, потенциально приводящие к ошибкам (классика жанра — деление на ноль). \n\nПоскольку в реальной жизни таких ситуаций значительно больше (пользователи допускают ошибки, злоумышленники осознанно «ломают» приложение, в среде работы приложения возникают проблемы и т. д.), негативных тест-кейсов оказывается значительно больше, чем позитивных (иногда — в разы или даже на порядки). \n\nВ отличие от позитивных негативные тест-кейсы не стоит объединять, т. к. подобное решение может привести к неверной трактовке поведения приложения и пропуску (необнаружению) дефектов.","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-princzipam-raboty-s-prilozheniem/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Позитивное тестирование (Positive testing)","anchor":"#позитивное-тестирование-positive-testing"},{"value":"Негативное тестирование (Negative testing, Invalid testing)","anchor":"#негативное-тестирование-negative-testing-invalid-testing"}]}},{"node":{"id":"1c93528f55299e3a76c2d8b0144d2d93","title":"Виды тестирования  по природе приложения","content":"\nДанный вид классификации является искусственным, поскольку «внутри» речь будет идти об одних и тех же видах тестирования, отличающихся в данном контексте лишь концентрацией на соответствующих функциях и особенностях приложения, использованием специфических инструментов и отдельных техник.\n\n## Тестирование веб-приложений (Web-applications testing) \nСопряжено с интенсивной деятельностью в области тестирования совместимости (в особенности — кросс-браузерного тестирования), тестирования производительности, автоматизации тестирования с использованием широкого спектра инструментальных средств.\n\n## Тестирование мобильных приложений (Mobile applications testing) \nТакже требует повышенного внимания к тестированию совместимости, оптимизации производительности (в том числе клиентской части с точки зрения снижения энергопотребления), автоматизации тестирования с применением эмуляторов мобильных устройств.\n\n## Тестирование настольных приложений (Desktop applications testing) \nЯвляется самым классическим среди всех перечисленных в данной классификации, и его особенности зависят от предметной области приложения, нюансов архитектуры, ключевых показателей качества и т. д.\n\nЭту классификацию можно продолжать очень долго. Например, можно отдельно рассматривать тестирование консольных приложений (console applications testing) и приложений с графическим интерфейсом (GUI-applications testing), серверных приложений (server applications testing) и клиентских приложений (client applications testing) и т. д.","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-prirode-prilozheniya/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Тестирование веб-приложений (Web-applications testing)","anchor":"#тестирование-веб-приложений-web-applications-testing"},{"value":"Тестирование мобильных приложений (Mobile applications testing)","anchor":"#тестирование-мобильных-приложений-mobile-applications-testing"},{"value":"Тестирование настольных приложений (Desktop applications testing)","anchor":"#тестирование-настольных-приложений-desktop-applications-testing"}]}},{"node":{"id":"b2507b0db7418c6abfe0f2288423492a","title":"Виды тестирования по фокусировке на уровне архитектуры приложения","content":"\nДанный вид классификации, как и предыдущий, также является искусственным и отражает лишь концентрацию внимания на отдельной части приложения.\n\n## Тестирование уровня представления (Presentation tier testing) \nСконцентрировано на той части приложения, которая отвечает за взаимодействие с «внешним миром» (как пользователями, так и другими приложениями). Здесь исследуются вопросы удобства использования, скорости отклика интерфейса, совместимости с браузерами, корректности работы интерфейсов.\n\n## Тестирование уровня бизнес-логики (Business logic tier testing)\nОтвечает за проверку основного набора функций приложения и строится на базе ключевых требований к приложению, бизнес-правил и общей проверки функциональности.\n\n## Тестирование уровня данных (Data tier testing) \nСконцентрировано на той части приложения, которая отвечает за хранение и некоторую обработку данных (чаще всего — в базе данных или ином хранилище). Здесь особый интерес представляет тестирование данных, проверка соблюдения бизнес-правил, тестирование производительности.\n ","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-fokusirovke-na-urovne-arhitektury-prilozheniya/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Тестирование уровня представления (Presentation tier testing)","anchor":"#тестирование-уровня-представления-presentation-tier-testing"},{"value":"Тестирование уровня бизнес-логики (Business logic tier testing)","anchor":"#тестирование-уровня-бизнес-логики-business-logic-tier-testing"},{"value":"Тестирование уровня данных (Data tier testing)","anchor":"#тестирование-уровня-данных-data-tier-testing"}]}},{"node":{"id":"2316ca7e1d904579ac9ceeb91855288a","title":"Виды тестирования по привлечению конечных пользователей","content":"\nВсе три перечисленных ниже вида тестирования относятся к операционному тестированию.\n\n## Альфа-тестирование (Alpha testing) \nВыполняется внутри организации-разработчика с возможным частичным привлечением конечных пользователей. Может являться формой внутреннего приёмочного тестирования. \n\nВ некоторых источниках отмечается, что это тестирование должно проводиться без привлечения команды разработчиков, но другие источники не выдвигают такого требования. \n\nСуть этого вида вкратце: продукт уже можно периодически показывать внешним пользователям, но он ещё достаточно «сырой», потому основное тестирование выполняется организацией-разработчиком.\n\n## Бета-тестирование (Beta testing) \nВыполняется вне организации-разработчика с активным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования. \n\nСуть этого вида вкратце: продукт уже можно открыто показывать внешним пользователям, он уже достаточно стабилен, но проблемы всё ещё могут быть, и для их выявления нужна обратная связь от реальных пользователей.\n\n## Гамма-тестирование (Gamma testing)\nФинальная стадия тестирования перед выпуском продукта, направленная на исправление незначительных дефектов, обнаруженных в бета-тестировании.\nКак правило, также выполняется с максимальным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования. \n\nСуть этого вида вкратце: продукт уже почти готов, и сейчас обратная связь от реальных пользователей используется для устранения последних недоработок.","date":"2022-05-16T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vidy-testirovaniya-po-privlecheniyu-konechnyh-polzovatelej/","order":10,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Виды тестирования","path":"/tag/%D0%92%D0%B8%D0%B4%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Альфа-тестирование (Alpha testing)","anchor":"#альфа-тестирование-alpha-testing"},{"value":"Бета-тестирование (Beta testing)","anchor":"#бета-тестирование-beta-testing"},{"value":"Гамма-тестирование (Gamma testing)","anchor":"#гамма-тестирование-gamma-testing"}]}},{"node":{"id":"61b1c834e5ddf36a514d7caffa38dd98","title":"Уровни тестирования","content":"\n## Пирамида тестирования (Test Pyramid)\n\n«Пирамида тестов» - метафора, которая означает группировку динамических тестов программного обеспечения по разным уровням. Она также дает представление, какое количество тестов должно быть в каждой из этих групп. Основной принцип разделения уровней - тест должен быть на том же уровне, что и тестируемый объект. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты тестами более низкого уровня.\n\n![](https://lh6.googleusercontent.com/yDN1s-lXbEFI5tsd429c2fT5DkHxfDNFpTotktfGZe2tdXVAdo218WSOksJIhBx5VDJffYvMOcadII\\_r7ln-kvX4iKFuuQ75io5IEimepSLJq\\_qkkZ\\_JH5x5UfdSXdF2PqbBPqpV)\n\n## Уровни тестирования(Testing Levels)\n\n* Unit/component/program/module testing - тестируется минимально-атомарный модуль программы, чаще всего это одна функция или метод. Таких тестов должно быть больше всего;\n* Integration testing - несколько модулей программы тестируются вместе;\n* System testing - вся программа тестируется полностью;\n* Acceptance testing - программа принимается заказчиком на соответствие заявленным требованиям либо тестировщики проходят end-to-end сценарии с точки зрения пользователя;\n\n### Модульное/юнит/компонентное тестирование (Module/Unit/Component testing)\n\nС этими терминами часто происходит путаница. Если ссылаться на глоссарий ISTQB, то все они - синонимы:\n\n* _**Модуль, юнит (module, unit): См. компонент.**_\n* _**Модульное, юнит тестирование (module testing, unit testing): См. компонентное тестирование.**_\n* _**Компонент (component): Наименьший элемент программного обеспечения, который может быть протестирован отдельно.**_\n* _**Компонентное тестирование (component testing): Тестирование отдельных компонентов программного обеспечения (IEEE 610).**_&#x20;\n\nТем не менее, некоторые источники описывают ситуацию несколько иначе и я решил выписать другую точку зрения.\n\n**Модульное тестирование (оно же юнит-тестирование)** используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы (отдельные методы класса или простая функция, subprograms, subroutines, классы или процедуры) в коде. Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups).\n\n**Компонентное тестирование** - тип тестирования ПО, при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. Это один из самых частых типов тестирования черного ящика, который проводится командой QA. Для каждого из этих компонентов будет определен сценарий тестирования, который затем будет приведен к Test case высокого уровня -> детальным Test case низкого уровня с предварительными условиями.\n\nИсходя из глубины уровней тестирования, компонентное тестирование можно классифицировать как:\n\n* Тестирование компонентов в малом (CTIS - Component testing In Small): тестирование компонентов может проводиться с или без изоляции остальных компонентов в тестируемом программном обеспечении или приложении. Если это выполняется с изоляцией другого компонента, то это называется CTIS;\n* Тестирование компонентов в целом (CTIL - Component testing In Large) - тестирование компонентов, выполненное без изоляции других компонентов в тестируемом программном обеспечении или приложении;\n\n| **Module/Unit testing**                                                                                        | **Component testing**                                                                                        |\n| -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| Тестирование отдельных классов, функций для демонстрации того, что программа выполняется согласно спецификации | Тестирование каждого объекта или частей программного обеспечения отдельно с или без изоляции других объектов |\n| Проверка в(на) соответствии с design documents                                                                 | Проверка в(на) соответствии с test requirements, use case                                                    |\n| Пишутся и выполняются разработчиками                                                                           | Тестировщиками                                                                                               |\n| Выполняется первым                                                                                             | Выполняется после Unit                                                                                       |\n\nДругой источник:\n\nПо-существу эти уровни тестирования представляют одно и тоже, разница лишь в том, что в компонентном тестировании в качестве параметров функций используют реальные объекты и драйверы, а в модульном/unit тестировании - конкретные значения.\n\n\\*В контексте юнит-тестирования еще можно встретить понятие [golden testing](https://ro-che.info/articles/2017-12-04-golden-tests). Оно означает те же юнит тесты, но с ожидаемыми результатами хранящимися в отдельном файле. Таким образом после прогона выходные значения тестов сравниваются с golden (эталонным) файлом.\n\n\\*Иногда юнит-тесты называют одинокими (solitary) в случае тотального применения имитаций и заглушек или общительными (sociable) в случае реальных коммуникаций с другими участниками.\n\n\\*Правило трех А(AAA) (arrange, act, assert) или триада «дано, когда, тогда» - хорошая мнемоника, чтобы поддерживать хорошую структуру тестов.\n\n### Интеграционное тестирование (Integration testing)\n\n_Интеграционное тестирование (integration testing): Тестирование, выполняемое для обнаружения дефектов в интерфейсах и во взаимодействии между интегрированными компонентами или системами. См. также тестирование интеграции компонентов, системное интеграционное тестирование. (ISTQB)_\n\n_Системное интеграционное тестирование (system integration testing): Тестирование интеграции систем и пакетов программ, тестирование интерфейсов связи с внешними системами (интернет и т.д.). (ISTQB)_\n\n_Интеграционное тестирование в малом (integration testing in the small): См. тестирование интеграции компонентов. (ISTQB)_\n\n_Интеграционное тестирование в целом (integration testing in the large): См. системное интеграционное тестирование. (ISTQB)_\n\n_Изоляционное тестирование (isolation testing): Тестирование отдельных компонентов в изоляции от окружающих компонентов в окружении компонентов, которые при необходимости эмулируются заглушками и драйверами. (ISTQB)_\n\n_Попарное интеграционное тестирование (pairwise integration testing): Вид интеграционного тестирования, нацеленного на пары компонентов, работающих совместно соответственно графу вызовов. (ISTQB)_\n\nИнтеграционное тестирование предназначено для проверки насколько хорошо два или более компонента ПО взаимодействуют друг с другом, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). С технологической точки зрения интеграционное тестирование является количественным развитием компонентного, поскольку также оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки (Stub) на месте отсутствующих модулей. Основная разница между компонентным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа. В частности, на уровне интеграционного тестирования часто применяются методы, связанные с покрытием интерфейсов, например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой.\n\n**Уровни интеграционного тестирования**:\n\n* **Компонентный интеграционный уровень** (CIT - [Component Integration testing](https://www.testing.guru/what-is-component-integration-testing/)): Проверяется взаимодействие между компонентами одной системы после проведения компонентного тестирования. Программные компоненты или модули могут быть определены в разное время совершенно разными группами спецификаций, component integration testing выполняется чтобы убедиться, что даже после различий в разработке модулей интеграция всего работает вместе. В этом случае также важно учесть отрицательные случаи, так как компоненты могут делать предположения относительно данных;\n* **Системный интеграционный уровень** (SIT - [System Integration testing](https://www.softwaretestinghelp.com/system-integration-testing/)): - это полное тестирование всей системы, состоящей из множества подсистем. Основная цель SIT - обеспечить правильное функционирование всех зависимостей программных модулей и сохранение целостности данных между отдельными модулями всей системы. SUT ([System Under Test](https://www.tutorialspoint.com/software\\_testing\\_dictionary/system\\_under\\_test.htm)) может состоять из аппаратного обеспечения, базы данных, программного обеспечения, комбинации аппаратного и программного обеспечения или системы, требующей взаимодействия с человеком (HITL - [Human in the Loop](https://en.wikipedia.org/wiki/Human-in-the-loop) Testing). SIT имеет предварительное условие, при котором несколько базовых интегрированных систем уже прошли системное тестирование. Затем SIT проверяет необходимые взаимодействия между этими системами в целом. Результаты SIT передаются в UAT (пользовательское приемочное тестирование);\n\n**Интеграция может быть как программной, так и софт-железо**:\n\n* **HSIT** - Hardware Software Integration Testing: представляет собой процесс тестирования компонентов компьютерного программного обеспечения (CSC - Computer Software Components) на предмет функциональности высокого уровня в целевой аппаратной среде. Тестирование черного ящика - это основной тип тестирования, используемый на этом уровне тестирования. Целью тестирования интеграции аппаратного / программного обеспечения является проверка поведения разработанного программного обеспечения, интегрированного в аппаратный компонент. Цель тестирования интеграции аппаратного и программного обеспечения на основе требований (Requirement based Hardware-Software Integration Testing) - убедиться, что программное обеспечение на целевом компьютере удовлетворяет высокоуровневым требованиям (high-level requirements);\n* **SSIT** - Software Software Integration Testing: это Computer Software Component Testing, работающего в среде целевого компьютера при моделировании всей системы (других CSC), и на функциональности высокого уровня. Оно фокусируется на поведении CSC в смоделированной среде хоста / цели. Для проверки интеграции программного обеспечения используются разные подходы;\n\n**Подходы к интеграционному тестированию**:\n\n* **Подход Большого взрыва (Big Bang Approach)**: _“Вид подхода к интеграционному тестированию, при котором элементы программного или аппаратного обеспечения, или и то и другое, собираются в компонент или в целую систему сразу, а не по этапам.” ( IEEE 610)_. Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если Test case и их результаты записаны неверно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования;\n* **Инкрементальный подход (Incremental Approach)**: при таком подходе тестирование выполняется путем объединения двух или более логически связанных модулей. Затем другие связанные модули поэтапно добавляются и тестируются для правильного функционирования. Процесс продолжается до тех пор, пока все модули не будут соединены и успешно протестированы. Осуществляется разными методами:\n  * **Нисходящий подход (Top-Down Approach)**: Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Преимущества: Локализация неисправностей проще. Возможность получить ранний прототип. Основные недостатки дизайна могут быть найдены и исправлены в первую очередь. Недостатки: Нужно много заглушек. Модули на более низком уровне тестируются недостаточно;\n  * **Восходящий подход (Bottom-Up Approach)**: В восходящей стратегии каждый модуль на более низких уровнях последовательно тестируется с более высокоуровневыми модулями, пока не будут протестированы все модули. Требуется помощь драйверов для тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения. Пример низкоуровневого модуля - модуль, который заведует хранением токенов авторизации. Высокоуровневый - модуль авторизации, в состав которого помимо прочего входит модуль токенов. Преимущества: Локализация ошибок проще. Не тратится время на ожидание разработки всех модулей, в отличие от подхода Большого взрыва. Недостатки: Критические модули (на верхнем уровне архитектуры ПО), которые контролируют поток приложения, тестируются последними и могут быть подвержены дефектам. Ранний прототип невозможен;\n  * [**Гибридный/сэндвич-подход**](https://www.ques10.com/p/38806/describe-bi-directionalsandwitch-integration-testi/) **(Sandwich/Hybrid/Bi-Directional Approach)**: Представляет собой комбинацию восходящего и нисходящего подходов. Здесь целью является средний слой, в то время как драйверы заменяют верхний слой, а заглушки нижний пока компоненты этих слоев не будут разработаны;\n\n**Критерии начала и окончания Integration Testing**:\n\nОбычно при выполнении интеграционного тестирования используется стратегия [ETVX](https://vijaybn.wordpress.com/2012/09/06/etvx-entry-task-validation-exit/) (Entry Criteria, Task, Validation, Exit Criteria).\n\n* Критерии начала:\n  * завершено модульное тестирование;\n* На входе:\n  * Software Requirements Data;\n  * Software Design Document;\n  * Software Verification Plan;\n  * Software Integration Documents;\n* Действия:\n  * На основе требований высокого и низкого уровня (High and Low-level requirements) создайте test cases and procedures;\n  * Комбинируйте сборки низкоуровневых модулей, которые реализуют общую функциональность;\n  * Разработайте тестовую обвязку (test harness);\n  * Протестируйте сборку;\n  * После прохождения теста сборка объединяется с другими сборками и тестируется до тех пор, пока система не будет интегрирована как единое целое;\n  * Повторите все тесты на целевой processor-based platform и получите результаты;\n* Критерии выхода:\n  * Успешное завершение интеграции Программного модуля на целевое Hardware;\n  * Правильная работа программного обеспечения в соответствии с указанными требованиями;\n* На выходе:\n  * Integration test reports;\n  * SVCP - Software Test Cases and Procedures;\n\n[_Test Harness_](https://www.softwaretestinghelp.com/what-is-test-harness/)_- (тестовая обвязка): Тестовое окружение, включающее в себя заглушки и драйверы, необходимые для проведения теста. (ISTQB)_\n\n[Test Driver и Test Stub](https://www.geeksforgeeks.org/difference-between-stubs-and-drivers/) являются искусственными заменами компонентов программы на время тестов по аналогии с моками в тестировании API. Тестовый драйвер - то, что вызывает тестируемый компонент. Тестовая заглушка - то, что возвращает тестируемому компоненту фиктивный ответ. Т.е. заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с тестируемым модулем.\n\n[**Тестирование интерфейса**](https://www.softwaretestinghelp.com/what-is-interface-testing/) - это тип интеграционного теста, который проверяет, правильно ли установлена ​​связь между двумя различными программными системами или их частями (модулями). Соединение, которое объединяет два компонента, называется интерфейсом. Этот интерфейс в компьютерном мире может быть чем угодно, как API, так и веб-сервисами и т. д. Тестирование интерфейса включает в себя тестирование двух основных сегментов:\n\n* Интерфейс веб-сервера и сервера приложений\n* Интерфейс сервера приложений и базы данных\n\n**Тестирование потоков (Thread testing)** - это вид тестирования программного обеспечения, который проверяет основные функциональные возможности конкретной задачи (потока). Обычно проводится на ранней стадии фазы интеграционного тестирования. Тестирование на основе потоков является одной из дополнительных стратегий, принятых в ходе System Integration Testing. Поэтому его, вероятно, следует более правильно назвать «тестом взаимодействия потоков» (thread interaction test).\n\nThread Testing подразделяется на две категории:\n\n* Однопоточное тестирование (Single thread testing) включает одну транзакцию приложения за раз;\n* Многопоточное тестирование (Multi-thread testing) включает одновременно несколько активных транзакций;\n\nКак проводить Thread Testing:\n\n* Тестирование на основе потоков является обобщенной формой тестирования на основе сеансов (session-based testing), в котором сеансы являются формой потока, но поток не обязательно является сеансом;\n* Для тестирования потока, поток или программа (небольшая функциональность) интегрируются и тестируются постепенно как подсистема, а затем выполняются для всей системы;\n* На самом низком уровне оно предоставляет интеграторам лучшее представление о том, что тестировать;\n* Вместо непосредственного тестирования программных компонентов требуется, чтобы интеграторы сосредоточились на тестировании логических путей выполнения в контексте всей системы;\n\nСоветы:\n\n* Протестируйте свою многопоточную программу, многократно выполняя ее с другим набором запущенных приложений;\n* Протестируйте свою многопоточную программу, активировав одновременно несколько экземпляров программы;\n* Выполняйте многопоточную программу на разных моделях оборудования с различными уровнями нагрузки и рабочими нагрузками;\n* Инспекция кода;\n* Собирайте только ошибки и сбои, которые произошли в потоках, отличных от основного;\n\n\n### Системное тестирование (System Testing)\n\nСистемное тестирование означает тестирование всей системы в целом, оно выполняется после интеграционного тестирования, чтобы проверить, работает ли вся система целиком должным образом. В основном это тестирование типа «черный ящик», которое оценивает работу системы с точки зрения пользователя с помощью документа спецификации и оно не требует каких-либо внутренних знаний о системе, таких как дизайн или структура кода.\n\n**Основное внимание уделяется следующему**:\n\n* Внешние интерфейсы;\n* Многопрограммность и сложный функционал;\n* Безопасность;\n* Восстановление;\n* Производительность;\n* Гладкое (smooth) взаимодействие оператора и пользователя с системой;\n* Возможность установки;\n* Документация;\n* Удобство использование;\n* Нагрузка / стресс;\n\n**Зачем нужно системное тестирование**?\n\n* Очень важно завершить полный цикл тестирования, и ST - это этап, на котором это делается;\n* ST выполняется в среде, аналогичной production environment, и, следовательно, заинтересованные стороны могут получить хорошее представление о реакции пользователя;\n* Это помогает свести к минимуму устранение неполадок после развертывания и количество обращений в службу поддержки;\n* На этом этапе STLC тестируются архитектура приложения и бизнес-требования. Это тестирование очень важно, и оно играет важную роль в предоставлении клиенту качественного продукта;\n\n**Критерии начала системного тестирования**:\n\n* Система должна соответствовать критериям окончания интеграционного тестирования, то есть все test cases должны быть выполнены, и не должно быть открытых критических ошибок или ошибок с приоритетом P1, P2;\n* System Test Plan должен быть одобрен и подписан;\n* Test cases/scenarios/scripts должны быть готовы к выполнению;\n* Все нефункциональные требования должны быть доступны, и для них должны быть созданы test cases;\n* Среда тестирования должна быть готова;\n\n**Критерии окончания системного тестирования**:\n\n* Все test cases должны быть выполнены;\n* В открытом состоянии не должно быть критических, приоритетных или связанных с безопасностью ошибок;\n* Если какие-либо ошибки со средним или низким приоритетом находятся в открытом состоянии, они должны быть исправлены с согласия клиента;\n* Отчет о выходе (Exit Report) должен быть отправлен;\n\n**Чем отличается системное тестирование от сквозного** (E2E - end-to-end testing)?\n\nСквозное тестирование - это методология тестирования программного обеспечения для тестирования flow приложения от начала до конца. Целью сквозного тестирования является моделирование реального пользовательского сценария и проверка тестируемой системы и ее компонентов на предмет интеграции и целостности данных.\n\nСистемное тестирование - этап предпоследний этап STLC и уровень тестирования, а E2E - подход к тестам. Обычно сквозные тесты выполняют после системного тестирования и перед приемочным, а также после внесения изменений (smoke и regression). E2E выполняется от начала до конца в реальных сценариях, таких как взаимодействие приложения с оборудованием, сетью, базой данных и другими приложениями. Основная причина проведения этого тестирования - определение различных зависимостей приложения, а также обеспечение передачи точной информации между различными компонентами системы.\n\n\n### Приемочное тестирование (AT - Acceptance testing)\n\n_Приемочное тестирование (acceptance testing): Формальное тестирование по отношению к потребностям, требованиям и бизнес процессам пользователя, проводимое с целью определения соответствия системы критериям приемки и дать возможность пользователям, заказчикам или иным авторизированым лицам определить, принимать систему или нет. (IEEE 610)_\n\n_Эксплуатационное приемочное тестирование (operational acceptance testing): Эксплуатационное тестирование в фазе приемочного тестирования, обычно выполняемое пользователем и/или сотрудниками с администраторским доступом, в рабочей среде (возможно, стимулированной), фокусируясь на функциональных аспектах. Например, восстанавливаемость, поведение ресурсов, устанавливаемость и техническое соответствие. (ISTQB)_\n\nПосле того, как процесс тестирования системы завершен командой тестирования, весь продукт передается клиенту и/или нескольким его пользователям для проверки приемлемости (acceptability). Е2Е бизнес-потоки проверяются аналогично в сценариях в реальном времени. Подобная производственной среда будет тестовой средой для приемочного тестирования (Staging, Pre-Prod, Fail-Over, UAT environment). Это метод тестирования черного ящика, при котором проверяется только функциональность, чтобы убедиться, что продукт соответствует указанным критериям приемки.\n\n**Виды приемочного тестирования**:\n\n* **Пользовательское** приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям. Могут существовать такие бизнес-требования и процессы, которые известны только конечным пользователям, и они либо пропускаются, либо неправильно интерпретируются, поэтому приемочное тестирование выполняется конечными пользователями, знакомыми с бизнес-требованиями;\n* **Бизнес -** приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам. BAT в основном фокусируется на бизнес-преимуществах (финансах), которые являются довольно сложными из-за меняющихся рыночных условий / прогрессирующих технологий, так что текущая реализация может претерпеть изменения, которые приведут к дополнительным затратам. Даже Продукт, отвечающий техническим требованиям, может не пройти BAT по этим причинам;\n* **Контрактное** приемочное тестирование (CAT - Contract Acceptance Testing) - это контракт, который определяет, что после того, как Продукт будет запущен в течение заранее определенного периода, должен быть проведен приемочный тест, и он должен пройти все приемочные тест-кейсы. Подписанный здесь контракт называется Соглашением об уровне обслуживания (SLA), которое включает условия, по которым платеж будет производиться только в том случае, если услуги Продукта соответствуют всем требованиям, что означает, что контракт выполнен. Иногда этот контракт может заключаться до того, как Продукт будет запущен. В любом случае, контракт должен быть четко определен с точки зрения периода тестирования, областей тестирования, условий по проблемам, возникающим на более поздних этапах, платежей и т. д.;\n* **Правовое** приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается. Это может быть непреднамеренным, но отрицательно скажется на бизнесе. Обычно разрабатываемый Продукт / приложение, предназначенный для выпуска во всем мире, должен пройти RAT, поскольку в разных странах / регионах действуют разные правила и положения, определенные его руководящими органами. Если какие-либо правила и нормы нарушаются для какой-либо страны, то этой стране или конкретному региону в этой стране не будет разрешено использовать Продукт и это будет считаться отказом (Failure). Вендоры Продукта несут прямую ответственность, если Продукт будет выпущен даже при наличии нарушения;\n* **Эксплуатационное** приемочное тестирование ([OAT - Operational Acceptance testing](https://en.wikipedia.org/wiki/Operational\\_acceptance\\_testing)) - это тип тестирования программного обеспечения, который оценивает эксплуатационную готовность программного приложения до его выпуска в производство. Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment). В основном это тестирование восстановления, совместимости, ремонтопригодности, доступности технической поддержки, надежности, восстановления после сбоя, локализации и т. д (recovery, compatibility, maintainability, technical support availability, reliability, fail-over, localization);\n* **Альфа-тестирование** ([Alpha Testing](https://www.softwaretestinghelp.com/alpha-testing/)) проводят для оценки продукта в среде разработки / тестирования специализированной командой тестировщиков, обычно называемой альфа-тестерами. Здесь отзывы и предложения тестировщиков помогают улучшить использование Продукта, а также исправить определенные ошибки;\n* **Бета-тестирование, полевые испытания** ([Beta Testing](https://www.softwaretestinghelp.com/beta-testing/), Field Testing) проводят для оценки Продукта, предоставляя его реальным конечным пользователям, обычно называемым бета-тестерами / бета-пользователями, в их среде. Собирается постоянная обратная связь от пользователей, и проблемы устраняются. Кроме того, это помогает в улучшении Продукта, чтобы обеспечить удобство работы пользователей. Тестирование происходит неконтролируемым образом, что означает, что у пользователя нет ограничений на использование Продукта;\n\n**Уровни Тестирования**\n1. Модульное тестирование (Unit Testing)\nКомпонентное (модульное) тестирование проверяет функциональность и ищет дефекты в частях приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты, классы, функции и т.д.).\n\n2. Интеграционное тестирование (Integration Testing)\nПроверяется взаимодействие между компонентами системы после проведения компонентного тестирования.\n\n3. Системное тестирование (System Testing)\nОсновной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.\n\n4. Операционное тестирование (Release Testing).\nДаже если система удовлетворяет всем требованиям, важно убедиться в том, что она удовлетворяет нуждам пользователя и выполняет свою роль в среде своей эксплуатации, как это было определено в бизнес моделе системы. Следует учесть, что и бизнес модель может содержать ошибки. Поэтому так важно провести операционное тестирование как финальный шаг валидации. Кроме этого, тестирование в среде эксплуатации позволяет выявить и нефункциональные проблемы, такие как: конфликт с другими системами, смежными в области бизнеса или в программных и электронных окружениях; недостаточная производительность системы в среде эксплуатации и др. Очевидно, что нахождение подобных вещей на стадии внедрения — критичная и дорогостоящая проблема. Поэтому так важно проведение не только верификации, но и валидации, с самых ранних этапов разработки ПО.\n\n5. Приемочное тестирование (Acceptance Testing)\nФормальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:\n• определения удовлетворяет ли система приемочным критериям;\n• вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.\n","date":"2022-05-15T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/urovni-testirovaniya/","order":11,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Уровни тестирования","path":"/tag/%D0%A3%D1%80%D0%BE%D0%B2%D0%BD%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Пирамида тестирования (Test Pyramid)","anchor":"#пирамида-тестирования-test-pyramid"},{"value":"Уровни тестирования(Testing Levels)","anchor":"#уровни-тестированияtesting-levels"}]}},{"node":{"id":"8562b6e5f8b1eae354402d50986f4ba9","title":"Техники тест-дизайна","content":"# Тест-дизайн и техники тест-дизайна (Test Design and Software Testing Techniques)\n\n_Проектирование теста (test design): Процесс перевода общих причин тестирования в конкретные тестовые условия и тестовые сценарии. (ISTQB)_\n\n_Причина тестирования (test objective): Причина или цель разработки и выполнения теста. (ISTQB)_\n\n_Тестовое условие (test condition): Объект или событие в компоненте или системе, которое должно быть проверено одним или несколькими тестовыми наборами. Например: функция, транзакция, свойство, атрибут качества или структурный элемент. (ISTQB)_\n\n**Тест-дизайн** - важный этап STLС, а именно деятельность по получению и определению тестовых примеров из test objectives и test conditions. Проще говоря, цель тест-дизайна - создать максимально эффективный набор кейсов, покрывающий наиболее важные аспекты тестируемого ПО, т.е. минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок.\n\n**Тест дизайн** — это этап процесса тестирования ПО, на котором проектируются и создаются тестовые сценарии (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования.\nРоли, ответственные за тест дизайн:\n• Тест аналитик — определяет «ЧТО тестировать?»\n• Тест дизайнер — определяет «КАК тестировать?»\n\nОдним из наиболее важных аспектов теста является то, что он проверяет, выполняет ли система то, что она должна делать. Copeland говорит: “По сути, тестирование - это процесс сравнения того, что есть с тем, что должно быть”. Если мы просто введем какие-то данные и подумаем, что это было весело, я предполагаю, что с системой, вероятно, все в порядке, потому что она не крашнулась, но действительно ли мы ее тестируем? Beizer называет это «детским тестированием» (kiddie testing). Мы можем не знать каждый раз, какой правильный ответ в деталях, и иногда мы все равно можем получить некоторую выгоду от этого подхода, но на самом деле это не проверка. Чтобы знать, что система должна делать, нам нужен источник информации о правильном поведении системы - это называется «оракул» или тестовый оракул (test oracle). После того, как заданное входное значение было выбрано, тестировщику необходимо определить, каким будет ожидаемый результат ввода этого входа, и задокументировать его как часть тестового примера.\n\nДавайте проясним. Требования или пользовательские истории с критериями приемлемости (формы test basis) определяют, что вы должны тестировать (test objects and test conditions), и исходя из этого, вы должны выяснить способ тестирования, то есть спроектировать тестовые примеры. Один из наиболее важных вопросов заключается в следующем: какие факторы влияют на успешный дизайн теста? Если вы читаете разные блоги, статьи или книги, вы найдете примерно следующее:\n\n* Время и бюджет, доступные для тестирования;\n* Соответствующие знания и опыт вовлеченных людей;\n* Определен целевой уровень покрытия (измерение уровня достоверности (measuring the confidence level));\n* Способ организации процесса разработки программного обеспечения (например, водопад или гибкая разработка);\n* Устанавливается соотношение методов создания тестов (например, ручных и автоматических);\n\nЭто неправда! Без достаточного времени и бюджета вы, вероятно, вообще не начнете ни одного проекта. Если у вас нет квалифицированных специалистов по тестированию программного обеспечения, включая дизайн тестов, то, вероятно, вы тоже не начнете проект. Однако, хороший дизайн теста включает три предварительных условия:\n\n* Полная спецификация (Complete specification)(test bases);\n* Анализ рисков и сложности (Risk and complexity analysis);\n* Исторические данные ваших предыдущих разработок;\n\nТребуются некоторые пояснения. Полная спецификация не означает безошибочную спецификацию, так как во время разработки теста можно найти и исправить множество проблем (предотвращение дефектов). Это только означает, что у нас есть все необходимые требования или в Agile разработке у нас есть все эпики, темы и пользовательские истории с критериями приемлемости (acceptance criteria). Существует минимальная ценность в одновременном рассмотрении затрат на тестирование и затрат на исправление дефектов, и цель хорошего тест-дизайна - выбрать подходящие методы тестирования, приближающиеся к этому минимуму. Это можно сделать, проанализировав сложность, риски и используя исторические данные. Таким образом, анализ рисков неизбежен для определения тщательности тестирования. Чем выше риск использования функции / объекта, тем более тщательное тестирование необходимо. То же самое можно сказать и о сложности кода. Для более рискованного или сложного кода мы должны сначала применить больше НЕкомбинаторных методов проектирования тестов вместо одного чисто комбинаторного.\n\nНаше другое и правильное представление о дизайне тестирования состоит в том, что если у вас есть соответствующая спецификация (тестовая база) и надежный анализ рисков и сложности, то, зная ваши исторические данные, вы можете выполнить дизайн теста оптимальным образом. Вначале у вас нет исторических данных, и вы, вероятно, не достигнете оптимума. Нет проблем, давайте сделаем предварительную оценку. Например, если риск и сложность низкие, используйте только исследовательское тестирование. Если они немного выше, используйте исследовательское тестирование и простые методы, основанные на спецификациях, такие как классы эквивалентности с анализом граничных значений. Если риск высок, вы можете использовать исследовательское тестирование, комбинационное тестирование, предотвращение дефектов, статический анализ и обзоры (reviews).\n\nЕще одно важное замечание. Критерии выбора тестов и адекватности тестовых данных различны. Первый - неотъемлемая часть любой техники тест-дизайна. Второй проверяет набор тестов. В результате процесса разработки тестов создаются независимые от реализации тестовые примеры, которые проверяют требования или пользовательские истории. Напротив, тесты, которые создаются на основе отсутствия покрытия по выбранным критериям адекватности тестовых данных, подтверждают проблемы, зависящие от реализации; однако это НЕ дизайн теста, это создание теста. Очень важно использовать метод «сначала тестирование» (test-first method), т. е. дизайн теста должен быть отправной точкой разработки. Дизайн тестов также очень эффективен для предотвращения дефектов, если он применяется до внедрения.\n\nИтак, хороший **процесс тест-дизайна** выглядит так:\n\n* Сбор информации, чтобы понять требования пользователей;\n* Получение всех важных бизнес-сценариев;\n* Создание тестовых сценариев для каждого производного критически важного бизнес-сценария;\n* Назначение всех запланированных тестовых сценариев различным тестовым случаям;\n\nЗатем вам нужно будет выбрать технику тест-дизайна для каждого требования. На этом этапе, если все реализовано правильно, вы можете внести значительные изменения, которые чрезвычайно повлияют на ваш [ROI](https://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D1%83%D0%BF%D0%B0%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C\\_%D0%B8%D0%BD%D0%B2%D0%B5%D1%81%D1%82%D0%B8%D1%86%D0%B8%D0%B9).\n\n**Роли**, ответственные за тест дизайн:\n\n* **Тест аналитик** (test analyst) - определяет \"ЧТО тестировать?\":\n  * Исследует продукт:\n    * Понимание цели создания продукта;\n    * Какими способами цель должна достигаться;\n    * Какие и основные и вспомогательные возможности предоставляет продукт пользователям;\n    * Оценка, правильно ли понял разработчик заказчика.\n  * Составляет логическую карту продукта: Интеллект - карта - это техника представления любого процесса, события, мысли или идеи в систематизированной визуальной форме;\n  * Разбивает программный продукт на основные части:\n    * Система расчленяется только по одному, постоянному для всех уровней признаку (Они должны отвечать на один и тот же вопрос, по отношению к своему родителю);\n    * Вычленяемые подсистемы должны взаимно исключать друг друга, а в сумме - характеризовать систему;\n    * На каждом уровне рекомендуется использовать не более 7 подсистем;\n  * Расставляет приоритеты для тестирования:\n    * Требования клиента;\n    * Степень риска;\n    * Сложность системы;\n    * Временные ограничения;\n* **Тест дизайнер** - определяет \"КАК тестировать?\";\n\nПопросту говоря, задача тест аналитиков и дизайнеров сводится к тому, чтобы используя различные стратегии и техники тест дизайна, создать набор Test case, обеспечивающий оптимальное тестовое покрытие тестируемого приложения. Однако, на большинстве проектов эти роли не выделяется, а доверяется обычным тестировщикам, что не всегда положительно сказывается на качестве тестов, тестировании и, как из этого следует, на качестве ПО (конечного продукта).\n\n**Техники тест дизайна**\n\n• _Эквивалентное Разделение (Equivalence Partitioning — EP)_. Как пример, у вас есть диапазон допустимых значений от 1 до 10, вы должны выбрать одно верное значение внутри интервала, скажем, 5, и одно неверное значение вне интервала — 0.\n\n• _Анализ Граничных Значений (Boundary Value Analysis — BVA)_. Если взять пример выше, в качестве значений для позитивного тестирования выберем минимальную и максимальную границы (1 и 10), и значения больше и меньше границ (0 и 11). Анализ Граничный значений может быть применен к полям, записям, файлам, или к любого рода сущностям имеющим ограничения.\n\n• _Причина / Следствие (Cause/Effect — CE)_. Это, как правило, ввод комбинаций условий (причин), для получения ответа от системы (Следствие). Например, вы проверяете возможность добавлять клиента, используя определенную экранную форму. Для этого вам необходимо будет ввести несколько полей, таких как «Имя», «Адрес», «Номер Телефона» а затем, нажать кнопку «Добавить» — это «Причина». После нажатия кнопки «Добавить», система добавляет клиента в базу данных и показывает его номер на экране — это «Следствие».\n\n• _Предугадывание ошибки (Error Guessing — EG)_. Это когда тестировщик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы «предугадать» при каких входных условиях система может выдать ошибку. Например, спецификация говорит: «пользователь должен ввести код». Тестировщик будет думать: «Что, если я не введу код?», «Что, если я введу неправильный код? », и так далее. Это и есть предугадывание ошибки.\n\n• _Исчерпывающее тестирование (Exhaustive Testing — ET)_ — это крайний случай. В пределах этой техники вы должны проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике применение этого метода не представляется возможным, из-за огромного количества входных значений.\n\n• _Попарное тестирование (Pairwise Testing)_ — это техника формирования наборов тестовых данных. Сформулировать суть можно, например, вот так: формирование таких наборов данных, в которых каждое тестируемое значение каждого из проверяемых параметров хотя бы единожды сочетается с каждым тестируемым значением всех остальных проверяемых параметров.\n\nДопустим, какое-то значений (налог) для человека рассчитывается на основании его пола, возраста и наличия детей — получаем три входных параметра, для каждого из которых для тестов выбираем каким-то образом значения. Например: пол — мужской или женский; возраст — до 25, от 25 до 60, более 60; наличие детей — да или нет. Для проверки правильности расчётов можно, конечно, перебрать все комбинации значений всех параметров:\n\n№\tпол\tвозраст\tдети\n1\tмужчина\tдо 25\tдетей нет\n2\tженщина\tдо 25\tдетей нет\n3\tмужчина\t25-60\tдетей нет\n4\tженщина\t25-60\tдетей нет\n5\tмужчина\tстарше 60\tдетей нет\n6\tженщина\tстарше 60\tдетей нет\n7\tмужчина\tдо 25\tдети есть\n8\tженщина\tдо 25\tдети есть\n9\tмужчина\t25-60\tдети есть\n10\tженщина\t25-60\tдети есть\n11\tмужчина\tстарше 60\tдети есть\n12\tженщина\tстарше 60\tдети есть\nА можно решить, что нам не нужны сочетания значений всех параметров со всеми, а мы хотим только убедиться, что мы проверим все уникальные пары значений параметров. Т.е., например, с точки зрения параметров пола и возраста мы хотим убедиться, что мы точно проверим мужчину до 25, мужчину между 25 и 60, мужчину после 60, а также женщину до 25, женщину между 25 и 60, ну и женщину после 60. И точно так же для всех остальных пар параметров. И таким образом, мы можем получить гораздо меньше наборов значений (в них есть все пары значений, правда некоторые дважды):\n\n№\tпол\tвозраст\tдети\n1\tмужчина\tдо 25\tдетей нет\n2\tженщина\tдо 25\tдети есть\n3\tмужчина\t25-60\tдети есть\n4\tженщина\t25-60\tдетей нет\n5\tмужчина\tстарше 60\tдетей нет\n6\tженщина\tстарше 60\tдети есть\nТакой подход примерно и составляет суть техники pairwise testing — мы не проверяем все сочетания всех значений, но проверяем все пары значений.\n\n\n**Техники тест-дизайна (Software testing techniques)**\n\n* Cтатические (Static):\n  * Reviews:\n    * Неформальное ревью (Informal review)\n    * Прохождение (Walkthrough)\n    * Техническое ревью (Technical Review)\n    * Инспекция (Inspection)\n  * Статический анализ (Static Analysis):\n    * Поток данных (Data Flow)\n    * Поток управления (Control Flow)\n    * Путь (Path)\n    * Стандарты (Standards)\n* Динамические (Dynamic):\n  * Белый ящик (White-box, Structure-Based)\n    * Выражение (Statement)\n    * Решение (Decision)\n    * Ветвь (Branch)\n    * Условие (Condition)\n    * Конечный автомат (FSM)\n  * Основанные на опыте (Experience-based):\n    * Предугадывание ошибки (Error Guessing - EG);\n    * Исследовательское тестирование (Exploratory testing);\n    * Ad-hoc testing;\n    * [Attack ](https://www.softwaretestinggenius.com/anatomy-of-various-types-of-experience-based-testing-techniques/)Testing;\n  * Черный ящик (Black-box, Specification-based):\n    * Эквивалентное Разделение (Equivalence Partitioning - EP)\n    * Анализ Граничных Значений (Boundary Value Analysis - BVA)\n    * Комбинаторные техники ([Combinatorial Test Techniques](https://sysgears.com/articles/test-design-techniques-overview/#combinatorial))\n    * Переходы между состояниями (State transition)\n    * Случаи использования (Use case testing)\n    * Domain testing\n    * Decision Table Testing\n    * Classification Tree Method\n    * State Transition Testing\n    * Cause-Effect Graphing\n    * Scenario Testing\n    * Random Testing\n    * Syntax Testing\n    * Check List Based Testing\n    * Risk-Based Testing\n    * User Journey Test\n\n\n## Static - Reviews\n\n_Рецензирование (review): Оценка состояния продукта или проекта с целью установления расхождений с запланированными результатами и для выдвижения предложений по совершенствованию. Примерами рецензирования могут служить: управленческое рецензирование, неформальное рецензирование, технический анализ, инспекция и разбор. (ISTQB)_\n\n_Неформальное рецензирование (informal review): Рецензирование, которое не основано на формальной (документированной) процедуре. (ISTQB)_\n\n_Разбор (walkthrough): Пошаговый разбор, проводимый автором документа для сбора информации и обеспечения одинакового понимания содержания документа. (IEEE 1028)_\n\n_Равноправный анализ (peer review): Рецензирование разрабатываемого программного продукта, проводящееся сотрудниками компании-разработчика с целью нахождения дефектов и внесение улучшений. Примерами рецензирования являются: инспекция, технический анализ и разбор. (ISTQB)_\n\n_Инспекция (inspection): Тип равноправного анализа, основанный на визуальной проверке документов для поиска ошибок. Например, нарушение стандартов разработки и несоответствие документации более высокого уровня. Наиболее формальная методика рецензирования и поэтому всегда основывается на документированной процедуре. (IEEE 610, IEEE 1028). См. также равноправный анализ._\n\nМетоды статического тестирования делятся на две основные категории, одной из которых являются ревью. Ранжирование по уровню формальности:\n\n![https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/peer\\_review.jpg](https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/peer\\_review.jpg)\n\n### Экспертные обзоры (Peer Reviews): \nРецензирование - это стандартизированный метод проверки правильности исходного кода при разработке программного обеспечения, который проводится для выявления дефектов на ранних этапах жизненного цикла и которые не могут быть обнаружены с помощью методов тестирования черного ящика.\n\n### Прохождение/просмотр/пошаговый разбор (walkthrough ):\nМетод проведения неформального группового / индивидуального просмотра. В walkthrough автор описывает и объясняет рабочий продукт на неформальной встрече своим коллегам или руководителю, чтобы получить обратную связь. Здесь проверяется применимость предложенного решения для рабочего продукта. Либо рабочий продукт проверяется на наличие дефектов несколькими лицами, кроме человека, который его фактически произвел;\n\n### Технический обзор (Technical Review):\nЭто метод более высокого уровня по сравнению с inspection или walkthrough, поскольку он также включает в себя управление. Этот метод используется для оценки (assess and evaluate) продукта путем проверки его соответствия стандартам разработки, руководствам и спецификациям. У него нет определенного процесса, и большая часть работы выполняется модератором, как описано ниже:\n\n* Модератор собирает и раздает материал и документацию всем членам команды;\n* Модератор также готовит набор показателей для оценки продукта в соответствии со спецификациями и уже установленными стандартами и гайдлайнами:\n  * последовательность;\n  * документация;\n  * соблюдение стандартов;\n  * полнота;\n  * определение проблемы и требования (? problem definition and requirements);\n* Результаты фиксируются в документе, который включает как дефекты, так и предложения;\n* Наконец, устраняются дефекты и учитываются предложения по улучшению продукта;\n\n### Инспекция: \nИнспекция определяется как наиболее формальная, тщательная, глубокая групповая проверка, направленная на выявление проблем как можно ближе к их исходной точке. Процесс проверки выполняется на ранних этапах SDLC и применяется к определенной части продукта, такой как SRS, код, дизайн продукта. и т. д. Это включает в себя ручное изучение различных компонентов продукта на более ранних этапах. Инспекционная деятельность следует определенному процессу, и участники играют четко определенные роли. Инспекционная группа состоит из трех-восьми человек, которые играют роли модератора, автора, читателя, записывающего и инспектора. Например, разработчик может выступать в качестве инспектора во время проверки кода, в то время как представитель по обеспечению качества может действовать как исполнитель стандартов.\n\n**Software inspection process:**\n\n* Планирование встречи: на этом этапе основное внимание уделяется определению продукта, подлежащего инспекции, и цели этой инспекции. На этом этапе назначается модератор, который управляет всем процессом. Назначенный модератор проверяет, готов продукт к инспекции или нет. Модератор также выбирает инспекционную группу и назначает им их роли. Модератор также планирует инспекционную встречу и раздает необходимые материалы инспекционной группе;\n* Обзор: на этом этапе инспекционной группе предоставляется вся справочная информация для инспекционного совещания. Автор, который является программистом или дизайнером, ответственным за разработку продукта, представляет свою логику и рассуждения о продукте, включая функции продукта, его предполагаемое назначение и подход или концепцию, использованные при его разработке. Удостоверяется, что каждый член инспекционной группы понял и знаком с задачами и целью инспекционного совещания, которое должно быть проведено;\n* Индивидуальная подготовка участников: на этом этапе члены инспекционной группы индивидуально готовятся к инспекционной встрече, изучая материалы, предоставленные на более ранних этапах. Члены команды выявляют потенциальные ошибки или недочеты в продукте и записывают их в журнал. Журнал передается модератору. Затем модератор собирает все журналы, полученные от участников, и отправляет их автору. Инспектор - лицо, ответственное за проверку и выявление ошибок и несоответствий в документах или программах, проверяет продукт и записывает все обнаруженные в нем проблемы (как общие, так и специфические). Инспектор записывает проблемы или issues в журнал вместе со временем, затраченным на подготовку. Модератор просматривает логи, чтобы проверить, готова ли команда к инспекционной встрече или нет. Наконец, модератор отправляет автору все скомпилированные логи;\n* Инспекционная встреча (Inspection Meeting): на этом этапе автор обсуждает вопросы, поднятые членами команды в скомпилированном журнале. Участники приходят к решению, является ли поднятый вопрос ошибкой или нет. Модератор завершает встречу и подводит итоги встречи - это список ошибок, обнаруженных в продукте, которые должен устранить автор.\n* Переделка: доработка проводится автором согласно сводному списку, представленному модератором на предыдущем этапе. Автор исправляет все ошибки и сообщает модератору;\n* Follow - up: модератор проверяет, все ли ошибки устранены или нет. Затем модератор готовит отчет. Если все ошибки исправлены и устранены, модератор выпускает документ. В противном случае в отчет добавляются нерешенные вопросы и назначается еще одно инспекционное собрание;\n\n![](https://lh3.googleusercontent.com/3Zp7j69Y1F9v2cNbZ6e6xR128Uc9GOtuq-Y-Rl44fuWU6cPb8ZC6S1E\\_V2AGJf1LVjIRQ6r2S2YaOc1E6-3qZBV5x9P9K4nVkbfn4C75dbz\\_ePadqrjDLY1XYAQjBzWnbaf5a2\\_Q)\n\n## Static - Static Analysis\n\n_Статический анализ (static analysis): Анализ артефактов разработки программного обеспечения, таких как требования или программный код, проводимый без исполнения этих программных артефактов. Статический анализ обычно выполняется при помощи вспомогательных инструментов. (ISTQB)_\n\nСтатический анализ - это анализ программных артефактов, таких как программный код (или требования, дизайн), выполняемый статически, т.е. без запуска и, очевидно, методом белого ящика. Основная цель этого анализа - как можно раньше найти ошибки, независимо от того, могут ли они вызывать отказы (failures). Как и в случае с обзорами (reviews), статический анализ обнаруживает ошибки (bugs), а не отказы. Обычно статический анализ проводят до формальной проверки, даже до unit testing, путём добавления этих проверок специалистами DevOps в пайплайн проекта. Статический анализ не связан с динамическими свойствами требований, дизайна и кода, такими как покрытие тестами (test coverage). Существует множество инструментов для статического анализа, которые в основном используются разработчиками до или во время тестирования компонентов или интеграции (чаще новые и измененные классы и функции), а также дизайнерами во время моделирования программного обеспечения. Инструменты могут отображать не только структурные атрибуты, такие как глубина вложенности или число цикломатической сложности и проверка на соответствие стандартам кодирования, но также графические изображения потока управления, взаимосвязи данных и количество отдельных путей от одной строки кода к другой. Информация может использоваться вплоть до формальных методов, которые математически подтверждают свойства данной программы.\n\n**Инструменты помогают в выявлении следующих дефектов:**\n\n* Неиспользуемые переменные;\n* Части кода, которые никогда не выполнятся;\n* Бесконечные циклы;\n* Переменная с неопределенным значением;\n* Неправильный синтаксис;\n* Несогласованные интерфейсы между модулями и компонентами, такие как неправильное использование объекта, метода или функции, включая неправильные параметры;\n* Уязвимости безопасности, такие как проблемы безопасности, связанные с переполнением буфера, возникающим из-за невозможности проверить длину буфера перед копированием в буфер;\n* Различные типы нарушения стандартов программирования, как нарушения, создающие риск фактического сбоя, так и нарушения, которые усложняют тестирование, анализ и поддерживаемость кода;\n\n**Методы статического анализа**:\n\n### Анализ управления (Control Analysis)\n\nФокусируется на изучении элементов управления, используемых в структуре вызовов, анализе потока управления и анализе переходов состояний (calling structure, control flow analysis and state transition analysis). Структура вызова связана с моделью путем идентификации вызовов и их структуры. Вызывающая структура может быть процессом, подпрограммой, функцией или методом. Анализ потока управления проверяет последовательность передачи управления и может выявить неэффективные конструкции в модели. Создается граф модели (CFG - Control Flow Graph), в котором условные ветви и стыки модели представлены узлами. По итогам также можно рассчитать цикломатическую сложность программы. Для анализа потока управления [могут быть](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7\\_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0\\_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F#:\\~:text=%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-,%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D0%B1%D1%8B%D1%82%D1%8C,-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D1%8B%3A%20%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%B5%D1%80%D1%82%D0%B0%D1%86%D0%B8%D1%8F) использованы: Абстрактная интерпретация, Удовлетворение ограничений, Типизация данных;\n\n### Анализ данных (Data Analysis)\n\nОбеспечивает правильную работу с объектами данных, такими как структуры данных и связанные списки. Кроме того, этот метод также обеспечивает правильное использование определенных данных. Анализ данных включает два метода, а именно: зависимость данных и анализ потока данных (data dependency and data flow analysis). Зависимость данных необходима для оценки точности синхронизации между несколькими процессорами. Анализ потока данных проверяет определение и контекст переменных. Виды анализа потока данных:\n  * Reaching Definitions;\n  * Available Expressions;\n  * Constant Propagation;\n  * Very Busy Expressions;\n  * Live Variables;\n  * Use-Definition & Definition-Use;\n* Анализ неисправностей / отказов (Fault/Failure Analysis): анализирует неисправности (некорректный компонент) и отказ (некорректное поведение компонента модели) в модели. Этот метод использует описание преобразования ввода-вывода для определения условий, являющихся причиной сбоя. Для определения отказов в определенных условиях проверяется проектная спецификация модели (model design specification);\n* Анализ интерфейса (Interface Analysis): проверяет взаимодействующие и распределенные модели для проверки кода (This software verifies and verifies interactive and distribution simulations to check the code). Существует два основных метода анализа интерфейса, и анализ пользовательского интерфейса исследует интерфейсы подмоделей и определяет точность структуры интерфейса. Анализ пользовательского интерфейса исследует модель пользовательского интерфейса и меры предосторожности, предпринимаемые для предотвращения ошибок во время взаимодействия пользователя с моделью. Этот метод также фокусируется на том, насколько точно интерфейс интегрирован в общую модель и симуляцию.\n\nАнализ потока управления (Control Flow Analysis) и анализ потока данных (Data Flow Analysis) взаимозависимы: чтобы получить точные результаты для анализа потока данных, необходимо учитывать поток управления (поскольку порядок операций влияет на возможные значения данных в конкретном месте программы). Чтобы получить точные результаты для анализа потока управления, необходимо учитывать поток данных, поскольку поток динамического управления (решение, принимаемое во время выполнения) зависит от значений данных в конкретных местах программы. Однако эти два анализа преследуют разные цели.\n\n### Граф потока управления (Control Flow Graph)\n\nГраф потока управления (CFG) - это графическое представление потока управления или вычислений во время выполнения программ или приложений. Графы потока управления в основном используются в статическом анализе, а также в приложениях-компиляторах, поскольку они могут точно представлять поток внутри программного модуля. Характеристики графа потока управления:\n\n* Граф потока управления процессно-ориентированный (process oriented);\n* Граф потока управления показывает все пути, которые можно пройти во время выполнения программы;\n* Граф потока управления - это [ориентированный](https://ru.wikipedia.org/wiki/%D0%9E%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9\\_%D0%B3%D1%80%D0%B0%D1%84) граф;\n* Рёбра в CFG изображают пути потока управления, а узлы в CFG изображают базовые блоки.\n\n[Полное описание возможных элементов графа](https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84\\_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0\\_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F).\n\n### Цикломатическая сложность (Cyclomatic Complexity)\n\nЦикломатическая сложность - это метрика для измерения сложности кода, основанная на графе потока управления. Независимый путь определяется как путь, имеющий хотя бы одно ребро, которое ранее не проходило ни в одном другом пути.\n\nОпределение из книги Ли Копланда - “A Practitioner's Guide to Software Test Design”, Главы 10:\n\nЦикломатическая сложность​ - это конечное минимальное количество независимых, нецикличных маршрутов (называемых основными маршрутами), которые могут образовывать все возможные линейные пути в программном модуле.\n\nЦикломатическая сложность может быть рассчитана относительно функций, модулей, методов или классов в программе как вручную, так и с помощью автоматизированных инструментов.\n\nМатематически цикломатическая сложность структурированной программы определяется с помощью ориентированного графа, узлами которого являются блоки программы, соединенные ребрами, если управление может переходить с одного блока на другой. Тогда сложность определяется как\n\n_M = E − N + 2P_,\n\nгде:\n\n* M = цикломатическая сложность,\n* E = количество ребер в графе,\n* N = количество узлов в графе,\n* P = количество компонент связности.\n\nВ другой формулировке используется граф, в котором каждая точка выхода соединена с точкой входа. В этом случае граф является сильносвязным, и цикломатическая сложность программы равна цикломатическому числу этого графа (также известному как первое число Бетти), которое определяется как\n\n_M = E − N + P_.\n\nЭто определение может рассматриваться как вычисление числа линейно независимых циклов, которые существуют в графе, то есть тех циклов, которые не содержат в себе других циклов. Так как каждая точка выхода соединена с точкой входа, то существует по крайней мере один цикл для каждой точки выхода.\n\nДля простой программы, или подпрограммы, или метода P всегда равно 1. Однако цикломатическая сложность может применяться к нескольким таким программам или подпрограммам (например, ко всем методам в классе), в таком случае P равно числу подпрограмм, о которых идет речь, так как каждая подпрограмма может быть представлена как независимая часть графа.\n\nМожет быть показано, что цикломатическая сложность любой структурированной программы с только одной точкой входа и одной точкой выхода эквивалентна числу точек ветвления (то есть, операторов if или условных циклов), содержащихся в этой программе, плюс один.\n\nЦикломатическая сложность может быть распространена на программу с многочисленными точками выхода; в этом случае она равна\n\n_π − s + 2_,\n\nгде:\n\n* π - число точек ветвления в программе,\n* s - число точек выхода.\n\nПрименение:\n\n* Ограничение сложности при разработке: одно из первоначально предложенных Маккейбом применений состоит в том, что необходимо ограничивать сложность программ во время их разработки. Он рекомендует, чтобы программистов обязывали вычислять сложность разрабатываемых ими модулей и разделять модули на более мелкие всякий раз, когда цикломатическая сложность этих модулей превысит 10. Эта практика была включена НИСТ-ом в методику структурного тестирования с замечанием, что со времени исходной публикации Маккейба выбор значения 10 получил весомые подтверждения, однако в некоторых случаях может быть целесообразно ослабить ограничение и разрешить модули со сложностью до 15. В данной методике признается, что иногда могут существовать причины для выхода за рамки согласованного лимита. Это сформулировано как рекомендация: «Для каждого модуля следует либо ограничивать цикломатическую сложность до согласованных пределов, либо предоставить письменное объяснение того, почему лимит был превышен»;\n* Применение при тестировании программного обеспечения: определение количества тестов, необходимых для полного покрытия кода. Цикломатическая сложность M имеет два свойства, для конкретного модуля:\n  * M - оценка сверху для количества тестов, обеспечивающих покрытие условий (точек ветвления);\n  * M - оценка снизу для количества маршрутов через граф потока управления и, таким образом, количества тестов для полного покрытия путей.\n* В составе других метрик: используется в качестве одного из параметров в индексе удобства сопровождения (англ. maintainability index).\n\n## Dynamic - White box\n\n_Разработка тестов методом белого ящика (white-box test design technique): Процедура разработки или выбора тестовых сценариев на основании анализа внутренней структуры компонента или системы. (ISTQB)_\n\n_Основанные на структуре методы проектирования тестирования используются для получения контрольных примеров из структурной характеристики, например структуры исходного кода или структуры меню. Если эти методы применяются к исходному коду приложения, то ожидаемые результаты для контрольных примеров получаются из базиса тестирования. Выбор, какие из основанных на структуре методов проектирования тестирования использовать в каждом конкретном случае, зависит от природы базиса тестирования и от присущих рисков. (ГОСТ 56920)_\n\n_Поток данных (data flow): Абстрактное представление последовательности и возможных изменений состояния объектов данных, при котором состояние объекта это: создание, использование либо уничтожение. (Beizer)_\n\n_Поток управления (control flow): Последовательность событий (путей) в процессе выполнения компонента или системы. (ISTQB)_\n\n**Динамическое тестирование методом белого ящика** - это стратегия, основанная на внутренних путях, структуре и реализации тестируемого программного обеспечения. Тесты здесь выполняются динамически, т.е. с запуском объекта тестирования и основаны на различных видах покрытии кода (путей исполнения программы).\n\nГлобально основных техник динамического тестирования методом белого ящика всего две:\n\n- **Тестирование потока управления** (Control Flow Testing);\n- **Тестирование потока данных** (Data Flow Testing).\n\nФактически, это динамическая часть одного цельного тестирования, статическая часть которого - анализ и построение графа, описывается в предыдущей теме про статический анализ, а на этом определяется целевое покрытие (Coverage Target), создаются соответствующие тест-кейсы, тесты исполняются и результаты выполнения тестов анализируются.\n\n### Уровни тестового покрытия в тестировании потока управления (Control Flow Testing)\n\nПод “покрытием\" имеется в виду отношение объема кода, который уже был проверен, к объему, который осталось проверить. В тестировании потока управления покрытие определяется в виде нескольких различных уровней. Заметим, что эти уровни покрытия представлены не по порядку. Это потому, что в некоторых случаях проще определить более высокий уровень покрытия, а затем определить более низкий уровень покрытия в условиях высокого.\n\n1. **100% покрытие операторов** (Statement/node coverage). Оператор (statement) - это сущность языка программирования, обычно являющаяся минимальным неделимым исполняемым блоком (ISTQB). Покрытие операторов - это метод проектирования тестов методом белого ящика, который включает в себя выполнение всех исполняемых операторов (if, for и switch) в исходном коде как минимум один раз. Процентное отношение операторов, исполняемых набором тестов, к их общему количеству является метрикой покрытия операторов. Борис Бейзер написал: \"тестирование, меньшее чем это (100% покрытие операторов), для нового программного обеспечения является недобросовестным и должно быть признано преступлением. …”. Несмотря на то, что это может показаться разумной идеей, на таком уровне покрытия может быть пропущено много дефектов и затруднен анализ покрытия некоторых управляющих структур. Покрытие операторов позволяет найти:\n\n* Неиспользованные выражения (Unused Statements);\n* Мертвый код (Dead Code);\n* Неиспользуемые ветви (Unused Branches);\n* Недостающие операторы (Missing Statements);\n\n2. **100% покрытие альтернатив/ветвей** (Decision/branch/all-edges/basis path/DC/C2/ decision-decision-path/edge coverage). «Решение» - это программная точка, в которой control flow имеет два или более альтернативных маршрута (ветви). На этом уровне достаточно такого набора тестов, в котором каждый узел с ветвлением (альтернатива), имеющий TRUE или FALSE на выходе, выполняется как минимум один раз, таким образом, для покрытия по веткам требуется как минимум два тестовых примера. На данном уровне не учитываются логические выражения, значения компонент которых получаются вызовом функций. В отличие от предыдущего уровня покрытия данный метод учитывает покрытие условных операторов с пустыми ветками. Покрытие альтернатив не гарантирует покрытие всех путей, но при этом гарантирует покрытие всех операторов;\n\nДля более полного анализа компонент условий в логических операторах существуют следующие три метода, учитывающих структуру компонент условий и значения, которые они принимают при выполнении тестовых примеров.\n\n3. **100% покрытие условий** (Condition/Toggle Coverage). Рассматриваются только выражения с логическими операндами, например, AND, OR, XOR. На этом уровне достаточно такого набора тест-кейсов, в котором каждое условие, имеющее TRUE и FALSE на выходе, выполнено как минимум один раз. Покрытие условий обеспечивает лучшую чувствительность к control flow, чем decision coverage. Для обеспечения полного покрытия по данному методу каждая компонента логического условия в результате выполнения тестовых примеров должна принимать все возможные значения, но при этом не требуется, чтобы само логическое условие принимало все возможные значения, т.е. Condition Coverage не дает гарантии полного decision coverage;\n\n4. **100% покрытие условий + альтернатив** (Decision + Condition coverage). На этом уровне тест-кейсы создаются для каждого условия и для каждой альтернативы, т.е. данный метод сочетает требования предыдущих двух методов - для обеспечения полного покрытия необходимо, чтобы как логическое условие, так и каждая его компонента приняла все возможные значения;\n\n5. **100% покрытия множественный условий** (Multiple condition coverage). Для выявления неверно заданных логических функций был предложен метод покрытия по всем условиям. При данном методе покрытия должны быть проверены все возможные наборы значений компонент логических условий: условий, альтернатив и условий/альтернатив. Т.е. в случае n компонент потребуется 2^n тестовых примеров, каждый из которых проверяет один набор значений. Тесты, необходимые для полного покрытия по данному методу, дают полную таблицу истинности для логического выражения. Несмотря на очевидную полноту системы тестов, обеспечивающей этот уровень покрытия, данный метод редко применяется на практике в связи с его сложностью и избыточностью. Еще одним недостатком метода является зависимость количества тестовых примеров от структуры логического выражения. Кроме того, покрытие множественных условий не гарантирует покрытие всех путей;\n\n6. **Покрытие бесконечного числа путей**. Если, в случае зацикливания, количество путей становится бесконечным, то имеет смысл существенно их сократить, ограничив количество циклов выполнения, что позволит уменьшить количество тестовых случаев. Первый вариант - не выполнять цикл совсем; второй - выполнить цикл один раз; третий - выполнить цикл n раз, где n - это небольшое значение, представляющее символическое количество повторений цикла; четвертый - выполнить цикл m раз, где m - максимальное количество повторений цикла. Кроме того, можно выполнить цикл m-1 и m+1 раз. Перед тем, как начинать тестирование потока управления, должен быть выбран соответствующий уровень покрытия;\n\n7. **100% покрытие путей** (Path coverage). Проверяет каждый линейно независимый путь в программе, что означает, что число тестовых примеров будет эквивалентно цикломатической сложности программы. Для кода модулей без циклов количество путей, как правило, достаточно мало, поэтому на самом деле можно построить тест-кейсы для каждого пути. Для модулей с циклами количество путей может быть огромным, что представляет неразрешимую проблему тестирования.\n\nПуть на самом деле является направлением, потоком выполнения, который следует за последовательностью инструкций. Он охватывает функцию от входа до точки выхода. Он охватывает statement, branch/decision coverage. Покрытие пути можно понять в следующих терминах:\n\n* **Loop coverage**: используется для проверки того, что все циклы были выполнены и сколько раз они были выполнены. Цель этого метода покрытия - убедиться, что циклы соответствуют предписанным условиям и не повторяются бесконечно и не завершаются ненормально. Цикл тестирования направлен на мониторинг от начала до конца цикла. Ценным аспектом этой метрики является определение того, выполняются ли циклы while и for более одного раза, т.к. эта информация не сообщается другими метриками;\n* **Function coverage**: показывает, вызывали ли вы каждую функцию или процедуру;\n* **Call coverage**: показывает, выполняли ли вы каждый вызов функции. Гипотеза состоит в том, что ошибки обычно возникают в интерфейсах между модулями (вызывающая функция и вызываемая функция). Также известен как покрытие пары вызовов (call pair coverage);\n\n7 вышеперечисленных уровней описываются в книге Копленда “A Practitioner's Guide to Software Test Design”, но можно найти и другие\n\n**FSM coverage (Finite State Machine Coverage)**\n\nКонечные автоматы (FSM) имеют конечное число состояний, условий, которые приводят к внутренним переходам между состояниями, и соответствующее поведение ПО в каждом состоянии автомата. Автомат обычно моделирует поведение управляющей логики.\n\nПокрытие FSM - покрытие конечного автомата, безусловно, является наиболее сложным методом покрытия кода. В этом методе покрытия вам нужно посмотреть, как много было переходов/посещений определенных по времени состояний (time-specific states). Оно также проверяет, сколько последовательностей включено в конечный автомат. Конечные автоматы могут иметь множество ветвей и несколько функциональных путей, а также любой скрытый путь (функциональный путь, пропущенный при проверке, или путь, непреднамеренно введенный на этапе реализации) в дизайне может вызвать серьезное нарушение функциональности, а также может создать тупик (система не может самостоятельно выйти из определенного состояния, даже если намеченный стимул присутствует).\n\n**Basis Path testing**\n\nЦель тестирования базового пути - в отличии от D-D Path (Decision-to-decision path) получить полное покрытие тех путей, которые находятся между точками принятия решений (decisions points) с высоким бизнес-риском и высокой бизнес-ценностью, т.к. проверять все возможные пути обходится слишком дорого. Это гибрид branch testing и path testing\n\n**LCSAJ coverage**\n\n_LCSAJ (LCSAJ): Последовательность линейного кода с переходами, состоящая из трех элементов (условно определяемая номерами строк исходного кода):_\n\n* _начало линейной последовательности выполняемых операторов_\n* _конец линейной последовательности_\n* _целевая строка кода, получающая управление после конца линейной последовательности_\n\n_(ISTQB)_\n\nLCSAJ (linear code sequence and jump) «линейная последовательность кода и переход». Каждый LCSAJ представляет собой сегмент кода, который выполняется последовательно от начальной точки до конечной точки, а затем прерывает последовательный поток для передачи потока управления. Каждая строка кода имеет плотность (density), то есть количество раз, когда номер строки появляется в LCSAJ.\n\nОдин LCSAJ состоит из трех компонентов:\n\n* Начало сегмента, который может быть ветвью или началом программы;\n* Конец сегмента, который может быть концом ветви или концом программы;\n* Конкретная целевая линия;\n\nЕго основное применение при динамическом анализе программного обеспечения, чтобы помочь ответить на вопрос «Сколько тестирования достаточно?». Динамический анализ программного обеспечения используются для измерения качества и эффективности тестовых данных программного обеспечения, где количественное определение выполняются в терминах структурных единиц кода при тестировании. В более узком смысле, LCSAJ является хорошо определенным линейным участком кода программы. При использовании в этом смысле, LCSAJ также называют JJ-путь (jump-to-jump path). 100% LCSAJ означает 100% Statement Coverage, 100% Branch Coverage, 100% procedure или Function call Coverage, 100% Multiple condition Coverage (в ISTQB говорится только о 100% Decision coverage).\n\nОпределенные метрики используются для проверки покрытия кода. Эти показатели могут помочь нам определить, достаточно ли тестирования или нет. Эти показатели называются коэффициентом эффективности тестирования (TER - Test Effectiveness Ratio):\n\n* TER-1: количество операторов, выполненных с помощью тестовых данных, деленное на общее количество операторов;\n* TER-2: количество ветвей потока управления, выполненных тестовыми данными, деленное на общее количество ветвей потока управления;\n* TER-3: количество LCSAJ, выполненных тестовыми данными, деленное на общее количество LCSAJ;\n\nИсследователи ссылаются на коэффициент покрытия путей длиной n LCSAJ как на коэффициент эффективности теста (TER) n + 2.\n\n### Data Flow Testing\n\nТестирование потока данных - это еще один набор методов / стратегий белого ящика, который связан с анализом потока управления, но с точки зрения жизненного цикла переменной. Переменные определяются, используются и уничтожаются, когда в них больше нет необходимости. Аномалии в этом процессе, такие как использование переменной без ее определения или после ее уничтожения, могут привести к ошибке. Рапс и Вьюкер, популяризаторы данного метода, писали: \"Мы уверены, что, как нельзя чувствовать себя уверенным в программе без выполнения каждого ее оператора в рамках какого-то тестирования, так же не следует быть уверенным в программе без видения результатов использования значений, полученных от любого и каждого из вычислений\".\n\nКогда «поток данных» через информационную систему представлен графически, он известен как диаграмма потока данных (Data Flow Diagram). Она также используется для визуализации обработки данных. Но не нужно путать это с графом потока данных (Data Flow Graph), который используется в Data Flow Testing. Граф потока данных похож на граф потока управления тем, что показывает поток обработки через модуль. Дополнительно к этому, он детализирует определение, использование и уничтожение каждой из переменных модуля. Мы построим эти диаграммы и убедимся, что шаблоны определение-использование-уничтожение являются подходящими. Сначала мы проведем статический анализ. Под \"статическим\" мы имеем в виду, что мы исследуем диаграмму (формально через проверки или неформально беглыми просмотрами). Потом мы проведем динамические тесты модуля. Под \"динамическими\" мы понимаем, что мы создаем и исполняем тестовые сценарии.\n\nТак как тестирование потока данных основано на потоке управления модуля, то, предположительно, поток управления в основном верный. Процесс тестирования потока данных сводится к выбору достаточного количества тестов, таких как:\n\n* каждое \"определение\" прослеживается для каждого его \"использования\";\n* каждое \"использование\" прослеживается из соответствующего ему \"определения\";\n\nЧтобы сделать это, перечислим маршруты в модуле. Порядок выполнения такой же, как и в случае с тестированием потока управления: начинаем с точки входа в модуль, строим самый левый маршрут через весь модуль и заканчиваем на выходе из него. Возвращаемся в начало и идём по другому направлению в первом разветвлении. Прокладываем этот путь до конца. Возвращаемся в начало и идём по другому направлению во втором разветвлении, потом в третьем и т.д., пока не пройдем все возможные пути. Затем создадим хотя бы один тест для каждой переменной, чтобы покрыть каждую пару определение-использование.\n\nСуществуют условные обозначения, которые могут помочь в описании последовательных во времени пар в жизненном цикле переменной:\n\n* \\~ - переменная еще не существует или предыдущий этап был последним\n* d - определено, создано, инициализировано\n* k - не определено, убито\n* u - используется (c - использование вычислений; p - использование предикатов)\n\nТаким образом, \\~ d, du, kd, ud, uk, uu, k \\~, u \\~ являются вполне допустимыми комбинациями, когда \\~ u, \\~ k, dd, dk, kk, ku, d \\~ являются аномалиями, потенциальными или явными ошибками. В настоящее время практически все они эффективно обнаруживаются компиляторами или, по крайней мере, IDE, и нам редко требуется выполнять статический анализ для обнаружения этих аномалий. То же самое относится и к динамическому анализу, который сфокусирован на исследовании / выполнении du пар - современные языки программирования снижают вероятность возникновения проблем, связанных с du. Так что в настоящее время такая проверка в основном не стоит усилий.\n\n\n## Dynamic - Black box\n\n_Разработка тестов методом черного ящика (black box test design technique): Процедура создания и/или выбора тестовых сценариев, основанная на анализе функциональной или нефункциональной спецификации компонента или системы без знания внутренней структуры. (ISTQB)_\n\n_Основанные на спецификации методы проектирования тестирования используются для получения контрольных примеров из базиса тестирования, определяющего ожидаемое поведение элемента тестирования. При использовании этих методов входные данные для тестирования контрольного примера и ожидаемый результат получаются из базиса тестирования. Выбор, какие из основанных на спецификации методов проектирования тестирования использовать в каждой конкретной ситуации, зависит от природы базиса тестирования и/или элемента тестирования, и от присущих рисков. (ГОСТ 56920)_\n\nВсе specification-based или Black Box testing techniques могут быть удобно описаны и систематизированы с помощью следующей таблицы:\n\n| **Группа**                                                                                                                                                                                                                                                                                                                                  | **Техника**                                                                                                                                                         | **Когда используется**                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| <p>Элементарные техники:</p><ul><li>сосредоточены на анализе входных / выходных параметров;</li><li>можно комбинировать для лучшего покрытия;</li><li>обычно не используют и не зависят от других методик;</li></ul>                                                                                                                        | Equivalence Partitioning                                                                                                                                            | Входные и выходные параметры имеют большое количество возможных значений                                                                                       |\n| Boundary Value Analysis                                                                                                                                                                                                                                                                                                                     | Значения параметров имеют явные (например, четко определенные в документации) границы и диапазоны или неявные (например, известные технические ограничения) границы |                                                                                                                                                                |\n| <p>Комбинаторные стратегии:</p><ul><li>объединяют возможные значения нескольких параметров ввода / вывода;</li><li>могут использовать элементарные приемы для уменьшения количества возможных значений;</li></ul>                                                                                                                           | All Combinations                                                                                                                                                    | Количество возможных комбинаций входных значений достаточно мало, или каждая отдельная комбинация входных значений приводит к определенному выходному значению |\n| Pairwise Testing                                                                                                                                                                                                                                                                                                                            | Количество входных комбинаций чрезвычайно велико и должно быть сокращено до приемлемого набора кейсов                                                               |                                                                                                                                                                |\n| Each Choice Testing                                                                                                                                                                                                                                                                                                                         | У вас есть функции, при которых скорее конкретное значение параметра вызывает ошибку, нежели комбинация значений                                                    |                                                                                                                                                                |\n| Base Choice Testing                                                                                                                                                                                                                                                                                                                         | Вы можете выделить набор значений параметров, который имеет наибольшую вероятность использования                                                                    |                                                                                                                                                                |\n| <p>Продвинутые техники:</p><ul><li>помогают проанализировать Систему с точки зрения бизнес-логики, иерархических отношений, сценариев и т. д.;</li><li>анализ основан на данных, организованных в таблицы, диаграммы и шаблоны;</li><li>может полагаться на элементарные и комбинаторные методы для разработки тестовых примеров;</li></ul> | Decision Table Testing                                                                                                                                              | Существует набор комбинаций параметров и их выходных данных, описываемых бизнес-логикой или другими правилами                                                  |\n| Classification Tree Method                                                                                                                                                                                                                                                                                                                  | У вас есть иерархически структурированные данные, или данные могут быть представлены в виде иерархического дерева                                                   |                                                                                                                                                                |\n| State Transition Testing                                                                                                                                                                                                                                                                                                                    | В функциональности есть очевидные состояния, переходы которых регулируются правилами (например, потоки)                                                             |                                                                                                                                                                |\n| Cause-Effect Graphing                                                                                                                                                                                                                                                                                                                       | Причины (входы) и следствия (выходы) связаны большим количеством сложных логических зависимостей                                                                    |                                                                                                                                                                |\n| Scenario Testing                                                                                                                                                                                                                                                                                                                            | В функционале есть четкие сценарии                                                                                                                                  |                                                                                                                                                                |\n| Другие техники                                                                                                                                                                                                                                                                                                                              | Random Testing                                                                                                                                                      | Вам необходимо имитировать непредсказуемость реальных вводных данных, или функциональность имеет несистематические дефекты                                     |\n| Syntax Testing                                                                                                                                                                                                                                                                                                                              | Функциональность имеет сложный синтаксический формат для входных данных (например, коды, сложные имена электронной почты и т. д.)                                   |                                                                                                                                                                |\n\n### Эквивалентное разделение (Equivalence Partitioning (ISTQB/Myers 1979) / Equivalence Class Testing (Lee Copeland))\n\nКласс эквивалентности представляет собой набор данных, которые либо одинаково обрабатываются модулем, либо их обработка выдает одинаковые результаты. При тестировании любое значение данных, входящее в класс эквивалентности, аналогично любому иному значению класса.\n\nЭквивалентное разделение - это разделение всего набора данных ввода / вывода на такие разделы. Таким образом, вам не нужно выполнять тесты для каждого элемента подмножества, и достаточно одной проверки, чтобы охватить все подмножество. Хитрость заключается в том, чтобы увидеть и идентифицировать разделы, т.к. далеко не всегда они представляют собой числа.\n\nПример: Мы пишем модуль для системы отдела кадров, который определяет, в каком порядке нужно рассматривать заявления о приеме на работу в зависимости от возраста кандидата.\n\nПравила нашей организации таковы:\n\n* от 0 до 16​ - не принимаются;\n* от 16 до 18​ - могут быть приняты только на неполный рабочий день;\n* от 18 до 55​ - могут быть приняты как сотрудники на полный рабочий день;\n* от 55 до 99​ - не принимаются;\n\nЧто в коде выглядит как:\n\n* If (applicantAge >= 0 && applicantAge <=16)\n  * hireStatus=\"NO\";\n* If (applicantAge >= 16 && applicantAge <=18)\n  * hireStatus=\"PART\";\n* If (applicantAge >= 18 && applicantAge <=55)\n  * hireStatus=\"FULL\";\n* If (applicantAge >= 55 && applicantAge <=90)\n  * hireStatus=\"NO\";\n\nИз чего очевидно, что вместо 100 кейсов нам понадобится 4 по числу эквивалентных классов, все остальные кейсы внутри своих классов будут давать одинаковый результат тестов и являются избыточными.\n\nТеперь мы готовы начать тестирование? Вероятно, нет. Что насчет таких входных данных как 969, -42, FRED или &$#! ? Должны ли мы создавать тестовые сценарии для некорректных входных данных? Для того, чтобы понять ответ, мы должны проверить подход, который пришел из объектно-ориентированного мира, названный \"проектирование-по-контракту\".\n\nВ подходе \"проектирование-по-контракту\" модули (в парадигме объектно-ориентированного программирования они называются \"методами\", но \"модуль\" является более общим термином) определены в терминах предусловий и постусловий. Постусловия определяют, что модуль обещает сделать (вычислить значение, открыть файл, напечатать отчет, обновить запись в базе данных, изменить состояние системы и т.д.). Предусловия описывают требования к модулю, при которых он переходит в состояние, описываемое постусловиями.\n\nНапример, если у нас есть модуль \"openFile\", что он обещает сделать? Открыть файл. Какие будут разумные предусловия для этого модуля?\n\n* файл должен существовать,\n* мы должны предоставить имя (или другую идентифицирующую информацию),\n* файл должен быть \"открываемым\", т.е. он не может быть открытым в другом процессе,\n* у нас должны быть права доступа к файлу и т.д.\n\nПредусловия и постусловия основывают контракт между модулем и всеми, кто его вызывает. Тестирование-по-контракту основывается на философии проектирования-по-контракту. При использовании данного подхода мы создаем только те тест-кейсы, которые удовлетворяют нашим предусловиям. Например, мы не будем тестировать модуль \"openFile\", если файл не существует. Причина проста. Если файл не существует, то openFile не обещает работать. Если не существует требования работоспособности в определенных условиях, то нет необходимости проводить тестирование в этих условиях.\n\nВ этот момент тестировщики обычно возражают. Да, они согласны, что модуль не претендует на работу в этом случае, но что делать, если предусловия нарушаются в процессе разработки? Что делать системе? Должны ли мы получить сообщение об ошибке на экране или дымящуюся воронку на месте нашей компании? Другим подходом к проектированию является оборонительное проектирование. В этом случае модуль предназначен для приема любого входного значения. Если выполнены обычные предусловия, то модуль достигнет своих обычных постусловий. Если обычные предварительные условия не выполняются, то модуль сообщит вызывающему, возвратив код ошибки или бросив исключение (в зависимости от используемого языка программирования). На самом деле, это уведомление является еще одним из постусловий модуля.\n\nНа основе этого подхода мы могли бы определить оборонительное тестирование: подход, который анализирует как обычные, так и необычные предварительные условия.\n\nНужно ли нам делать проверку с такими входными значениями, как -42, FRED и &$#! @? Если мы используем проектирование-по-контракту и тестирование-по-контракту, то ответ \"Нет\". Если мы используем оборонительное проектирование и, поэтому, оборонительное тестирование, то ответ \"Да\". Спросите ваших проектировщиков, какой подход они используют. Если их ответом будет «контрактный» либо «оборонительный», то вы знаете, какой стиль тестирования использовать. Если они ответят \"Хм?\", то это значит, что они не думают о том, как взаимодействуют модули. Они не думают о предусловиях и постусловиях контрактов. Вам стоит ожидать, что интеграционное тестирование будет главным источником дефектов, будет более сложным и потребует больше времени, чем ожидалось.\n\nНесмотря на то, что тестирование классов эквивалентности полезно, его величайшим вкладом является то, что оно приводит нас к тестированию граничных значений.\n\n### Анализ граничных значений (BVA - Boundary Value Analysis (Myers 1979)/range checking)\n\nТестирование классов эквивалентности - это самая основная методика тест-дизайна. Она помогает тестировщикам выбрать небольшое подмножество из всех возможных тестовых сценариев и при этом обеспечить приемлемое покрытие. У этой техники есть еще один плюс. Она приводит к идее о тестировании граничных значений - второй ключевой технике тест-дизайна.\n\nПример. Выше описывались правила, которые указывали, каким образом будет происходить обработка заявок на вакансии в зависимости от возраста соискателя.\n\nОбратите внимание на проблемы на границах - это \"края\" каждого класса. Возраст \"16\" входит в два различных класса эквивалентности (как и \"18\", и \"55\"). Первое правило гласит не нанимать шестнадцатилетних. Второе правило гласит, что шестнадцатилетние могут быть наняты на неполный рабочий день Тестирование граничных значений фокусируется на границах именно потому, что там спрятано очень много дефектов. Опытные тестировщики сталкивались с этой ситуацией много раз. У неопытных тестировщиков может появиться интуитивное ощущение, что ошибки будут возникать чаще всего на границах. Эти дефекты могут быть в требованиях, или в коде, если программист ошибется с указанием границ в коде (включительно/не включительно, индекс +-1).\n\nПопробуем исправить приведенный выше пример:\n\n* от 0 до 15​ - не принимаются;\n* от 16 до 17​ - могут быть приняты только на неполный рабочий день;\n* от 18 до 54​ - могут быть приняты как сотрудники на полный рабочий день;\n* от 55 до 99​ - не принимаются;\n\nА что насчет возраста -3 и 101? Обратите внимание, что требования не указывают, как должны быть рассмотрены эти значения. Мы можем догадаться, но \"угадывание требований\" не является приемлемой практикой. Следующий код реализует исправленные правила:\n\n* if (applicantAge >= 0 && applicantAge <= 15)\n  * hireStatus = \"NO\";\n* if (applicantAge >= 16 && applicantAge <= 17)\n  * hireStatus = \"PART\";\n* if (applicantAge >= 18 && applicantAge <= 54)\n  * hireStatus = \"FULL\";\n* if (applicantAge >= 55 && applicantAge <= 99)\n  * hireStatus = \"NO\";\n\nВ этом примере интересными значениями на границах или вблизи них являются {-1, 0, 1}, {15, 16, 17}, {17, 18, 19}, {54, 55, 56} и {98, 99, 100}. Другие значения, например {-42, 1001, FRED, %$#@} могут быть включены в зависимости от предусловий документации модуля.\n\nДля создания тест-кейсов для каждого граничного значения определите классы эквивалентности, выберите одну точку на границе, одну точку чуть ниже границы и одну точку чуть выше границы. Стоит отметить, что точка чуть выше границы может входить в другой класс эквивалентности. В таком случае не нужно дублировать тест. То же самое может быть верно по отношению точки чуть ниже границы.\n\nТестирование граничных значений является наиболее подходящим там, где входные данные являются непрерывным диапазоном значений.\n\n### Тестирование таблиц решений (Decision Table testing)\n\nЭтот простой, но эффективный метод заключается в документировании бизнес-логики в таблице как наборы правил, условий выполнения действий и самих действий. Тестирование таблиц принятия решений может быть использовано, когда система должна реализовывать сложные бизнес-правила, когда эти правила могут быть представлены в виде комбинации условий и когда эти условия имеют дискретные действия, связанные с ними.\n\nПример. Компания по автострахованию дает скидку водителям, которые состоят в браке и/или хорошо учатся.\n\n| -                | **Правило 1** | **Правило 2** | **Правило 3** | **Правило 4** |\n| ---------------- | ------------- | ------------- | ------------- | ------------- |\n| **Условия**      | -             | -             | -             | -             |\n| Состоит в браке? | Да            | Да            | Нет           | Нет           |\n| Хороший студент? | Да            | Нет           | Да            | Нет           |\n| -                | -             | -             | -             | -             |\n| **Действия**     | -             | -             | -             | -             |\n| Скидка ($)       | 60            | 25            | 50            | 0             |\n\nэта таблица содержит все комбинации условий. Задав два бинарных условия (\"да\" или \"нет\"), возможные комбинации будут: (\"да\", \"да\"), (\"да\", \"нет\"), (\"нет\", \"да\") и (\"нет\", \"нет\"). Каждое правило представляет собой одну из этих комбинаций. Нам, тестировщикам, нужно будет проверить, что определяются все комбинации условий. Пропущенное сочетание может привести к разработке такой системы, которая не сможет правильно обработать определенный набор исходных данных. Каждое правило является причиной \"запуска\" действия. Каждое правило может задать действие, уникальное для этого правила, или правила могут иметь общие действия. Для каждого правила с помощью таблицы решений можно указать более одного действия. Опять же, эти правила могут быть уникальными или быть общими. В такой ситуации выбрать тесты просто - каждое правило (вертикальная колонка) становится тест-кейсом. Условия указывают на входные значения, а действия - на ожидаемые результаты.\n\nЕсли тестируемая система имеет сложные бизнес-правила, а у ваших бизнес-аналитиков или проектировщиков нет документации этих правил, то тестировщикам следует собрать эту информацию и представить ее в виде таблицы решений. Причина проста: представляя поведение системы в такой полной и компактной форме, тест-кейсы могут быть созданы непосредственно из таблицы решений. При тестировании для каждого правила создается как минимум один тест-кейс. Если состояния этого правила бинарные, то должно быть достаточно одного теста для каждого сочетания. С другой стороны, если состояние является диапазоном значений, то тестирование должно учитывать и нижнюю, и высшую границы диапазона. Таким образом мы объединяем идею тестирования граничных значений с тестированием таблиц решений.\n\nЧтобы создать тестовую таблицу, просто измените заголовки строк и столбцов: правила станут тест-кейсами, условия входными значениями, а действия ожидаемыми результатами.\n\n### Комбинаторные техники тест-дизайна (Combination Strategies)\n\n_Комбинаторное тестирование (combinatorial testing): Метод, позволяющий выделить подходящую подгруппу тестовых комбинаций с целью добиться предопределенного уровня покрытия при тестировании объекта с множественными параметрами в случаях, когда эти параметры сами по себе состоят из нескольких значений, что приводит к появлению большего числа комбинаций, чем можно успеть протестировать за отведенное время. См. также метод дерева классификации, попарное тестирование, n-мерное (переборное) тестирование, тестирование с использованием ортогонального массива. (ISTQB)_\n\nТестовые примеры выбираются на основе некоторого понятия покрытия, и цель стратегии комбинирования состоит в том, чтобы выбрать тестовые примеры из набора тестов таким образом, чтобы было достигнуто 100% покрытие.\n\n* 1-wise coverage (each-used) - это самый простой критерий покрытия. Для 100% each-used покрытия требуется, чтобы каждое значение каждого параметра было включено хотя бы в один тестовый пример в наборе тестов.\n* 2-wise (pair-wise) coverage требует, чтобы каждая возможная пара значений любых двух параметров была включена в некоторый тестовый пример. Обратите внимание, что один и тот же тестовый пример часто охватывает более одной уникальной пары значений.\n* Естественным продолжением 2-wise coverage является t-wise coverage, которое требует включения всех возможных комбинаций интересных значений параметров t в какой-либо тестовый пример в наборе тестов.\n* Самый тщательный критерий покрытия, N-wise coverage, требует набора тестов, который содержит все возможные комбинации значений параметров в input parameter model (IPM).\n\n**Все комбинации** (All combinations): как видно из названия, этот алгоритм подразумевает генерацию всех возможных комбинаций. Это означает исчерпывающее тестирование и имеет смысл только при разумном количестве комбинаций. Например, 3 переменные с 3 значениями для каждой дают нам матрицу параметров 3х3 с 27 возможными комбинациями.\n\n**Тестирование каждого выбора** (EC - Each choice testing): эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример (Ammann & Offutt, 1994). Это также определение 1-wise coverage.\n\n**Тестирование базового выбора** (BC - Base choice testing): алгоритм стратегии комбинирования базового выбора начинается с определения одного базового тестового примера. Базовый тестовый пример может быть определен по любому критерию, включая простейший, наименьший или первый. Критерий, предложенный Амманном и Оффуттом (Ammann & Offutt, 1994), - это «наиболее вероятное значение» с точки зрения конечного пользователя. Это значение может быть определено тестировщиком или основано на рабочем профиле, если таковой существует. Из базового тестового примера создаются новые тестовые примеры, изменяя интересующие значения одного параметра за раз, сохраняя значения других параметров фиксированными в базовом тестовом примере. Базовый выбор включает каждое значение каждого параметра по крайней мере в одном тестовом примере, поэтому он удовлетворяет 1-wise coverage.\n\n### Попарное тестирование** (Pairwise testing)\n\nPairwise testing - техника тест-дизайна, а именно метод обнаружения дефектов с использованием комбинационного метода из двух тестовых случаев. Он основан на наблюдениях о том, что большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как правило менее критичны). Следовательно, выбирается пара двух тестовых параметров, и все возможные пары этих двух параметров отправляются в качестве входных параметров для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные на тестирование. Захватывающей надеждой попарного тестирования является то, что путем создания и запуска 1-20% тестов вы найдете 70-85% от общего объема дефектов.\n\nПример: По ТЗ сайт должен работать в 8 браузерах, используя различные плагины, запускаться на различных клиентских операционных системах, получать страницы от разных веб-серверов, работать с различными серверными, операционными системами. Итого:\n\n* 8 браузеров;\n* 3 плагина;\n* 6 клиентских операционных систем;\n* 3 сервера;\n* 3 серверных операционных системы;\n\n\\= 1296 комбинаций. Количество комбинаций настолько велико, что, скорее всего, у нас не хватит ресурсов, чтобы спроектировать и пройти тест-кейсы. Не следует пытаться проверить все комбинации значений для всех переменных, а нужно проверять комбинации пар значений переменных.\n\nИспользование всех пар для создания тест-кейсов основывается на двух техниках:\n\n* ортогональные массивы (OA - Orthogonal Array): это двумерный массив символов. На примере выше мы составляем таблицу, где столбцы представляют собой переменные (браузер, плагин, клиентская операционная система, веб-сервер и серверная операционная система, а строки - значения каждой переменной (Chrome/Opera, Windows 8/10/11 и т.п.). После чего нужно определить ортогональный массив, у которого будет столбец для каждой переменной (каждый столбец ортогонального массива имеет столько же вариантов значений, сколько имеет ваша переменная). Используя ортогональный массив для примера выше, все пары всех значений всех переменных могут быть покрыты всего лишь 64-мя тестами.\n* алгоритм Allpairs​: генерирует пары непосредственно, не прибегая к таким к ортогональным массивам. \"Несбалансированный\" характер алгоритма выбора всех пар требует только 48 тестов для примера. Следует отметить, что комбинации, выбранные методом ортогонального массива, могут быть не такими же, как те, которые выбраны Allpairs. Но это не важно. Важно лишь то, чтобы были выбраны все парные комбинации параметров. Это будут комбинации, которые мы хотим проверить.\n\nПодробнее с разбором примера см. у Копленда в главе 6.\n\nНа практике же вручную эти массивы никто не формирует, всю механику реализуют автоматизированные инструменты, самый популярный из них PICT. Тестировщику остается лишь подготовить и скормить данные.\n\n### Classification tree method\n\n_Метод дерева классификации (classification tree method): Разработка тестов методом черного ящика, в которой тестовые сценарии, описанные средствами дерева классификации, разрабатываются для проверки комбинаций выборок входных и/или выходных подмножеств. (Grochtmann) См. также комбинаторное тестирование._\n\nДерево классификации (Classification tree): структура, показывающее иерархически упорядоченные классы эквивалентности, которое используется для разработки тестовых примеров в методе дерева классификации (Classification tree method). Не путать с [Decision tree](https://en.wikipedia.org/wiki/Decision\\_tree).\n\nМетод дерева классификации: вид комбинаторной техники, в которой тестовые примеры, описанные с помощью дерева классификации, предназначены для выполнения комбинаций представителей входных и / или выходных доменов.\n\n![https://aneejian.com/assets/images/Classification-Tree-Database-System.png](https://aneejian.com/assets/images/Classification-Tree-Database-System.png)\n\nЧтобы рассчитать количество тестовых примеров, нам необходимо проанализировать требования, определить соответствующие тестовые функции (классификации) и их соответствующие значения (классы).\n\nОбычно для создания Classification tree используется инструмент Classification Tree Editor. Если же взять лист бумаги и ручку, то у нас есть тестовый объект (целое приложение, определенная функция, абстрактная идея и т. д.) вверху как корень. Мы рисуем ответвления от корня как классификации (проверяем соответствующие аспекты, которые мы определили). Затем, используя классы эквивалентности и анализ граничных значений, мы определяем наши листья как классы из диапазона всех возможных значений для конкретной классификации. И если некоторые из классов могут быть классифицированы далее, мы рисуем под-ветку / классификацию с собственными листьями / классами. Когда наше дерево завершено, мы делаем проекции листьев на горизонтальной линии (Test case), используя одну из комбинаторных стратегий (all combinations, each choice и т. д.), и создаем все необходимые комбинации.\n\nМаксимальное количество тестовых примеров - это декартово произведение всех классов всех классификаций в дереве, быстро приводящее к большим числам для реалистичных тестовых задач. Минимальное количество тестовых примеров - это количество классов в классификации с наиболее содержащимися классами. На втором этапе тестовые примеры составляются путем выбора ровно одного класса из каждой классификации дерева классификации.\n\n### Тестирование переходов между состояниями (State Transition testing)\n\n_Таблица состояний (state table): Таблица, показывающая конечные переходы для каждого состояния вследствие каждого возможного события, как для корректных, так и для некорректных переходов. (ISTQB)_\n\nТестирование переходов между состояниями определяется как метод тестирования ПО, при котором изменения входных условий вызывают изменения состояния в тестируемом приложении (AUT). В этом методе тестировщик предоставляет как положительные, так и негативные входные значения теста и записывает поведение системы. Это модель, на которой основаны система и тесты. Любая система, в которой вы получаете разные выходные данные для одного и того же ввода, в зависимости от того, что произошло раньше, является системой конечных состояний. Техника тестирования переходов между состояниями полезна, когда вам нужно протестировать различные системные переходы. Этот подход лучше всего подходит там, где есть возможность рассматривать всю систему как конечный автомат. Для наглядности возьмем классический пример покупки авиабилетов:\n\n![https://quality-lab.ru/wp-content/uploads/2017/02/unnamed-file.jpg](https://quality-lab.ru/wp-content/uploads/2017/02/unnamed-file.jpg)\n\n* Состояние (state, представленное в виде круга на диаграмме) - это состояние приложения, в котором оно ожидает одно или более событий. Состояние помнит входные данные, полученные до этого, и показывает, как приложение будет реагировать на полученные события. События могут вызывать смену состояния и/или инициировать действия;\n* Переход (transition, представлено в виде стрелки на диаграмме) - это преобразование одного состояния в другое, происходящее по событию;\n* Событие (event, представленное ярлыком над стрелкой) - это что-то, что заставляет приложение поменять свое состояние. События могут поступать извне приложения, через интерфейс самого приложения. Само приложение также может генерировать события (например, событие «истек таймер»). Когда происходит событие, приложение может поменять (или не поменять) состояние и выполнить (или не выполнить) действие. События могут иметь параметры (например, событие «Оплата» может иметь параметры «Наличные деньги», «Чек», «Приходная карта» или «Кредитная карта»);\n* Действие (action, представлено после «/» в ярлыке над переходом) инициируется сменой состояния («напечатать билет», «показать на экране» и др.). Обычно действия создают что-то, что является выходными/возвращаемыми данными системы. Действия возникают при переходах, сами по себе состояния пассивны;\n* Точка входа обозначается черным кружком;\n* Точка выхода показывается на диаграмме в виде мишени;\n\nВсе начинается с точки входа. Мы (клиенты) предоставляем авиакомпании информацию для бронирования. Служащий авиакомпании является интерфейсом между нами и системой бронирования авиабилетов. Он использует предоставленную нами информацию для создания бронирования. После этого наше бронирование находится в состоянии «Создано». После создания бронирования система также запускает таймер. Если время таймера истекает, а забронированный билет еще не оплачен, то система автоматически снимает бронь.\n\nКаждое действие, выполненное над билетом, и соответствующее состояние (отмена бронирования пользователем, оплата билета, получение билета на руки, и т. д.) отображаются в блок-схеме.\n\nНа основании полученной схемы составляется набор тестов.\n\nОпределим четыре разных уровня покрытия:\n\n1. Набор тестов, в котором все состояния​ будут посещены как минимум один раз. Этому требованию удовлетворяет набор из трех тестов, показанный ниже. Обычно это низкий уровень тестового покрытия.\n2. Набор тестов, в котором все события​ выполнятся как минимум один раз. Следует отметить, что тест-кейсы, которые покрывают каждое событие, могут быть точно теми же, которые покрывают каждое состояние. Опять же, это низкий уровень покрытия.\n3. Набор тестов, в котором все пути​ будут пройдены как минимум один раз. Несмотря на то, что этот уровень является наиболее предпочтительным из-за его уровня покрытия, это может быть неосуществимо. Если диаграмма состояний и переходов содержит петли, то количество возможных путей может быть бесконечным.\n4. Набор тестов, в котором все переходы​ будут осуществлены как минимум один раз. Этот уровень тестирования обеспечивает хороший уровень покрытия без порождения большого количества тестов. Этот уровень, как правило, один из рекомендованных.\n\nДиаграмма состояний и переходов - не единственный способ документирования поведения системы. Диаграммы, возможно, легче в понимании, но таблицы состояний и переходов могут быть проще в использовании на постоянной и временной основе. Таблицы состояний и переходов состоят из четырех столбцов - \"Текущее состояние​\", \"Событие​\", \"Действие\"​ и \"Следующее состояние\"​. Преимущество таблицы состояний и переходов в том, что в ней перечисляются все возможные комбинации состояний и переходов, а не только допустимые. При крайне необходимом тестировании систем с высокой степенью риска, например авиационной радиоэлектротехники или медицинских устройств, может потребоваться тестирование каждой пары состояние-переход, включая те, которые не являются допустимыми. Кроме того, создание таблицы состояний и переходов часто извлекает комбинации, которые не были определены, задокументированы или рассмотрены в требованиях. Очень полезно обнаружить эти дефекты до начала кодирования.\n\nИспользование таблицы состояний и переходов может помочь обнаружить дефекты в реализации, которые позволяют недопустимые пути из одного состояния в другое. Недостатком таких таблиц является то, что, когда количество состояний и событий возрастает, они очень быстро становятся огромными. Кроме того, в таблицах, как правило, большинство клеток пустые.\n\nПодробнее с разбором примера см. у Копленда в главе 7.\n\n### Domain testing\n\n_Анализ доменов (domain analysis): Методика разработки тестов, относящаяся к методу черного ящика, использующаяся для определения действенных и эффективных тестовых сценариев в случаях, когда множественные параметры могут или должны быть протестированы одновременно. Методика базируется и обобщает методы эквивалентного разбиения и анализа граничных значений/ (ISTQB)_\n\nВ главах по тестированию классов эквивалентности и граничных значений мы рассмотрели тестирование одиночных переменных, которые требовали оценки в указанных диапазонах. В этой главе мы рассмотрим тестирование нескольких переменных одновременно. Существуют две причины, по которым стоит обратить на это внимание:\n\n* у нас редко будет достаточно времени на создание тест-кейсов для каждой переменной в нашей системе. Их просто слишком много;\n* часто переменные взаимодействуют. Значение одной переменной ограничивает допустимые значения другой. В этом случае, если проверять переменные поодиночке, можно не обнаружить некоторые дефекты;\n\nDomain-тестирование​ - это техника, которая может применяться для определения эффективных и действенных тест-кейсов, когда несколько переменных (например, поля ввода) должны проверяться вместе - либо для эффективности, либо по причине их логического взаимодействия. Она использует и обобщает тестирование классов эквивалентности и граничных значений в n одномерных измерениях. Подобно этим техникам, мы ищем случаи, где граница была неверно определена или реализована. Несмотря на то, что эта техника лучше всего подходит для числовых значений, она может быть обобщена и на другие типы - boolean, string, enumeration и т.д.\n\nВ двухмерном измерении (с двумя взаимодействующими параметрами) могут возникнуть следующие дефекты:\n\n* сдвиг границы - граница, перемещённая вертикально или горизонтально;\n* направление границы - граница, повёрнутая под неправильным углом;\n* пропущенная граница;\n* лишняя граница\n\n![https://disk.yandex.ru/i/BspCpS91-UdJUw](https://lh4.googleusercontent.com/Q0kwVDWxN\\_6wbhcAEbxtNXlQm1sjQ\\_oBQDRPezEP3Dlz-ldlgAX02ai93tOLgAIi28rhUvJNnaCCWJgs7UYStLFPbeQAuyjlEDujShl60Wjkp7esyku4GlFDU67K6rVtcbCBb7p2)\n\nПодробнее с разбором примера см. у Копленда в главе 8.\n\n### Use case-based Testing\n\n_Сценарий использования системы (use case): Последовательность операций во взаимодействии актера и компонента или системы со значимым результатом, при которой актером может быть как пользователь, так и все, что может обмениваться информацией с системой. (ISTQB)_\n\nДо сих пор мы исследовали техники разработки тестовых сценариев для частей системы - входные переменные с их диапазонами и границами, бизнес-правила, представленные в виде таблиц решений, а также поведения системы, представленные с помощью диаграмм состояний и переходов. Теперь пришло время рассмотреть тестовые сценарии, которые используют системные функции с начала и до конца путем тестирования каждой из их индивидуальных операций.\n\nСегодня самым популярным подходом определения выполняемых системой операций является [диаграмма вариантов использования](https://habr.com/ru/post/566218/) (диаграмма прецедентов, Use case diagram). Как и таблицы решений и диаграммы состояний и переходов, диаграммы вариантов использования обычно создаются разработчиками для разработчиков. Но, как и другие техники, диаграммы вариантов использования содержат много полезной информации и для тестировщиков. Варианты использования были созданы Иваром Якобсоном и объяснены в его книге \"Объектно-ориентированная разработка программ: подход, основанный на вариантах использования\". Якобсон определил\n\nВариант использования (Use Case) - это сценарий, который описывает использование системы действующим лицом для достижения определенной цели (Ивар Якобсон - \"Объектно-ориентированная разработка программ: подход, основанный на вариантах использования\").\n\n* Действующее лицо (или актер) - это пользователь, играющий роль с уважением к системе, старающегося использовать систему для достижения чего-то важного внутри конкретного контекста. Действующими лицами в основном являются люди, хотя действующими лицами также могут выступать другие системы;\n* \"Сценарий\" - это последовательность шагов, которые описывают взаимодействия между актером и системой. Заметьте, что варианты использования определены с точки зрения пользователя, а не системы. Заметьте также, что операции, выполняемые внутри системы, хоть и важны, но не являются частью определения вариантов использования. Набор вариантов использования составляет функциональные требования системы.\n\nПрежде чем использовать сценарии для создания Test case, их необходимо подробно описать с помощью шаблона. Шаблоны могут варьироваться от проекта к проекту. Но среди таких обычных полей, как имя, цель, предварительные условия, актер (ы) и т. д., всегда есть основной успешный сценарий и так называемые расширения (плюс иногда подвариации). Расширения - это условия, которые влияют на основной сценарий успеха. А подвариации - это условия, которые не влияют на основной flow, но все же должны быть рассмотрены. После того, как шаблон заполнен данными, мы создаем конкретные Test case, используя методы эквивалентного разделения и граничных значений. Для минимального охвата нам нужен как минимум один тестовый сценарий для основного сценария успеха и как минимум один Test case для каждого расширения. Опять же, этот метод соответствует общей формуле «получите условия, которые меняют наш результат, и проверьте комбинации». Но способ получить это - проанализировать поведение Системы с помощью сценариев.\n\nПольза вариантов использования в том, что они:\n\n* позволяют выявить функциональные требования системы с точки зрения пользователя несмотря на техническую перспективу и независимо от того, какая парадигма разработки использовалась;\n* могут быть использованы для активного вовлечения пользователей в процесс сбора требований и определений;\n* предоставляют базис для идентификации ключевых компонентов системы, структур, баз данных и связей;\n* служат основанием для разработки тест-кейсов системы на приемочном уровне.\n\nПодробнее с разбором примера см. у Копленда в главе 8.\n\nКак создать хорошие сценарии (Сэм Канер):\n\n1. Напишите истории жизни для объектов в системе.\n2. Перечислите возможных пользователей, проанализируйте их интересы и цели.\n3. Подумайте об отрицательных пользователях: как они хотят злоупотреблять вашей системой?\n4. Перечислите «системные события». Как система справляется с ними?\n5. Перечислите «особые события». Какие приспособления система делает для них?\n6. Перечислите преимущества и создайте сквозные задачи, чтобы проверить их.\n7. Интервью пользователей об известных проблемах и сбоях старой системы.\n8. Работайте вместе с пользователями, чтобы увидеть, как они работают и что они делают.\n9. Читайте о том, что должны делать подобные системы.\n10. Изучите жалобы на предшественника этой системы или ее конкурентов.\n11. Создать фиктивный бизнес. Относитесь к нему как к реальному и обрабатывайте его данные.\n12. Попробуйте преобразовать реальные данные из конкурирующего или предшествующего приложения.\n\n### Cause/Effect, Cause-Effect (CE)\n\n_Таблица причинно-следственных решений (cause-effect decision table): См. таблица решений._\n\n_Таблица решений (decision table): Таблица, отражающая комбинации входных данных и/или причин с соответствующими выходными данными и/или действиям (следствиям), которая может быть использована для проектирования тестовых сценариев. (ISTQB)_\n\nТестовые примеры должны быть разработаны так, чтобы проявлять принципы, которые характеризуют взаимосвязь между входными и выходными данными компонента, где каждый принцип соответствует единственной возможной комбинации входных данных компонента, которые были выражены как логические значения. Для каждого тестового примера следует уточнить:\n\n* Логическое состояние для каждого эффекта;\n* Логическое состояние (истина или ложь) по любой причине;\n\nГраф причинно-следственных связей (Cause-Effect Graph) использует такую ​​модель логических взаимосвязей между причинами и следствиями для компонента. Каждая причина выражается как условие, которое может быть истинным, ложным на входе или комбинацией входных данных компонента. Каждый эффект выражается в виде логического выражения, представляющего результаты или комбинацию результатов для произошедшего компонента (?Every effect is expressed as a Boolean expression representing results, or a combination of results, for the component having occurred). Модель обычно представлена ​​как логический граф, связывающий производные логические выражения ввода и вывода с использованием логических операторов:\n\n* И (AND);\n* ИЛИ (OR);\n* Истина, если не все входные данные верны («не оба») ([NAND](https://en.wikipedia.org/wiki/NAND\\_gate));\n* Истина, когда ни один из входов не является истиной (\"ни один\") ([NOR](https://en.wikipedia.org/wiki/NOR\\_gate));\n* НЕ (NOT).\n\nCause-Effect Graph также известен как диаграмма Исикавы, поскольку он был изобретен Каору Исикава, или как диаграмма рыбьей кости из-за того, как он выглядит.\n\n![https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/cause\\_effect\\_graph.jpg](https://www.tutorialspoint.com/software\\_testing\\_dictionary/images/cause\\_effect\\_graph.jpg)\n\nГраф причинно-следственных связей похож на Decision Table и также использует идею объединения условий. И иногда они описываются как один метод. Но если между условиями существует много логических зависимостей, может быть проще их визуализировать на cause-effect graph.\n\n### Syntax testing\n\n_Синтаксическое тестирование (syntax testing): Разработка тестов методом черного ящика, в которой тестовые сценарии строятся на основе области определения входящих и/или выходных значений. (ISTQB)_\n\nСинтаксическое тестирование используется для проверки формата и правильности входных данных в случаях символьных текстовых полей, проверки соответствия формату файла, схеме базы данных, протоколу и т.д., при этом данные могут быть формально описаны в технических или установленных и определенных обозначениях, таких как BNF ([Форма Бэкуса - Наура](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D0%B0\\_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0\\_%E2%80%94\\_%D0%9D%D0%B0%D1%83%D1%80%D0%B0)).\n\n![https://globalcdh.org/files/shell/regex-match-in-cli.png](https://globalcdh.org/files/shell/regex-match-in-cli.png)\n\nКак правило, синтаксические тесты автоматизированы, так как они предполагают создание большого количества кейсов. Синтаксис тестируется с использованием двух условий:\n\n* Валидные: Проверка нормального состояния с использованием покрывающего набора путей синтаксического графа для минимально необходимых требований (?Testing the normal condition using the covering set of paths of the syntax graph, for the minimum necessary requirements). Иными словами находим возможные варианты значений, допускаемые отдельными элементами определения BNF, а затем разрабатываем кейсы, чтобы просто охватить эти варианты;\n* Невалидные: Проверка мусорных условий (garbage condition)\\* с использованием недопустимого набора входных данных.\n\nПримечание \\*: Мусорные условия - это метод проверки устойчивости системы к неверным или грязным данным. Условие выполняется путем предоставления в систему грязных данных (недопустимых данных), которые не поддерживаются указанным форматом и грамматикой синтаксиса. Для создания таких данных мы определяем и применяем возможные мутации (например, отсутствующий элемент, нежелательный дополнительный элемент, недопустимое значение для элемента и т. д.) к отдельным элементам определения BNF. Затем мы разрабатываем наши кейсы, применяя мутации, которые могут давать отличительные результаты (случаи, которые приводят к действительным комбинациям, исключаются).\n\n### Check List Based Testing\n\nТестирование на основе контрольного списка (чеклиста) выполняется с использованием предварительно подготовленного опытными тестировщиками чеклиста, который продолжает обновляться с учетом любых новых дефектов, обнаруженных при выполнении контрольных примеров контрольного списка. При любых изменениях в продукте прогоняется быстрый чеклист, чтобы убедиться, что из-за изменений не возникло новых дефектов. Этот контрольный список не имеет отношения к пользовательским историям.\n\n### User Journey Test\n\nUser Journey test, как следует из названия, охватывает полное путешествие пользователя по системе. Он охватывает сквозные тесты, из-за которых процент покрытия тестами больше по сравнению с другими методами. Этот метод помогает уменьшить количество тестовых примеров, поскольку тестовые примеры являются исчерпывающими и охватывают большую часть функциональности в одном сценарии. Сценарии написаны для самого сложного путешествия. Тесты взаимодействия с пользователем не связаны с пользовательскими историями (user stories).\n\n### User Story Testing (Agile)\n\nПользовательская история - это краткое и простое описание требований клиентов или конечного пользователя. Пользовательские истории написаны владельцем продукта (Product owner), поскольку именно он получает от клиента информацию о продукте, который будет создан. Если пользовательская история большая, она разбивается на несколько более мелких историй. Истории пользователей записываются на учетных карточках и вывешиваются на стене для обсуждения. Обсуждая важные аспекты функции, выберите те, которые в дальнейшем используются в пользовательской истории. Приемочные испытания - это заключительный этап, на котором продукт принимает заказчик после того, как он соответствует всем критериям выхода. Критерии приемлемости определяются владельцем продукта, заказчик на поставку также может привлекать разработчиков, определяя то же самое.\n\n### Exhaustive testing\n\n_Исчерпывающее тестирование (exhaustive testing): Методика тестирования, в которой набор тестов включает в себя все комбинации входных данных и предусловий. (ISTQB)_\n\nИсчерпывающее тестирование (Exhaustive testing - ET) - это крайний случай. В пределах этой техники вы должны проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике применение этого метода почти всегда не представляется возможным, из-за огромного количества входных значений.\n\n## Dynamic - Experience based\n\n### Error Guessing\n\n_Предположение об ошибках (EG - error guessing): Метод проектирования тестов, когда опыт тестировщика используется для предугадывания того, какие дефекты могут быть в тестируемом компоненте или системе в результате сделанных ошибок, а также для разработки тестов специально для их выявления. (ISTQB)_\n\nПредугадывание ошибки (Error Guessing - EG). Это когда тест аналитик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы \"предугадать\" при каких входных условиях система может выдать ошибку. Например, спецификация говорит: \"пользователь должен ввести код\". Тест аналитик, будет думать: \"Что, если я не введу код?\", \"Что, если я введу неправильный код? \", и так далее. Это и есть предугадывание ошибки.\n\nНекоторые факторы использующиеся при Error Guessing:\n\n* Уроки, извлеченные из прошлых релизов;\n* Исторические знания;\n* Интуиция;\n* Тикеты с прода;\n* Review checklist;\n* Пользовательский интерфейс приложения;\n* Отчеты о рисках программного обеспечения;\n* Тип данных, используемых для тестирования;\n* Общие правила тестирования;\n* Результаты предыдущих тестов;\n* Знание об AUT (тестируемое приложение);\n\n### Исследовательское тестирование (Exploratory testing)\n\n_Исследовательское тестирование (exploratory testing): Неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых и улучшенных тестов. (Bach)_\n\n_Исследовательское тестирование (exploratory testing): Тестирование, основанное на опыте, при котором тестер спонтанно разрабатывает и выполняет тестирования на основе существующих соответствующих знаний тестера, предшествующих исследований элемента тестирования (включая и результаты предыдущих тестирований) и эвристических \"эмпирических правил\" для общего поведения программного обеспечения и типов отказа. Примечание - Исследовательское тестирование направлено на выявление скрытых свойств (включая и скрытое поведение), которые сами по себе, с одной стороны, вполне возможно, безобидны, но, с другой стороны, могут повлиять на другие свойства тестируемого программного обеспечения и тем увеличить риск того, что программное обеспечение перестанет работать. (ГОСТ 56920)_\n\nИсследовательское Тестирование - одновременно является и техникой, и видом тестирования. В общем виде мы так или иначе всегда используем комбинацию сценарного и исследовательского подходов. Exploratory testing подразумевает под собой одновременно изучение проекта, функционала, тест-дизайн в уме и тут же исполнение тестов, после чего данный цикл может повторяться необходимое количество раз, каждый раз улучшая создаваемые кейсы и документируя пройденные сессии.\n\nДжеймс Бах указал на важную характеристику исследовательского тестирования - тестировщик участвует когнитивно. Он активно, целенаправленно, с любопытством исследует тестируемое программное обеспечение, всегда принимая на себя ответственность каждую минуту решать, какой путь к тому, что он выбрала для исследования, является наиболее многообещающим. Нет никаких искусственных ограничений на разведку. Тестировщик может свободно использовать любые доступные источники информации, включая спецификации, записи службы технической поддержки, реализации сопоставимого программного обеспечения конкурентами и (конечно) эксперименты (тесты), которые эмпирически раскрывают информацию. Нет никаких ограничений на методы тестирования, которые могут использовать исследователи - например, любая степень автоматизации подойдет. Однако исследователь не просто перезапускает старые тесты, а тестирует чтобы учиться. Вероятно, он будет внимательно изучать поведение программы во время ее тестирования, ища новые идеи о том, как она может выйти из строя, как ее можно было бы в дальнейшем протестировать или измерить, и насколько полезны эти тесты на данном этапе разработки. Выполнение тестов можно автоматизировать, а мышление - нет. Антитезой исследования является тестирование по сценарию, в котором тестировщик (или машина) следует набору процедур, изложенных давно, сравнивая наблюдаемое поведение с любыми результатами, которые разработчик тестов считал актуальными или интересными в то время. Познание произошло тогда, а не сейчас. Объем исследования такой же, как и объем самого тестирования. Разница в том, что исследователь выполняет их в любой полезной последовательности, смешивая исследование, дизайн, выполнение, интерпретацию и общение, чтобы постоянно открывать новую информацию и идти в ногу с текущими изменениями на рынке, платформе, дизайне и реализации тестируемого программного обеспечения.\n\n**Подход к тестированию**:\n\n* Используйте эвристики для управления тестированием;\n* Выполнение и создание тест-кейсов идут рука об руку;\n* Тест-кейсы продолжают развиваться на основе наблюдений и обучения тестировщиков;\n* К ET могут применяться различные методы тестирования, такие как анализ граничных значений, классы эквивалентности и т. д.;\n* ET можно использовать сессионно , чтобы сделать его более структурированным и сфокусированным;\n* Тестировщики могут развивать свои идеи, но никогда не отклоняться от своей миссии;\n* Тестирование ET не использует сценарии, а зависит от интуиции, навыков и опыта тестировщика;\n\n**Туры в исследовательском тестировании**: Чтобы систематизировать исследовательское тестирование можно использовать идею туров. Туры - это идеи и инструкции по исследованию программного продукта, объединенные определенной общей темой или целью. Туры, как правило, ограничены по времени - длительность тестовой сессии не должна превышать 4 часа. Идею туров развивали в своих работах Канер, Бах, Хендриксон, Болтон, Кохл и другие. Джеймс Виттакер (James A. Whittaker), хоть и не придумал саму идею туров, но предложил свой подход к исследовательскому тестированию с использованием туров и в своей книге “Exploratory Software Testing” в доступной форме озвучил идею туров и описал сами туры.\n\nТур - это своего рода план тестирования, он отражает основные цели и задачи, на которых будет сконцентрировано внимание тестировщика во время сессии исследовательского тестирования. При этом Виттакер использует метафору, что тестировщик - это турист, а тестируемое приложение - это город. Обычно у туриста (тестировщика) мало времени, поэтому он выполняет конкретную задачу в рамках выбранного тура, ни на что другое не отвлекаясь. Город (ПО) разбит на районы: деловой центр, исторический район, район развлечений, туристический район, район отелей, неблагополучный район.\n\n![https://www.software-testing.by/wp-content/uploads/2015/09/328.png](https://www.software-testing.by/wp-content/uploads/2015/09/328.png)\n\n### Свободное / Интуитивное тестирование (Adhoc, Ad-hoc Testing)\n\n_Свободное тестирование (ad hoc testing): Тестирование, выполняемое неформально; без формальной подготовки тестов, формальных методов проектирования тестов, определения ожидаемых результатов и руководства по выполнению тестирования. (ISTQB)_\n\n_Парное тестирование (pair testing): Два человека (двое тестировщиков, разработчик и тестировщик, или конечный пользователь и тестировщик), работающих вместе над поиском дефектов. Обычно они работают за одним компьютером, в течение работы, передавая управление друг другу. (ISTQB)_\n\nСвободное тестирование (ad-hoc testing) - это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. Такой способ тестирования в большинстве случаев дает большее количество заведенных отчетов об ошибке. Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.\n\nЧаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт. Однако при тестировании ad-hoc тестировщик должен иметь полные знания и осведомленность о тестируемой системе, особенно если проект очень сложный и большой. Поэтому нужно хорошее представление о целях проекта, его назначении, основных функциях и возможностях.\n\n**Виды свободного тестирования** (ad-hoc testing):\n\n* Buddy testing - процесс, когда 2 человека, как правило разработчик и тестировщик, работают параллельно и находят дефекты в одном и том же модуле тестируемого продукта. Сразу после того, как разработчик завершает модульное тестирование, тестировщик и разработчик вместе работают над модулем. Этот вид тестирования позволяет обеим сторонам рассматривать эту функцию в более широком масштабе. Разработчик получит представление обо всех различных тестах, выполняемых тестером, а тестировщик получит представление о том, какова внутренняя конструкция, которая поможет ему избежать разработки недействительных сценариев;\n* Pair testing - в этом тестировании два тестировщика (лучше с разным опытом) работают вместе над одним модулем. Идея, лежащая в основе этой формы тестирования состоит в том, чтобы заставить двух тестировщиков провести мозговой штурм идей и методов, чтобы выявить ряд дефектов. Оба могут разделять работу по тестированию и делать необходимую документацию по всем сделанным наблюдениям;\n* Monkey testing - произвольное тестирование продукта с целью как можно быстрее, используя различные вариации входных данных, нарушить работу программы или вызвать ее остановку (простыми словами - сломать);\n\n**Основные преимущества ad-hoc testing**:\n\n* нет необходимости тратить время на подготовку документации;\n* самые важные дефекты зачастую обнаруживаются на ранних этапах;\n* часто применяется, когда берут нового сотрудника. С помощью этого метода, человек усваивает за 3 дня то, что, разбираясь тестовыми случаями, разбирал бы неделю - это называется форсированное обучение новых сотрудников;\n* возможность найти трудновоспроизводимые и трудноуловимые дефекты, которые невозможно было бы найти, используя стандартные сценарии проверок;\n\n| Adhoc Testing                                                                                | Exploratory Testing                                                                  |\n| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |\n| Начинается с изучения приложения, а затем - с фактического процесса тестирования             | Начинается с тестирования приложения, а затем его понимания посредством исследования |\n| Самостоятельный вид тестирования                                                             | Разновидность Adhoc Testing                                                          |\n| Не требуется никакой документации                                                            | Обязательно наличие документации по деталям тестирования.                            |\n| Adhoc Testing проводят тестировщики, обладающие глубокими знаниями о приложении              | Для изучения приложения не обязательно иметь эксперта.                               |\n| Тестирование начинается после того, как будут собраны все данные для проведения тестирования | Сбор данных и тестирование происходят одновременно.                                  |\n| Это работает для отрицательных сценариев тестирования                                        | В основном это касается положительных сценариев                                      |\n| Ориентировано на улучшение процесса тестирования                                             | Ориентировано на изучение приложения                                                 |\n| Зависит от творческих способностей и интуиции тестировщика                                   | Зависит от любопытства и понимания тестировщика                                      |\n| Нет ограничений по времени                                                                   | Это ограниченный по времени метод                                                    |\n\n### Attack Testing\n\n_Атака (attack): Направленная и нацеленная попытка оценить качество, главным образом надежность, объекта тестирования за счет попыток вызвать определенные отказы. См. также негативное тестирование. (ISTQB)_\n\n\\_Тестирование на основе атак (attack-based testing): Методика тестирования на основе опыта, использующая программные атаки с целью провоцирования отказов, в частности - отказов, связанных с защищенностью. (ISTQB) \\_\n\n\nДиаграмма связей — это инструмент управления качеством, основанный на определении логических взаимосвязей между различными данными. Применяется этот инструмент для сопоставления причин и следствий по исследуемой проблеме.\n\n![](http://sixsigmaonline.ru/imgs/001/a0194.png)\n\n\n\nэквивалентные класы \nграничные значения\n\nдобавить еще\n\ndesign table \n\nэто все specification base\n\nнужно добавить white box техники\n\n","date":"2022-05-14T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/tehniki-test-dizajna/","order":12,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Техники тест-дизайна","path":"/tag/%D0%A2%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B8%20%D1%82%D0%B5%D1%81%D1%82-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0/"}],"headings":[{"value":"Static - Reviews","anchor":"#static---reviews"},{"value":"Static - Static Analysis","anchor":"#static---static-analysis"},{"value":"Dynamic - White box","anchor":"#dynamic---white-box"},{"value":"Dynamic - Black box","anchor":"#dynamic---black-box"},{"value":"Dynamic - Experience based","anchor":"#dynamic---experience-based"}]}},{"node":{"id":"86ac49748bffbf2ce2298c232043cc02","title":"Тестовая документация","content":"\n- [Тестовая политика и стратегия](/testovaya-politika-i-strategiya/)\n- [Международные стандарты тестовой документации](/mezhdunarodnye-standarty-testovoj-dokumentaczii/)\n- [Master Test Plan и тестовые планы для каждого уровня](/master-test-plan-i-testovye-plany-dlya-kazhdogo-urovnya/)\n- [Понятие Test Case и Test Suite](/ponyatie-test-case-i-test-suite/)\n- [Понятие Test Basis, Test Condition и Test Procedure](/ponyatie-test-basis-test-condition-i-test-procedure/)\n- [Check-list, как представитель Experience-Based](/check-list-kak-predstavitel-experience-based/)\n- [Bug Report](/bug-report/)\n- [Summary Report](/summary-report/)\n- [Requirements Tracebility Matrix](/requirements-tracebility-matrix/)\n- [Test Data Tables](/test-data-tables/)\n- [Test Scenario](/test-scenario/)\n- [External Test Reports](/external-test-reports/)\n- [Критерии приемки](/kriterii-priemki/)\n- [Метрики тестирования](/metriki-testirovaniya/)\n- [Требования](/trebovaniya/)\n- [Тестовый оракул](/testovyj-orakul/)\n\n\n## Виды тестовой документации\n\n### Тестовая поставка (test deliverable)\nЛюбой тестовый (рабочий) продукт, который должен быть доставлен кому-то другому, кроме автора тестового (рабочего) продукта. (ISTQB)\n\n### Тестовое обеспечение (testware)\nАртефакты, создаваемые во время процесса тестирования и требующиеся для планирования, разработки и выполнения тестов. Например: документация, сценарии, входы, ожидаемые результаты, процедуры установки и удаления, файлы, базы данных, окружение и любое другое дополнительное программное обеспечение или инструменты, используемые в тестировании. (Fewster and Graham)\n\n### Артефакт (artifact)\nЭто один из многих видов материальных побочных продуктов, возникающих в процессе STLC. Это не только документация, а в принципе всё, что создаётся для того, чтобы быть задействованным в тестировании.\n\n### Результаты тестирования (Test Deliverables)\nЭто артефакты, которые передаются заинтересованным сторонам проекта программного обеспечения в течение жизненного цикла разработки программного обеспечения. На каждом этапе жизненного цикла разработки программного обеспечения существуют разные результаты тестирования. Некоторые результаты тестирования предоставляются до этапа тестирования, некоторые - на этапе тестирования, а некоторые - после завершения циклов тестирования.\n\nНаличие или отсутствие документации, ее актуальность, как и используемые виды варьируются от компании к компании и даже от проекта к проекту. Создание и ведение документации требует весомого количества времени (и компетенций), а потому важно знать основные документы и их роль в процессах, учитывать требования всех заинтересованных лиц, нормативную и законодательную базу, политику и стандарты компании и особенности проекта чтобы понимать, какие из них необходимы (и обоснованны для бизнеса) в каждом случае. Существует огромное количество вариантов документов, часть из которых вы можете никогда и не встретить в реальной работе.\n\nПо Куликову документацию можно разделить на два больших вида в зависимости от времени и места ее использования:\n\n* Продуктная документация (product documentation, development documentation) используется проектной командой во время разработки и поддержки продукта. Она включает:\n  * План проекта (project management plan) и в том числе тестовый план (test plan);\n  * Требования к программному продукту (product requirements document, PRD) и функциональные спецификации (functional specifications document, FSD; software requirements specification, SRS);\n  * Архитектуру и дизайн (architecture and design);\n  * Тест-кейсы и наборы тест-кейсов (test cases, test suites);\n  * Технические спецификации (technical specifications), такие как схемы баз данных, описания алгоритмов, интерфейсов и т.д.;\n* Проектная документация (project documentation) включает в себя как продуктную документацию, так и некоторые дополнительные виды документации и используется не только на стадии разработки, но и на более ранних и поздних стадиях (например, на стадии внедрения и эксплуатации). Она включает:\n  * Пользовательскую и сопроводительную документацию (user and accompanying documentation), такую как встроенная помощь, руководство по установке и использованию, лицензионные соглашения и т.д.;\n  * Маркетинговую документацию (market requirements document, MRD), которую представители разработчика или заказчика используют как на начальных этапах (для уточнения сути и концепции проекта), так и на финальных этапах развития проекта (для продвижения продукта на рынке).\n\nМожно встретить и другие классификации.\n\n* Внутренняя документация подробно описывает процесс разработки продукта, например стандарты, проектную документацию, заметки о деловой переписке и т. д. Внешняя документация относится к документам, которые подробно описывают сам продукт, например, Системная документация и Пользовательская документация.\n* К внешней документации можно отнести Test policy, Test strategy, различные отчеты, Defect Report, Замечание, Запрос на изменение (улучшение), к внутренней всё от чеклиста до плана тестирования, тестовые данные и т.п. Пользовательская документация (User documentation) - это вся документация, которая будет передана конечному пользователю в комплекте с ПО.\n\n\n### Политика качества (Quality policy)\nОтражает видение компании в отношении производства и поставки качественного продукта;\n### Политика тестирования (Test policy)\nДокумент высокого уровня, в котором описаны принципы, методы и все важные цели тестирования в организации;\n### Стратегия тестирования (Test strategy)\nСтатический документ документ высокого уровня (high-level), обычно разрабатываемый менеджером проекта (project manager). Это документ, который отражает подход к тестированию продукта и достижению целей. Обычно он выводится из Спецификации бизнес-требований (BRS - Business Requirement Specification). На основе стратегии тестирования готовится План тестирования;\n### План тестирования (Test plan)\nДокумент, который содержит план всех действий по тестированию, которые необходимо выполнить для получения качественного продукта. План тестирования является производным от описания продукта (Product Description), SRS (Software requirements specification) или сценариев использования (Use Case) для всех будущих действий проекта. Обычно его готовит руководитель тестирования или менеджер по тестированию (Test Lead or Test Manager);\n### Отчет об оценке усилий (Effort Estimation Report)\nВ этом отчете группы тестирования оценивают усилия для завершения процесса тестирования;\n### Сценарий тестирования (Test Scenario)\nЭлемент или событие программной системы, которое может быть проверено одним или несколькими тестовыми случаями;\n### Тестовый набор/комплект** (Test Suite)\n“Комплект тестовых наборов для исследуемого компонента или системы, в котором обычно постусловие одного теста используется в качестве предусловия для последующего.” (ISTQB)_. Некоторый набор формализованных Test case, объединенных между собой по общему логическому признаку;\n### Тестовый случай/пример (Test case)\nНабор положительных и отрицательных исполняемых шагов тестового сценария, который имеет набор предварительных условий, тестовых данных, ожидаемого результата, пост-условий и фактических результатов;\n### Тест сурвей (Test Survey)\nВ рунете только [один источник](https://www.a1qa.ru/blog/obespechivaem-kachestvo-mobilnyh-prilozhenij-shag-2-planirovanie-testovyh-aktivnostej/) о нем, но есть упоминания в истории чатов коммьюнити. Test Survey по детализации занимает место посередине между чек-листом и тест-кейсом, а именно содержит в себе только summary и expected result. Т.е. подробнее чек-листов, где только заголовки, но с ожидаемым результатом и без шагов и прочего как в тест-кейсах;\n### Чек-лист (Check List)\nПеречень формализованных Test case в упрощенном виде удобном для проведения проверок, часто только список из заголовков кейсов;\n### Матрица прослеживаемости требований (Requirements Traceability Matrix)\nДокумент, который соотносит требования с тестовыми примерами;\n### Тестовые данные (Test Data)\nДанные, которые существуют (например, в базе данных) на начало выполнения теста и влияют на работу, или же испытывают влияние со стороны тестируемой системы или компонента.” (ISTQB). “Созданные или отобранные данные, удовлетворяющие входным требованиям для выполнения одного или более контрольных примеров, которые могут быть определены в плане тестирования, контрольном примере или процедуре тестирования. (ГОСТ 56920)\n### Отчет о дефектах (Defect Report)\nЦель документа заключается в том, чтобы зафиксировать факт ошибки и передать разработчикам подробную информацию о ней;\n### Отчет о выполнении теста (Test Execution Report)\nСодержит результаты тестирования и сводку действий по выполнению тестов;\n### Сводный отчет о тестировании (Test summary report)\nПредставляет собой документ высокого уровня, в котором резюмируются проведенные действия по тестированию, а также результаты тестирования;\n### Графики и метрики (Graphs and Metrics)\nПредназначены для мониторинга и управления процессом и продуктом. Это помогает без отклонений вести проект к намеченным целям. Метрики отвечают на разные вопросы. Важно решить, на какие вопросы вы хотите получить ответы;\n### Отчет о тестовых инцидентах (Test incident report)\nСодержит все инциденты, разрешенные или неразрешенные, обнаруженные во время тестирования;\n### Отчет о завершении тестирования (Test closure report)\nСодержит подробный анализ обнаруженных ошибок, удаленных ошибок и несоответствий, обнаруженных в программном обеспечении;\n### Отчет о статусе тестирования (Test status report)\nПредназначен для отслеживания статуса тестирования. Его готовят периодически или еженедельно. В нем указаны работы, выполненные до настоящего времени, и работы, которые еще не завершены;\n### Еженедельный отчет о статусе (менеджер проекта для клиента)\nWeekly status report похож на отчет о статусе тестирования, но генерируется еженедельно;\n### Отчет об улучшении (?Enhancement report)\nОписание неявных/некритичных косвенных требований, которые не были учтены при планировании/реализации продукта, но несоблюдение, которых может вызвать неприятие у конечного потребителя;\n### Запрос на модификацию (Modification Request)\nЗапрос клиента на изменение существующей функциональности;\n### Примечания к выпуску (Release Note)\nПримечания к выпуску будут отправлены клиенту, заказчику или заинтересованным сторонам вместе со сборкой. Он содержит список новых выпусков, исправления ошибок;\n### Руководство по установке / настройке (Installation/configuration guide)\nЭто руководство помогает установить или настроить компоненты, из которых состоит система, и ее аппаратные и программные требования;\n### Руководство пользователя (User guide)\nэто руководство помогает конечному пользователю понять как пользоваться продуктом;\n### Документы требований**.\n\n![https://api.docs.cntd.ru/img/12/00/13/49/98/1a71a934-c9ab-4de5-af4b-f4fa89eeb93d/P0020.png](https://lh6.googleusercontent.com/IJjhp1x7295N97WqgjsR90wavx8yHHm2iitMKK5LCcXu98Y6Jva60iyylSJt\\_hpnhJbD43DTXTXxg5d7gtJbb7pMFxue-tP-TtucTH8d1aXapLgjwXZUUtdfwLmuyGq\\_1rI\\_3OdQ)\n\nИсточник:\n\n* [Test Deliverables in Software Testing - Detailed Explanation](https://www.softwaretestingmaterial.com/test-deliverables/)\n\nДоп. материал:\n\n* [ГОСТ Р 56922-2016/ISO/IEC/IEEE 29119-3:2013 Часть 3: “Документация тестирования”](https://docs.cntd.ru/document/1200134998)\n* [ГОСТ Р ИСО/МЭК 15910-2002: “Процесс создания документации пользователя программного средства”](https://docs.cntd.ru/document/1200030141)\n* [ГОСТ Р 57100-2016/ISO/IEC/IEEE 42010:2011 “Описание архитектуры”](https://docs.cntd.ru/document/1200139542)\n* [Podlodka#223 - Техническая документация](https://www.youtube.com/watch?v=S8kiPiG0jW8)\n* [Пользовательская документация](https://habr.com/ru/post/542288/#:\\~:text=2.%C2%A0-,%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F,-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F)\n* [What Is Test Data? Test Data Preparation Techniques With Example](https://www.softwaretestinghelp.com/tips-to-design-test-data-before-executing-your-test-cases/)\n* [Что такое тестовая документация и зачем она нужна?](https://testengineer.ru/chto-takoe-testovaya-dokumentaciya-i-zachem-ona-nuzhna/)\n* [Шаблон улучшения](http://okiseleva.blogspot.com/2015/10/blog-post\\_16.html)\n\n\n\n\n## виды тестовой документации\nhttps://www.freecodecamp.org/news/how-to-write-qa-documentation-that-will-work/\n\n\n","date":"2022-05-13T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/testovaya-dokumentacziya/","order":13,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Виды тестовой документации","anchor":"#виды-тестовой-документации"},{"value":"виды тестовой документации","anchor":"#виды-тестовой-документации-1"}]}},{"node":{"id":"32737abd923693143bf93bb8156bb5f6","title":"Тестовая политика и стратегия","content":"\n## Политика качества и политика тестирования (Quality policy and Test policy)\n\n### Политика качества\n\nЭто заявления, сделанные организациями для передачи своих долгосрочных стратегических целей, задач, видения в отношении производства и поставки качественного продукта. \n\nВ этих политиках излагаются основные принципы организации, которые помогают им следовать установленным процедурам при разработке и тестировании продукта и постоянно стремиться к улучшению как продукта, так и процесса. \n\nПолитика в области качества отражает основные ценности организации, что помогает понять их представления об атрибуте качества, о том, что для них означает качество, подходах, ключевых областях внимания и приоритетах при обеспечении качества для своих клиентов.\n\nНаличие четко определенной политики в области качества в соответствии со стандартами ISO 9001 является обязательным требованием для организации. Quality policy составляют CEO и Quality Manager.\n\nПри написании политики подчеркиваются следующие ключевые области:\n\n* **Внимание клиентов**  \nПотребности и ожидания клиентов являются важнейшим ключевым критерием, который помогает в достижении перспектив качества продукта. Таким образом, основное внимание следует уделять информированию о текущих и будущих потребностях клиента, а также их выполнению;\n* **Лидерство**  \nДолжна быть в состоянии моделировать и создавать мотивационную и восторженную среду, чтобы извлекать максимум из каждого человека для достижения качества;\n* **Постоянное улучшение**  \nДолжна стремиться к постоянному совершенствованию процедуры и подхода, чтобы улучшить качество;\n* **Процесс**  \nДолжна отражать соблюдение и следование всем стандартным методам и процессам, что способствует повышению качества;\n* **Отношения**  \nДолжна быть направлена на укрепление отношений с клиентом / покупателем;\n* **Создание и распространение осведомленности**  \nИнформирование людей как внутри (персонал), так и за пределами (целевые клиенты) организации о стандартах, принципах и практиках, которым следует организация.\n\nКроме того, она должна обеспечивать прочную основу для достижения целей в области качества и периодически пересматриваться и обновляться, чтобы постоянно соответствовать существующим требованиям и ожиданиям. Вкратце можно сказать, что политика в области качества, определяемая организациями, действует как зеркало и отражает их виртуальный образ в реальном мире, на основе которого внешние организации могут воспринимать и понимать свои основные принципы и обязательства по отношению к вкладу в качество.\n\n### Политика тестирования\n\n_Политика тестирования (test policy): Документ высокого уровня, описывающий принципы, подход и основные цели организации в отношении тестирования. (ISTQB)_\n\n**Политика тестирования** объясняет философию тестирования компании в целом и указывает направление, которого отдел тестирования должен придерживаться и которому следует следовать. Это должно относиться как к новым проектам, так и к проектам на поддержке. \n\nУстановление старшими менеджерами соответствующей политики тестирования обеспечивает прочную основу, в которой могут работать специалисты-практики. Это поможет обеспечить максимальную стратегическую ценность каждого проекта.\n\nПолитика тестирования является частью политики качества, если она есть, в таких случаях политика качества разъяснит общую цель менеджмента в отношении качества. В ином случае этот документ верхний в иерархии тестовой документации. Политика тестирования содержит следующее:\n\n* Обозначение преимуществ тестирования и коммерческой ценности, которые оправдывают [затраты на качество](https://tryqa.com/what-is-cost-of-quality-in-software-testing/);\n* Определяет [цели тестирования](https://tryqa.com/what-is-the-software-testing-objectives-and-purpose/), такие как укрепление доверия, обнаружение дефектов и снижение рисков для качества;\n* Описывает методы измерения эффективности тестирования и результативности выполнения задач тестирования;\n* Обобщает [процессы](https://tryqa.com/what-is-fundamental-test-process-in-software-testing/), используемые при тестировании;\n* Описывает для организации способы [улучшения процессов](https://tryqa.com/software-testing-process-improvements-for-test-qa-managers/) тестирования.\n\nПолитика тестирования также должна включать действия по тестированию, необходимые для поддержки текущего проекта, а также разработки новых проектов.\n\nИсточники:\n\n* [Quality Policy](https://www.professionalqa.com/quality-policy)\n* [What is Test Policy? What does it contain?](https://tryqa.com/what-is-test-policy-what-does-it-contain/)\n\nДоп. материал:\n\n* [ISO 9001 Quality Policy - How to Write & Communicate your Policy Statement](https://www.iso-9001-checklist.co.uk/5.2-quality-policy.htm)\n\n## Стратегия тестирования (Test strategy)\n\n_Стратегия тестирования (test strategy): Высокоуровневое описание уровней тестирования, которые должны быть выполнены, и тестирования, входящего в эти уровни, для организации или программы из одного или более проектов. (ISTQB)_\n\nСтратегия тестирования - это статический документ высокого уровня, обычно разрабатываемый менеджером проекта. \n\nЭто документ, который отражает подход к тестированию продукта и достижению целей, и дает четкое представление о том, что команда тестирования будет делать для всего проекта. Обычно он выводится из Спецификации бизнес-требований (BRS).\n\nКак только стратегия тестирования готова, группа тестирования начинает писать подробный план тестирования и продолжает дальнейшие этапы тестирования. \n\nВ мире Agile некоторые компании не тратят время на подготовку плана тестирования из-за минимального времени для каждого выпуска, но они поддерживают документ стратегии тестирования. Это один из важных документов в test deliverables, которым команда тестирования делится с заинтересованными сторонами для лучшего понимания объема проекта, рисков, подходов к тестированию и других важных аспектов.\n\nСодержание стратегии будет разным в зависимости от проекта, поэтому нет единого для всех шаблона. Можно найти эвристики в помощь, множество зарубежных статей на тему составления стратегии и некоторые общие пункты, которые чаще используются:\n\n* **Обзор и объем** (Scope and overview): объем работ по тестированию (что тестировать и зачем тестировать) и обзор тестируемого продукта;\n* **Подход к тестированию** (Test Approach):\n  * Уровни тестирования (Test levels);\n  * Виды тестирования (Test Types);\n  * Роли и обязанности (Roles and responsibilities);\n  * Требования к окружениям (Environment requirements);\n* **Инструменты тестирования** (Testing tools): инструменты, необходимые для проведения тестов (TMS, багтрекинговая система, стек автоматизации);\n* **Отраслевые стандарты**, которым необходимо следовать (Industry standards to follow): В этом разделе описывается отраслевой стандарт для производства высококачественной системы, которая соответствует ожиданиям клиентов или превосходит их. Обычно менеджер проекта определяет модели и процедуры тестирования, которым необходимо следовать для достижения целей проекта;\n* **Результаты тестирования** (Test deliverables): документация, которую необходимо создать до, во время и по окончании тестирования;\n* **Метрики тестирования** (Testing metrics): метрики, которые следует использовать в проекте для анализа статуса проекта;\n* **Матрица отслеживания требований** (RTM);\n* **Риски и способы их снижения** (Risk and mitigation): все риски тестирования и план по их снижению;\n* **Инструмент отчетности** (Reporting tool): как будут отслеживаться дефекты и проблемы;\n* **Результаты тестов** (Test Summary): виды сводных отчетов о тестах, которые будут создаваться, с указанием периодичности. Сводные отчеты о тестах будут генерироваться ежедневно, еженедельно или ежемесячно, в зависимости от критичности проекта.\n\nИсточники:\n\n* [The Complete Guide To Writing Test Strategy](https://www.softwaretestingmaterial.com/test-strategy/)\n\nДоп. материал:\n\n* [Большая качественная подборка материалов по теме](https://www.huibschoots.nl/wordpress/?page\\_id=441#strategy)\n* [Practical test strategy using heuristics](https://huddle.eurostarsoftwaretesting.com/resources/test-management/practical-test-strategy-using-heuristics/)\n* [Creating a Quality Strategy](https://thinkingtester.com/creating-a-quality-strategy/)\n* [Стратегия обеспечения качества и вопросы в процессе ее составления](https://testengineer.ru/strategiya-obespecheniya-kachestva/)\n* [6 Ways to Come Up with a Solid Test Strategy](https://blog.gurock.com/solid-test-strategy/)\n* [Creating a quality strategy](https://theqalead.com/topics/creating-a-quality-strategy/)\n* Примеры: [раз](https://www.experimentus.com/itm/15\\_Project\\_Test\\_Strategy\\_Agile.pdf), [два](https://strongqa.com/qa-portal/testing-docs-templates/test-strategy), [три](https://www.template.net/business/strategy-templates/sample-test-strategy-template/)\n\n\n\n","date":"2022-06-21T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/testovaya-politika-i-strategiya/","order":14,"category":{"title":"manual","path":"/category/manual/"},"tags":[{"title":"Тестовая документация","path":"/tag/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/"}],"headings":[{"value":"Политика качества и политика тестирования (Quality policy and Test policy)","anchor":"#политика-качества-и-политика-тестирования-quality-policy-and-test-policy"},{"value":"Стратегия тестирования (Test strategy)","anchor":"#стратегия-тестирования-test-strategy"}]}}]}},"relatedCategory":{"id":"603a2c0d964c5170463a1125f6911641","title":"manual","path":"/category/manual/","related":[{"id":"mobile","path":"/category/mobile/","title":"mobile"},{"id":"api","path":"/category/api/","title":"api"}]}},"context":{}}