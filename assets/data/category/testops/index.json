{"hash":"74078440e78cf7eff9cd218b18924da13af0a419","data":{"category":{"title":"testops","path":"/category/testops/","belongsTo":{"totalCount":11,"pageInfo":{"totalPages":2,"currentPage":1},"edges":[{"node":{"id":"aa7b4cd5a8b428d469d433c4c9796f4f","title":"Ресурсы. CI","content":"\n## Ресурсы. CI\n\nhttps://www.youtube.com/watch?v=RmziIx1D_Lo\n\nhttps://www.youtube.com/watch?v=jX9K5MqTNYM\n\nhttps://www.youtube.com/watch?v=XwQ65qaoPzw\n\nhttps://www.youtube.com/watch?v=hgi7AEEr2B0\n\nhttps://www.youtube.com/watch?v=Xos_J-byz3E\n\nhttps://www.youtube.com/watch?v=rg2PK0jECeM\n\nhttps://www.youtube.com/watch?v=1AJS74luWyI\n\nhttps://www.youtube.com/watch?v=oxbbnDpghCM\n\nhttps://www.youtube.com/watch?v=PeA1QLDxaFQ\n\nhttps://www.youtube.com/watch?v=xERPGjUVSCc\n\nhttps://www.youtube.com/watch?v=Iam2NlTukFQ\n\nhttps://www.youtube.com/watch?v=dxGGZQiuD6Q","date":"2022-06-08T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-ci/","order":null,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Ресурсы. CI","anchor":"#ресурсы-ci"}]}},{"node":{"id":"46f764e6fd31743c5f8112a1d7b7483f","title":"Ресурсы. Kubernetes, Docker, Selenoid","content":"\n## Docker\n\nhttps://www.youtube.com/watch?v=0OIgiYVRDiI\n\nhttps://www.youtube.com/watch?v=LeA2_GJ1e70\n\nhttps://www.youtube.com/watch?v=QF4ZF857m44\n\n## Kubernetes\n\nhttps://www.youtube.com/watch?v=_-NRlfur9gE\n\nhttps://youtu.be/Hv1LjlTD3Dk\n\nhttps://www.youtube.com/watch?v=HsWsFuuOjKM\n\nhttps://www.youtube.com/watch?v=fVhpWxqBm2I\n\nhttps://www.youtube.com/watch?v=yPU7sYMGIgM\n\nhttps://www.youtube.com/watch?v=VqLW2TLJM3E\n\nhttps://www.youtube.com/watch?v=EnhwnuJRSXY\n\nhttps://www.youtube.com/watch?v=Mw_rEH2pElw&list=PL8D2P0ruohOBSA_CDqJLflJ8FLJNe26K-\n\n\n## Selenoid. How to.\n\nhttps://www.youtube.com/watch?v=0z3FFTCdYDY&t\n\nhttps://www.youtube.com/watch?v=L01F3i_ZZpA\n\nhttps://www.youtube.com/watch?v=zxMPrUOO48w&t=1242s\n\nhttps://www.youtube.com/watch?v=wAKcBinMn6o&t=1575s\n\nhttps://www.youtube.com/watch?v=Ig24ZJtRI-Y\n\n---\n\nhttps://www.youtube.com/watch?v=w-VXxYa8EJY\n\nhttps://youtu.be/hNBMavE_70Q\n","date":"2022-06-08T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-kubernetes-docker-selenoid/","order":null,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Docker","anchor":"#docker"},{"value":"Kubernetes","anchor":"#kubernetes"},{"value":"Selenoid. How to.","anchor":"#selenoid-how-to"}]}},{"node":{"id":"dfb6220aef4f7a7060af2e915f6a4522","title":"Микросервисная архитектура","content":"\n## Микросервисная архитектура\n\n### Особенности\n\n- дает простоту и независисмость деплоймента;\nМы можем деплоить каждый микросервис отдельно.\nНапример, если есть изменения в микросервисе А, то мы деплоим только его и нам не нужно передеплаивать UI или другие микросервисы;\n\n- каждый микросервис имеет одну свою собственную, как правило простую функцию;\nи как правило, поддерживается одной командой, иногда даже из 1-2 человек;\n\n- отсутсвие иерархической структуры;\nмикросервис может комуницировать с БД или с другим микросервисом, нет какой то четкой структуры.\n\n- микросервисы взаимодействуют друг с другом напрямую;\n\n### Преимущества\n\n- микросервисы взаимодействуют по очень легковесным сетевым протоколам, как правило это REST;\n\n- мы можем в пределах одного приложения использовать какие угодно технологии и языки программирования;\nнапример, один микросервис на java, а другой на nodejs и это отлично работает;\n\n- простота масштабирования микросервисной архитектуры;\n\n### Проблемы для автоматизации тестирования\n\n- каждый микросервис имеет собственную ценность для заказчика \nесли монолитное приложение мы тестируем и используем все целиком, то в тут каждый микросервис имеет свою ценность;\nи не обязательно его использовать с тем UI клиентом, который был написан изначально, клиент может захотеть использовать другой клиент, мобильный клиент или переписать UI;\nнам важно, чтобы микросервис сам по себе выполнял те функции, которые на него возложены;\n\n- проблема мертвого кода\nкогда есть микросервисы и один микросервис мы больше не используем, его заменили на другой микросервис\nпри этом если automation framework остается монолитным то возникает проблема что есть автотесты которые существую но при этом они уже не нужны.\n\n- нужно также тестировать взаимодействие между микросервисами\n\n### Архитектура для автотестирования\n- тесты на java\n- конфигурация spring\n- билд через Maven\n- BDD - Cucumber\n- взаимодействие с UI - Selenium(Selenide)\n- взаимодействие с BackEnd - RestAssured\n- хранилице тестов - Google Cloud Platform\n- управление контейнерами - Kubernetes\n- для запуска тестов - Selenoid\n- для отчетности - Report Portal, Allure\n\n**Unit тесты** пишутся разработчиками.\n\n**Integrartion тестирование** - разбито  на 2 слоя: слой клиента, который работает как аналог UI, отправляет запросы и принимает ответы\nи уровень тестов, где происходят проверки.\n\n**UI тестирование** - имеет 3 слоя: уровень страниц (pages), уровень шагов (steps), уровень тестов (tests)\n\nДалее UI тесты подключаются к Selenoid - это браузеры, которые запускаются в докер контейнерах и оркестрируются Kubernetes' ом.\nЧтобы включить ui тесты в pipeline. \n\nUI тесты и BackEnd тесты не взаимодействуют между собой, поэтому чтобы создать тестовые данные, например пользователя который будет логиниться в приложение, это нужно будет делать через UI, что не совсем удобно.\n\nДля решения этой проблемы мы подключаем клиентскую часть Backend тестов через dependency в Мавен проект UI тестов, для того чтобы создать тестовые данные или ускорить работу UI тестов(например для быстрого логина в приложение).\n\nДля проверки взаимодействия микросервисов, мы подключаем клиентскую часть backEnd тестов для микросервиса 1 к клиентской часть backend тестов микросервиса 2 и проверяем.\n\nДля предоставления результатов используется Allure репорт, он используется для внутренних нужд.\n\nДля кастомера используется Report Pirtal, где отображаются результаты со всех уровенй тестирования.\n\n#### Selenoid\n\n- доступен сразу из коробки\n\n- есть 2 решения:\n  1. деплоится на виртуальную машину\n  2. деплоится в kubernetes кластер\nесли есть cloud платформа то можно бытсро с помощью seleonoid поднять браузер в cloud'е\n\n- браузеры стартуют очень быстро (~30сек)\n\n- надежность\nбраузеры сами закрываются ничего не зависает\n\n- запись видео\n\n## Docker\n\nDocker container - экземпляр Docker Image который содержит три атрибута:\n- docker image\n- среда запуска\n- стандартный набор инструкций\n\n### Преимущества\n\n- приложения портируемые и стандартно упакованные\nзапустить можно везде где есть docker engine\n- деплоймент простой и повторяемый \n- поддержка микросервисной архитектуры\nкаждый микросервис запакован, изолирован и запускается отдельно\n\n### Tools for containers orchestration\n\n- kubernetes - самый распространненый инструмент\n- docker swarm - нативный tool\n- rancher\n- mesos\n\n#### Источник информации:\n1. ❗[Automation testing solution for micro service architecture](https://www.youtube.com/watch?v=0QVlMsObhuQ)","date":"2022-07-27T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/mikroservisnaya-arhitektura/","order":1,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"},{"title":"микросервисы","path":"/tag/%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B/"}],"headings":[{"value":"Микросервисная архитектура","anchor":"#микросервисная-архитектура"},{"value":"Docker","anchor":"#docker"}]}},{"node":{"id":"c1e39273d25f748e47b87dc280b07ce4","title":"CREATE, DROP, DELETE, UPDATE, INSERT, ALTER","content":"\n## Состав таблицы\n\n1. Дать таблице имя, пусть она будет называться book, вот некоторые правила для выбора имен таблиц:\n- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;\n- имя должно быть уникальным в пределах базы данных.\n\nТакже рекомендуется:\n- чтобы имя было существительным в единственном числе;\n- имя должно быть понятным и соответствовать тому объекту, который оно описывает;\n- имя должно быть как можно короче, максимум до 10 символов.\n\n2. Определить структуру таблицы, из каких атрибутов(столбцов, полей) она будет состоять.\n\nПравила по выбору имени поля информационного объекта:\n- может включать английские буквы, цифры и знак подчеркивания, должно начинаться с буквы;\n- имя поля должно быть уникальным в пределах таблицы.\n\nРекомендации по выбору имени поля информационного объекта:\n- имя должно быть понятным и соответствовать тем данным, которые хранятся в поле;\n- имя может состоять из нескольких слов, тогда слова разделяются подчеркиванием, после подчеркивания слово пишется с маленькой буквы.\n\n3. Включить ключевое поле id, которое является ОБЯЗАТЕЛЬНЫМ ЭЛЕМЕНТОМ каждой реляционной таблицы. Ключевое поле является уникальным для каждой записи, однозначно определяет запись и в дальнейшем будет использоваться для связей с другими таблицами.\n\nРекомендации по именованию  ключевых полей:\n- имя должно состоять  из двух частей: начинаться с названия таблицы, которой поле принадлежит, затем через подчеркивание необходимо указать id.\n\n## Основные типы данных SQL\n\n- INT, INTEGER  \n_Описание:_ Целое число, могут принимать значения от -2 147 483 648 до 2 147 483 647  \t\n_Пример:_ -567 1205\n\n- DECIMAL, NUMERIC  \n_Описание:_ Вещественное число, в скобках указывается максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой.\nМожно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне -10^38+1 до 10^38-1.\nDECIMAL(4,1) NUMERIC(6,3)  \n_Пример:_ 34.6 -3.294\n\n- DATE  \n_Описание:_ Дата в формате ГГГГ-ММ-ДД \n26 июля 2020 года\n3 января 2021 года  \n_Пример:_ 2020-07-26 2021-01-03\n\n- VARCHAR  \n_Описание:_ Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле VARCHAR(10)(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному количеству символов в строке)  \n_Пример:_ пример описание\n\nРекомендации по выбору типов данных для полей таблицы.\n- Выбирайте минимальный тип данных исходя из максимального значения поля. Например, если максимальный текст, который может быть записан в поле, имеет длину 25 символов, значит нужно использовать тип VARCHAR(25).\n- Для описания ключевого поля используйте описание INT PRIMARY KEY AUTO_INCREMENT. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего).\n\n## Создание таблицы\n\nДля создания таблицы используется SQL-запрос. \n\n```sql\nCREATE TABLE genre(\n    genre_id INT PRIMARY KEY AUTO_INCREMENT, \n    name_genre VARCHAR(30)\n);\n```\n\nРекомендации по записи SQL запроса\n- Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово). \n- Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.\n- Имена таблиц и полей - строчными (маленькими) буквами.\nSQL-запрос можно писать на нескольких строках.\n- В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).\n\n## Вставка записи в таблицу\n\nВ таблицу, состоящую из двух столбцов добавим новую строку, при этом в поле1 заносится значение1,  в поле2 - значение2.\n\n```sql\nINSERT INTO таблица(поле1, поле2) \nVALUES (значение1, значение2);\n```\n\nПри составлении списка полей и списка значений необходимо учитывать следующее:\n- количество полей и количество значений в списках должны совпадать;\n- должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый элемент списка значений должен относиться к первому столбцу в списке столбцов, второй – ко второму столбцу и т.д.;\n- типы данных элементов в списке значений должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция - недопустима);\n- новые значения нельзя добавлять в поля, описанные как PRIMARY KEY AUTO_INCREMENT;\n- рекомендуется заполнять все поля записи, если же поле пропущено, значение этого поля зависит от установленных по умолчанию значений, если значения не установлены - на данной платформе вставляется пустое значение (NULL).","date":"2022-07-07T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/create-drop-delete-update-insert-alter/","order":1,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Состав таблицы","anchor":"#состав-таблицы"},{"value":"Основные типы данных SQL","anchor":"#основные-типы-данных-sql"},{"value":"Создание таблицы","anchor":"#создание-таблицы"},{"value":"Вставка записи в таблицу","anchor":"#вставка-записи-в-таблицу"}]}},{"node":{"id":"8254c31741f638f0043c46953a422fae","title":"CI/CD","content":"\n**CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка)** — это технология автоматизации тестирования и доставки новых модулей разрабатываемого проекта заинтересованным сторонам (разработчикам, аналитикам, инженерам качества, конечным пользователям и др.).\n\n## Принципы CI/CD\nКонцепция непрерывной интеграции и развертывания относится к agile-методологиям разработки программного обеспечения. Ее основная цель — уделение достаточного внимания бизнес-требованиям, безопасности и качеству кода конечного продукта. В рамках подхода решаются следующие задачи:\n\n- автоматизация последовательной сборки, упаковки и тестирования программных продуктов;\n- автоматизация развертывания приложения в различных окружениях;\n- минимизация ошибок и уязвимостей программного продукта.\n\nРазработка по методике CI/CD соответствует таким основным принципам:\n- **Распределение ответственности.** Задачи и этапы разработки разделяются между членами команды или ее подгруппами (при работе над большим проектом). Рабочий процесс организуется с учетом бизнес-логистики, внедрения сквозных функций, проведения тестов, безопасности хранения данных и т.д.\n- **Сокращение рисков.** Каждый разработчик или подгруппа разработчиков должны стремиться минимизировать уязвимости и ошибки на всех этапах разработки. Для этого постоянно контролируется бизнес-логистика, проводится пользовательское тестирование продукта, оптимизируется хранение, обработка данных и т.д.\n- **Оптимизация обратной связи.** Успех проекта зависит от того, как работают друг с другом разработчики, клиенты и пользователи. Это влияет на скорость внесения в приложение корректировок и обновлений. Если сборку и тестирование можно автоматизировать, то во многих других операциях требуется участие человека. Чтобы взаимодействие происходило конструктивнее, уменьшается количество посредников между заказчиком, исполнителями и пользователями.\nСоздание рабочей среды. Для удобства совместной работы у разработчиков должно быть общее рабочее пространство. Помимо основной ветки процесса в нем должна быть побочная – в ней удобнее проводить тестирование, вносить корректировки, отслеживать отказоустойчивость и т.д.\n\nСI/CD представляет собой современную аналогию конвейерного производства. Их объединяют четкое распределение труда, непрерывный, потоковый характер рабочего процесса, параллельное выполнение сразу нескольких задач (например, кодинга и тестирования). Сегодня эта концепция является доминирующей в DevOps.\n\n## Этапы CI/CD\n**Написание кода.** Каждый разработчик создает код отведенного ему модуля и тестирует его в ручном режиме. Затем разработанный и проверенный программный блок интегрируется в основной ветке с текущей версией продукта. Как только все модули будут опубликованы в главной ветке, команда переходит к следующему этапу.\n\n**Сборка.** Заранее подобранная система контроля версий запускает автоматизированную сборку и тестирование всего продукта. Триггеры могут быть настроены автоматически или вручную. Автоматическая сборка выполняется с помощью Jenkins или другого сервера непрерывной интеграции.\n\n**Ручное тестирование.** Как только CI-сервер закончит автоматизированную сборку продукта, он передается тестировщикам на проверку. Они используют различные методики тестирования для выявления и устранения ошибок и уязвимостей программы.\n\n**Релиз.** После исправления ошибок вычищенный и отлаженный код переходит на этап релиза для клиентов. Его проверяет заказчик, возможно, с привлечением своих специалистов или ограниченной группы пользователей. По результатам проверки код отправляется на доработку или согласуется.\n\n**Развертывание.** Текущая версия программы размещается на продакшн-серверах разработчика. Заказчик может работать с программой, исследовать ее функции, искать уязвимости.\n\n**Поддержка и отслеживание.** После развертывания приложение становится доступным конечным пользователям. Параллельно этому разработчики выполняют его поддержку и одновременно мониторят реакцию пользователей, анализируют их опыт взаимодействия с программой.\n\n**Планирование.** На основании данных, полученных при изучении пользовательского опыта, разработчик подготавливает план доработок, включающий новые функции, исправление ошибок и т.д. После этого он вносит все корректировки в продукт — и цикл разработки начинается снова.\n\nТаким образом, рабочий процесс по методологии CI/CD включает как последовательные, так и параллельные этапы. Именно для распараллеливания в рабочем пространстве создается побочная ветка — в ней проще вести работу, не вмешиваясь в основной код до тех пор, пока программируемый модуль не будет готов к интеграции. Условно рабочий процесс по методологии CI/CD можно представить в виде следующей схемы:\n\n## Общий принцип CI/CD-разработки\n\n### Преимущества CI/CD\n**Сокращение сроков разработки.** Методология уменьшает время доработок до нескольких дней, в сложных проектах — недель. Это позволяет разработчикам быстрее тестировать и опробовать нововведения, а затем внедрять их в продукт раньше конкурентов.\nОтбор перспективных вариантов. Быстрое тестирование и большое количество итераций позволяют разработчику вовремя отсеивать бесперспективные варианты кода на начальных этапах. Это также способствует экономичному расходованию времени и ресурсов без их распыления на тупиковые направления.\n\n**Качество тестирования.** Сочетание ручной и автоматизированной проверки позволяет выявлять ошибки на ранних этапах разработки. Это снижает вероятность их накопления на этапе релиза, что еще больше сокращает время работы над проектом.\n\n## Недостатки CI/CD\n**Высокие требования к опыту.** Рабочий процесс в любой компании можно перевести на методологию CI/CD. Однако это требует от разработчиков как знания самой концепции на практическом уровне, так и умения быстро реорганизовать процессы в самой организации. Иными словами, CI/CD имеет достаточно большой порог вхождения в сравнении со многими традиционными методологиями.\n\n**Сложность постоянного взаимодействия.** Непрерывная интеграция и доставка программного продукта требуют от разработчиков высокой скоординированности действий. На практике это означает, что должно быть отдельное лицо, которое занимается организацией рабочего процесса и налаживанием взаимодействия между членами команды.\n\n## Инструменты для CI/CD\nТак как непрерывная интеграция и развертывание подразумевает автоматизацию многих процессов в ходе разработки, для этого созданы различные программные инструменты и сервисы:\n\n**GitLab.** Эта платформа позволяет управлять хранилищами проекта, документировать результаты тестирования и доработок, анализировать и дополнять функциональность проекта, выявлять и устранять ошибки.\n\n**Docker.** СD-система, позволяющая контейнеризировать проект, то есть упаковать его со всем окружением и зависимостями.\n\n**Travis-CI.** Сервер, который можно подключать к виртуальным репозиториям GitHub с минимальными настройками. Благодаря использованию облачных технологий его не нужно отдельно устанавливать.\n\n**Jenkins.** Один из самый популярных DevOps-инструментов, совместимый со всевозможными плагинами для адаптации под различные проекты и задачи.\n\n**PHP Censor.** CI-сервер, автоматизирующий сборку PHP-проектов. Может работать с репозиториями GitLab, Mercurial и другими, с библиотеками для тестирования Atoum, PHP Spec, Behat.\n\nВозможность оперативно вносить изменения, постоянно тестировать и дорабатывать продукт, взаимодействовать не только друг с другом, но и с клиентом — вот что делает концепцию CI/CD популярной среди разработчиков. Сегодня ее понимание и практическое освоение являются важной рекомендацией при разработке как крупных, так и небольших проектов.\n\nhttps://www.youtube.com/watch?v=7S1ndRRht6M\n\n## Вопросы\n\n### Какие стадии должны быть в любом пайплайне?\n\n- build\n- test - unit, integration tests\n- lint - metrics chacks: coverage, code analysis\n- deploy\n- system tests: api tests, ui tests\n\n### Что такое Continuous Integration и Continuous Deployment? В чем разница между Continuous Deployment и Continuous Delivery?\nContinuous Integration (CI) - непрерывная интеграция, это практика разработки программного обеспечения, при которой члены команды часто интегрируют свою работу. Интеграция это слияние новой версии кода со стабильной и проверка, что при этом ничего не сломалось. \n\nРазница между Continuous Delivery и Continuous Deployment очень маленькая. Представим два пайплайна для одного и того же приложения. В каждом есть шаги:\n\nSource Control - внесение изменений в систему контроля версий ПО\nBuild - сборка приложения и прогон unit тестов\nStaging - деплой на тестовое окружение, прогон интеграционных, нагрузочных и других тестов\nProduction - деплой на окружение с пользователями\nКаждый пайплайн запускается автоматически по триггеру из системы контроля версий. В случае Continuous Deployment каждый следующий шаг, будет выполнен автоматически если предыдущий был успешный, включая деплой на Production.\n\nЕсли же у вас Continuous Delivery, то шаги будут выполняться автоматически только в безопасной среде, а перед деплоем на Production пайплайн остановится и будет ждать ручного подтверждения. Механизм, как это будет реализовано может быть разным. От самого простого, когда ответственный человек должен зайти в пайплайн и нажать кнопку Next, до интерактивного бота с кнопками в корпоративном мессенджере.\n\nЗачем нужен ручной апрув перед деплоем на Production, ведь это тормозит пайплайн т.е. доставку фич и исправлений багов? Вопрос резонный, но ответ такой же. Не все проекты одинаковые, есть такие в которых решение о деплое на Production должно быть принято человеком ответственно и осознанно. Когда бизнес сложный, с большим количеством факторов и нельзя переложить выбор “деплоить или нет” на пару алгоритмических критериев, тогда и применяется Continuous Delivery, а не Continuous Deployment.\n\n\n52. Опишите основные этапы CI/CD.\n момент, когда триггерится сборка, например, когда разработчик сделал коммит в свою ветку, запускается процесс, который выполняется специально написанными скриптами и утилитами. Этот процесс состоит из нескольких обязательных шагов. Простой пример для PR:\n\nПри открытии каждого Pull Request, Git-сервер отправляет уведомление CI-серверу;\nCI-сервер клонирует репозиторий, проверяет исходную ветку (например bugfix/wrong-sorting), и сливает код с кодом master-ветке;\nТогда запускается билд-скрипт (сценарий сборки). Например ./gradlew build;\nЕсли эта команда возвращает код ответа “0”, то билд успешно выполнен. (Другой ответ означает ошибку);\nCI-сервер направляет уведомление об успешном билде на Git-сервере;\nЕсли билд был успешен, то Pull Request разрешается слить с существующим кодом. (Если не успешен, то, соответственно, не разрешается).\nОшибка в любом из шагов приводит к полному падению всей сборки. Ну и, само собой разумеется, шаги расположены в таком порядке, чтобы сужать воронку потенциальных проблем. Если Quality Gate предыдущего этапа не пройдет, то на проверку следующего уже можно не тратить ресурсы.\n\nПример Quality Gates, которые встроены в pipeline отсюда:\n\nСборка сервиса:\nПроверка наличия конфигурации корректного формата;\nПроверка стандартов оформления кода;\nПроверка на необходимое покрытие Unit-тестами;\nГенерации и публикации контрактов (контроль обратной совместимости).\nЗапуск Beta-тестов;\nОбязательный code-review;\nСканирование на уязвимости.\nПример сферического пайплайна в вакууме отсюда:\n\nCode scanning: код проверяется на соответствие общему гайдлайну (linters), уязвимости (code security) и качество (code quality);\nUnit tests;\nBuild: этап для сборки artifacts/packages/images и т.д. Здесь уже можно задуматься о том, каким будет стратегия версионирования всего приложения. Во времена контейнеризации, в первую очередь интересуют образы для контейнеров и способы их версионирования;\nScan package: пакет/образ собрали. Теперь нужно просканировать его на уязвимости. Современные registry уже содержат инструментарий для этого;\nDeploy: стадия для развертывания приложения в различных окружениях;\nIntegration testing: приложение задеплоили. Оно где-то живет в отдельном контуре. Наступает этап интеграционного тестирования. Тестирование может быть как ручным, так и автоматизированным;\nPerformance testing (load/stress testing): данный вид тестирования имеет смысл проводить на stage/pre-production окружениях. С тем условием, что ресурсные мощности на нем такие же, как в production;\nCode Review / Approved: одним из важнейших этапов являются Merge Request. Именно в них могут производиться отдельные действия в pipeline перед слиянием, а также назначаться группы лиц, требующих одобрения перед слиянием.\n\n\n53. Опишите пример процесса CI (и/или CD), который начинается с момента, когда разработчик запушил изменения/PR в Git?\n\n54. Расскажите о разновидностях тестов, которые мы можем использовать в CI пайплайне.\n\n55. Какие инструменты CI вы использовали? Есть ли опыт работы с Jenkinsfile?\n\n56. Какие виды тестов вы знаете и зачем они нужны?\n\n72. Как автоматическое тестирование интегрируется в CI?\n\n73. Как настроить Job или Pipeline на знакомом вам CI-инструменте?\n\n74. Какие инструменты для генерации репорта после выполнения автоматических тестов вы знаете?\n\n75. Какую информацию должен содержать отчет о выполнении автоматических тестов?","date":"2022-07-27T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/ci-cd/","order":2,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"},{"title":"CI","path":"/tag/CI/"},{"title":"CD","path":"/tag/CD/"}],"headings":[{"value":"Принципы CI/CD","anchor":"#принципы-cicd"},{"value":"Этапы CI/CD","anchor":"#этапы-cicd"},{"value":"Общий принцип CI/CD-разработки","anchor":"#общий-принцип-cicd-разработки"},{"value":"Недостатки CI/CD","anchor":"#недостатки-cicd"},{"value":"Инструменты для CI/CD","anchor":"#инструменты-для-cicd"},{"value":"Вопросы","anchor":"#вопросы"}]}},{"node":{"id":"e32cda98ac188fcccf94b3fd1cf66fcf","title":"Docker","content":"\nDocker - это средство упаковки (в контейнеры), доставки и запуска (запуск осуществляется одним и тем же образом, единый интерфейс) приложения.\nДокер - это история про виртуализацию, но не ту какую вам предоставляют виртуальные машины, которые разворачивают полноценную ОС внутри вашей. Главная задача Докера запустить приложение. \n\n## Базовые понятия\n\nDocker image - это сборка, говтовое к запуску приложение, но еще не запущеное.\n\nDocker container -  работающее приложение, созданное на базе имеджа.\n\nНа основе одного образа можно создать много одинаковых контейнеров.\nНапример, нужно 10 реплик одного сервиса.\n\nДля контейнера образ является read only системой, он не может его изменить.\n\nImage - слоеный пирог, напрмиер image Ubuntu и возьмем его за базу и поставим туда Nginx и поставим туда mongo и поставим питон.\n\nРеестр имеджей - он находится локально там хранятся те images которые создали именно вы.  \nТакже есть docker hub - там реестр всех имеджей, которые поддерживаются создателями докера но так же и те которые создавали другие люди.\n\n## Посмотреть images\n\n```\ndocker images\n```\n\n## Посмотреть запущенные контейнеры\n\n```\ndocker ps\n```\n\n-a - посмотреть в том числ остановленные контейнеры\n-a -q - отобразить только id контейнера\n\n## Создаем свой докер образ\n\n```\ndocker build -t hello-world .\n```\n\ndocker build - команда для создания образа\n-t - тег, название образа\n. - путь к текущей директории (где находится приложение)\n\nТакже нужно указать как именно нужно упаковать приложение, для этого создается Dockerfile.\n\nВ Dockerfile нужно описать шаги для упаковки нашего приложения.\n\n```docker\nFROM python:3.6 \n\nRUN mkdir -p /usr/src/app/\nWORKDIR /usr/src/app/\n\nCOPY . /usr/src/app/\n\nCMD [\"python\", \"app.py\"]\n```\n\n- FROM - базовый образ, через :(двоеточие) указывается тег\n- RUN - указывает что нужно выполнить указанную команду\n- WORKDIR - начальный каталог в который нужно перейти\n- COPY - копирует содержимое из источника в целевую папкув контейнере\n- CMD - указывает какие команды нужно выполнить когда мы запустим контейнер, запускает команды через shell \n- ENTRYPOINT - аналог CMD, но команды выполняются без shell оболочки\n\n## Запуск контейнера\n\n- запуск контейнера  \ndocker run <имя образа>\n```\ndocker run hello-world\n```\n\nКонтейнер работает до тех пор пока работает приложение.\n\n- задаем имя контейнера при запуске  \ndocker run **--name** <имя контейнера> <имя образа>\n```\ndocker run --name hello hello-world\n```\n\n- запуск контейнера в фоне, чтобы можно было работать с консолью  \ndocker run --name <имя контейнера> **-d** <имя образа>\n```\ndocker run --name hello -d hello-world\n```\n\n- запуск контейнера с автоудалением после остановки  \ndocker run --name <имя контейнера> -d **--rm** <имя образа>\n```\ndocker run --name hello -d --rm hello-world\n```\n\n## Удалить контейнер\n\nНапример те которые уже отработали\n\n- удалить один контейнер\ndocker rm <id контейнера>\ndocker rm <имя контейнера>\n```\ndocker rm 1e0c7cd00041\n```\n\n- удалить все контейнеры\ndocker rm $(docker ps -qa) \n\n## Остановить контейнер\n\n- docker stop <id контейнера>\n- docker stop <имя контейнера>\n\n## Проброска портов\n\nКонтейнер собирается в полностью изолированном окружении и если явно не пробросить порты то приложение будет не видно.\n\nЧтобы пробросить порт нужно в Dockerfile указать EXPOSE 8080 тем самым мы указываем что мы можем этот порт пробросить.\n\nЧтобы выполнить проброску нужно при запуске контейнера указать флаг -p и через двоеточие 2 порта (1- порт нашей машины, 2 - порт в контейнере)\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 hello-world\n```\n\n## Переменные окружения\nМожно указать в Dockerfile\n\nENV <название переменной> <значение>\n\nно иногда переменные нужно менять поэтому можно указывать переменные при запуске контейнера\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 -e <имя переменной>=<значение> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -e TZ=Europe/Moscow hello-world\n```\n\n## Работа с внешними данными\n\n1. монтируем папку\nделается это при запуске контейнера через параметр -v\n\ndocker run --name <имя контейнера> --rm -p 8080:80880 -v <папка на хостовой машине(абсолютный путь)>:<папка в контейнере(абсолютный путь)> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -v ...:... hello-world\n```\n\n2. docker volume\n\nпосмотреть какие volume доступны\n\n```\ndocker volume ls\n```\n\nчтобы создать volume\n\n```\ndocker volume create <имя>\n```\n\nтеперь при запуске можно указать \n\ndocker run --name <имя контейнера> --rm -v <имя volume>:<папка в контейнере(абсолютный путь)> <имя образа>\n```\ndocker run --name hello --rm -p 8080:80880 -v ...:... hello-world\n```\n\n## Удалить image\n\ndocker rmi <имя image>\n\n## Получить список images id \n\ndocker images -q\n\n## Удалить все images\n\ndocker rmi $(docker images -q)\n\n## Многосервисная архитектура \n\nДля каждого сервиса имеется свой Dockerfile. \nЕсли через docker run выполнять настройке переменных когда есть много сервисов это не совсем удобно.\n\nДля этого используется docker-compose - надстройка над докером.\n\nДля его использования нужно создать docker-compose.yaml\n\n\nуказываем версию, volumes и описываем настройки каждого сервиса\n\n**Настройки сервиса:**\n\nbuild: указываем откуда взять Dockerfile либо image: mongo:latest если нужно взять готовый образ\n\nvolumes: \n  - <имя volume>:<абсолютный путь к папке в контейнере>\n\nports: - проброска портов\n  - 8080:8080 \n\nrestart: always - если вдруг машина перезагрузится то докер сам перезапустит контейнеры\n\nenvironment: - перечисляем переменные окружения\n- TZ=Europe/Moscow\n\n## Создаем ssh ключ\n\nпереходим из домашнего каталога в .ssh и запускаем ssh-keygen, затем выводим на экран публичный ключ\n\n```\ncd .ssh\nssh-keygen -t rsa\n# задаем имя, например vscale\ncat vscale.pub | pbcopy\n```\n\nсоздаем в папке .ssh файл config\n```\nvim config\n```\n\nУказываем в config настройки\n\nhost <имя хоста пожеланию>\n  hostname <шз адрес сервера>\n  user root\n  IdentityFile ~/.ssh/vscale\n\nСозряняем и выполняем команду \nssh vs\n\n## Устанавливаем docker на сервере\n\n```\nsudo apt update\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\nsudo add-app-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\"\nsudo apt install docker-ce\n```\n\n## Устанавливаем docker-compose на сервере\n\n```\nsudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s` -`uname -m` -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n```\n\n## Запуск docker-compose\ndocker-compose up -d\n\n-d - чтобы контейнеры в фоне работали\n\n## Остановить docker-compose\ndocker-compose down -d\n\n## Работа с docker hub\n\nСоздать свой репозиторий можно с сайта hub.docker.com нажав Create Repository  \nлибо просто запушив свои первый image\n\nнужно в имя образа вставить идентификатор пользователя и через / имя репозитория\n\n```\ndocker build -t artemproject/statisticmanager .\ndocker login\ndocker push artemproject/statisticmanager\n```\n\n## Запуск postgres в docker\nЧтобы запустить postgres в docker нужно:\n\n1. Сделать pull image\n\n```docker\ndocker pull postgress\n```\n\n2. Запустить инстанс докера\n\n```docker\ndocker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres\n```\n\n--name - имя контейнера на локальной машине\nPOSTGRES_PASSWORD= - здесь указывается пароль\n-d (detach) необходимо указывать для того чтобы терминал оставвался терминалом локального компьютера, а не терминалом БД\npostgres - название контейнера который мы будем запускать\n-p 5432:5432 - проброс портов, порт внутри контейнера будет соответсвовать порту нашего компьютера\n\n3. Проверяем запущенные контейнеры\n\n```docker\ndocker ps -a\n```\n\nДля работы с БД нужно подключить Postgress JDBC - `'org.postgresql:postgresql:42.3.6'`\nи часть фреймворка Spring для работы с БД - `'org.springframework:spring-jdbc:5.3.20'`\n\nсистема виртуализации для запуска приложения в ихолированной среде.\n\nSELECT departamens.name FROM departamens LEFT JOIN users ON users.departament_id = departamens.id WHERE users.departament_id IS NULL;\n\n\n\n\n","date":"2022-07-28T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/docker/","order":2,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Базовые понятия","anchor":"#базовые-понятия"},{"value":"Посмотреть images","anchor":"#посмотреть-images"},{"value":"Посмотреть запущенные контейнеры","anchor":"#посмотреть-запущенные-контейнеры"},{"value":"Создаем свой докер образ","anchor":"#создаем-свой-докер-образ"},{"value":"Запуск контейнера","anchor":"#запуск-контейнера"},{"value":"Удалить контейнер","anchor":"#удалить-контейнер"},{"value":"Остановить контейнер","anchor":"#остановить-контейнер"},{"value":"Проброска портов","anchor":"#проброска-портов"},{"value":"Переменные окружения","anchor":"#переменные-окружения"},{"value":"Работа с внешними данными","anchor":"#работа-с-внешними-данными"},{"value":"Удалить image","anchor":"#удалить-image"},{"value":"Получить список images id","anchor":"#получить-список-images-id"},{"value":"Удалить все images","anchor":"#удалить-все-images"},{"value":"Многосервисная архитектура","anchor":"#многосервисная-архитектура"},{"value":"Создаем ssh ключ","anchor":"#создаем-ssh-ключ"},{"value":"Устанавливаем docker на сервере","anchor":"#устанавливаем-docker-на-сервере"},{"value":"Устанавливаем docker-compose на сервере","anchor":"#устанавливаем-docker-compose-на-сервере"},{"value":"Запуск docker-compose","anchor":"#запуск-docker-compose"},{"value":"Остановить docker-compose","anchor":"#остановить-docker-compose"},{"value":"Работа с docker hub","anchor":"#работа-с-docker-hub"},{"value":"Запуск postgres в docker","anchor":"#запуск-postgres-в-docker"}]}},{"node":{"id":"8411675ac667afb9e4f5fb5ff1339541","title":"Базовые запросы с использованием LIKE, BETWEEN, ORDER BY, ALIASES, IN, TOP-LIMIT, DISTINCT","content":"\n## Выборка всех данных из таблицы\n\nДля того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры:\n\nключевое слово SELECT; \nсимвол « *» ; \nключевое слово FROM; \nимя таблицы.\n\n```sql\nSELECT * FROM book;\n```\n\n## Выборка отдельных столбцов\n\nДля того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: \n\nключевое слово SELECT ; \nсписок столбцов таблицы через запятую; \nключевое слово FROM ; \nимя таблицы.\n\n```sql\nSELECT title, amount FROM book;\n```\n\n## AS - Выборка новых столбцов и присвоение им новых имен\n\nДля того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые имена используется SQL запрос следующей структуры: \n\nключевое слово SELECT ; \nимя столбца;\nключевое слово AS ; \nновое название столбца (можно русскими буквами), но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, Количество_книг ; \nзапятая; \nимя столбца; \n.... \nключевое слово FROM ; \nимя таблицы.\n\nРезультатом является таблица, в которую включены все данные из указанных после SELECT столбцов исходной таблицы. Каждому столбцу присваивается новое имя, заданное после AS, или столбец получает имя столбца исходной таблицы, если AS отсутствует.\n\n```sql\nSELECT title AS Название, amount \nFROM book;\n```\n\n## Выборка данных, вычисляемые столбцы, математические функции\n\nС помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора SELECT указывается выражение и задается имя.\n\nВыражение может включать имена столбцов, константы, знаки операций, встроенные функции.\n\nРезультатом является таблица, в которую включены все данные из указанных после SELECT столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.\n\n```sql\nSELECT title, author, price, amount, \n     price * amount AS total \nFROM book;\n```\n\nВ SQL реализовано множество  математических функций для работы с числовыми данными. В таблице приведены некоторые из них.\n\n|Функция|\tОписание|\tПример|\n|---|---|---|\n|CEILING(x)|\tвозвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)|CEILING(4.2)=5 CEILING(-5.8)=-5|\n|ROUND(x, k)|округляет значение x до k знаков после запятой, если k не указано – x округляется до целого|ROUND(4.361)=4 ROUND(5.86592,1)=5.9|\n|FLOOR(x)|возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)|FLOOR(4.2)=4 FLOOR(-5.8)=-6|\n|POWER(x, y)|возведение x в степень y|POWER(3,4)=81.0|\n|SQRT(x)|квадратный корень из x|SQRT(4)=2.0 SQRT(2)=1.41...|\n|DEGREES(x)|конвертирует значение x из радиан в градусы\t|DEGREES(3) = 171.8...|\n|RADIANS(x)|конвертирует значение x из градусов в радианы|\tRADIANS(180)=3.14...|\n|ABS(x)\t|модуль числа x\t|ABS(-1) = 1 ABS(1) = 1|\n|PI()\t|pi = 3.1415926...\t ||\n\nСуществуют разные способы округления чисел. В SQL реализовано математическое округление. Для округления вещественного числа нужно в записи числа выбрать разряд в дробной части, до которого производится округление. Цифра, записанная в выбранном разряде: не меняется, если следующая за ней справа цифра - 0, 1, 2, 3 или 4; увеличивается на единицу, если следующая за ней справа цифра - 5,6,7,8 или 9.\n\n```sql\nSELECT title, \n    price, \n    ROUND((price*18/100)/(1+18/100),2) AS tax, \n    ROUND(price/(1+18/100),2) AS price_tax \nFROM book;\n```\n\n## Выборка данных, вычисляемые столбцы, логические функции\n\nВ SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF:\n\n```IF(логическое_выражение, выражение_1, выражение_2)```\nФункция вычисляет `логическое_выражение`, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.\n\nДопускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `IF`.\n\n```sql\nSELECT title, amount, price, \n    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale\nFROM book;\n```\n\n```sql\nSELECT title, amount, price,\n    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,\n    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка\nFROM book;\n```\n\n## Выборка данных по условию\n\nС помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово WHERE и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.\n\nЛогическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.\n\n```sql\nSELECT title, price \nFROM book\nWHERE price < 600;\n```\n\n## Выборка данных, логические операции\n\nЛогическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.\n\nПриоритеты операций:\n1. круглые скобки\n2. умножение  (*),  деление (/)\n3. сложение  (+), вычитание (-)\n4. операторы сравнения (=, >, <, >=, <=, <>)\n5. NOT\n6. AND\n7. OR\n\n```sql\nSELECT title, author, price \nFROM book\nWHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;\n```\n\nВ данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  author = 'Есенин С.А.' and price > 600, а потом уже выражение через or. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше 600.\n\n## Операторы BETWEEN, IN - выборка данных\n\nЛогическое выражение после ключевого слова WHERE может включать операторы  BETWEEN и IN. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.\n\n### Оператор BETWEEN\nОператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.\n\n```sql\nSELECT title, amount \nFROM book\nWHERE amount BETWEEN 5 AND 14;\n```\n\n### Оператор  IN\nОператор  IN  позволяет выбрать данные, соответствующие значениям из списка.\n\n```sql\nSELECT title, price \nFROM book\nWHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');\n```\n\n## Оператор ORDER BY - выборка данных с сортировкой\n\nПри выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию). \n\nСтолбцы после ключевого слова ORDER BY можно задавать:\n- названием столбца;\n- номером столбца;\n- именем столбца (указанным после AS).\n\n```sql\nSELECT title, author, price\nFROM book\nORDER BY title;\n```\n\n## Оператор LIKE - выборка данных\nОператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.\n\n|Символ-шаблон|\tОписание|\tПример|\n|---|----|---|\n|%\t|Любая строка, содержащая ноль или более символов|\tSELECT * FROM book WHERE author LIKE '%М.%' - выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»|\n|_ (подчеркивание)|\tЛюбой одиночный символ|\tSELECT * FROM book WHERE title LIKE 'Поэм_' - выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.|\n\n\n| Шаблон | Описание |\n| --- | --- |\n| 'Б%' | значение, начинающееся с буквы «Б». |\n| \"_ _ _ _ _\" | значение, состоящее ровно из 5 букв |\n| \"_ _ _ _ _ _%\" | значение  длиннее 5 символов |\n| title LIKE \"\\_% и \\_%\" _(отбирает слово И внутри названия)_ <br><br> OR title LIKE \"и \\_%\" _(отбирает слово И в начале названия)_ <br><br> OR title LIKE \"\\_% и\" _(отбирает слово И в конце названия)_ <br><br> OR title LIKE \"и\" | Значение которое содержит букву \"и\" как отдельное слово, если считать, что слова отделяются друг от друга пробелами и не содержат знаков препинания. |\n|\"% %\" | значение состоит ровно из одного слова|\n|\"_% %\" | значение состоит из двух и более слов |\n\n## Оператор DISTINCT - Выбор уникальных элементов столбца\n\nЧтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.\n\n```sql\nSELECT DISTINCT author\nFROM book;\n```\n\n## Оператор GROUP BY - Выбор уникальных элементов столбца\n\nОператор GROUP BY группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после GROUP BY .\n\nС помощью GROUP BY можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании DISTINCT.\n\n```sql\nSELECT  author\nFROM book\nGROUP BY author;\n```\n\n## Групповые функции SUM и COUNT - Выборка данных\n\nПри группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.\n\n```sql\nSELECT author, sum(amount), count(amount)\nFROM book\nGROUP BY author;\n```\n\n1. В таблице book определяются строки, в которых в столбце author одинаковые значения\n2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это author)\n3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция SUM(), а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае amount)\n4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция COUNT(), в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает COUNT(), если в группе есть пустые значения)\n\nФункцию COUNT() можно применять к любому столбцу, в том числе можно использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения Null, то\n- COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;\n- COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.\n\n## Групповые функции MIN, MAX и AVG\n\nК групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.\n\n```sql\nSELECT author, MIN(price) AS min_price\nFROM book\nGROUP BY author;\n```\n\n## Выборка данных c вычислением, групповые функции\n\nВ качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.\n\n```sql\nSELECT author, SUM(price * amount) AS Стоимость\nFROM book\nGROUP BY author;\n```\n\n```\n+------------------+-----------+\n| author           | Стоимость |\n+------------------+-----------+\n| Булгаков М.А.    | 4715.47   |\n| Достоевский Ф.М. | 11802.03  |\n| Есенин С.А.      | 9750.00   |\n+------------------+-----------+\n```\n\n```sql\nSELECT author, ROUND(AVG(price),2) AS Средняя_цена\nFROM book\nGROUP BY author;\n```\n\n## Вычисления по таблице целиком\n\nГрупповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.\n\n```sql\nSELECT SUM(amount) AS Количество\nFROM book;\n```\n\n## Выборка данных по условию, групповые функции\nВ запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.\n\n```sql\nSELECT author,\n    MIN(price) AS Минимальная_цена, \n    MAX(price) AS Максимальная_цена\nFROM book\nGROUP BY author\nHAVING SUM(price * amount) > 5000; \n```\n\nТакже в запросах с группировкой можно сортировать данные.\n\n```sql\nSELECT author,\n    MIN(price) AS Минимальная_цена, \n    MAX(price) AS Максимальная_цена\nFROM book\nGROUP BY author\nHAVING SUM(price * amount) > 5000 \nORDER BY Минимальная_цена DESC;\n```\n\nWHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:\n\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY\n","date":"2022-07-07T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/bazovye-zaprosy-s-ispolzovaniem-like-between-order-by-aliases-in-top-limit-distinct/","order":2,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Выборка всех данных из таблицы","anchor":"#выборка-всех-данных-из-таблицы"},{"value":"Выборка отдельных столбцов","anchor":"#выборка-отдельных-столбцов"},{"value":"AS - Выборка новых столбцов и присвоение им новых имен","anchor":"#as---выборка-новых-столбцов-и-присвоение-им-новых-имен"},{"value":"Выборка данных, вычисляемые столбцы, математические функции","anchor":"#выборка-данных-вычисляемые-столбцы-математические-функции"},{"value":"Выборка данных, вычисляемые столбцы, логические функции","anchor":"#выборка-данных-вычисляемые-столбцы-логические-функции"},{"value":"Выборка данных по условию","anchor":"#выборка-данных-по-условию"},{"value":"Выборка данных, логические операции","anchor":"#выборка-данных-логические-операции"},{"value":"Операторы BETWEEN, IN - выборка данных","anchor":"#операторы-between-in---выборка-данных"},{"value":"Оператор ORDER BY - выборка данных с сортировкой","anchor":"#оператор-order-by---выборка-данных-с-сортировкой"},{"value":"Оператор LIKE - выборка данных","anchor":"#оператор-like---выборка-данных"},{"value":"Оператор DISTINCT - Выбор уникальных элементов столбца","anchor":"#оператор-distinct---выбор-уникальных-элементов-столбца"},{"value":"Оператор GROUP BY - Выбор уникальных элементов столбца","anchor":"#оператор-group-by---выбор-уникальных-элементов-столбца"},{"value":"Групповые функции SUM и COUNT - Выборка данных","anchor":"#групповые-функции-sum-и-count---выборка-данных"},{"value":"Групповые функции MIN, MAX и AVG","anchor":"#групповые-функции-min-max-и-avg"},{"value":"Выборка данных c вычислением, групповые функции","anchor":"#выборка-данных-c-вычислением-групповые-функции"},{"value":"Вычисления по таблице целиком","anchor":"#вычисления-по-таблице-целиком"},{"value":"Выборка данных по условию, групповые функции","anchor":"#выборка-данных-по-условию-групповые-функции"}]}},{"node":{"id":"5ba3e2265e1b5bfd3ea7cdfeae9d571f","title":"Объединение таблиц(вложенные запросы, джойны","content":"\nВложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:\n\nсравнения выражения с результатом вложенного запроса;\nопределения того, включено ли выражение в результаты вложенного запроса;\nпроверки того, выбирает ли запрос определенные строки.\nВложенный запрос имеет следующие компоненты:\n\nключевое слово SELECT  после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент) ;\nключевое слово FROM и имя таблицы, из которой выбираются данные;\nнеобязательное предложение WHERE;\nнеобязательное предложение GROUP BY:\nнеобязательное предложение HAVING.\n Вложенные запросы  могут включаться в WHERE или HAVING так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):\n\nWHERE | HAVING выражение оператор_сравнения (вложенный запрос);\nWHERE | HAVING выражение, включающее вложенный запрос;\nWHERE | HAVING выражение [NOT] IN (вложенный запрос);\nWHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос).\nТакже вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT\n\nВложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.\n\n```sql\nSELECT title, author, price, amount\nFROM book\nWHERE price = (\n         SELECT MIN(price) \n         FROM book\n      );\n```\nВложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.\n\n```sql\nSELECT title, author, amount \nFROM book\nWHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;\n```\n\nВложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором IN.\n\n```WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)```\n\nОператор IN определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после WHERE получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE author IN (\n        SELECT author \n        FROM book \n        GROUP BY author \n        HAVING SUM(amount) >= 12\n      );\n```\n```sql\nSELECT author, title, amount\nFROM book\nWHERE author IN (\n        SELECT amount \n        FROM book \n        GROUP BY amount \n        HAVING COUNT(amount) = 1\n);\n```\n\n## Вложенный запрос, операторы ANY и ALL\nВложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).\n\nОператоры ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.\n\nПри использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY:\n\namount > ANY (10, 12) эквивалентно amount > 10\n\namount < ANY (10, 12) эквивалентно amount < 12\n\namount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)\n\namount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12\n\nПри использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:\n\namount > ALL (10, 12) эквивалентно amount > 12\n\namount < ALL (10, 12) эквивалентно amount < 10\n\namount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)\namount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12\n\nВажно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.\n\nВывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE amount < ALL (\n        SELECT AVG(amount) \n        FROM book \n        GROUP BY author \n      );\n```\n\nВывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.\n\n```sql\nSELECT title, author, amount, price\nFROM book\nWHERE amount < ANY (\n        SELECT AVG(amount) \n        FROM book \n        GROUP BY author \n      );\n```\n\n## Вложенный запрос после SELECT\nВложенный запрос может располагаться после ключевого слова SELECT. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.\n\nПример\n\nВывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.\n\nЗапрос:\n```sql\nSELECT title, author, amount, \n    (\n     SELECT AVG(amount) \n     FROM book\n    ) AS Среднее_количество \nFROM book\nWHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;\n```\n\n```\n+-----------------------+------------------+--------+--------------------+\n| title                 | author           | amount | Среднее_количество |\n+-----------------------+------------------+--------+--------------------+\n| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |\n| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |\n| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |\n+-----------------------+------------------+--------+--------------------+\n```\n\n","date":"2022-07-07T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/obedinenie-tablicz-vlozhennye-zaprosy-dzhojny/","order":2,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Вложенный запрос, операторы ANY и ALL","anchor":"#вложенный-запрос-операторы-any-и-all"},{"value":"Вложенный запрос после SELECT","anchor":"#вложенный-запрос-после-select"}]}},{"node":{"id":"fdabea050bd600941e7f616a86f828f0","title":"Kubernetes","content":"\n## Kubernetes\nKubernetes - открытая платформа созданная для автомтаического деплоя, масштабирования и оперирования контейнерами приложений.\n\nПортативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами которая облегчает как декларативную настройку так и автоматизацию.\n\nKubernetes состоит из нод. Как правило рекомендуют использовать не менее 3х нод для Kubernetes. \nMaster Node и 2 Work Nodes. \n\n**Master Node** - отвечает за поддержание желаемого состояния для вашего кластера.\nС Master Node взаимодействует kubectl - интерфейс командной строки, который позволяет через командную строку управлять Kubernetes кластером.\n\nС другой стороны у нас есть пользователь, который через интернет обращается к нашему приложению через Work Node и через kube-proxy ходит непосредственно на pod'ы.Основные фундаментальные концепции Kubernetes -  это pod и node, а также kublet, kube-proxy, etcd.\n\n**Nodes(узлы)** - это виртуальные либо физические машины в Kubernetes кластере на которых будут запускаться контейнеры.\nНода содержит kublet, Docker, kube-proxy. Также нода может содержать 1 или несколько под.\n\n**Pod** - минимальный юнит в Kubernetes с которым можно взаимодействовать, абстрактный объект Kubernetes представляющий группу из одного или нескольких контейнеров приложения (например Docker).\n\nПоды можно создавать, деплоить и удалять. Одна пода - один процесс в кластере. \nПод содержит: Docker container, storage resources, уникальный IP. \n\n**Cluster** - совокупность мастер-сервисов и нод.\n\n**Namespace** - это способ разделения ресурсов кластера между несколькими пользователями.\nНапример, namespace команд, проектов и тд.\n\nЧтобы зайти в кластер и начать запускать команды нужно установить kubectl.\n\nkubectl - это инструмент командной строки kubernetes, который позволяет запускать команды для кластеров Kubernetes. Вы можете использовать kubectl для развертывания приложений проверки и управлени ресурсов кластера а также просмотра логов\n\n### Жизненный цикл Pod\n\n- Pending - ожидание, под ждет ресурсов. Под был принят кластером но один или несколько контейнеров еще не были запущены и нужно подождать.\n- Running - запуск, созданы контейнеры необходимые для пода и запуска непосредственно на этой ноде. Под привязан к узлу и все контейнеры созданы.\n- ContainerCreating - собираются контейнеры.\n- Succeeded/Completed - успешный запуск, все контейнеры созданы, работают, нода запущена.\n- CreateContainerConfigError - ошибка конфигурации.\n- Failed - неуспешный запуск, запуск зафейлился приходит response != 1\n- CrashLoopBackOff - под уходит в бесконечный цикл. Под был запущен крашнулся перезапустился и заново крашнулся (установлено значение restartPolicy: Always) нужно изучить логи.\n- Terminating -  трафик не идет на под, под тушится после его удаления\n\nЧтобы работало автодоплнение нужно выполнить команду:\n\n```\nsource <(kubectl completion bash)\n```\n\nДалее нужно получить доступ к кластеру:\n\n- Получить список всех неймспейсов\n```\nkubectl get namespaces\n```\n\n- получить список всех подов во всех неймспейсах\n```\nkubectl get pods --all-namespaces\n```\n\n- получить список всех подов во всех неймспейсах там где есть название ssr с подробным выводом логов\n```\nkubectl get pods --all-namespaces -o wide |grep ssr\n```\n\n- получить список подов в определенном неймспейсе\n```\nkubectl get pods -n core-team\n```\n\n```\nkubectl get pods -n core-team|grep besida-madmax\n```\n\nПосле того как вышел список подов мы можем увидеть статусы в которых они находятся:\n\n- Обзор запущенного пода\n```\nkubectl -n core-team describe pod besida-trunk-ua-685d5d4f-hpdw2\n```\n\n- Вывести логи пода \n```\nkubectl -n core-team logs besida-trunk-ua-685d5d4f-hpdw2\n```\n\nотображает логи на лету\n```\nkubectl -n core-team logs -f besida-trunk-ua-685d5d4f-hpdw2\n```\n\n### Controllers\n\nУправляется Controller Manager'ом. \n\nВиды контроллеров:\n- ReplicaSets - проверяет что необходимое количество pod запущено все время. Если pods стало меньше (например одна изпод закрешилась), то replicaSet создаст новую. ReplicaSets существует не самостоятельно а в рамках Deployment.\n\n- Deployments - предоставляет декларативное описание для апдейта ReplicaSet и Pod. В ранних версиях Kubernetes вместо ReplicaSet и Deployment использовался Replication Controller. Но это нарушало принцип single responsibilities и в дальнейшем он был разделен и облегчилась задача rollback'a - если во время деплоймента что то пошло не так то в текущих условиях легко откатиться назад и востановить работоспособность приложения.  \n\n- DeamonSets - проверяет что на каждой ноде запущен экземпляр конкретной поды. Если ноды добавляются в кластер или удаляются из кластера то DeamonSet добавить или удалить поды на этой ноде. Удаление DeamonSet означает удаление всех под из кластера.\n\n- Jobs - это процесс верхнего уровня для пода. Используется когда нужно запустить pod для выполнения какой то задачи один раз или по расписанию. Типичный пример - cron job.\n\n- Services - позволяет сетевое взаимодействие между деплойментами. Необходимы, когда нужно, чтобы поды из разных деплойментов взаимодействовали между собой. \n\nНапример: FrontEnd Pod взаимодействует с BackEnd Pods через Backend Service.\n\n### Виды сервисов:\nInternal - ip-адрес доступен только внутри кластера. \n\nExternal - эндпоинт доступен по ip адресу ноды(такой сервис называют NodePod). \n\nLoad Balancer - открывает приложение в интернет через лоад балансер (обычно используется когда кубернетис кластер развернут в облаке (GCP, AWS, Azure).\n\n\n### Labels\n\nПара ключ/значение, может быть присоединена к таким объектам как поды, сервисы и доплойменты. Используются пользователями Кубернетис для идентификации аттрибутов для объектов. Уникальны в пределах объекта. \n\nПример: \"environment\": \"dev\", \"environment\": \"qa\", \"environment\": \"prod\"\n\nLabels как правило используются не одни а с selectors.\n\n### Selectors\n\n- equality-based: '=' и '!='\n- Set-based: 'IN', 'NOTIN' и 'EXISTS'\n\nLabels и Selectors обычно используются в kubectl командах для получения списков объектов и их фильтрации. НапримерЖ получение списка под на QA env.\n\n### Namespaces\n\nКонцепция неймспейсов позволяет реализовать множество виртуальных кластеров внутри одного физического кластера. Это полезно, когда есть необходимость разделять ресурсы физического кластера между командами и контролировать доступ к ресурсам.\n\n### Kublet\n\n- Запущен на каждой work-ноде\n- Коммуницирует с API сервером, который запущен на Master Node\n- Запускает контейнеры для под через docker engine\n- Подключает и запускает диски и сикреты для под\n- Запускает хелсчеки для проверки статусов под/нод и сообщает статус API серверу\n\n### Kube-proxy\n\n- Запущен на каждой work-ноде\n- Рефлицирует сетевой трафик для сервисов (NodePort и LoadBalancer)\nконфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.\n\n\n### Режимы Kube-proxy\n\n- User space mode (наиболее широко используемый)\n- Iptables mode\n- Ipvs mode (alpha version)\n\n### etcd\nРаспределённое и высоконадёжное хранилище данных в формате \"ключ-значение\", которое используется как основное хранилище всех данных кластера в Kubernetes.\n\n### kube-scheduler\nКомпонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.\n\n\n## Команды Kubernetes\n\n- получить список подов\n```\nkubectl get pods\n```\n\n- получить список сервисов\n```\nkubectl get services\n```\n\n- получить список деплойментов\n```\nkubectl get deployments\n```\n\n- поднимаем selenium-hub\n```\nkubectl create -f selenium-hub-deployment.yaml\n```\n\n- поднимаем selenium-hub-svc\n```\nkubectl create -f selenium-hub-svc.yaml\n```\n\n- поднимаем selenium-node\n```\nkubectl create -f selenium-node-chrome-deployment.yaml\n```\n\n\n\n\n## CI/CD microservices\n\nCI - Continious Integration это когда разработчики интегрируют свои код в общий репозиторий на постоянной основе и постоянно проходят некий quality gate который показывает что их код синтегрировался корректно. \n\nCD - Continious Delivery это когда артефакт который мы собрали в рамках Continious Integration и начинаем поставлять его на разные окружения.\nContinious De[loyment это когда мы в процессе Continious Delivery не ждем ручного апрува а автоматом через энвайронменты проводим и выкатываем на продакшен.\n\nКак этого достичь:\n1. Докеризация микросервисов\nнужно получить артефакт который будет неизменным - нужно быть уверенным что тот артефакт который мы собрали в таком же виде дойдет до продакшена\n2. Мы можем присваивать артефакту теги и тем самым продвигать его на следущую стадию\n3. Мы не завязываемся на технический стек\n4. Это прощает деплоймент, управление окружением, конфигурацию и т.д.\n5. Эфективное использование ресурсов\n\nУ нас есть контейнер - запущенный процесс который представляет наш микросервис и image - immutable артефакт который мы собрали в рамках  CI и выложили его в registry - реестр images, где хранятся наши артефакты.\n\n## Версионирование\n\nСемантическое версионирование - \nглавная версия отвечает за то какие знаковые изменения были сделаны в микросервисе(то что мы не поломали API), если мы не имеем обратной совместимости то увеличиваем эту версию либо по большим релизом и с каждым релизом увеличиваем;\nминорная версия - либо начинаем каждый раз с нуля в рамках каждого нового большошо релиза либо если девелопим интерациями то используют номер интерации, тогда можно быстро востановить когда эта версия была выпущена.\nпатч версия - для хот фиксов \nкомит хештег как суффикс и дата как дополнительный суффикс\n\n## CI pipeline\n\nРазработчик делает комит в гит репозиторий на CI делается: build code, run unit tests, build image, push image(пушится в реестр контейнеров). На выходе мы получаем кодовые артифакты, результаты тестов, image контейнер.\n\nQuality Gates:\n- unit tests\n- integration tests\n- static code analysis\n- api tests\n- contract tests\n- security checks\n\nЧтобы поставить полностью всю систему нужно знать версии всех микросервисов.\n\nЗдесь нужно учитывать совместимость - это когда мы взяли набор микросервисов подняли провели тесты и после этого мы говорим что этот набор сервисов совместим \n\nПоэтому нужно сохранять нобор версий этих сервисов как отдельный артефакт \nЭтот артефакт можно положить в систему контроля версий(например гит)\nДальше в Continious Delivery будет участвовать этот набор. и дальше можно промоутить этот артефакт между разными окружениями. Если мы добавим зависимость на какую то версию postgress или elastic то мы получим полную совместимсоть\n\nЭто делается с помощью property файла и прописываем версии.\nМожно использовать helm.\n\n**Пример:**\n\nУ нас есть 3 сервиса с соответсвущими версиями и мы их собрали в compatible set. \n\nИ тут появляется доработка в одном из сервисов и появляется его новая версия и это новый кандидат мы хотим его продвинуть. \n\nМы собираем новый set с этим кандидатом и пытаемся его запустить и билд падает(возможно оказалась проблема в несовместимости например с ui частью).\n\nИ появилась необходимость сделать исправление в другом микросервисе, разработчики делают исправление, получают новую версию и хотят ее задеплоить. И тут вступает фактор, что нужно подхватывать всех новых кандидатов, потому что если бы подхватили только последний кандидат, он могбы упасть так как ожидает исправлений, которые появились в первом сервисе.\n\nЕсли билд проходит успешно, то мы делаем совместимый между собой set и сохраняем его в сисетму контроля версий.\n\nЕсли билд падает, то артифакт невидим и нет возможность такой билд куда-то задеплоить просто так, не пройдя тест на совместимость. \n\nПосле того как артефакт появился в системе контроля версий, то либо jenkins джоба это проверяет, либо оператор в Kubernetes переодически мониторит что появляется и говорит что надо это деплоить - вручную или по расписанию. \n\nFlux CD мониторит появление новых images в гите и говорит что можно их задеплоить.\n\n## Выполняем деплой на окружение\n\nДля этого мы создаем Jenkins джобу или github actions которая показывает нам список окружений который нам доступен: dev, qa, stage, prod либо оставляем создаем новое окружение. Также показываются для выбора не отдельные микросервисы а показыватся сеты. Еще нужно указать TTL(Time To Live) окружение будет автоматически очищаться по истечению времени. \n\nНо если будет много окружений - это займет все ресурс и для решения этой проблемы нужен Kubernetes.\n\nКак ускорить создание окружения в Kubernetes:\n- каждое окружение уходит в отдельый namespace \n- конфигурируем минимальные лимиты и scale фактор \n- выносим основные внешние ресурсы (DB, Elastcsearch, Redis, Kafka)\n- используем готовые images с данными\n- сконфигурируем все тулы \n- асинхронное удаление окружение\n- задаем TTL\n\n\nzhuk.__\n\n","date":"2022-07-27T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/kubernetes/","order":3,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Kubernetes","anchor":"#kubernetes"},{"value":"Команды Kubernetes","anchor":"#команды-kubernetes"},{"value":"CI/CD microservices","anchor":"#cicd-microservices"},{"value":"Версионирование","anchor":"#версионирование"},{"value":"CI pipeline","anchor":"#ci-pipeline"},{"value":"Выполняем деплой на окружение","anchor":"#выполняем-деплой-на-окружение"}]}},{"node":{"id":"3414eaf8e8a92bec3507c78322cf1d7f","title":"Linux","content":"\n## Terminal: основы\n\n- pwd  - вывести текущую директорию (print working directory)\n\n- ls - вывести содержимое директории (list directory content)\n    - ls --all --human-readable -l путь\n    - ls -a -h -l путь\n    - ls -ahl путь ls -lah путь\n\n-a, --all — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.\n\n-h, --human-readable — добавлять к каждому размеру файла букву размера, например, M для двоичных мегабайт (`мебибайт').\n\n-l, --format=long, --format=verbose — в дополнении к имени каждого файла, выводятся тип файла, права доступа к файлу, количество ссылок на файл, имя владельца, имя группы, размер файла в байтах и временной штамп (время последней модификации файла, если не задано другое). Для файлов с временем больше чем 6 месяцев назад или больше, чем 1 час в будущее, временной штамп содержит год вместо времени дня.\n\n- man команда - справка о команде (для выхода: Q)\n- clear - очистить экран терминала\n- exit - закрыть терминал\n\n### Специальные символы:\n- . текущая директория\n- .. директория на уровень выше\n- ~ домашняя директория\n- \\* любое количество любых символов\n- ? ровно один любой символ\n\n\n- mkdir путь_до_директории - создать директорию\n- mkdir -p путь_до_директории - создать директорию и ее “родителей”\n- touch путь_до_файла - создать файл\n- cd путь_до_директории - войти в директорию\n- rm путь_до_файла - удалить файл\n- rm -r путь_до_директории -  удалить директорию\n- rm -rf путь_до_директории - удалить директорию (без вопросов)\n- сp путь_до_файла1 путь_до_файла2 - скопировать файл1 в файл2\n- cp -r путь_до_дир1 путь_до_дир2 - скопировать дир1 в дир2\n- mv путь1 путь2 - переместить директорию или файл\n\n## Запуск исполняемых файлов\n- Ctrl + C - прервать выполнение\n- Ctrl + Z - приостановить выполнение\n    - fg продолжить (foreground)\n    - bg продолжить в фоновом режиме (background)\n- program & - запустить выполнение программы сразу в фоновом режиме\n\n- ./имя_программы - запустить выполнение программы из текущей директории\n- /полный/путь/имя_программы\n\n- chmod +x имя_программы - сделать программу исполняемой\n\n## Ввод/вывод\n- cat файл - вывести содержимое файла на экран\n- less файл - открыть файл на чтение\n    - q – выход; \n    - / – поиск;\n    - g – в начало; \n    - G – в конец\n- nano файл - редактировать файл\n    - Ctrl + X – выход\n\n- Программа < файл - брать stdin из файла\n\n- Программа > файл - выводить stdout в файл\n- Программа >> файл - аналогично, но с дозаписью в файл\n\n- Программа 2> файл - выводить stderr в файл\n- Программа 2>> файл - аналогично, но с дозаписью в файл\n\n- Прогр1 | Прогр2 | … | ПрогрN - передать stdout Прогр1 в качестве stdin для Прогр2, далее stdout Прогр2 в качестве stdin для Прогр3 и т.д.\n\n## Скачивание файлов из интернета\n- wget ссылка - скачать файл по ссылке и сохранить в текущей директории\n- wget -P путь_до_директории ссылка - скачать файл по ссылке и сохранить в директории заданной путем\n- wget -O путь_до_файла ссылка - скачать файл по ссылке и сохранить под указанным именем\n\n- wget -c ссылка - докачать файл по ссылке в случае обрыва связи\n- wget --spider ссылка - проверить доступность файла по ссылке\n- wget -i текстовый_файл - скачать несколько файлов по ссылкам из текстового файла\n\n- wget -r -l глубина ссылка - рекурсивное скачивание файлов по ссылке на указанную глубину(по умолчанию глубина 5)\n- wget -r -A тип,тип,...,тип ссылка - рекурсивное скачивание файлов только определенного типа (типов)\n\n## Работа с архивами\n\n### Распаковка архивов\n- unzip архив.zip - распаковать содержимое архива.zip\n- gunzip архив.gz - распаковать содержимое архива.gz, файл архив.gz удалить\n\n### Создание архивов\n- zip архив.zip файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.zip\n- gzip файл - запаковать файл в файл.gz, исходный файл удалить\n- tar -cvf архив.tar файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar (без сжатия)\n- gzip архив.tar - запаковать архив.tar в архив.tar.gz, исходный архив.tar удалить\n- tar -zcvf архив.tar.gz файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar.gz (c сжатием при помощи gzip)\n\n### Распаковка архивов\n- tar -xvf архив.tar - распаковать архив.tar\n- tar -xzvf архив.tar.gz - распаковать архив.tar.gz (с использованием gunzip)\n\nЕще один архиватор:\n- bzip2 файл\n- bunzip2 файл.bz2\n- tar -cjvf архив.tar.bz2 файл1 файл2 ...\n- tar -xjvf архив.tar.bz2\n\n### Сжатие/распаковка без удаления\n- gzip -c файл > файл.gz\n- gunzip -c файл.gz > файл\n- bzip2 -c файл > файл.bz2\n- bunzip2 -c файл.bz2 > файл\n\n## Работа на сервере\n\nДля входа на сервер, нужно знать:\n1) адрес сервера,\n2) логин и пароль.\n\n### Команда входа\nssh логин@адрес_сервера -p порт\n\nна клиенте хранится закрытый ключ ~/.ssh/id_rsa, ~/.ssh/id_rsa.pub  \nна сервере открытый ключ ~/.ssh/authorized_keys\n\n### Создание ключа\n- ssh-keygen - создание ключа\n- ssh-add - сообщить системе о ключе\n- cat ~/.ssh/id_rsa.pub - просмотр публичного ключа:\n- nano ~/.ssh/authorised_keys - редактирование авторизованных ключей (на сервере)\n\n### Копирование файлов\n- scp -P порт логин@адрес_сервера:путь1 путь2 - с сервера (путь1) на клиента (путь2)\n- scp -P порт путь1 логин@адрес_сервера:путь2 - с клиента (путь1) на сервер (путь2)\n\n### Установка, удаление и обновление программ\n\n- sudo apt-get install программа - Установка программ через терминал\n- sudo apt-get remove программа - Удаление программ через терминал:\n- sudo apt-get update - Обновление ссылок на пакеты:\n- sudo apt-get upgrade - Обновление установленных пакетов:\n- sudo apt-get install --only-upgrade программа - Обновление отдельной программы:\n\n### контроль запускаемых программ\n- jobs - посмотреть запущенные программы\n- fg %<номер> - продолжить программу с этим номером\n- bg %<номер> - продолжить программу с этим номером в фоновом режиме \n- ps - посмотреть ваши процессы\n- top - отслеживать процессы в реальном времени\n- top -u <имя пользователя> - отслеживать процессы этого пользователя \n- kill <номер процесса> - завершить процесс с этим номером\n- kill -9 <номер процесса> - “убить” процесс с этим номером\n\n### Многопточные приложения\n- free -g - информация об оперативной памяти\n- nproc - количество ядер процессора\n- lscpu - детальная информация о процессоре\n- bowtie2-build - запуск построения индекса генома\n    - bowtie2-build <геном> <индекс>\n        - bowtie2-build ref.fasta index\n- bowtie2 - запуск выравнивателя bowtie\n    - bowtie2 -x <индекс> -U <риды>\n        - bowtie2 -x index -U reads.fastq\n    - bowtie2 -x <индекс> -U <риды> -p <количество потоков>\n        - bowtie2 -x index -U reads.fastq -p 4\n\n### Менеджер терминалов\n- Ctrl + Shift + T - открыть новую вкладку в терминале\n- Alt + <цифра> - перейти в указанную вкладку\n- Ctrl + Shift + W - закрыть текущую вкладку\n- tmux - запустить tmux\n- Ctrl + B - перейти в режим команд\n- Ctrl + B и C (зажать Ctrl+B, отпустить, затем нажать С) - создать новую вкладку\n- Ctrl + B и <цифра> - перейти в указанную вкладку\n- Ctrl + B и N / Ctrl + B и P - перейти в следующую / предыдущую вкладку\n- Ctrl + B и X (или exit) - закрыть вкладку\n- Ctrl + B и D - временно выйти из tmux\n- tmux attach / tmux a - вернуться в tmux\n- tmux list-sessions - посмотреть список запущенных tmux’ов\n- Ctrl + B и PgUp - перейти в режим просмотра истории\n- PgUp, PgDown, стрелки - перемещать курсор по истории\n- Esc, Ctrl + C - выйти из режима просмотра истории\n\n## Редактор Vim\n### Вход\nvim\nvim файл\nvim файл1 файл2 файл3 ...\n\n### Главные команды\n:q - выход\n:help - справка\nvimtutor - очень хороший автотуториал!\n\n### Режимы работы\n1. normal\n- Режим по умолчанию\n- Любая клавиша воспринимается как команда\n- «Сложные» команды начинаются с ‘:’\n\n2. insert\n- Режим ввода текста — все, что вы\nнажимаете, вставляется (заменяется).\n- Выход через `<Esc>`, `<Ctrl+c>`\n\n3. visual\n- Режим выделения\n\n### Перемещение\n- По символам:\n    - Стрелочки\n    - h,j,k,l\n- По словам:\n    - w, W — в начало следующего слова\n    - e, E — в конец\n    - b, B — в начало предыдущего\n\n- Еще крупнее:\n0,^,$ — начало строки, первый непробельный символ, конец строки\n- Совсем крупно:\n - gg — начало файла\n - G — конец\n - :21 `<Enter>` — перейти к строке 21\n - `<Ctrl+D>`, `<Ctrl+U>` — вниз/вверх на N строчек, где N обычно пол-экрана\n\n### Удаление\n- По символам:\n    - x — символ под курсором\n    - X — символ до курсора\n- Сразу много: d [<кол-во>] <ход>\n    - dе — удалить до конца текущего слова\n    - d$ — удалить до конца строки\n    - d5w — удалить пять слов\n- Специальная команда\n    - dd — удалить строку (или, например, d10d)\n\n### Создание\ni — войти в insertion mode\na — сдвинуть курсор вправо и войти в insertion mode\nI = ^i\nA = $a\no — вставить пустую строку снизу и редактировать ее\nO — то же, но строка сверху\n\n### Копирование\ny <кол-во> <ход> — скопировать\nyy — скопировать строку\n\n### Вставить\np — вставить после\nP — вставить перед\n\n### Поиск и замена\n#### Поиск\n- /<текст> — искать <текст> вперед\n- ?<текст> — назад\n- n — следующее вхождение, \n- N — предыдущее\n\n#### Замена\n- :%s/<что ищем>/<на что меняем>/<флаги>\n- флаги: \n    - g – много замен в строке, \n    - с – подтверждение\n\n### Полезные команды\n#### Отмена/возврат\n- u — отменить последнее действие\n- `<Ctrl+r>` — вернуть отмененное действие\n\n#### Сохранение работы\n- :w — сохранить изменения\n- :wq — сохранить и выйти\n- :q! — выйти без сохранения\n- :w `<файл>` — сохранить изменения в `<файл>`\n\n## Программирование на bash\n- оболочка (shell) – интерпретатор команд\n- sh (Bourne shell) – стандарт и доступна почти в любом дистрибутиве (1977)\n- bash (Bourne again shell) – усовершенствованная и модернизированная вариация sh (1989)\n- csh, tcsh, zsh, ...\n\n### Создаем программу\nvim my_first_script.sh\n```\n#!/bin/bash\necho \"Hello, world!\"\n```\n\n### Запускаем программу\nchmod +x my_first_script.sh  \n./my_first_script.sh\n\n### Переменные\nПеременная (variable) - именованная область памяти\n\n**имя (name):**\n- буквы, цифры, _;\n- не может начинаться с цифры.\n\n**значение (value):**\n- числа;\n- строки (если есть пробелы, то в кавычках);\n- отдельные символы.\n\n### Запись (перезапись) значения\n<имя>=<значение>\n```\npath=~/Docs\n```\n\n### Чтение\n$<имя> или ${<имя>}\n```\npath2=$path/file1.txt # path2=~/Docs/file1.txt\necho “Path is $path2” # Path is ~/Docs/file1.txt\necho “Path is ${path}2” # Path is ~/Docs2\n```\n\n### Аргументы\n#### Передача аргументов скрипту:\n./script.sh arg1 arg2 arg3 ...\n\n#### Обработка внутри скрипта:\n$1 первый аргумент  \n$2 второй аргумент  \n...\n\n\\$0 имя скрипта  \n$# количество аргументов\n\n```\nvar=”Первый аргумент равен $1”\necho ”Всего было передано $# аргументов”\n```\n\n### Ветвление: основы\n\n#### Синтаксис:\n```\nif [[ условие ]]\nthen\n    # действия, если условие истинно\nfi\n```\n\n\n#### Условия (строки):\n- -z <строка> # строка пуста\n- -n <строка> # строка не пуста\n- <стр1> == <стр2> # строки равны\n- <стр1> != <стр2> # строки не равны\n\nПример:\n```\nif [[ -z $1 ]]\nthen\n echo “Первый аргумент пустой!”\nfi\n```\n```\nif [[ $var1 == $var2 ]]\nthen\n echo “Переменные равны!”\nfi\n```\n\n#### Условия [числа (строки)]:\n\n<число/строка> операция <число/строка>\n\n- -eq == # равно\n- -ne != # не равно\n- -lt < # меньше\n- -le # меньше или равно\n- -gt > # больше\n- -ge # больше или равно\n\nоперации вида “-хх” – только для чисел!  \nоперации-знаки – только для строк!  \n\n#### Условия (файлы):\n- -e <путь> # путь существует\n- -f <путь> # это файл\n- -d <путь> # это директория\n- -s <путь> # размер файла больше 0\n- -x <путь> # файл исполняемый\n\n#### Условия (логические):\n- ! # отрицание логического выражения\n- && # логическое «И»\n- || # логическое «ИЛИ»\n\n### Ветвление: альтернативы\n#### Синтаксис:\n```\nif [[ условие ]]\nthen\n    # действия, если условие истинно\nеlse\n    # действия, если условие ложно\nfi\n```\n\n```\nif [[ условие1 ]]\nthen\n    # действия, если условие1 истинно\nelif [[ условие2 ]]\nthen\n    # действия, если условие1 ложно,\n    # но условие2 истинно\nеlse\n    # действия, если оба условия ложны\nfi\n```\n\n```\ncase переменная in\nзнач1)\n    # действия, если переменная==знач1\n    ;;\nзнач2)\n    # действия, если переменная==знач2\n    ;;\n*)\n    # действия, если переменная\n    # не равна ни одному из вариантов\nesac\n```\n\n### Циклы\n#### Синтаксис:\n```\nfor переменная in список_значений\ndo\n    # действия, каждый раз переменная\n    # принимает следующее значение\n    # из списка\ndone\n```\n\n```\nfor переменная in список_значений\ndo\n    # действия, каждый раз переменная\n    # принимает следующее значение\n    # из списка\ndone\n```\n\nbreak прервать выполнение  \nсontinue перейти на след. значение\n\n\n```\nwhile [[ условие ]]\ndo\n    # действия, пока условие истинно\ndone\n```\n\n- read переменная - записать введенное пользователем значение в переменную\n\n\n### Арифметика\n#### Синтаксис:\nlet “переменная = выражение”\n\nПример:\n```\nlet “c = 1 + 1”\nlet “c = a + b”\n```\n \n#### Операции:\n- +, -, /, * стандартные\n- % остаток от деления\n- ** возведение в степень\n\n#### Cокращение:\nlet “a=a+b” эквивалентно let “a+=b”\n\n### Внешние программы\n#### Синтаксис:\nпеременная=`программа`\n\nПример:\n```\na=`echo “test”`\nfiles=`ls ~`\n```\n\n#### Код возврата:\n- 0 корректное завершение\n- не 0 в процессе работы были ошибки\n\n#### Узнать код:\n$?\n\n#### Выйти с кодом:\nexit код\n\nПример:\n```\ntouch file.txt\necho $?\n```\n\n\nПроверка кода возврата:\n```\nif `программа`\nthen\n    # действия, если код 0\nеlse\n    # действия, если код не 0\nfi\n```\n\n### Функции\n#### Задаем функцию:\n```\nимя_функции ()\n{\n    # действия\n} \n```\n\n#### Используем функцию:\n...\nимя_функции\n...\n\n#### Функции с параметрами:\n```\nимя_функции ()\n{\n    # действия с $1, $2, … , $#\n}\n```\n\n#### Используем функцию:\n...\nимя_функции аргумент1 аргумент2 ...\n...\n\n#### Переменные:\n```\nимя_функции ()\n{\n    var_global=1\n    local var_local=1\n}\n```\n\n#### Используем:\nимя_функции\n```\necho $var_global # выведет 1\n```\n```\necho $var_local # ничего не выведет\n```\n\n#### Компактная запись:\n```\nимя_функции () { действ1; действ2; }\n```\n\n#### Актуально и в других конструкциях:\n```\nif [[ $var==”test ”]]; then\n...\nfor i in 1 2 3 4 5; do\n...\n```\n\n## Продвинутый поиск и редактирование\n- find -iname “<имя файла>” не учитывать регистр\n- find -path “<путь>” найти указанный путь\n- find -size <размер> выводить файлы указанного размера \n- find -maxdepth <число> искать не больше чем на заданное число уровней вниз\n- find -mindepth <число> искать начиная с заданного числа уровней вниз\n\n### Поиск строк по регулярному выражению\n- grep -l “<строка>” <файл> список файлов с этой строкой\n- grep -L “<строка>” <файл> список файлов, где этой строки нет\n- grep -n “<строка>” <файл> выводить номер строки в файле\n- grep -m <число> “<строка>” <файл> не искать дальше после заданного числа вхождений\n- grep -A <число> “<строка>” <файл> выводить это число строк после вхождения\n- grep -B <число> “<строка>” <файл> выводить это число строк до вхождения\n- grep -C <число> “<строка>” <файл> выводить это число строк вокруг вхождения\n- grep -E “<шаблон>” <файл> найти указанный шаблон в файле\n- grep -E “<шаблон>” <файл> найти указанный шаблон в файле\n- grep -E “^go” <файл> найти строки, начинающиеся с “go”\n- grep -E “go$” <файл> найти строки, оканчивающиеся на “go”\n- grep -E “c[au]t” <файл> найти все слова, содержащие cut и cat\n- grep -E “ [a-z]ight ” <файл> слова из 5 букв, кончающиеся на “ight”\n- grep -E “ [a-z]*ight ” <файл> слова из 4 и более букв, кончающиеся на “ight” \n- grep -E “ [a-z]+ight ” <файл> слова из 5 и более букв, кончающиеся на “ight”\n- grep -E “ [a-z]?ight ” <файл> слова из 4-5 букв, кончающиеся на “ight”\n- grep -E “ [a-zA-Z]*ight ” <файл> слова, кончающиеся на “ight” (разрешены большие буквы)\n\n- cat <файл> | sed ‘инструкция’\n- sed ‘инструкция’ <файл> - потоковый редактор: читает строчки из stdin (или из файла), обрабатывает их по инструкции и пишет в stdout\n\n### Если хотим писать в файл\n- \\> <файл> обычное перенаправление\n- -i, --in-place перезаписать входной файл\n- sed ‘s/John/Nick/g’ old.txt > new.txt заменить все John на Nick\n- sed -r ‘s/J[a-z]*n/Nick/g’ old.txt > new.txt заменить все слова, которые начинаются на J и кончаются на n на Nick\n- sed -n ‘2,4p’ file.txt вывести строки с 2 по 4\n- sed ‘2,4d’ file.txt вывести все строки кроме 2-4\n- sed -n ‘/[0-9]\\{2\\}/p’ file.txt вывести строки с 2 цифрами подряд\n- sed '2,/[Rr]ight/d' file.txt вывести все строки кроме со 2 до строки содержащей “right” (с большой или маленькой буквы)\n\n## Права доступа\n\n- users - узнать кто сейчас в системе\n\n- less /etc/passwd  \n    syslog&#58;x&#58;100:103::...  \n    bi&#58;x&#58;1000:1000:bi,,,...(UID >= 1000) - узнать какие вообще есть пользователи\n\n- groups <имя_пользователя> - узнать группы пользователя\n\n- ls -l <путь> - узнать права доступа\n```\nls -l <путь>\ndrwxrwxr-x 2 user group ... dir\n-rw-rw-r-- 1 user group ... file\n```\n \n- r (100, 4) – Read\n- w (010, 2) – Write\n- x (001, 1) – eXecute\n\n### Права у файлов\nr – просмотр содержимого  \nw – редактирование  \nx – запуск  \n\n### Права у директорий\nr – просмотр содержимого  \nw – создание/удаление файлов/поддиректорий  \nx – 1) вход в директорию  \n    2) просмотр inode файлов/поддиректорий\n \n### Изменить права доступа\n- chmod [ugoa][+-][rwx] <путь>\n```\nchmod ug+rw file.txt\n```\n- chmod [octal code] <путь>\n```\nchmod 777 file.txt\n```\n\n### Изменить обладателя\n- chown new_user:new_group <путь>\n```\nchown zoidberg file.txt\n```\n```\nchown :futurama file.txt\n```\n\n### Cуперпользователь\nroot (группа root)\n\n### Сделать от имени root:\n- sudo <действие>\n```\nsudo mkdir dir\n```\n```\nsudo chmod -r dir\n```\n\n### Посчитать что-то в файле:\n- wc [что-считаем] <путь>\n```\nwc -l file.txt\n```\n```\nwc -w file.txt\n```\n```\nwc -c file.txt\n```\n\n### Сравнить файлы/директории\n- diff [-q -r] <путь1> <путь2>\n```\ndiff file1.txt file2.txt | less\n```\n```\ndiff -qr dir1/ dir2/\n```\n\n### Узнать сколько места занимаем на диске\n- du [--max-depth <глубина> -h] <путь>\n```\ndu -h ~/\n```\n```\ndu –-max-depth 1 -h .\n```\n```\ndf [-h]\n```\n\n### узнать сколько места занято/свободно\n- во всей системе\n\nВывести часть файла:  \nhead [-n <количество строк>] <путь>  \ntail [-n <количество строк>] <путь>  \n```\nhead -n 10 file.txt\n```\n```\ntail -n 50 file.txt | less\n```\n\n### Работа с файлами/директориями\nможно использовать {имя1,имя2,...}  \nmkdir ./{dir1,dir2,dir3}  \ntouch ~/{file1,file2}.txt\n\n### Вывод с сортировкой:\n- ls --sort=[вид сортировки] -l <путь>\n```\nls –-sort=size -l ~/\n```\n```\nls –-sort=time -l .\n```\n\n### Перенаправление в один файл\n- &> или &>>\n```\nprogram &>> both.txt\n```\n\n### Перенаправление одного потока в другой\n- 2>&1 stderr в stdout\n- 1>&2 stdout в stderr\n\n### Перенаправление в никуда и из ниоткуда:\n- /dev/null\n```\nprogram 2>/dev/null\n```\n```\ncat /dev/null > file.txt\n```","date":"2022-06-12T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/linux/","order":4,"category":{"title":"testops","path":"/category/testops/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Terminal: основы","anchor":"#terminal-основы"},{"value":"Запуск исполняемых файлов","anchor":"#запуск-исполняемых-файлов"},{"value":"Ввод/вывод","anchor":"#вводвывод"},{"value":"Скачивание файлов из интернета","anchor":"#скачивание-файлов-из-интернета"},{"value":"Работа с архивами","anchor":"#работа-с-архивами"},{"value":"Работа на сервере","anchor":"#работа-на-сервере"},{"value":"Редактор Vim","anchor":"#редактор-vim"},{"value":"Программирование на bash","anchor":"#программирование-на-bash"},{"value":"Продвинутый поиск и редактирование","anchor":"#продвинутый-поиск-и-редактирование"},{"value":"Права доступа","anchor":"#права-доступа"}]}}]}},"relatedCategory":{"id":"b9b65e6a5922bc834b5223e06177ce4d","title":"testops","path":"/category/testops/","related":[{"id":"automation","path":"/category/automation/","title":"automation"}]}},"context":{}}