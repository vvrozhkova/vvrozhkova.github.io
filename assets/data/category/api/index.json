{"hash":"7ce6058f470c3851afaa44882541a7f3d1089ffc","data":{"category":{"title":"api","path":"/category/api/","belongsTo":{"totalCount":7,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"1afd0e96bb915d4dc17e2e8e2eda1796","title":"Ресурсы. API","content":"\n\n## API testing\n\nhttps://www.youtube.com/watch?v=kAZYAs8Mta4\n\nhttps://www.youtube.com/watch?v=vRl2oO7hCFY\n\nhttps://www.youtube.com/watch?v=FRkelR5H3ho\n\nhttps://www.youtube.com/watch?v=vaEHDkDcPTo\n\nhttps://www.youtube.com/watch?v=woB6yiX-Ll8\n\nhttps://www.youtube.com/watch?v=9VnBVmo1Muc\n\nhttps://www.youtube.com/watch?v=syapweRMiOQ\n\nhttps://www.youtube.com/watch?v=gc4jlXfjNow\n\nhttps://www.youtube.com/watch?v=VTVx5Rx6rsY\n\n## Rest Assured\n\nhttps://www.youtube.com/watch?v=c3V7N0MCm6g\n\nhttps://www.youtube.com/watch?v=x0-uXN2JnFQ","date":"2022-06-09T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-api/","order":null,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"API testing","anchor":"#api-testing"},{"value":"Rest Assured","anchor":"#rest-assured"}]}},{"node":{"id":"9dbf86a57a0665da8cf1e6f212d1348b","title":"Чек лист проверок API","content":"\n## Чек-лист API тестов\n- Корректность структуры данных\n- POST запросы\n  - Заполнены все поля валидными данными\n  - Заполнены только обязательные поля\n  - Заполнены не все обязательные поля\n  - Не заполнено ни одно поле\n  - Валидация данных в полях (корректные и некорректные данные)\n  - Пустой JSON\n  - Дата создания объекта\n- GET запросы\n  - Пустой список (если возможно)\n  - Заполненный список\n  - Пагинация в списке (limit, offset)\n  - Получение списка с ограничением на количество записей\n  - Получение списка начиная с указанного номера\n  - В случае передачи параметров с некорректным значением возвращается 400 с описанием ошибки в теле ответа\n  - При отрицательном offset список пользователей возвращается начиная с первой позиции\n  - При несуществующем offset возвращается пустой список пользователей\n  - Сортировка списка\n  - Запрос данных по валидному ID, проверка возвращения корректных данных\n  - Запрос данных по несуществующему ID, но в валидном формате\n  - Запрос данных по невалидному ID\n- PUT запросы\n  - Обновление с корректными данными\n  - Обновление по несуществующему ID\n  - Обновление по невалидному ID\n  - Валидация полей (корректные и некорректные данные)\n  - Частичное обновление (в JSON присутствуют не все поля)\n- DELETE запросы\n  - Удаление существующего объекта\n  - Удаление уже удаленного объекта\n  - Удаление по несуществующему ID\n  - Удаление по невалидному ID\n  - Удаление и повторное добавление такой же сущности (если есть уникальные поля)\n- Проверка статусов ответов\n- Проверка всех возможных ошибок\n- Остальные специфичные проверки в случае сложной логики","date":"2022-06-09T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/chek-list-proverok-api/","order":null,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Чек-лист API тестов","anchor":"#чек-лист-api-тестов"}]}},{"node":{"id":"bbe1ecadfdf2db6a5f56de8513343a0b","title":"Понимание клиент-серверной архитектуры","content":"\nВ клиент серверной архитектуре есть три звена:\n- клиент\n- сервер\n- база данных\n\nКогда мы вводим данные в программу клиент, клиент передает данные на сервер, а сервер перенаправляет его в БД. Клиент может быть web приложением или desktop приложением.\n\nПосле того как запрос был обработан в БД, поисковый результат возвращается обратно на сервер, а сервер передает его на клиент. Клиент отрисовывает информацию пользователю.\n\n## Клиент\nНужен для пользователя, он отрисовывает байты кода. Отвечает за то чтобы отобразить пользователю нужную информацию и позволить сформировать запрос в удобном интерфейсе, иногда еще провести базовые проверки введенных данных.\n\n## Сервер\nНа сервере находится основная логика приложения. \n\n### Почему всю логику нельзя хранить на клиенте?\nМожно. Но клиентов у нас может быть много. К нашему приложению могут обращаться с разных компьютеров. И чтобы все работало быстро и не тормозило нужен мощный клиентский компьютер. Поэтому проще заплатить за мощный сервер, который будет эту логику обрабатывать и остальные клиентские машины могут быть слабее. Также если вся логика будет на клиенте то получается что на каждом клиенте будет храниться код который обрабатывает логику а это дублирование кода. И если мы что то исправляем то нам надо вносить изменения на сотни компьютеров. А это дорого, долго и неудобно.\n\n## База данных\nХранилище данных. Его иногда может и не быть. \n\nЕсли приложение простое, то данные могут харниться на сервере. Такая архитектура называется двузвенная. Но в таком случае если сервер упадет или перезагрузится, то информация потеряется. Поэтому лучше когда она храниться отдельно. \n\nЭто может быть не база данных, сервер может записывать информацию в файлы. Но тогда программисту нужно будет самому фактически делать самописную базу данных. Опять же для простых приложений можно и так. Но для серьезного продукта лучше иметь отдельную базу данных. \n\nБаза данных специально ориентирована на хранение информации для того чтобы можно было быстро и легко по этой информации искать и она обеспечивает сохранность данных. Даже если компьютер выключится все равно наши данные сохранятся. Также повышается надежность приложения, тк в базе могут храниться персональные данные: ФИО, ИНН, Адрес, Телефон и т.д. и не все должны иметь к ним доступ. \n\n**Недостаток клиент серверной архитектуры**\n\nЕсли одно звено упало то не работает все приложение.\n\nЧтобы такого не случалось делают кластер серверов. Это значит что работает не один сервер а несколько. Также перед ними добавляют балансировщик, который решает кому отправлять запрос. Когда приходит запрос балансировщик смотрит какой из серверов менее загружен и передает туда запрос. Такое бывает когда приложение высоконагруженное и один сервер с ним просто не справляется. Таким образом в кластере может быть не 2 сервера, а 10, 15 и т.д.\n\nТочно также можно балансировать базу данных, может быть несколько копий баз данных на разных машинах и балансировщик отправляет запрос то к одной бвзе то ко второй.\n\nТакая схема называется **горящий резерв**. Если нам нужно обновить приложение мы отключаем один сервер временно переложив всю нагрузку на оставшийся обновляем один сервер снова его запускаем, гасим второй и обновляем пока нагрузка идет на оставшиеся сервера и т.д. Работа приложения совсем не останавливается. \n\nИ есть схема **холодный резерв**, когда второй сервер является резервной копией на всякий случай и все запросы идут на один сервер, но если с ним что то случилось и он упал тогда балансировщик перенаправляет всю нагрузку на второй сервер. \n\nТакие схемы помогают нам устранить проблему упало одно звено все отдыхают.\n\nСервер дороже, у дисков для серверного приложения особые требования по надежности и есть поддержка специфичных функций. \n","date":"2022-06-23T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/ponimanie-klient-servernoj-arhitektury/","order":1,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"api","path":"/tag/api/"}],"headings":[{"value":"Клиент","anchor":"#клиент"},{"value":"Сервер","anchor":"#сервер"},{"value":"База данных","anchor":"#база-данных"}]}},{"node":{"id":"f690f34738ec91fccddd8790059b1fbf","title":"Взаимодействие сервера, клиента и БД","content":"\n**Интернет** - это много компьютеров подключенных друг к другу через сеть.\n\nУ каждого компьютера в интернете есть свой адрес - **ip адрес**, такой адрес есть у вашего компьютера телфона у сервера гугл и даже ваших часов.\n\nВсе сообщения от одного компьютера к другому посылаются на ip адрес получателя и каким то образом находят его.\n\nКогда мы пишем адрес google.com, компьютер должен узнать ip адрес сервера гугл, для этого есть механизм **DNS** - его цель для определенного доменного имени вернуть его ip-адрес. Но для этого ваш компьютер должен знать ip-адрес dns сервера. Когда вы включаете модем или телефон подключается к сети 4G ваш провайдер говорит адрес своего DNS сервера.Такие DNS сервера есть у многих компаний: у Google, Cloudflare и других.\n\nПосле того как браузер узнал ip-адрес сервера он устанавливает с ним **TCP соединение**. После установления соединения браузер отсылает по этому адресу запрос. Запрос представляет собой отсылку небольшого текста от браузера к серверу. Выглядит этот текст примерно так:\n\n```\nGET / HTTP/2\nHost: google.com\nUser-Agent: Mozilla/5.0\nAccept: */*\n```\n\nЭто **HTTP запрос**. Протокол HTTP - это основной способ общения браузера с сервером. \nПо этому протоколу могут слать запросы не только браузеры, но и напрмиер мобильные приложения, одно серверное приложение может общаться с другим по такому протоколу. \n\nСтрочки в начале текста запроса называются **Headers(Заголовки)**. Каждая строчка это отдельный заголовок. Есть еще тело запроса. Например, если вы отправляете форму, то данные из этой формы будут передаваться в теле запроса. \n\nВ первой строчке обычно идет тип запроса, URL, тип протокола.\n\nОсновные виды запросов:\n- GET\n- POST\n- PUT\n- DELETE\n- OPTIONS\n\nКогда вы открываете веб страницу в браузере то он шлет GET запрос, а если отправляете форму, то POST запрос.\n\nДруги типы могут быть нужны чтобы взаимодействовать по протоколу REST API. \nКогда приложениям нужно общаться с друг с другом то это общение согласились проводить по определенным правилам. Программистам, которые пишут фронт и бек приложения нужно договорится в каком формате они будут отправлять данные. \n\n## Coockie\n\nЭто кусочки информации которые сервер отдает браузеру, браузер их сохраняет и потом при каждом запросе отправляет их вместе с запросом. Это нужно для того что иногда серверу нужно знать что запрос пришел от определенного браузера/определенного человека. Например если вы залогинились на сайте сервер отдает браузеру куки в котором записан id вашего пользователя и потом при каждом запросе от браузера эти куки используются для того чтобы сервер знал что это именно вы. \n\nHttp это не единственный протокол, есть еще и другие, например, WebSoket протокол - используется для того чтобы организовать двустороннее взаимодействие между сервером и браузером, т.е. сообщения могут ходить как от сервера к браузеру, так и от браузера к серверу. \n\n## Сервер\nСервер - это один или несколько компьютеров которые подключены к интернету. Физически такие компьютеры обычно расположены в специальных зданиях которые называют дата центры. На сервере обычно работает специальное приложение которое так и называется веб сервер. Самые популярные сервера: Nginx, Microsoft IIS, Apache. Веб сервер обычно решает что делать с запросом, если это статический контент например картинка то веб сервер сам может получить ее с диска и отдать браузеру. А если это запрос к странице то веб сервер передает этот запрос дальше к специальной программе. И эта программа называется серверное приложение. \n\nСерверное приложение получает запрос, после этого оно идет в базу данных чтобы получить оттуда данные, сформировать их в каком то формате и вернуть, например в виде html-страницы. Есть и другие форматы данных. Либо выдает ошибку. После этого веб сервер получает этот ответ от серверного приложения и отдает его в браузер. После этого он может закрыть соединение либо оставить его открытым. \n\nКак правило веб приложения пишут так чтобы в них не хранилось ничего, никакое состояние, чтобы состояние хранились в базе данных. Это сделано в основном для того чтобы приложение можно было масштабировать, запускать копию приложения на нескольких компьютерах(серверах) одновременно. А это нужно для производительности, потому что у вас может быть тысячи или миллионы запросов в минуту. \n\n## Реляционные базы данных\n\nСамые популярные: Postgres, MySQL/MariaDB, MS SQL, Oracle.\n\nДанные хранятся в виде таблиц и получить их от туда можно с помощью SQL запросов. Состочние приложения должно храниться в базе данных. Например если пользователь ищет гостиницу в сочи то список таких гостиниц должен храниться в базе данных. И у базы данных есть важное свойство - она быстрая, если мы хотим получить список гостиниц куда пускают с животными то база данных вернет такой список за считанные милисекунды. У базы данных для этого есть специальный механизм - индексы (Index) и у каждой гостиницы может быть поле с признаком пускают ли туда с животными или нет. И индекс это такая структура которая позволяет быстро найти все записи где в этом поле стоит определенное значение. Также базы данных умеют объединять данные из нескольких таблиц, группировать данные по каком то полю или вычислять значение по нескольким полям. \n\nЕсли много пользователей пытаются получить доступ к одной и той же странице то нет смысла каждый раз генерировать ее с помощью приложения снова и снова. В этом случае поможет кеширование. \n\n## Кеширование\nКеш - промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. \n\nКеширование может быть на разном уровне, можно полностью закешировать страницу и тогда приложение вообще не будет вызываться, а страница будет браться постоянно из кеша. Многие популярные веб серверы так умеют. Например для Nginx достаточно указать директорию куда складывать кеш и все заработает само. Еще можно кешировать часть страницы тогда вы сами решаете когда пишите приложение что именно вы будуте кешировать. Кеш обычно держат в памяти либо использует какое -нибудь специальное хранилище типа redis. А базы данных сами умеют кешировать запросы к ним. Например Postgress пытается держать все индексы в памяти чтобы как можно более быстрее к ним можно было обращаться. И даже сам Центральный процессор кеширует ту память с которой он в данный момент работает. \n\nВ заголовках которые возвращает сервер есть заголовок Content-type который говорит в каком формате возвращаются данные. чаще всего  данные возвращаются в следующих форматах: HTML, JSON, Yaml, XML, текст без форматирования. \n\nПосле того как все данные от сервера переданы, TCP соединение может быть закрыто или оставаться открытым. И управляет этим процессом специальный заголовок: Connection: Keep-Alive. Если TCP соединение остается открытым то браузер может послать через него еще один запрос к серверу. Например чтобы получить картинки или файлы скриптов. \n\nФорматы данных\n\n- текстовые форматы:\n    - HTML - используется для описания содержимого веб страниц\n    - JSON, Yaml, XML - форматы с помощью которых можно описывать любые данные\n\nДля того чтобы отобразить веб страницу браузеру нужно распарсить текст и понять из каких частей состоит страница, будут ли там заголовки картинки какой то текст. Может быть туда включены javascript скрипты или css стили. После этого браузер пытается составить DOM дерево. Все что показано на странице организовано в памяти в виде структуры которая называется дерево. Есть корневой элемент - `<html>` у него 2 наследника `<head>` и `<body>` и так далее до текста картинок заголовков и тд.\n\nИногда в процессе построения такого дерева на встречается ссылка на внешний ресурс, например, на картинку и обычно браузер может запросить этот внешний ресурс и сразу же продолжить построение дерева не дожидаясь ответа. Но иногда все же приходится дожидаться загрузки внешнего ресурса, например javascript файла, чтобы продолжить построение дерева и это замедляет открытие страницы. И как только DOM дерево будет построено в памяти браузер рисует то что получилось на экране. Этот процесс назфвается рендерингом. Браузер берет css стили и накладывает на DOM дерево после этого пытается понять где на экране должен находиться каждый из блоков и после этого ричсует это в окошке браузера. После того как страница отрисовалась браузер начинает делать 2 вещи: слушать события например не нажали ли вы на какую то кнопку или ссылку на экране и выполнять javascript код который он загрузил вместе со страницей и тут вступает в работу фронтенд приложение. \n\nФронтенд приложение - это javascript код который работает в браузере он умеет слушать события которые происходят на странице и реагировать на них. У этого кода есть доступ к API браузера. API браузера - это набор функций которые может вызывать программа на javascript'e. \n\nПримеры Browser API:\n- DOM API - с его помощью можно менять содержимое веб страницы\n- Vibration API - позволяет телефону вибрировать когда вы захотите\n- WebGL - позволяет программировать 3хмерную графику в браузере\n\nНо не все браузеры могут поддерживать конкретный API. \n\nРабота мобильных приложений похоже на работу браузера, они могут отправлять запросы на сервер и получать на них ответы и они могут использовать теже форматы данных что и браузерное приложение, html формат обычно не использует потому что нет смысла генерировать веб страницу когда можно показать нативные контролы. \n","date":"2022-06-24T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/vzaimodejstvie-servera-klienta-i-bd/","order":2,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"api","path":"/tag/api/"}],"headings":[{"value":"Coockie","anchor":"#coockie"},{"value":"Сервер","anchor":"#сервер"},{"value":"Реляционные базы данных","anchor":"#реляционные-базы-данных"},{"value":"Кеширование","anchor":"#кеширование"}]}},{"node":{"id":"abd886cd338d3e591f60b91e64c86da6","title":"REST и SOAP","content":"\n## API\nAPI - это контракт, который предоставляет программа: какие операции можно выполнять.\n\nAPI включает:\n- операции которые можно проводить\n- данные которые подаются на вход\n- данные которые предоставляются на выходе\n\nAPI - набор функций. \n\nAPI  входа, API отчетности, API платежек и тд\nили одно общее API.\n\nНа каждое API есть контракт который говорит какие функции можно выполнять.\n\nДля SOAP таким контрактом является wsdl, для REST - wadl.\n\nОписание функций которые мы можем использовать. Одни и теже функции можно использовать в разных API.\n\nВызвать API можно напрямую или косвенно.\n\nНапрямую:\n- система вызывает функции внутри себя;\n- одна система вызывает метод другой системы;\n- в автотестах;\n\nКосвенно:\n- пользователь работает с GUI;\n\nТестирование (через) API\n\nКогда одна система общается с другой по протоколу(HTTP, GMS) передачи данных - это называется remote API(общение по сети).\nЕсть еще shared memory API - это когда программа общается в одной виртуальной памяти\n\nSOAP\nПередает сообщение в xml формате. \nWSDL - это список всех методов которые нам доступны через SOAP.\n\n## REST и SOAP\n\nREST и SOAP на самом деле не сопоставимы. REST — это архитектурный стиль. SOAP — это формат обмена сообщениями. Давайте сравним популярные реализации стилей REST и SOAP.\n\nREST означает REpresentational State Transfer (Википедия: «передача состояния представления»). Это популярный архитектурный подход для создания API в современном мире.\n\nПример реализации RESTful: JSON через HTTP;  \nПример реализации SOAP: XML поверх SOAP через HTTP;\n\nНа верхнем уровне SOAP ограничивает структуры ваших сообщений, тогда как REST — это архитектурный подход, ориентированный на использование HTTP в качестве транспортного протокола.\n\nСпецифика SOAP — это формат обмена данными. С SOAP это всегда SOAP-XML, который представляет собой XML, включающий:\n- Envelope (конверт) – корневой элемент, который определяет сообщение и пространство имен, использованное в документе,\n- Header (заголовок) – содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации,\n- Body (тело) – содержит сообщение, которым обмениваются приложения,\n- Fault – необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений. И запрос, и ответ должны соответствовать структуре SOAP.\n\nСпецифика REST — использование HTTP в качестве транспортного протокола. Он подразумевает наилучшее использование функций, предоставляемых HTTP - методы запросов, заголовки запросов, ответы, заголовки ответов и т. д.\n\n### Формат обмена сообщениями\n\nВ SOAP вы используете формат SOAP XML для запросов и ответов.\nВ REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.\n\n### Определения услуг\n\nSOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.\nREST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.\n\n### Транспорт\n\nSOAP не накладывает никаких ограничений на тип транспортного протокола. Вы можете использовать либо Web протокол HTTP, либо MQ.\n\nREST подразумевает наилучшее использование транспортного протокола HTTP\n\nПростота реализации\n\nRESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.\n\nREST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.\nОднако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.\n\n## Типы запросов\n\n### Метод GET\nМетод GET - используется для получения информации о ресурсе.\n\n### Метод POST\nМетод POST предназначен для создания новых ресурсов и передачи данных.\n\n### Метод PUT\nДля обновления информации уже существующего объекта часто используется метод PUT. Также этой цели может служить метод PATCH, но принципы их работы различаются.\n\nМетод PUT обновляет ресурс полностью, в то время как метод PATCH вносит частичные изменения в существующем ресурсе, затрагивая только указанные поля, переданные в теле запроса.\n\nМетод PUT является идемпотентным. Это означает, что если мы отправим один и тот же запрос PUT десять раз, результат будет одинаковым. При первом вызове PUT внесет изменение в базу данных, а последующие вызовы будут заменять тот же объект теми же данными.\n\n### Метод PATCH\nС другой стороны, метод PATCH может использоваться не только для обновления, но и для добавления данных. В случае многократного вызова одинакового запроса метод PATCH приведет к внесению соответствующего количества изменений в базу данных.\n\n\n### Метод DELETE\nЕсли нам необходимо удалить неправильно сформированный заказ в интернет-магазине, пользователя в социальной сети или фотографию в Instagram, мы используем метод DELETE. Метод DELETE может иметь тело запроса, но также может и не иметь, но как правило, тело запроса в методе DELETE не используется.\n\nПример DELETE запроса, на удаление пользователя с id=123:\n\nDELETE /users/123 HTTP/1.1\nHost: example.com\nПосле успешного выполнения метода DELETE мы можем получить различные статус-коды и тела ответа от сервера:\n\n- 200 OK указывает на успешное выполнение удаления, и ответ содержит тело.\n- 202 Accepted используется, если удаление будет успешным, но еще не завершено.\n- 204 No Content означает, что удаление было выполнено, но тело ответа отсутствует.\n- 401 Unauthorized возникает, если попытка удаления выполняется без авторизации.\n- 403 Forbidden указывает на отсутствие прав на выполнение данной операции.\n- 404 Not Found возникает, если попытка удаления направлена на несуществующий или ненайденный ресурс.\nКак и метод PUT, метод DELETE не поддерживает кэширование.\n\n### Метод HEAD\nДанный метод по своей сути похож на GET, но сервер отвечает на запрос одним лишь заголовком(без тела). (Отсюда и название метода.) Применяется, например, чтобы узнать, существует ли в сети тот или иной URL и не произошло ли каких-нибудь изменений.\n\n### Метод OPTIONS\nOPTIONS - служит для получения параметров для ресурса или для сервера в целом и при этом сам ресурс ни как не затрагивается (то есть это более дешевая операция по сравнению с HEAD)\nOPTIONS возвращает параметры в заголовке. Список параметров зависит о ресурса и/или сервера. Обычно это заголовок Allow, который описывает какие методы доступны для ресурса.\nЭтот метод позволяет клиенту определять опции и/или требования, связанные с ресурсом, или возможностями сервера, но не производя никаких действий над ресурсом и не инициируя его загрузку.\n\n### Идемпотентность\nИдемпотентные методы - это методы, которые либо не изменяют состояние в базе данных, либо изменяют состояние только при первом запросе. В случае повторной отправки идентичного запроса, состояние в базе данных не изменяется. Идемпотентными методами являются: GET, PUT, DELETE, HEAD и OPTIONS.","date":"2022-06-24T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/rest-i-soap/","order":3,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"api","path":"/tag/api/"}],"headings":[{"value":"API","anchor":"#api"},{"value":"REST и SOAP","anchor":"#rest-и-soap"},{"value":"Типы запросов","anchor":"#типы-запросов"}]}},{"node":{"id":"33f3582b8c2938c6981667a346cfa836","title":"Response codes","content":"\nКод ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:\n\n1. Информационные 100 - 199\n2. Успешные 200 - 299\n3. Перенаправления 300 - 399\n4. Клиентские ошибки 400 - 499\n5. Серверные ошибки 500 - 599\n\n<table>\n <thead>\n  <tr>\n   <th scope=\"col\">Код ответа</th>\n   <th scope=\"col\">Название</th>\n   <th scope=\"col\">Описание</th>\n   <th scope=\"col\">Версия HTTP</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th colspan=\"4\"><em>Информационные</em></th>\n  </tr>\n  <tr>\n   <td id=\"100\">100</td>\n   <td>Continue</td>\n   <td>\"Продолжить\". Этот промежуточный ответ указывает, что запрос успешно принят и клиент может продолжать присылать запросы либо проигнорировать этот ответ, если запрос был завершён.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"101\">101</td>\n   <td>Switching Protocol</td>\n   <td>\"Переключение протокола\". Этот код присылается в ответ на запрос клиента, содержащий заголовок <code>Upgrade:</code>, и указывает, что сервер переключился на протокол, который был указан в заголовке. Эта возможность позволяет перейти на несовместимую версию протокола и обычно не используется.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td>102</td>\n   <td>Processing</td>\n   <td>\"В обработке\". Этот код указывает, что сервер получил запрос и обрабатывает его, но обработка ещё не завершена.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td>103</td>\n   <td>Early Hints</td>\n   <td>\"Ранние подсказки\". В ответе сообщаются ресурсы, которые могут быть загружены заранее, пока сервер будет подготавливать основной ответ. <a href=\"https://datatracker.ietf.org/doc/rfc8297\">RFC 8297 (Experimental)</a>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Успешные</em></th>\n  </tr>\n  <tr>\n   <td id=\"200\">200</td>\n   <td>\n    <p>OK</p>\n   </td>\n   <td>\"Успешно\". Запрос успешно обработан. Что значит \"успешно\", зависит от метода HTTP, который был запрошен:\n    <ul>\n     <li>GET: \"ПОЛУЧИТЬ\". Запрошенный ресурс был найден и передан в теле ответа.</li>\n     <li>HEAD: \"ЗАГОЛОВОК\". Заголовки переданы в ответе.</li>\n     <li>POST: \"ПОСЫЛКА\". Ресурс, описывающий результат действия сервера на запрос, передан в теле ответа.</li>\n     <li>TRACE: \"ОТСЛЕЖИВАТЬ\". Тело ответа содержит тело запроса полученного сервером.</li>\n    </ul>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"201\">201</td>\n   <td>Created</td>\n   <td>\"Создано\". Запрос успешно выполнен и в результате был создан ресурс. Этот код обычно присылается в ответ на запрос PUT \"ПОМЕСТИТЬ\".</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"202\">202</td>\n   <td>Accepted</td>\n   <td>\"Принято\". Запрос принят, но ещё не обработан. Не поддерживаемо, т.е., нет способа с помощью HTTP отправить асинхронный ответ позже, который будет показывать итог обработки запроса. Это предназначено для случаев, когда запрос обрабатывается другим процессом или сервером, либо для пакетной обработки.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"203\">203</td>\n   <td>Non-Authoritative Information</td>\n   <td>\"Информация не авторитетна\". Этот код ответа означает, что информация, которая возвращена, была предоставлена не от исходного сервера, а из какого-нибудь другого источника. Во всех остальных ситуациях более предпочтителен код ответа 200 OK.</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"204\">204</td>\n   <td>No Content</td>\n   <td>\"Нет содержимого\". Нет содержимого для ответа на запрос, но заголовки ответа, которые могут быть полезны, присылаются. Клиент может использовать их для обновления кешированных заголовков полученных ранее для этого ресурса.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"205\">205</td>\n   <td>Reset Content</td>\n   <td>\"Сбросить содержимое\". Этот код присылается, когда запрос обработан, чтобы сообщить клиенту, что необходимо сбросить отображение документа, который прислал этот запрос.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"206\">206</td>\n   <td>Partial Content</td>\n   <td>\"Частичное содержимое\". <span id=\"result_box\" lang=\"ru\"><span class=\"hps\">Этот код ответа</span> <span class=\"hps\">используется, когда клиент присылает </span><span class=\"hps\">заголовок</span> <span class=\"hps\">диапазона</span><span>, чтобы</span> выполнить <span class=\"hps\">загрузку отдельно,</span> <span class=\"hps\">в</span> <span class=\"hps\">несколько потоков</span></span>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Сообщения о перенаправлениях</em></th>\n  </tr>\n  <tr>\n   <td id=\"300\">300</td>\n   <td>Multiple Choice</td>\n   <td>\n    <p><span id=\"result_box\" lang=\"ru\"><span>\"</span></span><span class=\"short_text\" id=\"result_box\" lang=\"ru\"><span class=\"alt-edited\">Множественный выбор</span></span>\"<span lang=\"ru\"><span>. </span></span>Этот код ответа присылается, когда з<span lang=\"ru\"><span>апрос</span> <span>имеет более чем</span> <span>один из возможных</span> <span>ответов</span><span>.</span> И <span>User-agent </span><span>или</span> <span>пользователь должен</span> <span>выбрать один из ответов</span><span>. </span></span>Не существует стандартизированного способа выбора одного из полученных ответов.</p>\n   </td>\n   <td>HTTP/1.0 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"301\">301</td>\n   <td>Moved Permanently</td>\n   <td>\n    <p>\"Перемещён на постоянной основе\". Этот код ответа значит, что <span id=\"result_box\" lang=\"ru\"><span>URI </span><span>запрашиваемого</span> <span>ресурса</span> <span>был изменён</span><span>.</span> <span>Возможно,</span> <span>новый</span> <span>URI </span></span><span lang=\"ru\"><span>будет </span></span>предоставлен <span lang=\"ru\"><span>в ответе.</span></span></p>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"302\">302</td>\n   <td>Found</td>\n   <td>\n    <p>\"Найдено\". Этот код ответа значит, что запрошенный ресурс <em>временно изменён</em>. <span id=\"result_box\" lang=\"ru\"><span>Новые</span> <span>изменения в</span> <span>URI</span> <span>могут быть</span></span> доступны в <span id=\"result_box\" lang=\"ru\"><span>будущем</span></span>. <span id=\"result_box\" lang=\"ru\"><span>Таким образом,</span> этот<span> </span><span>URI,</span> <span>должен</span> <span>быть использован</span> <span>клиентом</span> <span>в</span> <span>будущих запросах</span><span>.</span></span></p>\n   </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"303\">303</td>\n   <td>See Other</td>\n   <td>\"Просмотр других ресурсов\". Этот код ответа присылается, чтобы направлять клиента для получения запрашиваемого ресурса в другой URI с запросом GET.</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"304\">304</td>\n   <td>Not Modified</td>\n   <td>\"Не модифицировано\". Используется для кеширования. Это код ответа значит, что запрошенный ресурс не был изменён. Таким образом, клиент может продолжать использовать кешированную версию ответа.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"305\">305</td>\n   <td>Use Proxy</td>\n   <td>\"Использовать прокси\". Это означает, что запрошенный ресурс должен быть доступен через прокси. Этот код ответа в основном не поддерживается из соображений безопасности.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"306\">306</td>\n   <td>Switch Proxy</td>\n   <td>Больше не использовать. Изначально подразумевалось, что \" последующие запросы должны использовать указанный прокси.\"</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"307\">307</td>\n   <td>Temporary Redirect</td>\n   <td>\"Временное перенаправление\". Сервер отправил этот ответ, чтобы клиент получил запрошенный ресурс на другой URL-адрес с тем же методом, который использовал предыдущий запрос. Данный код имеет ту же семантику, что код ответа <code>302 Found</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если в первом запросе использовался <code>POST</code>, то во втором запросе также должен использоваться <code>POST</code>.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"308\">308</td>\n   <td>Permanent Redirect</td>\n   <td>\n    <p>\"Перенаправление на постоянной основе\". Это означает, что ресурс теперь постоянно находится в другом URI, указанном в заголовке <code>Location:</code> HTTP Response. Данный код ответа имеет ту же семантику, что и код ответа <code>301 Moved Permanently</code>, за исключением того, что агент пользователя не должен изменять используемый метод HTTP: если <code>POST</code> использовался в первом запросе, <code>POST</code> должен использоваться и во втором запросе.<br><br>Примечание: Это экспериментальный код ответа, Спецификация которого в настоящее время находится в черновом виде.</p>\n\n   </td>\n   <td><a class=\"external\" href=\"http://greenbytes.de/tech/webdav/draft-reschke-http-status-308-07.html\">draft-reschke-http-status-308</a></td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Клиентские</em></th>\n  </tr>\n  <tr>\n   <td id=\"400\">400</td>\n   <td>Bad Request</td>\n   <td>\"Плохой запрос\". Этот ответ означает, что сервер не понимает запрос из-за неверного синтаксиса. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"401\">401</td>\n   <td>Unauthorized</td>\n   <td>\"Неавторизованно\". Для получения запрашиваемого ответа нужна аутентификация. Статус похож на статус 403, но,в этом случае, аутентификация возможна. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"402\">402</td>\n   <td>Payment Required</td>\n   <td>\"Необходима оплата\". Этот код ответа зарезервирован для будущего использования. Первоначальная цель для создания этого когда была в использовании его для цифровых платёжных систем(на данный момент не используется).</td>\n   <td>HTTP/0.9 и 1.1</td>\n  </tr>\n  <tr>\n   <td id=\"403\">403</td>\n   <td>Forbidden</td>\n   <td>\"Запрещено\". У клиента нет прав доступа к содержимому, поэтому сервер отказывается дать надлежащий ответ. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"404\">404</td>\n   <td>Not Found</td>\n   <td>\"Не найден\". Сервер не может найти запрашиваемый ресурс. Код этого ответа, наверно, самый известный из-за частоты его появления в вебе. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"405\">405</td>\n   <td>Method Not Allowed</td>\n   <td>\"Метод не разрешён\". Сервер знает о запрашиваемом методе, но он был деактивирован и не может быть использован. Два обязательных метода,  <code>GET</code> и <code>HEAD</code>,  никогда не должны быть деактивированы и не должны возвращать этот код ошибки.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"406\">406</td>\n   <td>Not Acceptable</td>\n   <td>\n    <p>Этот ответ отсылается, когда веб сервер после выполнения <a href=\"/en/HTTP/Content_negotiation#Server-driven_negotiation\" title=\"https://developer.mozilla.org/en/HTTP/Content_negotiation#Server-driven_negotiation\">server-driven content negotiation</a>, не нашёл контента, отвечающего критериям, полученным из user agent.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"407\">407</td>\n   <td>Proxy Authentication Required</td>\n   <td>Этот код ответа аналогичен коду 401, только аутентификация требуется для прокси сервера.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"408\">408</td>\n   <td>Request Timeout</td>\n   <td>Ответ с таким кодом может прийти, даже без предшествующего запроса. Он означает, что сервер хотел бы отключить это неиспользуемое соединение. Этот метод используется все чаще с тех пор, как некоторые браузеры, вроде Chrome и IE9, стали использовать <a class=\"external\" href=\"http://www.belshe.com/2011/02/10/the-era-of-browser-preconnect/\">HTTP механизмы предварительного соединения</a> для ускорения сёрфинга  (смотрите bug(634278) , будущей реализации этого механизма в Firefox). Также учитывайте, что некоторые серверы прерывают соединения не отправляя подобных сообщений.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"409\">409</td>\n   <td>Conflict</td>\n   <td>\n    <p>Этот ответ отсылается, когда запрос конфликтует с текущим состоянием сервера.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"410\">410</td>\n   <td>Gone</td>\n   <td>\n    <p>Этот ответ отсылается, когда запрашиваемый контент удалён с сервера.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"411\">411</td>\n   <td>Length Required</td>\n   <td>\n    <p>Запрос отклонён, потому что сервер требует указание заголовка <code>Content-Length</code>, но он не указан.</p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"412\">412</td>\n   <td>Precondition Failed</td>\n   <td>Клиент указал в своих заголовках условия, которые сервер не может выполнить</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"413\">413</td>\n   <td>Request Entity Too Large</td>\n   <td>\n    <p>Размер запроса превышает лимит, объявленный сервером. Сервер может закрыть соединение, вернув заголовок <code>Retry-After</code></p>\n   </td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"414\">414</td>\n   <td>Request-URI Too Long</td>\n   <td>URI запрашиваемый клиентом слишком длинный для того, чтобы сервер смог его обработать</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"415\">415</td>\n   <td>Unsupported Media Type</td>\n   <td>Медиа формат запрашиваемых данных не поддерживается сервером, поэтому запрос отклонён</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"416\">416</td>\n   <td>Requested Range Not Satisfiable</td>\n   <td>Диапазон указанный заголовком запроса <code>Range</code> не может быть выполнен; возможно, он выходит за пределы переданного URI</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"417\">417</td>\n   <td>Expectation Failed</td>\n   <td>Этот код ответа означает, что ожидание, полученное из заголовка запроса <code>Expect</code>, не может быть выполнено сервером.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <th colspan=\"4\"><em>Серверные</em></th>\n  </tr>\n  <tr>\n   <td id=\"500\">500</td>\n   <td>Internal Server Error</td>\n   <td>\"Внутренняя ошибка сервера\". Сервер столкнулся с ситуацией, которую он не знает как обработать. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"501\">501</td>\n   <td>Not Implemented</td>\n   <td>\"Не выполнено\". Метод запроса не поддерживается сервером и не может быть обработан. Единственные методы, которые сервера должны поддерживать (и, соответственно, не должны возвращать этот код) -  <code>GET</code> и <code>HEAD</code>.</td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"502\">502</td>\n   <td>Bad Gateway</td>\n   <td>\"Плохой шлюз\". Эта ошибка означает что сервер, во время работы в качестве шлюза для получения ответа, нужного для обработки запроса, получил недействительный (недопустимый) ответ. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"503\">503</td>\n   <td>Service Unavailable</td>\n   <td>\"Сервис недоступен\". Сервер не готов обрабатывать запрос. Зачастую причинами являются отключение сервера или то, что он перегружен. Обратите внимание, что вместе с этим ответом удобная для пользователей(user-friendly) страница должна отправлять объяснение проблемы.  Этот ответ должен использоваться для временных условий и <code>Retry-After:</code> HTTP-заголовок должен, если возможно, содержать  предполагаемое время до восстановления сервиса. Веб-мастер также должен позаботиться о заголовках, связанных с кешем, которые отправляются вместе с этим ответом, так как эти ответы, связанные с временными условиями, обычно не должны кешироваться. </td>\n   <td>HTTP/0.9 и выше</td>\n  </tr>\n  <tr>\n   <td id=\"504\">504</td>\n   <td>Gateway Timeout</td>\n   <td>Этот ответ об ошибке предоставляется, когда сервер действует как шлюз и не может получить ответ вовремя.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n  <tr>\n   <td id=\"505\">505</td>\n   <td>HTTP Version Not Supported</td>\n   <td>\"HTTP-версия не поддерживается\". HTTP-версия, используемая в запросе, не поддерживается сервером.</td>\n   <td>Только HTTP/1.1</td>\n  </tr>\n </tbody>\n</table>","date":"2022-06-24T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/response-codes/","order":7,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"api","path":"/tag/api/"}],"headings":[]}},{"node":{"id":"ad670de0619e54d48ccdd11b3e12edf9","title":"Аутентификация и авторизация","content":"## Идентификация\nИдентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.\n\n## Аутентификация\nАутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.\n\n## Авторизация\nАвторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.\n\n## Пример\nСкажем, пользователь хочет войти в свой аккаунт Google. Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов. Вот что при этом происходит:\n\nДля начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.\n\nПосле этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это аутентификация.\n\nСкорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это двухфакторная аутентификация.\n\nПосле этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — это авторизация.\n","date":"2022-06-24T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/autentifikacziya-i-avtorizacziya/","order":7,"category":{"title":"api","path":"/category/api/"},"tags":[{"title":"api","path":"/tag/api/"}],"headings":[{"value":"Идентификация","anchor":"#идентификация"},{"value":"Аутентификация","anchor":"#аутентификация"},{"value":"Авторизация","anchor":"#авторизация"},{"value":"Пример","anchor":"#пример"}]}}]}},"relatedCategory":{"id":"e82172d9aa664b5cd683f7a73172f4a5","title":"api","path":"/category/api/","related":[{"id":"manual","path":"/category/manual/","title":"manual"},{"id":"automation","path":"/category/automation/","title":"automation"}]}},"context":{}}