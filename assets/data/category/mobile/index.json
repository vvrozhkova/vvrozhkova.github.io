{"hash":"7ef89d9cd3f6579eddc6e6b2d3ffbd18a73c2491","data":{"category":{"title":"mobile","path":"/category/mobile/","belongsTo":{"totalCount":6,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"361bd553ebc8936c1e1b3b66d6d0a824","title":"Подходы Badoo","content":"","date":"2022-06-19T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/podhody-badoo/","order":null,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"selenium","path":"/tag/selenium/"},{"title":"mobile","path":"/tag/mobile/"}],"headings":[]}},{"node":{"id":"cd3c1f0d4c8b2334c668d7cce4626219","title":"Изоляция компонентов","content":"\nПри выполнении теста с полным флоу можно встретить несколько проблем:\n- в интернет-магазине иногда нужно будет совершить оплату, чтобы закончить тест\n- задействовать реальную сервисную службу (чтобы собрать заказ)\n- зарезервировать ресурсы\n- долгая обратная связь тк нужно выполнить весь набор действий\n\nРешением этих проблем может стать идея тестирования приложения по частям.\n\n\n## Модульные(unit) тесты\n\n- Как правило тесты на функции или методы классов.\n- Для этих тестов не нужна сборка приложения.\n- Высокая скорость исполнения.\n\nСреди unit тестов выделяют:\n- Sociable - тесты, которые используют реальные модули приложения; \n- Solitary - тесты, которые используют подставные объекты или тестовые дублеры.\n\n### Тестовые дублеры\n\n#### Dummy\nКогда требуется передать в функцию объект, который в дальнейшем в тесте не будет использоваться. \nВ этом случае передается, например, пустая строка или пустой объект.\n\n#### Fake\nМожет иметь реальную реализацию, но не может использоваться в продакшене.\nНапример, использование In Memory DataBase вместо ORM(Object-Relational Mapping), которую скорее всего не получится использовать в продакшене.\n\n#### Stub\nВсегда возвращает статичный ответ по заданному запросу.\nЕсли нужно протестировать взаимодействие с внешним API, которое может быть недоступно, то его можно заменить stub'ом.\n\n#### Spy\nПохоже на stub, но еще может следить за вашим приложением.\nНапример, вы тестируете функцию в результате, которой происходит отправка письма пользователю, но в тестах не нужно рассылать настоящие письма, поэтому в функцию можно встроить \"шпиона\", который будет следить был ли вызвов отправки письма пользователю или нет, но при этом сам он отправлять письмо не будет. Такие тесты больше на поведение, чем на состояние.\n\n#### Mock\nВключает преимущества всех предыдущих дублеров. Это заранее запрограммированный объект который может принимать на вход различные значения и иметь некоторые ожидания. В зависимости от этих ожиданий, он возвращает ответ. ","date":"2022-08-28T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/izolyacziya-komponentov/","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Модульные(unit) тесты","anchor":"#модульныеunit-тесты"}]}},{"node":{"id":"87dd301e329d0403ae18a8438ba060c7","title":"Мобильная автоматизация","content":"\n## Сложности мобильной автоматизации\n\nОсновные сложности при автоматизации тестирования мобильных приложений:\n\n1. существует несколько платформ: Android, iOs;\n2. у Android есть разные лаунчеры, обертки, которые также хотелось бы покрыть;\n3. сложный деплой, сложнее чем на вебе, тк прежде чем запустить тесты нужно собрать билды (их нужно где то собирать и как то передавать в тесты).\nТакже сложные хот фиксы, их не так просто сделать  как в вебе, например, нужно проходить процесс ревью перед заливом в маркет;\n4. сложность в масштабировании (параллелизации и многопоточном запуске), т. к. используется много ресурсов для запуска мобильных тестов( и для эмуляторов, и для реальных устройств)\nзапустить всё во много потоков не так просто и дорого;\n5. дорогостоящая инфраструктура - есть простой вариант, использование cloud ферм для запуска тестов, но цена у них очень высокая. А для запуска на реальном железе - для iOs нужны Mac устройства, \nс хорошими ресурсами и это тоже дорого.\n6. нестабильные тесты - т.к. в моб приложении ограниченная зона видимости, мы видим только те элементы, которые отображаются на экране. Могут быть разнообразные popup, push сообщения, нотификации, которые перекрывают элементы.\n\nОднако, в автоматизации моб приложений мы используем тот же паттерн Page Objects, Selenium под капотом и тот же подход к написанию тестов (Arrange(подготавливаем данные) - Act(выполняем действие) - Assert(проверяем)).\n\n## Инструменты для мобильной автоматизации\n\n|                       |Appium     |Espresso         |XCUITest   |Detox     |Selendroid|\n|-----------------------|-----------|-----------------|-----------|----------|----------|\n|**iOS**                |+          |-                |+          |+         |+         |\n|**Android**            |+          |+                |-          |+         |+         |\n|**Type**               |Balck box  |White box        |Black box  |Grey box  |Black box |\n|**Programming Lang**   |Almost any |Kotlin           |Swift      |JavaScript|Java      |\n|**Cost**               |Free       |Free             |Free       |Free      |Free      |\n|**Community**          |Very active|Google           |Apple      |Wix       |Average   |\n|**Speed**              |Slow       |Fast             |Fast       |Fast      |Slow      |\n|**Web, native, hybrid**| +         |Hybrid and native|Only native|Only      |+         |\n\n\nSelendroid - достаточно старый инструмент, используется скорее теми компаниями которые взяли его еще давно, неизвестно поддерживается ли он на текущий день.\n\nDetox - подходит только для приложений на react native, нативные моб приложения им не получится автоматизировать.\n\nEspresso, XCUITest - нативные инструменты, заточные под свою платформу.\n\n\n## Преимущества Appium\n\n1. Возможность писать кросс платформенные тесты. \nНаписав один раз тест под одну платформу, нужно минимальное количество действий чтобы адаптировать его под другую (добавить соответсвующие локаторы и обработать индивидуальные особенности платформы);\n2. Позволяет писать тесты на практически любом языке программирования;\n3. Нет необходимости модифицировать код приложения. Appium - полный Black box и нам ненужно модифицировать код самого приложения;\n4. Работает на основе Selenium JSON wire protocol;\n5. Open source фреймворк с активным комьюнити. Спонсируется souce lab которая также предоставляет cloud решения;\n6. Поддержка параллельного запуска используя Selenium Grid;\n\n## Архитектура Appium\n\nAppium - это http сервер.\n\nУ нас есть тестовый скрипт, мы передаем его в Appium и Appium транслирует его на мобильные устройства, с помощью json wire protocol. \n\nAppium - это обертка над теми же нативными инструментами(XCUITest и UIAutomator, Expresso), т.к. он все свои команды дальше ретранслирует в команды понятные нативным инструментам.\n\nДля iOS используется XCUITest, для Android можно выбрать между UIAutomator и Expresso. \n\nДля Expresso добавили поддержку примерно в 2020 г, он на 20% быстрее, чем UIAutomator. Плюс Expresso делает Appium немного Grey box'ом, потому что есть возможность сделать backdoor к приложению и в целом делает немного более открытым код приложения.\n\nJSONWP(JSON wire protocol) - механизм, созданный командой разработчиков WebDriver. Этот протокол представляет собой набор четко определенных стандартизированных endpoints, открытых через RESTfull API.\n\n`AppiumDriver.getPageSource();` - этот метод вызовет HTTP-запрос, и получит ответ от API. Назад вернется page source в формате строки.\n\n`/session/:sessionId/source` - эндпоинт, который обрабатывает метод getPageSource.\n\n\n## Appium + Android\n\nAppium работает с Android через Espresso и UIAutomator. Поддерживается Google.\nEspresso быстрее чем UIAutomator. \n\n## Appium + iOS\n\nНесколько лет назад под капотом использовался не XCUITests, а другой фреймворк. Но Apple решила прекратить его поддержку и выпустила XCUITests. А XCUITests на тот момент противоречил философии Appium, в том что нам не нужно модифицировать код, т.к. XCUITests нужно было собирать вместе с приложением. \n\nИ некоторое время, Appium нельзя было использовать для iOS приложений. На помощь пришел Facebook и сделал WebDriverAgent Server. При запуске тестов на Appium'e на моб устройство также ставится WebDriverAgent и он транслирует команды от Appium к XCUITests.\n\n## Способы запуска\n\n- на реальных устройствах;\n\nЭто самый надежный вариант. Но построить свою ферму дорого и сложно поддерживать, тк устройства всегда были подключены к сети и нужно выполнять настройки, чтобы не всплывали всяки popup сообщения и если они всегда в сети, то нужно будет часто менять батарейку и собрать парк из разных девайсов будет дорого  и сложно.\n\n- на симуляторах/эмуляторах;\n\nОптимальный вариант. Не так много кейсов, которые репродьюсятся только на реальных устройствах. Они есть но их не много.\n\nдля iOS - используются симуляторы, на Android поднимаются эмуляторы. \n\nИспользуются стандартные эмуляторы, которые предоставляет Android Studio и симуляторы от XCode для iOS.\n\n- на cloud фермах \n    - Browser Stack (2 параллельных запуска ~ 400$ в месяц, 5 параллельных запусков ~ 1000$ в месяц)\n    - Sauce Labs\n    - AWS Device Farm\n    \nСамые удобные, тк просто указываем url на хост в ферме и запускаем. Но это очень дорого, плюс вопрос к секьюрности для запусков тестов. \n\n## Запуск тестов\n\n- для iOS\n\nПри запуске на реальном устройстве:\n1. собираем .ipa файл, подписанный сертификатом организации\n2. берем девайс, добавленный в провижен организации\n3. используется аккаунт с сертификатом разработчика\n\nПри запуске на симуляторе просто собираем через XCode .app файл.\nНа симуляторе нельзя установить файл с расширением .ipa, потому что там другая архитектура и он там не запустится.\n\n- для Android\n\nСобираем apk через Gradle и Android Studio на эмулятор и на реальное устройство и можно работать.\n\n## Что нужно чтобы начать?\n\n### Android\n- JDK (Java Development Kit)\n- Android SDK\n- Appium\n\n### iOS\n- Mac OS\n- XCode\n- JDK (Java Development Kit)\n- Homebrew\n- Node and npm\n\nhttps://qa-automation.git-doc.evo.dev/mobile/ubuntu.html\n\n## Стек инструментов\n\n- Appium\n- Java/Kotlin\n- TestNg\n- Maven\n- Allure REport\n- AssertJ\n- Log4J\n\n## Инструменты чтобы находить локаторы\n\n### Android\n\n- UIAutomatorViewer (Android)\n- Appium Inspector - делает скриншот текущего экрана и показывает состояние выбранного элемента.\n\nМожно искать элементы по id и по xPath:\n\n- Id\n\nresource-id = id\n```java\n@AndroidFindBy(id = \"tvProSalePay\")\n```\n\n- xPath\n```java\n@AndroidFindBy(xpath = \"//android.widget.TextView[@text = 'XL']\")\n```\n\n### iOS\n\nМожно использовать только Appium Inspector, так как нет других инструментов для этой цели.\n\nМожно искать по id, iOSClassChain, iOS predicate string (в порядке снижения скорости). \n\nПо xPath тоже можно но крайне не рекомендуется так как это происходит очень медленно из за того что в iOS приложениях нет xml дерева и appium его вычисляет самостоятельно а на это тратится время.\n\n- Id\n```java\n@iOSXCUITFindBy(id=\"client name\")\n```\n\n- iOSClassChain\nАналог xPath.\n\n```java\n@iOSXCUITFindBy(iOSClassChain=\"**/XCUIElementTypeButton[`name == 'icRatingStar'`]\")\n```\n\n- iOS predicate string\n\nСвой тип локаторов.\n\n```java\nString selector = \"type == 'XCUIElementTypeButton' AND value BEGINSWITH[c] 'bla' AND visible == 1\"\n```\n\n## Боли Appium \n\n### Недоступные элементы\n\nНекоторые объекты не имеют выделенного элемента в DOM дереве и сложно с ними взаимодействовать отдельно, например взять текст. Встречается в сообщениях об ошибке, тост сообщениями, поп-апами.\n\n**Решение:**\n\n1. Можно использовать библиотеку tesseract - для распознавания текста на изображении.\n2. Клики по координатам.  \nЕсли нужно кликнуть на элемент, которого нет в дом дереве.  \nВ этом случае лучше брать не координаты этого элемента, а стараться брать соотношение по экрану (находить центр и т.д.), потому что если мы поменяем устройство, на котором будем прогонять и там расширение экрана другое, то мы столкнемся с трудностями.\n\n### Ограниченная зона видимости\n\nКогда мы делаем скриншот в Appium, мы видим дерево только тех элементов, которые есть сейчас на экране, то что вне мы не видим. \n\n**Решение:**\n\nДойти до элементов вне зоны видимости мы можем только проскролив.\n\n- iOS\n\n```java\nHashMap<String, String> scrollObject = new HashMap<>();\nscrollObject.put(\"element\", element.getId());\nscrollObject.put(\"toVisible\", \"true\");\n\ndriver.executeScript(\"mobile:scroll\", scrollObject);\n```\n\n- Android\n\n```java\nprotected void scrollToElementAndroid(String scrollableListId, String selectionText){\n    ((AndroidDriver) driver).findElementByAndroidUIAutomator(\"new UiScrollable(new UiSelector().scrollable(true)\"\n    + \".resourceId(\\\"\" + scrollableListId + \"\\\"))\"\n    + \".setAsHorizontalList().scrollIntoView(new UiSelector().text(\\\"\" + selectionText + \"\\\"))\").click();\n}\n```\n\n**Универсальный скролл**\n\n```java\npublic void swipeUpToFindElement(By by, int maxSwipes){\n    int alreadySwiped = 0;\n    while(driver.findElements(by).size() == 0){\n        if (alreadySwiped > maxSwipes){\n            waitForElementToBePresent(by, \"Невозможно найти элемент по свайпу\", Constants.SMALL_TIMEOUT);\n            return;\n        }\n        swipeUpQuick();\n        Log.info(\"Выполнен свайп\");\n        ++alreadySwiped;\n    }\n}\n```\n\n### Платформозависимость\n\nУ Android и iOS есть свои особенности.\n\n- Разные атрибуты у элементов\niOS - value, android - text\niOs - visible, android - displayed\niOS - enabled, android - checked, checkable, enabled\n\n- Различия в основных флоу приложения на Android и на iOS\n\n- Часто при работе с веб вью на разных версиях Android у элементов разный xPath\n\n```java\n@AndroidFindAll(\n\n)\n```\n\nwatch?v=zp0qC6JT0rE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","date":"2022-09-02T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/mobilnaya-avtomatizacziya/","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Сложности мобильной автоматизации","anchor":"#сложности-мобильной-автоматизации"},{"value":"Инструменты для мобильной автоматизации","anchor":"#инструменты-для-мобильной-автоматизации"},{"value":"Преимущества Appium","anchor":"#преимущества-appium"},{"value":"Архитектура Appium","anchor":"#архитектура-appium"},{"value":"Appium + Android","anchor":"#appium--android"},{"value":"Appium + iOS","anchor":"#appium--ios"},{"value":"Способы запуска","anchor":"#способы-запуска"},{"value":"Запуск тестов","anchor":"#запуск-тестов"},{"value":"Что нужно чтобы начать?","anchor":"#что-нужно-чтобы-начать"},{"value":"Стек инструментов","anchor":"#стек-инструментов"},{"value":"Инструменты чтобы находить локаторы","anchor":"#инструменты-чтобы-находить-локаторы"},{"value":"Боли Appium","anchor":"#боли-appium"}]}},{"node":{"id":"409a47c4437edeb463348b8ada720d11","title":"Инструменты тестирования мобильных приложений","content":"\n## Симулятор vs Эмулятор\n\n### Симулятор \nОбычно используется для iOS.\n\n- Железо не эмулируется, только софтверная часть\n- Работает быстрее реальных устройстви мы не можем гарантировать что на реальном устройстве будет работать также\n- Невозможно установить телефонные приложений и работать с Siri\n- Невозможно проверить \"железные\" фичи: Bluetooth, NFC, звонки\n\nБаги возникающие на симуляторе в любом случае нужно править так как рано или поздно они могут появиться и на реальном устройстве:\n- Краш на симуляторе/девайсе\n- Разъезжается верстка\n\n### Эмулятор\nИспользуется для Android.\n\n- Имеется и Software и Hardware, можно задавать параметры памяти и т.д.\n- Работает медленно\n- Нет покупок внутри приложений\n- Google сервисы\n\nБаги:\n- Device-specific\n- Ошибки в транзакции\n- Библиотеки не под x86\n\nДостоинства:\n- Можно задавать различные разрешения\n- Можно работать с памятью\n- Тестировать GPS\n- Перехват и шейпинг(проверка траффика)\n\n## Реальные устройства\n\nОсновная проблема что не всегда есть возможность создать собственную ферму устройств\n\n- медленный Debug\n- iOS: разметка\n- Работа с памятью, сложно сэмулировать нужно забивать память вручную\n- Android: перехват трафика\n- Многообразие устройств\n\n## Среда разработки\n\nAndroid SDK, XCode\n\nADB - Android Debug Bridge - устанавливается вместе с Android SDK, и позволяет управлять устройством на базе Android. \n\nADB позволяет:\n- аосмотреть какие устройства подключены и могут работать с ADB\n- просматривать логи\n- копировать файлы с/на аппарат\n- устанавливать/удалять приложения\n- выполнять различные скрипты управления\n\n## Логи\n\nVerbose - вся информация с приложения\nDebug - логи для дебаг режима\nInfo - информация о состоянии\nWarn - предупреждение о нештатных ситуациях\nError - ошибка в приложении\n\nЕсли баг возникает у пользователя на проде, то проверяются логи в Fabric или Firebase Crashlitics.\n\nВ Firebase Crashlitics можно смотреть статистику работы без сбоев - какой процент пользователей работает без сбоев, список ошибок которые произошли и т.д.\n\nCrashlytics отображает:\n- Период возникновени ошибки\n- Тип ошибки\n    - Crash\n    - Warning\n- Версия приложения\n- Устройство\n- Операционная система\n- Идентификатор пользователя\n\n\n## Developer Console. Ошибки ANR и сбои\n\n1. Период возникновения ошибки\n2. Версия Android\n3. Версия приложения\n\nМинусы:\n1. Нет поиска по устройству\n2. Убрали поиск по отчетам пользователей\n\n## Перехват трафика\n\n- Charles\n- Fidler\n\nПроверяются запросы и ответы на клиенте и сервере.\n\nЕсли приходит ответ в зашифрованном виде то можно селать следущее чтобы его расшифровать\n\n1. Настроить прокси на устройстве или эмуляторе\n2. Установить SSL сертификат для HTTPS на устройстве с которого считываются запросы\n3. Выполнить действия с устройства\n4. Изучать необходимую информацию\n\n## Тестирование API\n\n- Postman\n    - Проверка сервера без клиента\n    - Проверка получаемых данных от сервера\n\n## Аналитика\n\n- Firebase - Firebase Debug View\n\nAndroid  \nadb shell setprop debug.firebase.analytics.app <package_name>\n\niOS  \nв командной строке Xcode:\n-FIRDebugEnabled\n\n- Google Analytics\n\nadb shell setprop log.tag.GAv4 DEBUG\n\nadb logcat -v time -s GAv4\n\nОтправляемые события будут отображаться в консоли но в самом Google Analytics нет реал тайм борда\nи в лучшем случае через сутки можно будет проверить что события дошли.\n\n- Яндекс AppMetrica\n\nВ самом кабинете можно указать устройство версию и не нужно никаких команд запускать.\n\n## Push уведомления\n\n- Firebase - Firebase Debug View\n\n- Яндекс AppMetrica\n\nМожно настраивать уведомления.\nНо иногда можно случайно отправить push на продакшен.\n\nНужно попросить разработчиков чтобы написали метод testPush.json, который будет отправлять push только на тестовое устройство. \n\n## Мнемоники\n\nПомогают выполнять важные проверки. \n\n### I SLICED UP FUN\n\n![I SLICED UP FUN](https://hsto.org/getpro/habr/upload_files/8f6/5c8/0c9/8f65c80c9c2cf5cf89c417c2240364be.png)\n\n## Автоматизация\n\n### Monkey UI/Application Exerciser Monkey\n\n```\nadb shell monkey\n-p your.package.name -v 500\n```\n\nhttps://developer.android.com/studio/test/monkey\n\nМожно указать ограничения по скорости, оганичить действия только внутри вашего приложения, можно указать id  и если приложение упадет можно по этом id воспроизвести действия, а также другие парамтры.\n\n\nИсточник:\n\n1. ❗ [«Инструменты тестирования мобильных приложений», Ксения Апачиди](https://www.youtube.com/watch?v=DH2XI5q1eUE)\n2. ❗ [Тестирование мобильных приложений: tips & tricks](https://habr.com/ru/company/badoo/blog/269189/)","date":"2022-09-06T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/instrumenty-testirovaniya-mobilnyh-prilozhenij/","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Симулятор vs Эмулятор","anchor":"#симулятор-vs-эмулятор"},{"value":"Реальные устройства","anchor":"#реальные-устройства"},{"value":"Среда разработки","anchor":"#среда-разработки"},{"value":"Логи","anchor":"#логи"},{"value":"Developer Console. Ошибки ANR и сбои","anchor":"#developer-console-ошибки-anr-и-сбои"},{"value":"Перехват трафика","anchor":"#перехват-трафика"},{"value":"Тестирование API","anchor":"#тестирование-api"},{"value":"Аналитика","anchor":"#аналитика"},{"value":"Push уведомления","anchor":"#push-уведомления"},{"value":"Мнемоники","anchor":"#мнемоники"},{"value":"Автоматизация","anchor":"#автоматизация"}]}},{"node":{"id":"f28f426da5d71fef613a05a31b514709","title":"Особенности тестирования мобильных приложений","content":"\n## Виды мобильных приложений, их плюсы и минусы\n\n### Web приложения\n\nВеб-приложения представляют собой адаптированные веб-сайты, которые открываются через браузеры. \n\nПользователь не скачивает приложение и не хранит его на своем устройстве. Если его «скачивают», скорее всего, речь идет о том, что оно добавляется в закладки браузера. \n\nОдним из самых распространенных подвидов считают PWA — прогрессивные веб-приложения, которые, по сути, являются нативными приложениями внутри браузера. \n\nСложно выделить примеры, чтобы не ошибиться. Разные источники приводят в пример Google Maps, программы Microsoft Office.\n\n#### Плюсы\n- Не требуют настроек под операционную систему, что делает разработку быстрой и менее дорогой.\n- Не требуют загрузки, установки и не занимают место на устройстве пользователя.\n- Не требуют обновлений, поэтому в теории их проще поддерживать со стороны разработчика и, опять же, пользователю не надо устанавливать никакие обновления, чтобы работать с площадкой.\n\n#### Минусы\n- Веб-приложения зависят от браузера. И функции, которые доступны в одном браузере, могут не поддерживаться в другом. Это означает, что пользовательский опыт будет отличаться. \n- Веб-приложения не работают без подключения к интернету. \n- Не имеют доступа к ресурсам мобильного устройства, в связи с этим имеют ограниченную функциональность.\n\n### Нативные приложения\n\nНативные мобильные приложения — самый распространенный и дорогой в разработке вид, так как создается отдельно для каждой ОС (iOS, Android или другие). \n\nКогда мы говорим о мобильных приложениях, чаще всего имеем в виду именно нативные. Pokemon Go, Spotify и многие другие являются именно нативными приложениями.\n\n#### Плюсы\n- Высокая производительность (скорость работы и надежность). Это связано с тем, что приложение создается для каждого ОС с учетом его особенностей. В итоге это обеспечивает пользователю позитивный опыт взаимодействия.\n- Доступ к аппаратной части устройства (геолокации, камере, микрофону, акселерометру, датчикам освещенности, календарю, push-уведомлениям) и широкий функционал за счет этого; Это тоже упрощает и улучшает пользовательский опыт.\n- Adjust упоминает, что нативные приложения еще и более безопасны с точки зрения защиты данных пользователя.\n- Нет ограничения функционала скоростью и качеством Интернет-соединения, приложение может работать без выхода в сеть;\n- Можно распространять через магазин проложений.\n\n#### Минусы\n- Стоимость разработки. Нативное приложение нужно разрабатывать отдельно для каждой ОС, а потом поддерживать его. Все это требует расходов. \n- Нативные приложения занимают место в памяти устройства пользователя, причем с каждым новым обновлением это занятое место может расти.\n\n### Гибридные приложения\n\nНазвание говорит само за себя: это веб-приложения, которые выглядят как нативные и имеют их признаки. \n\nВ частности, иконки на рабочем столе мобильного устройства пользователя, хорошую производительность и возможность работать в автономном режиме. \n\nСреди гибридных приложений выделяют Uber, Evernote. Некоторые источники относят к гибридам и Instagram.\n\n#### Плюсы\n- Более бюджетная и быстрая разработка по сравнению с нативными. \n- Более быстрая загрузка — это хорошее преимущество для пользователя и возможность улучшения пользовательского опыта. \n- Возможность взаимодействия с ОС устройства. \n- Есть встроенный браузер.\n- Можно распространять через магазин прилодений.\n- Мультиплатформенные.\n\n#### Минусы\n- Все равно не такая хорошая производительность, как у нативных приложений.\n- Ограниченный доступ к ресурсам мобильного устройства.\n- Не полностью автономны, нужно подключение к интернету.\n\n## Отличия web и mobile тестирования\n\n1. Мобильные устройства можно переносить, в связи с этим появляются свои особенности, меняется геолокация и т.д.\n2. У мобильных устройств  высокая фрагментация (много устройств на которых можно использовать приложение) и больше пользователей\n3. Мобильные прилодения имеют ограничения в ресурсах (оперативной и постоянной памяти)\n4. Разное взаимодействие в отлечие от web'a (tap, swipe и т.д.)\n5. Разное поведение с подкючением к интернету и без подключения.\n\n## Тестирование mobile приложений\n\n1. Выбор устройств.\nИз всего зоопарка устройств нужно выбратьустройства для тестирования. Для этого можно обратиться к статистике и аналитике по использованию вашего приложения, если такой статистики нет то моно обратиться к статистике google илии apple.\n\n2. Размеры экрана и touch интерфейс\n- Элементы должны быть определенного размера чтобы пользователь смог попасть и не было мискликов.\n- Все сценарии в приложении не должны вести на пустые экраны.\n- В touch интерфейсе нужно проверять многократное нажатие на элементы, мультитач[^«множественное касание» — функция сенсорных систем ввода, осуществляющая одновременное определение координат двух и более точек касания.] и нативные жесты которые могут использоваться.\n- скорость отклика элементов (высокая; нажатая клавиша должна визуально отличаться)\n\n3. Ресурсы устройства\n- кейсы с утечкой памяти;\n    - можно проверить с помощью программы Instruments (стандартное приложение MacOS). Может быть не более 30мб на 2г айфон/айпод, примерно 70мб для всех девайсов до 2-го айпада\n    - уделить внимание окнам с большим количеством информации, при длительном пребывании пользователя в приложении\n- кейсы, когда не хватает памяти для установки и работы приложения;\n- кейсы, когда не хватает памяти для обновления и работы приложения;\n- кейсы, когда переносим или устанавливает приложение на sd карту;\n\n4. Разрешения экрана и версии ОС\n- можно столкнуться с ошибками верстки;\n- на разных разрешениях приложение зачастую выглядит по разному;\n- кейсы с портретной и альбомной ориентацией устройства;\n\nЕсли приложение работает с разными форматами файлов то нужно проверять все эти форматы, чтобы приложеине корректно работало с каждым.\n\n5. Реакция на внешнее прерывание\nВнешние прерывания:\n- входящие/исходящие звонки/сообщения/смс/ммс/напоминание/нотификацию ;\n- уведомления от других приложений;\n- разрядка устройства, переход устройства в энергосберегающий режим, переход устройства в режим ожидания, смена ориентации в режиме ожидания;\n- кейсы с разными подключениями (с разными сетями: wi-fi, 3G);\n- при включенной/отключенной функции bluetooth, геопозиция, режим полета, функции где используется камера;\n- кейсы с потерей связи;\n- кейсы с зарядкой устройства(разряд/изъятие батареи);\n- с извлечением/подключением sd карты/кабеля/зарядки;\n- закрыть приложение для того, чтобы открыть какое-то другое на некоторое время и вернуться к вашему приложению позже;\n- послать девайс в сон на некоторое время.\n\n6. Доступ к связи\n- позитивный кейс (наличие отличной постоянной связи);\n- наличие постоянной неотличной связи;\n- отсутствие связи;\n- потеря связи;\n\n7. Постоянная мобильность\n- Крэш в приложении при попытке восстановить приложение из бэкграунда с предварительной сменой ориентации экрана;\n- Крэш в приложении при “потряхивании” девайса в момент совершения этим девайсом фотосъёмки (приложение изначально создавалось для создания фото);\n\n8. Проверка работы приложений на ретина экранах и различных версия OS\n- корректное отображение различных элементов на экранах ретина/не ретина\n- установка приложения на корректную версию OS\n- проверить установку на все возможные девайсы\n- различные функции на девайсах: отсутствие/наличие камеры(ipad) (автофокуса), отсутствие/наличие GPS\n\n9. Проверка типа покупок (восстанавливаемые, не восстанавливаемые)\n- проверка соответствия фактической/заявленной стоимости приложения\n- проверка восстановления покупки независимо от девайса, а с привязкой к учетной записи\n\n10. Проверка работы обратной связи\n- сообщения при загрузке контента/прогресс\n- сообщения при ошибке доступа к сети\n- наличие сообщений при попытке удалить важную информацию\n- наличие экрана/сообщения при окончании процесса/игры (экран Game over)\n\n11. Проверка работы обновлений\n- проверка различных путей установки обновлений (wifi, bluetooth, usb)\n- проверка работы установленных изменений, мест, куда они вносились\n- убедиться в поддерживаемости обновлений более старыми операционками, чтобы элементы которые на новой системе работают хорошо не падали на более старых версиях.\n\n12. Реклама в мобильном приложении\n- реклама не должна перекрывать кнопки управления приложением\n- реклама должна иметь доступную кнопку закрытия, потому что чаще всего пользователь ее не ищет, а просто удаляет приложение с концами\n\n13. Проверка локализации\n- на другом языке на экране должно хватить места для текста\n- даты должны соответствовать формату установленного региона\n- временные настройки должны быть соблюдены\n\n14. Проверка энергопотребления\n- необходимо проверять насколько сильно ваше мощное приложение опустошает батарею устройства. Скорее всего пользователь удалит его, если из-за него мобилку придется под заряжать слишком часто.\n\n## Жизненный цикл приложения\n\nКогда мы тестируем кейсы на прерывание мы проверяем как правильно приложение работает с жизненным циклом.\n\n![Жизненный цикл приложения](https://metanit.com/java/android/pics/life_cycle.png)\n\n## Обратная связь с пользователем\n\nУ всех элементов нажатых пользователем должно быть соответсвующее состояние благодаря этому пользователь видит действительно ли нажатие случилось или нет.\n\nТакже нужно смотреть на отклик(реакция на нажатие), есть ли какая то скорость отклика она не должна быть достаточно быстрой и не должна быть достаточно медленной. При таком тестировании желательно использовать не самые топовые устройства(девайсы).\n\nКогда загружаем какой нибудь контент нужно использовать прогресс бар чтобы пользователь видел что идет загрузка. \n\nВсе сценарии должны иметь завершающий success экран, чтобы пользователь также видел что его кейс завершился и можно пойти на другой экран.  \n\nДолжны быть четкие и понятные сообщения об ошибках. Чтобы пользователь понимал чтоо ему нажимать, вдруг он удаляет какую то важную информацию. Текст сообщения должен быть крайне понятным и простым. \n\nТакже если используются уведомления на экране, например о покупках, можно использовать звуки и вибрацию. Звуки, вибрация и уведомления должны быть синхронизированы между собой, такой кейс тоже надо проверять. \n\n## Настройки разработчика в Android\n\nВ Android и iOS есть специальный режим разработчика, это список настроек/параметров которые мы можем использовать при тестировании.\n\nНапример:\n\n- **Профиль обработки GPU** - показывает насколько быстро рисуется интерфейс нашего приложения. Если будет выше зеленой линии значит не все так гладко с интерфейсом.\n\n- **Показывать ограничения макета** - показывает как все элементы расположены относительно друг друга.\nЕсли мы тестируем верстку можно включить этот режим и сравнить с макетом.\n\n- **Параметр \"Отладка\"** - используется при дебаге.\n\n- **Параметр \"Конфигурация USB\"** - как подключаться для отадки, для зарядки, для передачи файлов.\n\n- **Параметр \"Не сохранять операции\"(\"Do not keep activities\")** - используется для тестирования жизненого цикла. При включении этого параметра при навигации в новый экран предыдущий экран уничтожается, если мы снавигируемся назад то приложение падает. \n\nдля iOS есть такой же режим:\n\n- **Параметр \"Network Link Conditioner\"** - для тестирования с разным качеством связи(3G, LTE и т.д.) и с возможностью задавать собственные профайлы, кастомные со своими параметрами какая нам сеть нужна.\n\n## Помощь при релизах \n\n### Beta версии\n\n#### iOS\nПеред релизами можно использовать beta версии.\nДля iOS для этих целей можно использовать TestFlight, релиз выкладываетя и пояляется в TestFlight и далее смотрится как поведет себя приложение.\n\n#### Android\nНечто похожее также имеется и на Android.\nТакже используется Beta testing версии для внутреннего тестирования.\n\n### Выпуск автоматических обновлений\n\n#### iOS\nТакже в iOS есть функция поэтапного выпуска автоматических обновлений. Если включается этот параметр то в течение недели наше обновление будет выкатываться с 1% пользователей до 100%, каждый день постепенно увеличиваясь.\n\n#### Android\nВ Android также можно делать выпуск автоматических обновлений, но здесь есть больше контроля на этим процессом. \n\nЕсли мы желаем поэтапный релиз для iOS то мы можем его только остановить но не поменять проценты или другие настройки, в Google Play можно указать процент - сколько пользователей нужно от общего количества, в любой момент остановить и в любой момент продолжить, в любой момент поменять этот процент. \n\n### Отчеты о тестировании\n\nТакже в Google Play есть отчеты о тестировании. Когда вы загружаете свой apk файл и публикуете, через некоторое время там появится отчет о тестировании этой версии. \n\nGoogle на своей фабрике устройств тестирует нашу apk, в течении ~ 10 минут и в итоге выдает отчет по разным параметрам: по безопасности, будут видны краши если они были, видно на каких устройствах тестировалось, видно скриншоты и запись видео в том случае если что то пошло не так.  \n\n## Чек-лист тестирования мобильных приложений:\n\n- Геолокация.\n- Работа приложения в разных режимах: portrait/landscape, split screen.\n- Поля ввода.\n- Пуш уведомления.\n- Прерывания — входящие звонки, СМС, доступ к интернету, предупреждение о низком заряде батареи, внезапное отключение устройства и другие.\n- Поддержка платежных систем (если присутствуют платежные транзакции).\n- Соответствие гайдлайнам операционных систем.\n- Влияние на производительность устройства.\n\nТакже необходимо проанализировать сетевой трафик: обрыв сети и слабый интернет, исходящие запросы и полученные ответы. Для этого используют снифферы Charles/Fiddler, Proxyman и другие.\n\nПри необходимости выполняют тестирование API. Для этой задачи используют специализированные инструменты: Swagger, Postman, SOAPUI. Они помогают документировать запросы и выполнять их интерактивную проверку. Подробнее их мы рассмотрим дальше.\n\nДля тестирования на различных устройствах используют эмуляторы вроде Genymotion, BlueStacks. Однако успешные тесты на эмуляторе не гарантируют, что приложение будет работать без сбоев на реальных устройствах. Чтобы подключиться к реальным мобильным устройствам и интегрировать туда автотесты, используют фермы BrowserStack, Xamarin или AWS. Либо можно поднять собственную ферму на базе OpenSTF — это позволит всем сотрудникам иметь равный доступ к тестовым устройствам, что особо важно в условиях распределенных команд и удаленной работы.\n\nДля автоматизации UI тестирования мобильных приложений используют Appium, Detox, Ranorex — инструменты автоматизации для запуска сценариев и тестирования приложений на Android или iOS с помощью веб-драйвера. Подробнее инструменты для автоматизации тестирования мы рассмотрим ниже.\n\nКогда ваш проект имеет большое количество автотестов, будет полезно автоматизировать их запуск при каждой сборке нового билда. Чтобы настроить этот процесс, используйте системы CI/CD — Jenkins/TeamCity.\n\nИсточник:\n\n1. ❗ [«Особенности тестирования мобильных приложений», Игорь Плотников](https://www.youtube.com/watch?v=Vy_6hfmk34E)\n2. ❗ [Мобильное тестирование, автоматизация и тестирование API: С чем нужно уметь работать тестировщику в 2021 году](https://habr.com/ru/company/reksoft/blog/541344/)","date":"2022-09-05T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/osobennosti-testirovaniya-mobilnyh-prilozhenij/","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Виды мобильных приложений, их плюсы и минусы","anchor":"#виды-мобильных-приложений-их-плюсы-и-минусы"},{"value":"Отличия web и mobile тестирования","anchor":"#отличия-web-и-mobile-тестирования"},{"value":"Тестирование mobile приложений","anchor":"#тестирование-mobile-приложений"},{"value":"Жизненный цикл приложения","anchor":"#жизненный-цикл-приложения"},{"value":"Обратная связь с пользователем","anchor":"#обратная-связь-с-пользователем"},{"value":"Настройки разработчика в Android","anchor":"#настройки-разработчика-в-android"},{"value":"Помощь при релизах","anchor":"#помощь-при-релизах"},{"value":"Чек-лист тестирования мобильных приложений:","anchor":"#чек-лист-тестирования-мобильных-приложений"}]}},{"node":{"id":"0863d597c5db8b9e48addd453dcef705","title":"Тестирование мобильного приложения","content":"\n## С чего начать?\n\n### Этап 1: Планирование\nКогда этап разработки приложения почти завершен, вы должны снова поставить перед собой вопрос - чего вы пытаетесь достичь разработкой данного приложения и какие у вас есть ограничения.\n\nВы должны определить следующее:\n\n- Взаимодействует ли ваше приложение с другими приложениями?\n- Насколько функциональны все возможности приложения?\n- Является ли тестируемое мобильное приложение нативным, Mobile-web или гибридным?\n- Ограничена ли задача тестирования приложения тестированием только внешнего интерфейса?\n- Стоят ли задачи на тестирование бэкенда?\n- Какова должна быть совместимость с различными беспроводными сетями?\n- Как сильно данные приложения и свободное пространство, занимаемое им, зависят от особенностей использования приложения?\n- Насколько быстро загружается ваше приложение, насколько быстро происходит серфинг по меню приложения и его функциям?\n- Как будет обрабатываться возможное увеличение нагрузки на приложение?\n- Влияют ли различные изменения в статусе и состоянии телефона на работу мобильного приложения?\n- Убедитесь, что вы договорились с командой тестировщиков о роли каждого из них и о ваших ожиданиях от процесса тестирования. В конце концов, общение является ключом к поддержанию правильной рабочей среды в команде.\n\nПравильное понимание ролей и задач также относится и к моменту прописывания списка тест кейсов. Вся команда QA должна поддерживать и обновлять этот документ с отчетами по тестированию всех функций, реализованных на протяжении всего процесса разработки.\n \n### Этап 2. Определение необходимых типов тестирования мобильных приложений\nПеред тестированием любых мобильных приложений определите, что именно в данном мобильном приложении вы хотите протестировать: набор функциональности, удобство использования, совместимость, производительность, безопасность и т. д. На этом же этапе имеет смысл выбрать методы тестирования мобильного приложения.\n\nОпределите, на какие целевые устройства направлено данное приложение, и какие требования  к функционалу следует проверить.\n\nВы также должны определить, какие целевые устройства нужно включить в список тестирования.\n\nВы можете сделать это следующим образом:\n\n- Выяснить, какие устройства будет поддерживать приложение;\n- Определить, какая версия операционной системы будет самой ранней из тех, что  поддерживаются приложением;\n\n- Выявить наиболее популярные модели мобильных устройств у целевой аудитории;\n- Определить набор не основных (дополнительных) устройств с экранами разных размеров, потенциально  поддерживаемых приложением;\n- Решить, будете ли вы использовать для тестирования физические устройства или их эмуляторы.\n\n### Этап 3: Тестовые случаи и разработка сценариев тестирования приложения\nПодготовьте документ, описывающий тестовые случаи (test cases) для каждой тестируемой функции и функциональности.\n\nВ дополнение к функциональным тестовым случаям, также должны быть охвачены некоторые отдельные моменты (кейсы):\n\n- Особенность использование батареи;\n- Скорость работы приложения;\n- Требования к данным;\n- Объем используемой памяти.\n\nТакже перед началом тестирования важно определиться, какое сочетание ручного и автоматического тестирования вы будете применять.\n\nПри необходимости подготовьте отдельные наборы ручных тестовых случаев и сценариев для автоматического тестирования и адаптируйте их согласно требованиям проекта.\n \n### Этап 4: Ручное и автоматическое тестирование\nТеперь пришло время для выполнения ручных и автоматизированных тестов.\nРанее, на предыдущих этапах, вы уже определили, какие тесты и скрипты использовать и подготовили их. Теперь, на текущем этапе, вы выполняете запуск тестов для проверки механизмов основной функциональности, чтобы убедиться в отсутствии поломок.\n\nАвтоматизированное тестирование мобильных приложений хорошо экономит время и другие ресурсы тестировщиков.\n\n### Этап 5: Тестирование юзабилити и бета-тестирование\nПосле того, как базовый функционал протестирован, настало время убедиться, что мобильное приложение является достаточно простым в использовании и обеспечивает удовлетворительный пользовательский опыт. На этом этапе необходимо поддерживать соответствие матрице кроссплатформенности, чтобы обеспечить охват пользователей различных платформ, достигнутый бета-тестерами.\n\nПосле того, как приложение будет протестировано внутри компании, вы сможете выпустить бета-версию приложения на рынок.\n\n**Тестирование совместимости**\n\nМобильные устройства различаются в зависимости от платформы, модели и версии их операционной системы. Важно выбрать такое подмножество устройств, которое будет соответствовать вашему приложению.\n\n**Тестирование пользовательского интерфейса**\n\nПользовательский опыт является ключевым элементом, при тестировании приложения. Ведь наше приложение разрабатывается именно для конечных пользователей. Вам следует качественно проверить удобство использования приложения, навигацию по его элементам и контент. Тестируйте меню, опции, кнопки, закладки, историю, настройки и навигацию приложения.\n\n**Тестирование интерфейса**\n\nТестирование пунктов меню, кнопок, закладок, истории, настроек и навигации по приложению.\n\n**Тестирование внешних факторов**\n\nПриложения для мобильных устройств не будут единственными приложениями на устройстве пользователя. Вместе с вашим приложением будут установлены приложения от сторонних разработчиков. Возможно десятки таких приложений. Следовательно, вашему приложению придётся взаимодействовать с этими сторонними приложениями и прерывать работу различных функций устройства, таких как различные типы сетевых подключений, обращение к SD-карте, телефонные звонки и другие функции устройства.\n\n**Тестирование доступности**\n\nМобильными устройствами могут пользоваться различные люди с ограниченными возможностями. По этой причине важно  протестировать возможность работы с приложением людей с дальтонизмом, нарушениями слуха, проблемами пожилого возраста и другими возможными проблемами.  Такое тестирование является важной частью общего тестирования юзабилити.\n\n### Этап 6: Тестирование производительности\nМобильные устройства предоставляют для приложений меньший объем памяти и меньшую доступную мощность процессора, чем стационарные компьютеры и ноутбуки. По этой причине в работе мобильных приложений очень важна эффективность использования предоставляемых ресурсов. Вам следует проверить работоспособность тестируемого приложения, изменив соединение с 2G, 3G на WIFI, проверить скорость отклика, потребление заряда батареи, стабильность работы и т. д.\n\nРекомендуется проверять приложение на предмет масштабируемости применения и наличие возможных проблем с производительностью.\n\nВ рамках этого этапа важно пройти и нагрузочное тестирование мобильного приложения.\n\n**Функциональное тестирование**\n\nФункциональность приложения должна быть полностью протестирована. Особое внимание следует уделить установке, обновлениям, регистрации и входу в систему, обеспечению, работе со специфическими функциями устройства и сообщениям об ошибках.\n\nФункциональное тестирование мобильного приложения, по большей части, может быть выполнено так же, как вы выполнили бы его для любого другого типа приложения. По этой причине мы не будем вдаваться в подробности этого типа тестирования. Однако следует указать области, которые имеют особое значение для мобильных приложений.\n\nИмейте в виду, что функциональное тестирование должно включать в себя тестирование всех функций приложения и не должно быть излишне сосредоточено на какой-то одной функции.\n\nВ рамках функционального тестирования, вам следует выполнить следующие тесты:\n\n- Тестирование процесса установки;\n- Тестирование возможности обновлений;\n- Эксплуатационное тестирование;\n- Тестирование процесса регистрации и авторизации;\n- Тестирование функций, специфических для устройства;\n- Тестирование отправки и получения сообщений об ошибках;\n- Низкоуровневое тестирование ресурсов: использование памяти, автоматическое освобождение ресурсов и т.д.\n- Тестирование сервисов: функционирование как в режиме онлайн, так и в автономном режиме.\n\n### Этап 7: Аттестационное тестирование и тестирование безопасности приложения\nБезопасность и конфиденциальность данных имеют огромное значение в наше время. Пользователи требуют, чтобы вся их информация хранилась безопасно и конфиденциально.\n\nУбедитесь, что тестируемое приложение надежно защищено. Выполните проверку на возможность внедрения SQL инъекций, на возможность перехвата сеансов, анализа дампов данных, анализа пакетов и SSL трафика.\n\nОчень важно проверить безопасность хранилища конфиденциальных данных вашего мобильного приложения и его поведение в соответствии с различными схемами разрешений для устройств.\n\nПомимо проверки безусловного шифрования имен пользователей и паролей, задайте себе следующие вопросы:\n\n- Есть ли у приложения сертификаты безопасности?\n- Использует ли приложение безопасные сетевые протоколы?\n- Существуют ли какие-либо ограничения, например количество попыток входа в систему до блокировки пользователей?\n \n### Этап 8: Тестирование устройства\nВыполните тесты по тем алгоритмам, которые вы ранее прописали в тестовых случаях и сценариях тестирования на всех определенных для тестирования устройствах, в облаке и / или на физических устройствах.\n\n### Этап 9: контрольный этап и резюме\nЭтот этап включает в себя подробное и полное тестирование - от ранних итеративных этапов тестирования до регрессионных тестов, которые все еще могут потребоваться для стабилизации работы приложения и выявления незначительных дефектов.\n\nНа этом этапе тестирования вы можете добавить для проверки новые функции и изменить настройки на те, которых не будет в финальной версии.\n\nПосле завершения тестирования приложения, дополнительные параметры и функции, добавленные для проверки на этом этапе, удаляются, и окончательная версия становится готовой для представления общественности.\n\n**Итоговый отчет о тестировании**\n\nВесь процесс тестирования мобильных приложений должен быть тщательно задокументирован. Проверьте дважды, сделаны ли нужные записи, и после этого сформируйте свой окончательный отчет о тестировании (test summary report).\n\nЭтот отчет должен включать:\n\n- Важную информацию, выявленную в результате проведенных испытаний;\n- Информацию о качестве проводимого тестирования;\n- Сводную информацию о качестве тестируемого мобильного приложения;\n- Статистику, полученную из отчетов об различных инцидентах;\n- Информацию о видах тестирования и времени, затраченном на каждый из них.\n\nСледует также указать в отчете, что:\n\n- данное мобильное приложение пригодно для использования в том качестве, в котором заявлено;\n- соответствует всем критериям приемлемости функционала и качества работы.\n\n","date":"2022-09-07T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/testirovanie-mobilnogo-prilozheniya/","order":1,"category":{"title":"mobile","path":"/category/mobile/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"С чего начать?","anchor":"#с-чего-начать"}]}}]}},"relatedCategory":{"id":"94252df58cf6098f05cbf18a7cae32b6","title":"mobile","path":"/category/mobile/","related":[{"id":"manual","path":"/category/manual/","title":"manual"},{"id":"automation","path":"/category/automation/","title":"automation"}]}},"context":{}}