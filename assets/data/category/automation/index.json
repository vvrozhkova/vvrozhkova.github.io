{"hash":"02799b688b4cb7ace869e49ff69fbf95eb6f42e6","data":{"category":{"title":"automation","path":"/category/automation/","belongsTo":{"totalCount":24,"pageInfo":{"totalPages":3,"currentPage":1},"edges":[{"node":{"id":"e2ee3d5b1de78d3b249f973bb2f483f2","title":"Assertions","content":"\nВместо сложения слов лучше использовать supplier\n\n()-> \"gfdg\"+ test + \"expected \";","date":"2022-06-08T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/assertions/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[]}},{"node":{"id":"6f27ad167274af18748e3dabc1d1618d","title":"Курс по автоматизации тестирования Java","content":"\n## Вводное занятие. Сразу к практике!\n\n❌ [Вводное занятие. 13-ый поток](https://qa.guru/pl/teach/control/lesson/view?id=242247981&editMode=0)\n\n❌ [Selenium 4. Новые возможности](https://qa.guru/pl/teach/control/lesson/view?id=234815403&editMode=0)\n\n## Профессионально работаем с IntelliJ IDEA Юрий Артамонов\n\n1. Основы\n2. Git and Github\n3. Docker\n4. Базы данных\n5. HTTP Client\n6. Selenium\n7. BDD Support\n\n✅ https://www.youtube.com/watch?v=5qrn-Z5Put4\n\n✅ https://www.youtube.com/watch?v=zp0qC6JT0rE\n\n## 2. Git. Github. Погружаемся. Дмитрий Тучс\n\n1. Еще раз повторим основы Git & Github.\n2. Основы ветвления, pull requests.\n\n✅ [Дополнительное занятие. Станислав Васенков. «GitHub. Readme»](https://www.youtube.com/watch?v=ERYv-g2l0QE)\n\n❌ [Принимаем пулреквесты](https://www.youtube.com/watch?v=X0X1N39ciUw)\n\n## 3. Погружаемся в инструментарий и библиотеки. Станислав Васенков.\n\n1. Теория: Gradle, JUnit5, Selenide.\n2. Практика. Работаем с тренажером demoqa.com\n3. Рассмотрим подробнее возможности Selenide и CSS/Xpath-селекторы\n\n## 4. Основы Java. Дмитрий Тучс.\n\n1. Src - main\n2. Класс с точки зрения файлов\n3. Класс с точки зрения Java\n4. Class fields - переменные (в чем разница)\n5. Примитивные типы данных\n6. Литералы\n7. Операторы\n8. Управляющие конструкции\n9. Метод, как описание поведения\n10. Создание обьектов и вызов методов\n\n✅ [QA.GURU 13-ый поток. Дмитрий Тучс. «Основы Java»](https://www.youtube.com/watch?v=JyLdYQPNOi8)\n\n✅ [Основы Java #2. Продолжение](https://qa.guru/pl/teach/control/lesson/view?id=231894553&editMode=0)\n\n✅ [QA.GURU 11-ый поток. Дополнительное занятие. Дмитрий Тучс. «Java. Продолжение»](https://www.youtube.com/watch?v=IFqwHW5PtSM)\n\n✅ [Дополнительное занятие. Дмитрий Тучс. ООП на примере Java](https://qa.guru/pl/teach/control/lesson/view?id=222958479&editMode=0)\n\n✅ [QA.GURU 8-ой поток. Дополнительное занятие. Дмитрий Тучс. «Основы Java. Продолжение»](https://www.youtube.com/watch?v=Arb5Zt1ydgI)\n\n✅ [Основы Java #3. Продолжение](https://qa.guru/pl/teach/control/lesson/view?id=231894597&editMode=0)\n\n✅ [QA.GURU 11-ый поток. Дополнительное занятие. Дмитрий Тучс. «Основы Java. Продолжение»](https://www.youtube.com/watch?v=sCRgsgREWKU)\n\n✅ [QA.GURU 11-ый поток. Дмитрий Тучс. Дополнительное занятие «Основы Java. Продолжение. Часть II»](https://www.youtube.com/watch?v=icT5QaOC_Yg)\n\n## 5. Продолжаем разрабатывать автотесты. PageObjects. Станислав Васенков.\n\n1. Добавляем в код PageObjects\n2. Изучаем подходы - степовой, сценарный, dsl\n3. Добавляем PageComponents\n\n❌ [Станислав Васенков — Как Testid-strategy победила PageObject и BDD/Cucumber монстров](https://www.youtube.com/watch?v=w5EgCZgj5yE)\n\n## 6. Продолжаем разрабатывать автотесты. Генерация тестовых данных. Станислав Васенков.\n\n1. Генерим рандомные значения используя встроенные библиотеки\n2. Используем JavaFaker\n\n## 7. JUnit 5. Дмитрий Тучс\n\n1. Аннотация @Test\n2. Что из себя представляют аннотации в Java\n3. Пишем свою простейшую реализацию JUnit\n4. @Disabled , @DisplayName\n5. тест кейс - что такое и из чего состоит\n6. Параметризованные тесты - концепция\n- Sources (дата-провайдеры)\n- Нэйминг\n\n❌ [junit5/junit4/assertions: кто как готовит свои тесты, кто на чем обжегся и какие вещи никогда не стал бы использовать](https://www.youtube.com/watch?v=w1ey2zjf3-s)\n\n❌ [Дмитрий Тучс — JUnit 5 Parallel test execution. Теория и практика](https://youtu.be/ZIkIUCyJBGU)\n\n❌ [QA.GURU 10-ый поток. Дополнительное занятие. Дмитрий Тучс. «JUnit 5. Продолжение»](https://www.youtube.com/watch?v=3pOjh6O7-cg)\n\n## 8. Selenide #1. Алексей Виноградов\n\n1. Лайвкодинг - тесты для GitHub\n2. DOM для начинающих\n3. Основные функции библиотеки Selenide (справочник-шпаргалка)\n\n❌ [Обзор новинок Selenide и Q&A](https://qa.guru/pl/teach/control/lesson/view?id=222958530&editMode=0)\n\n## 10. Allure Reports. Артём Ерошенко\n\n1. Практика. Подключение Allure Reports и настройка отчетности о прохождении автотестов.\n2. Практика. Построение более информативной отчетности c вложениями:\n- Прикладываем скриншоты, файлы, логи и другие вложения в отчет.\n3. Теория. Обзор возможностей Allure Reports.\n\n## 9. Работаем с файлами. Дмитрий Тучс\n\n1. Как скачать и прочитать файл\n2. Проверяем контент в .txt, .pdf, .xls/.xlsx, .doc/.docx, .zip\n\n## 11. Jenkins. Создаем первую задачу. Станислав Васенков.\n1. Практика. Создаем задачу (Job), связываем с репозиторием в Github, запускаем тесты удаленно.\n2. Теория. Основы Jenkins.\n3. Теория. Основы CI/CD.\n4. Работа в парах: создаем друг другу джобы и запускаем чужой код\n\n## 12. Управляем параметрами в коде и в Jenkins. Станислав Васенков.\n1. Передаем параметры в код из командной строки\n2. Прячем приватные данные с библиотекой owner\n3. Передаем параметры из jenkins\n\n## 13. Телеграм-бот. Отправляем уведомления о результатах прохождении автотестов. Станислав Васенков.\n1. Практика. Пишем телеграмм-бота.\n2. Практика. Постобработка сборки. Настраиваем отправку уведомлений в Jenkins.\n3. Теория. Обзор возможностей Telegram API.\n\n## 14. Учимся быстро разрабатывать готовые проекты для тестовых заданий. Станислав Васенков.\n\nНабиваем руку небольшими проектами.\n\n1. Находим интересную нам вакансию (hh.ru / linkedin / @qa_jobs)\n2. Делаем небольшой проект:\n- разрабатываем 5-10 простых автотестов на сайт из вакансии,\n    - создаем задачу в jenkins,\n- прячем секретные данные с owner (более развернуто будет в следующем занятии)\n- настраиваем Allure-отчет, добавляем вложения:\n    - снимки экрана,\n    - логи браузера,\n    - видеозапись теста,\n- настраиваем нотификация в telegram / slack.\n\nПо мере прохождения курса добавим сюда:\n- автотесты на API\n- тест-план Allure TestOps - с ручными и автоматизированными тестами\n- интеграцию с Jira\n3. Отправляем наш проект hr c сопроводительным письмом\n\n\n## 15. Selenoid. Роман Орлов\n1. Практика. Добавляем контейнеризацию к задаче в Jenkins.\n2. Теория. Основы Docker. Selenoid\n\n❌ [Дополнительное занятие. Selenoid. Роман Орлов (на GO)](https://qa.guru/pl/teach/control/lesson/view?id=225328797&editMode=0)\n\n## 16. Библиотека Owner. Артём Ерошенко\n\n1. Правильно организуем хранение свойств (properties) в проекте с библиотекой Owner\n2. Прячем секретные данные в Jenkins\n\n## 17. Selenide #2. Алексей Виноградов\n\n1. Практика:\n- Написание автотестов на Selenide.\n- Тестирование виджетов.\n2. Теория:\n- Закрепление знаний полученных на практике\n- Java\n- JUnit5\n\n## 18. REST API. Пишем автотесты с Rest-assured. Станислав Васенков.\n\n1. Практика. Пишем тесты на REST API при помощи библиотеки Rest-assured\n2. Теория. Основы HTTP-протокола, типы запросов, коды ответов.\n\n❌ [Алексей Кузнецов. «Retrofit2»](https://qa.guru/pl/teach/control/lesson/view?id=229174108&editMode=0)\n\n## REST API. Декомпозируем UI-тесты. Подключаем отчетность\n\n1. Превращаем UI-взаимодействия в Api-запросы.\nБольше возможностей REST-assured\n2. Подключаем Allure-listener\n3. Добавляем шаблоны для более красивого отчета\n\n## 19. REST API. Продолжаем изучать. Станислав Васенков.\n\n1. Практика. Декомпозируем UI-автотест в несколько API-автотестов.\nБольше возможностей REST-assured\n2. Изучаем вспомогательные инструменты:\n- Postman,\n- Charles/Fiddler,\n- chrome dev tools (вкладка Network)\n3. Теория. Больше про REST API.\n4. Теория. Обзор SOAP API\n\n## 20. REST API/ Groovy. Алексей Кузнецов\n\n- Groovy для ассертов и основы языка\n- Немного магии java\n- Спецификации\n- Шаблоны для Allure\n\n## Дополнительное занятие. REST API. Дмитрий Тучс\n\n- Swagger\n- API с другой стороны (backend на spring boot)\n- Интеграция backend со Swagger\n- Контроллеры, возвращающие списки объектов\n- Практика\n\n## Дополнительное занятие. SOAP API. Дмитрий Тучс\n\n1. Основы протокола\n2. Soap UI\n\n## 21. Мобильная автоматизация #1. Разрабатываем автотесты с Browserstack\n\n1. Практика. Учимся пользоваться инспектором в Browserstack, разрабатываем первые автотесты на iOS / Android с Selenide\n2. Практика. Browserstack-API. Забираем логи, видео.\n3. Теория. Основы тестирования мобильных приложений.\n\n## 22. Мобильная автоматизация #2. Разрабатываем автотесты с эмулятором Android-устройства и на своем телефоне\n\n1. Настраиваем рабочее место:\n- Appium\n- Android Studio\n- Настраиваем переменные среды\n2. Эмулируем Android устройство\n3. Подключаем свой телефон\n4. Практика. Разрабатываем автотесты с Appium.\n5. Теория. Основы Appium.\n\n[BONUS] Запускаем тесты на школьном Selenoid - Android\n\n## 23. Allure TestOps #1. Артем Ерошенко\n1. Знакомство с системой.\n2. Заведение тест-кейсов.\n3. Создание первого тест-плана.\n\n## 24. Allure TestOps #2. Артем Ерошенко\n1. Интеграции с Jenkins и Jira\n2. Объединение ручных тестов и автотестов в единый тест-план\n3. Метрики, графики, углубленное изучение платформы\n4. Администрирование\n5. Обзор решений и внедренных проектов\n\n## 25. Дипломный проект\n\nНабиваем руку небольшими проектами.\n\n1. Находим интересную нам вакансию (hh.ru / linkedin / @qa_jobs)\n2. Делаем небольшой проект - разрабатываем 5-10 простых автотестов на сайт из вакансии, добавляем джобу в дженкинсе с аллюр-отчетом\nДобавляем сюда Selenoid, Allure TestOps, Jira, Telegram notifications\n3. Отправляем наш проект hr c сопроводительным письмом\n\n❌ [Проверка дипломных проектов 7-го потока](https://qa.guru/pl/teach/control/lesson/view?id=223930680&editMode=0)\n\n❌ [Проверка дипломных проектов 8-го потока](https://www.youtube.com/watch?v=wI8dVgOQzJ8)\n\n## 26. Переезд на собственную инфраструктуру с ресурсов школы. Егор Иванов (выпускник первого потока)\n\nНастроим тестовый стенд локально. Точно также стенд настраивается на любом VPS, например в DigitalOcean.com\n\n1. Рассмотрим базовые команды Linux, которые понадобятся\n2. Доступ к удаленному серверу через ssh Ubuntu  \n  2.1 Доступ к Ubuntu через ssh при помощи публичного RSA ключа\n3. На виртуальной машине установим:  \n  3.1 Java  \n  3.2 Docker  \n  3.3 Docker-compose\n4. Создаем конфиг для docker-compose\n5. Поднимаем Selenoid + Selenoid UI  \n  5.1 Проверяем, как это работает\n6. Поднимаем Jenkins  \n  6.1 Первичные настройки Jenkins.  \n  6.2 Проверка работоспособности.\n  \nЗадание не обязательное. Доступ к инфраструктуре школы останется после окончания обучения (в разумных пределах, конечно).\n\n❌ [Дополнительное занятие. SQL + работа с базой из Java. Дмитрий Тучс.](https://qa.guru/pl/teach/control/lesson/view?id=222958523&editMode=0)\n\n❌ [Дополнительное занятие. Дмитрий Тучс. Тестируем gRPC](https://qa.guru/pl/teach/control/lesson/view?id=222958538&editMode=0)\n\n❌ [Делаем ревью библиотеки allure-notifications. Дмитрий Тучс. Алексей Кузнецов](https://qa.guru/pl/teach/control/lesson/view?id=242453199&editMode=0)\n\n❌ [Делаем ревью автотестов для Allure TestOps. Дмитрий Тучс. Александр Киреев](https://qa.guru/pl/teach/control/lesson/view?id=243490573&editMode=0)\n\n❌ [Дорабатываем сервис генерации проектов start.autotests.cloud. Станислав Васенков](https://qa.guru/pl/teach/control/lesson/view?id=244143788&editMode=0)\n\n❌ [QA.GURU. Станислав Васенков. «Расширенное занятие по уведомлениям о статусе ваших автотестов.»](https://www.youtube.com/watch?v=ybbGlgCusOQ)\n\n\n\n","date":"2022-06-10T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/kurs-po-avtomatizaczii-testirovaniya-java/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Вводное занятие. Сразу к практике!","anchor":"#вводное-занятие-сразу-к-практике"},{"value":"Профессионально работаем с IntelliJ IDEA Юрий Артамонов","anchor":"#профессионально-работаем-с-intellij-idea-юрий-артамонов"},{"value":"2. Git. Github. Погружаемся. Дмитрий Тучс","anchor":"#2-git-github-погружаемся-дмитрий-тучс"},{"value":"3. Погружаемся в инструментарий и библиотеки. Станислав Васенков.","anchor":"#3-погружаемся-в-инструментарий-и-библиотеки-станислав-васенков"},{"value":"4. Основы Java. Дмитрий Тучс.","anchor":"#4-основы-java-дмитрий-тучс"},{"value":"5. Продолжаем разрабатывать автотесты. PageObjects. Станислав Васенков.","anchor":"#5-продолжаем-разрабатывать-автотесты-pageobjects-станислав-васенков"},{"value":"6. Продолжаем разрабатывать автотесты. Генерация тестовых данных. Станислав Васенков.","anchor":"#6-продолжаем-разрабатывать-автотесты-генерация-тестовых-данных-станислав-васенков"},{"value":"7. JUnit 5. Дмитрий Тучс","anchor":"#7-junit-5-дмитрий-тучс"},{"value":"8. Selenide #1. Алексей Виноградов","anchor":"#8-selenide-1-алексей-виноградов"},{"value":"10. Allure Reports. Артём Ерошенко","anchor":"#10-allure-reports-артём-ерошенко"},{"value":"9. Работаем с файлами. Дмитрий Тучс","anchor":"#9-работаем-с-файлами-дмитрий-тучс"},{"value":"11. Jenkins. Создаем первую задачу. Станислав Васенков.","anchor":"#11-jenkins-создаем-первую-задачу-станислав-васенков"},{"value":"12. Управляем параметрами в коде и в Jenkins. Станислав Васенков.","anchor":"#12-управляем-параметрами-в-коде-и-в-jenkins-станислав-васенков"},{"value":"13. Телеграм-бот. Отправляем уведомления о результатах прохождении автотестов. Станислав Васенков.","anchor":"#13-телеграм-бот-отправляем-уведомления-о-результатах-прохождении-автотестов-станислав-васенков"},{"value":"14. Учимся быстро разрабатывать готовые проекты для тестовых заданий. Станислав Васенков.","anchor":"#14-учимся-быстро-разрабатывать-готовые-проекты-для-тестовых-заданий-станислав-васенков"},{"value":"15. Selenoid. Роман Орлов","anchor":"#15-selenoid-роман-орлов"},{"value":"16. Библиотека Owner. Артём Ерошенко","anchor":"#16-библиотека-owner-артём-ерошенко"},{"value":"17. Selenide #2. Алексей Виноградов","anchor":"#17-selenide-2-алексей-виноградов"},{"value":"18. REST API. Пишем автотесты с Rest-assured. Станислав Васенков.","anchor":"#18-rest-api-пишем-автотесты-с-rest-assured-станислав-васенков"},{"value":"REST API. Декомпозируем UI-тесты. Подключаем отчетность","anchor":"#rest-api-декомпозируем-ui-тесты-подключаем-отчетность"},{"value":"19. REST API. Продолжаем изучать. Станислав Васенков.","anchor":"#19-rest-api-продолжаем-изучать-станислав-васенков"},{"value":"20. REST API/ Groovy. Алексей Кузнецов","anchor":"#20-rest-api-groovy-алексей-кузнецов"},{"value":"Дополнительное занятие. REST API. Дмитрий Тучс","anchor":"#дополнительное-занятие-rest-api-дмитрий-тучс"},{"value":"Дополнительное занятие. SOAP API. Дмитрий Тучс","anchor":"#дополнительное-занятие-soap-api-дмитрий-тучс"},{"value":"21. Мобильная автоматизация #1. Разрабатываем автотесты с Browserstack","anchor":"#21-мобильная-автоматизация-1-разрабатываем-автотесты-с-browserstack"},{"value":"22. Мобильная автоматизация #2. Разрабатываем автотесты с эмулятором Android-устройства и на своем телефоне","anchor":"#22-мобильная-автоматизация-2-разрабатываем-автотесты-с-эмулятором-android-устройства-и-на-своем-телефоне"},{"value":"23. Allure TestOps #1. Артем Ерошенко","anchor":"#23-allure-testops-1-артем-ерошенко"},{"value":"24. Allure TestOps #2. Артем Ерошенко","anchor":"#24-allure-testops-2-артем-ерошенко"},{"value":"25. Дипломный проект","anchor":"#25-дипломный-проект"},{"value":"26. Переезд на собственную инфраструктуру с ресурсов школы. Егор Иванов (выпускник первого потока)","anchor":"#26-переезд-на-собственную-инфраструктуру-с-ресурсов-школы-егор-иванов-выпускник-первого-потока"}]}},{"node":{"id":"3be64faa1fe9afd96ff0c811fa66f4b8","title":"Code Style","content":"\nqwerty","date":"2023-05-21T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/code-style/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"code style","path":"/tag/code%20style/"},{"title":"java","path":"/tag/java/"}],"headings":[]}},{"node":{"id":"5589b8535773fb9a787c3643c3654afd","title":"Ресурсы для написания проекта по автоматизации 1","content":"\n## Kubernetes, Docker, Selenoid\n\n[Ресурсы. Kubernetes, Docker, Selenoid](/resursy-kubernetes-docker-selenoid/)\n\n## Selenium 4\n\n[Ресурсы. Selenium 4](/resursy-selenium-4/)\n\n## API\n\n[Ресурсы. API](/resursy-api/)\n\n## UI\n\n[Ресурсы. UI](/resursy-ui/)\n\n## CI\n\n[Ресурсы. CI](/resursy-ci/)\n\n## Тест дизайн\n\n[Ресурсы. Тест дизайн](/resursy-test-dizajn/)\n\n## Паттерны проектирования\n\nhttps://www.youtube.com/watch?v=EnooA2kEhY0\n\nhttps://www.youtube.com/watch?v=-JI9tcWr8E4\n\nhttps://www.youtube.com/watch?v=oVx1Z04Ajq0\n\nhttps://www.youtube.com/watch?v=pln38fIbYqA\n\n## Статический анализ\n\nhttps://youtube.com/watch?v=O0-vAiqGrVk\n\nhttps://www.youtube.com/watch?v=E87YkXhdxAA\n\n## Тестовое покрытие\n\nhttps://www.youtube.com/watch?v=vl79g-0zzP0\n\nhttps://www.youtube.com/watch?v=lMD82Pj3Llk\n\nhttps://www.youtube.com/watch?v=rtwjMceVRaw\n\n## kotlin в автоматизации\n\nhttps://www.youtube.com/watch?v=fkboozZ2CWA\n\nhttps://www.youtube.com/watch?v=2For6QVZqsg\n\n## Appium\n\nhttps://www.youtube.com/watch?v=2ECGcMejda0\n\nhttps://www.youtube.com/watch?v=qYu0CrXqPps\n\n## Карьера в IT\n\nhttps://www.youtube.com/watch?v=Euh4ohO9Ong\n\nhttps://www.youtube.com/watch?v=1wvYjuq9508\n\nhttps://www.youtube.com/watch?v=cNxX4cyrviA\n\n## Code Review\n\nhttps://www.youtube.com/watch?v=RFUMO7XTAQY\n\nhttps://www.youtube.com/watch?v=edNscDtiYGE\n\n## Тестовые данные \n\nhttps://www.youtube.com/watch?v=E21AxgHX2B0\n\n## Разное\n\nhttps://www.youtube.com/watch?v=99q5KnqycmY\n\nhttps://www.youtube.com/watch?v=x-tNXvvz_KA\n\nhttps://www.youtube.com/watch?v=AoJb6QLeIMI\n\nhttps://www.youtube.com/watch?v=hYSQq4XqWIw\n\nhttps://www.youtube.com/watch?v=roLrGhpQeq4\n\nhttps://www.youtube.com/watch?v=13KmFOo8Qag\n\nhttps://www.youtube.com/watch?v=hQqjXjwWH_4","date":"2022-06-08T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-dlya-napisaniya-proekta-po-avtomatizaczii-1/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Kubernetes, Docker, Selenoid","anchor":"#kubernetes-docker-selenoid"},{"value":"Selenium 4","anchor":"#selenium-4"},{"value":"API","anchor":"#api"},{"value":"UI","anchor":"#ui"},{"value":"CI","anchor":"#ci"},{"value":"Тест дизайн","anchor":"#тест-дизайн"},{"value":"Паттерны проектирования","anchor":"#паттерны-проектирования"},{"value":"Статический анализ","anchor":"#статический-анализ"},{"value":"Тестовое покрытие","anchor":"#тестовое-покрытие"},{"value":"kotlin в автоматизации","anchor":"#kotlin-в-автоматизации"},{"value":"Appium","anchor":"#appium"},{"value":"Карьера в IT","anchor":"#карьера-в-it"},{"value":"Code Review","anchor":"#code-review"},{"value":"Тестовые данные","anchor":"#тестовые-данные"},{"value":"Разное","anchor":"#разное"}]}},{"node":{"id":"8d9bed2d7f5e2e7fb092ceb89f92f47f","title":"Проблемы и решения","content":"\n## Ошибка Timeout waiting to lock... во время сборки Gradle проекта \nВ терминале нужно выполнить команду \n```\nfind ~/.gradle -type f -name \"*.lock\" -delete\n``` \n\n## ITK\nSelenide вернет проинициализированный объкт после того как откроет страницу по указанному url.\n\n```java\nHuman h = Selenide.open(\"\", Human.class);\n```\n\n## Папка test не подсвечивается как модуль\nНужно пометить папку src-test-java как Test Source и пересобрать проект в gradle\n","date":"2022-06-13T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/problemy-i-resheniya/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Ошибка Timeout waiting to lock... во время сборки Gradle проекта","anchor":"#ошибка-timeout-waiting-to-lock-во-время-сборки-gradle-проекта"},{"value":"ITK","anchor":"#itk"},{"value":"Папка test не подсвечивается как модуль","anchor":"#папка-test-не-подсвечивается-как-модуль"}]}},{"node":{"id":"7d259c24b7fc3b35d9985fd391d1dbea","title":"Ресурсы. UI","content":"\n## Разработка фреймворка\n\n✅ [Слои тестового фрамеворка: Что? Где? Когда? Антон Шапин. COMAQA Piter 2017](https://youtu.be/8Qm9TJtclYw)\n\n❌ [Секция QA: Полезные практики создания автоматических тестов с использованием Cucumber-JVM](https://youtu.be/tX3V90K8VIU)\n\n✅ [Практика создания модульного тестового проекта (Денис Кудряшов, Leroy Merlin)](https://youtu.be/eIOyQ4Axktk)\n\n✅ [Десять причин моей ненависти - Андрей Солнцев. QA Fest 2019](https://youtu.be/pln38fIbYqA)\n\n❌ [Mocks and network tricks in UI automation - Дмитрий Прокопук. QA Fest 2019](https://youtu.be/rYl3HV_43qg)\n\n❌ [Не изобретайте велосипед! Грамотные функциональные тесты с WebDriver и Thucydides -Николай Алименков](https://youtu.be/mlS5n6ykAgg)\n\n❌ [Sergey Pirogov - Test Cases as a Code](https://youtu.be/dAJ9CIioTIA)\n\n✅ [Что делать, если у вас слишком много автотестов (Сергей Потанин, Wrike, Воронеж)](https://youtu.be/N2eOA4t_xaM)\n\n❌ [Артем Ерошенко — Воркшоп. Fullstack QA: Разбираемся в зоопарке тестов. Часть 1](https://youtu.be/wMm2mxVv1h0)\n\n❌ [Артем Ерошенко — Воркшоп. Fullstack QA: Разбираемся в зоопарке тестов. Часть 2](https://youtu.be/lRSevfOCqwM)\n\n✅ [Сергей Разуваев — Проблемы и решения при тестировании тяжелого энтерпрайза](https://youtu.be/q7G3825dueQ)\n\n❌ [Андрей Солнцев — Воркшоп: Как начать свой проект автоматизации с нуля. Продолжение (часть 1)](https://youtu.be/h254Tccxgq4)\n\n❌ [Андрей Солнцев — Воркшоп: Как начать свой проект автоматизации с нуля. Продолжение (часть 2)](https://youtu.be/WETyt87o_R4)\n\n✅ [Дмитрий Тучс — JUnit 5 Parallel test execution. Теория и практика](https://youtu.be/ZIkIUCyJBGU)\n\n❌ [#11 Артем и Сева. Моки(Mocks) и стабы(Stubs).](https://youtu.be/VbVcGpS8HV4)\n\n❌ [Николай Алименков Автоматизация тестирования Web UI](https://youtu.be/cUoSTBkeFy4)\n\n❌ [А вы знаете что тестируют ваши тесты? (Николай Алименков, SQADays-11)](https://youtu.be/irldaKe-PwU)\n\n❌ [Андрей Солнцев, Антон Кекс — Воркшоп: Парное программирование. Часть 1](https://youtu.be/8K1apzz8Ml4)\n\n❌ [Андрей Солнцев, Антон Кекс — Воркшоп: Парное программирование. Часть 2](https://youtu.be/Itm_KUGo8Ro)\n\n❌ [Владимир Ситников — assertTrue, как много в этом слове...](https://youtu.be/1XoQv5oeAm8)\n\n[Артем Ерошенко — TestOps: DevOps для тестировщиков](https://youtu.be/Iam2NlTukFQ)\n\n[Артем Ерошенко — Нужно сделать рефакторинг проекта? Есть IDEA!](https://youtu.be/Y6oryeeFZYc)\n\n[Артем Ерошенко — Простота, доверие, контроль — три кита автоматизации веб-тестирования](https://youtu.be/gwXpYB6ZayE)\n## Ускорение тестов\n\nhttps://www.youtube.com/watch?v=GZXq6oovGcw\n\nhttps://www.youtube.com/watch?v=yyzGP2CyMRM\n\n### Flaky tests\n\n- 2017\n\n❌ [2017.11.29 Андрей Солнцев - Flaky tests](https://youtu.be/y5TqMKdzmlk) //27.12\n\n- 2018\n\n❌ [Flaky tests are a pain (Andrei Solntsev, Estonia) [RU]](https://youtu.be/zOiSo1hYjF8) // 31.03\n\n❌ [Андрей Солнцев — Flaky tests](https://youtu.be/jLG3RXECQU8) // 2.04\n\n\n- 2019\n\n❌ [Flaky tests 2.0 - (Andrey Solntsev, Estonia)](https://youtu.be/ibx8nVvt-Js) //18.04\n\n❌ [2019.04.30 Андрей Солнцев — Flaky tests. Часть 2](https://youtu.be/elQ2LGGU2bg) // 6.05\n\n- 2020\n\n❌ [Flaky tests: The method. (Andrei Solntsev, Estonia) [RU]](https://youtu.be/6MfMtky-0q4) //15.03\n\n❌ [2020.08.31 Андрей Солнцев - Flaky tests: Метод](https://youtu.be/SSglWLW40Ac) //1.11\n\n\n- 2021\n\n❌ [Андрей Солнцев — Flaky tests. Порядок имеет значение](https://youtu.be/fFe3reCoeBQ) // 9.02\n\n❌ [Андрей Солнцев — Flaky tests. Метод](https://youtu.be/LDjDtR6kd2c) // 9.09\n\n\n## BDD\n\nhttps://www.youtube.com/watch?v=5FM88buqCYU\n\nhttps://www.youtube.com/watch?v=OYj-kWmLcns\n\n## Page Object\n\nhttps://www.youtube.com/watch?v=3aA5roxhlrQ\n\nhttps://www.youtube.com/watch?v=bMwthP9JMmM\n\nhttps://www.youtube.com/watch?v=jT1mIQmdVuo\n\n## интеграционные тесты\n\nhttps://www.youtube.com/watch?v=S4PblsCWANA\n\n## Xpath\n\nhttps://www.youtube.com/watch?v=nuWWl1jE3Vg\n\nhttps://www.youtube.com/watch?v=QcrLCYB_ckc\n\nhttps://www.youtube.com/c/SoftwareTestingMaterialWebsite/videos\n\n\n## test data \n\nhttps://www.youtube.com/watch?v=E21AxgHX2B0\n\nhttps://www.youtube.com/watch?v=dMRlZQMuKNc\n\nhttps://www.youtube.com/watch?v=STsuxvFQTI8\n\n## отчеты\n\nhttps://www.youtube.com/watch?v=4UjOXFnwDOo\n\nhttps://www.youtube.com/watch?v=tcH9-wrkVrk\n\nhttps://www.youtube.com/watch?v=C72RC7hz6Cw\n\nhttps://www.youtube.com/watch?v=rONnA66Ud1A\n\n## интеграция с TMS\n\nhttps://www.youtube.com/watch?v=P-vureOnDWY\n\nhttps://www.youtube.com/watch?v=epXQp6Sq2Oc\n\nhttps://www.youtube.com/watch?v=xjyacUQ3598\n\nhttps://www.youtube.com/watch?v=s5pendRUgKM\n\nhttps://www.youtube.com/watch?v=p4WU6cMMsls\n\nhttps://youtu.be/ipWx2sIcIeI\n\n## Разное\n\nhttps://www.youtube.com/watch?v=zpB3u0vFJnk\n\nhttps://www.youtube.com/watch?v=kYm-lHutUBI\n\nhttps://www.youtube.com/watch?v=aElDbHjJrV0\n\nhttps://www.youtube.com/watch?v=wIOX_I69zYg\n\nhttps://youtu.be/YnEfNzJauvM\n\nhttps://youtu.be/BEPGrEWZVUE\n\nhttps://www.youtube.com/watch?v=oSIqXLxzR0s\n\n","date":"2022-06-09T00:00:00.000Z","icon":"fas fa-bug","image":"null","path":"/resursy-ui/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"qa","path":"/tag/qa/"}],"headings":[{"value":"Разработка фреймворка","anchor":"#разработка-фреймворка"},{"value":"Ускорение тестов","anchor":"#ускорение-тестов"},{"value":"BDD","anchor":"#bdd"},{"value":"Page Object","anchor":"#page-object"},{"value":"интеграционные тесты","anchor":"#интеграционные-тесты"},{"value":"Xpath","anchor":"#xpath"},{"value":"test data","anchor":"#test-data"},{"value":"отчеты","anchor":"#отчеты"},{"value":"интеграция с TMS","anchor":"#интеграция-с-tms"},{"value":"Разное","anchor":"#разное"}]}},{"node":{"id":"082b43d0f2853fd3012326e26df2377d","title":"Selenide","content":"\n## Настройка таймаута\n\nВыполняется через System.setProperty();\n\n```java\nmvn -Dselenide.timeout=8000\n```\n\n## Коллекции\n\n$ - возвращает первый элемент\n$$ - возвращает список\n\n```java\n$$(\".error\").shouldHave(size(3));\n```\n\n```java\n$$(\"#employees tbody tr\").shouldHave(\n  tests(\n    \"John Belushi\",\n    \"Bruce Willis\",\n    \"John Malkovich\"\n  )\n);\n```\n\n## Коллекции: фильтрации\n```java\n$$(\"#employees tbody tr\")\n  .filter(visible)\n  .shouldHave(size(4));\n```\n\n## Поиск элементов\n\n```java\n$(\"#loginBtn\") = $(By.id(\"loginBtn\"));\n$(\".active\") = $(By.className(\"active\"));\n$(\"[name=username]\") = $(By.name(\"username\"));\n$x(\"//div//h1\") = $(By.xpath(\"//div//h1\"));\n```\n\n### Поиск по атрибутам\n```java\n$(by(\"type\", \"checkbox\"));\n$(by(\"readonly\", \"readonly\"));\n$(byTitle(\"Login form\"));\n$(byValue(\"Alert button\"));\n$(by(\"data-test-id\", \"alert-button\"));\n\n$(byText(\"Hello\"));\n$(withText(\"ello\"));\n```\n\n## Открываем браузер\n\n```java\nopen(\"url\");\n```\n\n## Ввести значение в поле\n\n```java\n$(By.name(\"user.name\")).setValue(\"john\");\n```\n\n## Кликнуть мышью один раз\n\n```java\n$(\"#submit\").click();\n```\n\n## Выполнить проверку по тексту элемента\n\n```java\n$(\".menu\").shouldHave(text(\"Hello, John!\"));\n```\n\n## Page Object\n\n```java\npublic class GooglePage {\n  public void search(String queue){\n    $(By.name(\"q\"))\n        .val(queue)\n        .pressEnter();\n  }\n}\n\nМожно вынести локатор в поле класса:\n\n```java\npublic class GooglePage {\n  private By query = By.name(\"q\");\n\n  public void search(String queue){\n    $(query)\n        .val(queue)\n        .pressEnter();\n  }\n}\n```\n\n```java\n@Test{\n  var page = new GooglePage();\n}\n```\n\nМожно вынести в поле весь элемент, но тогда нужно инициализировать класс страницы через специальный Factory метод.\n\n```java\npublic class GooglePage {\n  private SelenideElement query = $(By.name(\"q\"));\n\n  public void search(String queue){\n    query\n        .val(queue)\n        .pressEnter();\n  }\n}\n```\n\n```java\n@Test{\n  var page = page(GooglePage.class);\n}\n```\n\n## Аналог Yandex HtmlElements\n\n```java\npublic class HtmlElementsPage {\n  SelenideElement container = $(\"...\");\n  SelenideElement username = container.$(\"...\");\n  SelenideElement password = container.$(\"...\");\n\n  public void login(String un, String pwd){\n    username.val(un);\n    password.val(pwd);\n  }\n}\n```\nИли другой вариант:\n\n```java\npublic class HtmlElementsPage {\n  @FindBy(id=\"status\")\n  StatusBlock status;\n}\nclass StatusBlock extends ElementsContainer {\n  @FindBy(className=\"username\")\n  SelenideElement username;\n\n  @FindBy(className = \"password\")\n  SelenideElement password;\n}\n```\n\n## Навигация по DOM'у\n\n```java\n$.parent()\n$.closest(\"table\")\n```\n\n```java\n$(\"table td[data-foo='bar']\")\n.closest(\"table\")\n.find(\"tr\", 4)\n.find(byText(\"text\"));\n```\n\n## Задать тип браузера для запуска\n\n```java\njava -Dselenide.browser=chrome\njava -Dselenide.browser=firefox\njava -Dselenide.browser=ie\njava -Dselenide.browser=cy.test.MyWebDriver\n```\n\nЭти параметры удобно использовать когда в gradle.build мы создаем разные tasks или в pom.xml создаем разные profile\n\n```groovy\ntask chrome(type: Test){\n  systemProperties['selenide.browser'] = 'chrome'\n}\n\ntask firefox(type: Test){\n  systemProperties['selenide.browser'] = 'firefox'\n}\n```\n\n**Jenkins**\nJob 1: ./gradlew chrome  \nJob 2: ./gradlew firefox\n\nили можно задать браузер прямо в коде\n\n```java\n@Before\npublic void setUp(){\n  Configuration.browser = \"chrome\";\n  // or Configuration.browser = \"firefox\";\n  // or Configuration.browser = \"cy.MyWebDriver\";\n}\n```\n\n## Задать свой WebDriver (со своими настройками)\n\n- setWebDriver (не рекомендуется)  \nПри использовании этого способа, нужно самому закрывать драйвер.\n\n```java\n@Before\npublic void setUp(){\n  this.browser = new ChromeDriver(........);\n  WebDriverRunner.setWebDriver(browser);\n}\n```\n\n- WebDriverProvider  \nНужно только открыть закрывать и другие действия Selenide делает сам.\n\n```java\n@Before\npublic void setUp(){\n  Configuration.browser = MyWDProvider.class.getName();\n  open(\"https://google.com\");\n}\n\nstatic class MyWDProvider implements WebDriverProvider{\n  @Override\n  public WebDriver createDriver(DesiredCapabilities capabilities){\n    ChromeOptions options = new ChromeOptions();\n    options.setHeadless(true);\n    options.setArguments(\"--proxy-bypass-list=<-loopback>\");\n    options.merge(desiredCapabilities);\n    return new ChromeDriver(options);\n  }\n}\n```\n\n## Два браузера в одном тесте\n\n```java\nvar b1 = new SelenideDriver();\nb1.open(\"http://some.site.com\");\nb1.$(\"#username\").val(\"petja\").pressEnter();\nb1.$(\"#name\").shouldHave(text(\"Hello, Petja!\"));\n\nvar b2 = new SelenideDriver();\nb2.open(\"http://some.site.com/admin\");\nb2.$(\".block[data-username='petja']\").click();\n\nb1.$(\"#name\").shouldHave(text(\"Goodbye, Petja!\"));\n```\n\nПри вызове браузеров можно также передавать разные настройки:\n\n```java\nvar b1 = new SelenideDriver(\n  new SelenideConfig()\n  .timeout(6000)\n  .browser(\"chrome\")\n  .headless(true)\n);\n\nvar b2 = new SelenideDriver(\n  new SelenideConfig()\n  .timeout(90_000)\n  .browser(\"firefox\")\n  .proxyEnabled(true)\n);\n```\n\n## Прокси\n\n### Загрузка файлов\n\nЕсть два варианта: \n- Configuration.fileDownload = HTTPGET;  \nЕсли файл загружается по ссылке. Включен по умолчанию.\n\n```java\n@Test \npublic void userCanViewTerminalDetailsAsPDF() throws FileNotFoundException { \n  File detailsAsPdf = $(\"#print-pdf\").download(); \n  PDF pdf = new PDF(pdfFile); \n  assertThat(pdf, containsText(\"PP028004\")); \n  assertThat(pdf, containsText(\"Торговый терминал\")); \n  assertThat(pdf, containsTextCaseInsensitive(\"VeriFone VX 810\")); \n} \n```\n\n> Проверить pdf и xls можно с помощью:  \n> - github.com/codeborne/pdf-test  \n> - github.com/codeborne/xls-test\n\n- Configuration.fileDownload = PROXY;\nКогда по клику по элементу начинается загрузка файла.\nSelenide запускает свой прокси-сервер и перехватывает запросы/ответы.\n\nОн умеет: \n- Скачивать файлы \n- Подменять заголовки \n- Инжектить JS код на страницу \n- И т.д. и т.п.\n\nПо умолчанию он отключен так как если тесты запускаются на машине A а браузер на машине B и с машины B не видна машина A, то могут быть проблемы.\n\n```java\n@Before \npublic void setUp() { \n  Configuration.proxyEnabled = true; \n  open(\"https://google.com\"); \n}\n\n@Test \nvoid canAddInterceptorsToProxyServer() { \n  SelenideProxyServer proxy = getSelenideProxy(); \n\n  proxy.addRequestFilter(\"proxy-usages.request\", (request, \n  contents, messageInfo) -> { \n    String url = messageInfo.getUrl(); \n    log(url + \"nn\" + contents.getTextContents()); \n    return null; \n    });\n}\n```\n\n## Параллелизация\n\nПроблемы которые могут возникать:\n- Статические переменные \n- Одновременный доступ к данным \n- синхронизация \n- И т.д.\n\nЛучше запускать тесты в N процессов(forks).\n\n### Maven\n\npom.xml: \n\n```xml\n<plugin> \n  <groupId>org.apache.maven.plugins</groupId> \n  <artifactId>maven-surefire-plugin</artifactId> \n  <configuration> \n    <forkCount>3</forkCount> \n    <reuseForks>true</reuseForks> \n  </configuration> \n</plugin> \n```\n\n### Gradle\n\n```groovy\ntest {\n  maxParallelForks = 5\n}\n```\n\n## Трюки с JavaScript\n\n### Выбрать дату\n\n```java\nvoid setDateByName(String name, String date) { \n  executeJavaScript(\n    String.format(\"$('[name=\\\"%s\\\"]').val('%s')\", \n    name, date)); \n} \n\n@Test { \n  setDateByName(\"recurrent.startDate\", \"16.01.2009\"); \n}\n```\n\n### Выбрать опцию в bootstrap select\n\n```java\nvoid selectBS(WebElement select, String value) { \n  executeJavaScript( \n    \"$(arguments[0]).val(arguments[1]).trigger('change')\", \n    select, value); \n} \n\n@Test { \n  selectBS($(By.name(\"operationCode\")), \"11100\"); \n}\n```\n\n### Слайдер\n\n```java\nvoid setMaxYearlyFee(int value) { \n  executeJavaScript( \n    \"$('#sld').data('slider').value[0] = arguments[0];\" + \n    \"$('#sld').triggerHandler('slide');\" \n    ); \n} \n\n@Test { \n  setMaxYearlyFee(100); \n}\n```\n\n### Отключить Confirm окно\n\n```java\npublic static void mockConfirm() { \n  executeJavaScript( \n    \"window.confirm = function() {return true;};\" \n  ); \n}\n```\n\n### Контакты в мобильном \n\nЭмуляция функции.\n\n```java\nprivate void mockCordovaContactsAPI(String number) { \n  executeJavaScript( \n    \"window.plugins = {\" + \n    \" contactNumberPicker: { \" + \n    \" pick: function(callback) {\" + \n    \" callback({\" + \n    \" phoneNumber:\\\"\" + number + \"\\\"\"\"\n    });}}}\"); \n} \n    \n@Test { \n  mockCordovaContactsAPI(\"+79110080075\"); \n}\n```\n\n### Кол-во видимых элементов \n\nСелениум не умеет искать по jquery локатору.\n\n```java\n@Test { \n  $$(\".offer:visible\").shouldHave(size(3)); \n} \n@Test {\n  $$(\".offer\").filter(visible) .shouldHave(size(3)); \n} // это может быть медленно если на странице много элементов\n```\n\nЧерез JavaScript в разы быстрее:\n\n```java\nint sizeOf(String cssSelector) { \n  Number count = executeJavaScript( \n    \"return $(arguments[0]).length\", cssSelector); \n    return count.intValue(); \n} \n@Test { \n  assertEquals(1, sizeOf(\".offer:visible\")); \n}\n```\n\n### Из списка элементов исключить другой список \n\nЗадача: найти страны из excel и страны на странице и найти те которые есть на странице но нет в excel.\n\n```java\nList<String> страныИзЭксельки = ...; \nList<String> страныСоСтраницы = $$(“td:nth-child(3)”) \n  .excludeWith(text(“text”)) \n  .stream() \n  .map(el -> el.getText()) \n  .collect(toList()); // Это м.б. медленно :(\n```\n\n```java\nList<String> страныИзЭксельки = ...; \nList<String> страныСоСтраницы = executeJavascript( \n  \"return Array.from(\" + \n  \" document.querySelectorAll('td:nth-child(3)')\" \n  + \").map(x => x.textContent)\"\n); // А вот это быстро\n```\n\n### fast set value\n\nПроблема: \n\n1. $.sendKeys() медленный \n2. Иногда $.sendKeys() не работает:  \n  a. Элемент невидимый   \n  b. Маска на поле  \n  c. Какой-нибудь хитрый JS  \n  d. Какой-нибудь компонент типа DatePicker \n  \nНа помощь приходит JavaScript!\n\nРежим “fast set value” - значение не вводится по одному символу, а вставляется сразу через JS.\n\nДля того чтобы включить этот режим нужно:\n\nУстановить системную переменную:\n```\nmvn -Dselenide.fastSetValue=true \n```\nили\n\nВызвать метод:\n```java\n@Before public void setUp() { \n  Configuration.fastSetValue = true; \n} \n```\n\nВ этом случае setValue функция начинает работать через JS.\n\nТакде в любой момент можно выбирать:\n- $.setValue(“john”) - быстро \n- $.sendKeys(“john”) - если быстро никак \n\n\n## Самопальные команды\n\n### Слайдер \n\nИмеем функцию для установки значения слайдера:\n\n```java\n@Test { \n  setMaxYearlyFee($(“#slider”), 100); \n}\n\nvoid setMaxYearlyFee(WebElement slider, int value) { \n  executeJavaScript(...); \n} \n```\n\nНо вместо этой записи иногда удобнее иметь такую:\n```java\n@Test { \n  $(“#slider”).setMaxYearlyFee(100); \n} \n```\nА ещё круче вот так: \n\n```java\n@Test {\n  $(“#slider”) \n  .setMaxYearlyFee(100) \n  .setMinYearlyFee(15) \n  .selectFee(50) \n} \n```\n\nТак можно в Kotlin и Groovy Но не в Java!\n\nНо можно так: \n```java\n@Test { \n  $(“#slider”) \n  .execute(setMaxYearlyFee(100)) \n  .execute(setMinYearlyFee(15)) \n  .execute(selectFee(50)) \n} \n\nCommand<SelenideElement> setMaxYearlyFee(int fee) { \n  return (proxy, locator, args) -> { \n    executeJavaScript(\".... \" + fee); \n    return proxy; \n  }; \n} \n```\n\nСм. https://ru.selenide.org/2019/09/02/selenide-5.3.0/\n\n## Selenide и мобильники\n### Selenide для мобильников (Appium) \n\nМожно без аннотаций: \n\n```java\n@Test public void mobileCalculator() { \n  $(By.name(\"2\")).click(); \n  $(By.name(\"+\")).click(); \n  $(By.name(\"4\")).click(); \n  $(By.name(\"=\")).click(); \n  $(By.className(\"android.widget.EditText\")) \n  .shouldHave(text(\"6\")); \n} \n```\nhttps://github.com/selenide-examples/selenide-appium\n\n\n### Пэдж обжекты и Appium \n\nА можно и с аннотациями:\n\n```java\nclass MobileCalculatorPage { \n  @AndroidFindBy(id = \"op_add\") \n  @iOSFindBy(id = “op_add”); \n  SelenideElement plus; \n} \n```\nhttps://github.com/selenide/selenide-appium\n\n### Test setup\n\nСтандартного браузера нет поэтому нужно задавать класс своего драйвера.\nИспользуется для открытия приложения метод `open()` без параметра.\n\n```java\npublic class CalculatorTest {\n  @Before\n  public void setUp(){\n    Configuration.startMaximized = false;\n    Configuration.browserSize = null;\n    Configuration.browser = MyAndroidDriver.class.getName();\n    open();\n  }\n}\n```\n\n#### Android\n\n```java\npublic class MyAndroidDriver implements WebDriverProvider {\n  @Override\n  public WebDriver createDriver(DesiredCapabilities caps){\n    caps.setCapabilities(\"version\" ,\"4.4.2\");\n    caps.setCapabilities(\"automationName\" ,\"Appium\");\n    caps.setCapabilities(\"platformName\" ,\"Android\");\n    caps.setCapabilities(\"deviceName\" ,\"0123456789ABCDEF\");\n    caps.setCapabilities(\"appPackage\" ,\"com.android.calculator2\"); // т.к. калькулятор приложение Android по умолчанию, то достаточно указать только package\n    caps.setCapabilities(\"appActivity\" ,\"com.android.calculator2.Calculator\"); // запустится сразу указанное Activity\n\n    return new AndroidDriver(new URL(\"http://127.0.0.1:4723/wd/hub\"), caps); // URL запущенного Appium Server\n  }\n}\n```\n\n#### iOS\n\n```java\npublic class MyIOSDriver implements WebDriverProvider {\n  @Override\n  public WebDriver createDriver(DesiredCapabilities caps){\n    caps.setCapabilities(\"platformName\" ,\"iOS\");\n    caps.setCapabilities(\"deviceName\" ,\"iPhone 11\");\n    caps.setCapabilities(\"platformVersion\" ,\"13.0\");\n    caps.setCapabilities(\"app\", resourcePath(\"apks/Wikipedia.app\"));\n    caps.setCapabilities(MobileCapabilityType.NEW_COMMAND_TIMEOUT, \"16\");\n    caps.setCapabilities(\"autoAcceptAlerts\", true);\n\n    return new IOSDriver(\"http://127.0.0.1:4723/wd/hub\", caps); // URL запущенного Appium Server\n  }\n}\n```\n\n### Универсальный Page Object (для iOS, Android, Web)\n\n```java\nclass MobileCalculatorPage {\n  @FindBy(id=\"op_add\")\n  @AndroidFindBy(id=\"op-add\")\n  @iOSFindBy(id=\"operandAdd\");\n  private SelenideElement plus;\n}\n```\n\nдля инициализации класса для web используется метод page, для mobile метод screen\n\n```java\nCalculatorPage calculator = page(CalculatorPage.class);\n```\n\n```java\nCalculatorPage calculator = screen(CalculatorPage.class);\ncalculator.number2.click();\ncalculator.plus.click();\ncalculator.number4.click();\ncalculator.equal.click();\ncalculator.result.shouldHave(text(\"6\"));\n```","date":"2022-06-19T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/selenide/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"selenium","path":"/tag/selenium/"},{"title":"selenide","path":"/tag/selenide/"}],"headings":[{"value":"Настройка таймаута","anchor":"#настройка-таймаута"},{"value":"Коллекции","anchor":"#коллекции"},{"value":"Коллекции: фильтрации","anchor":"#коллекции-фильтрации"},{"value":"Поиск элементов","anchor":"#поиск-элементов"},{"value":"Открываем браузер","anchor":"#открываем-браузер"},{"value":"Ввести значение в поле","anchor":"#ввести-значение-в-поле"},{"value":"Кликнуть мышью один раз","anchor":"#кликнуть-мышью-один-раз"},{"value":"Выполнить проверку по тексту элемента","anchor":"#выполнить-проверку-по-тексту-элемента"},{"value":"Page Object","anchor":"#page-object"},{"value":"Аналог Yandex HtmlElements","anchor":"#аналог-yandex-htmlelements"},{"value":"Навигация по DOM'у","anchor":"#навигация-по-domу"},{"value":"Задать тип браузера для запуска","anchor":"#задать-тип-браузера-для-запуска"},{"value":"Задать свой WebDriver (со своими настройками)","anchor":"#задать-свой-webdriver-со-своими-настройками"},{"value":"Два браузера в одном тесте","anchor":"#два-браузера-в-одном-тесте"},{"value":"Прокси","anchor":"#прокси"},{"value":"Параллелизация","anchor":"#параллелизация"},{"value":"Трюки с JavaScript","anchor":"#трюки-с-javascript"},{"value":"Самопальные команды","anchor":"#самопальные-команды"},{"value":"Selenide и мобильники","anchor":"#selenide-и-мобильники"}]}},{"node":{"id":"7d1a83289c7e76ef68e0e31d8e39a35f","title":"Инфраструктура проекта автотестирования","content":"\n## Общая схема инфраструктуры\n\nИнфраструктура проекта по автоматизации тестирования состоит из следующих компонентов:\n\n- Selenium WebDriver\n- Язык программирования\n- Сборщик, менеджер зависимостей\n- Тестовый фреймворк\n\n## Инфраструктура для Java\n\n- Selenium WebDriver - chromedriver\n- Язык программирования - Java\n- Сборщик - Gradle\n- Менеджер зависимостей - Maven Central\n- Тестовый фреймворк - JUnit\n\n","date":"2022-06-12T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/infrastruktura-proekta-avtotestirovaniya/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Общая схема инфраструктуры","anchor":"#общая-схема-инфраструктуры"},{"value":"Инфраструктура для Java","anchor":"#инфраструктура-для-java"}]}},{"node":{"id":"c9a5d9cd4f6903515e864e4fc9743724","title":"Понятие автоматизированного тестирования","content":"\n## Что такое автоматизированное тестирование?\nАвтоматизированное тестирование (Automation Testing, Test Automation) — техника тестирования, в которой для выполнения тест кейсов используются специальные программы. Это отличает ее от ручного тестирования, в котором тест кейсы выполняются вручную тестировщиком.\n\nПрограммы для автоматизации сравнивают полученные результаты с актуальными и генерируют подробные тест-репорты.\n\nРазработка продукта циклична и итерационна — и на каждой итерации, как правило, требуется выполнение одного и того же набора тестов. С помощью инструментов автоматизированного тестирования можно записывать наборы тестов (test suites) и выполнять, когда это необходимо. Как только набор тестов автоматизирован, участие человека в выполнении тестов практически не требуется. Это делает автоматизированное тестирование эффективной техникой. Цель автоматизации — уменьшить количество тестов, которые нужно выполнять вручную.\n\n## Зачем нужно автоматизированное тестирование?\nАвтоматизированное тестирование — лучший способ улучшить эффективность, покрытие продукта тестами, уменьшить время на тестирование. \n\nПреимущества автоматизированного тестирования:\n\n- Автоматизированное тестирование увеличивает скорость тестирования\n- Автоматизированное тестирование не требует участия человека для выполнения тестов. Отсутсвует влияние человеческого фактора.\n- Средства автоматизации способны выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов. \n- Средства автоматизации способны собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.\n- Ручное тестирование всех возможных сценариев использования требует много времени (и, следовательно, денег)\n- Автоматизированные тесты могут быть запущены в любое время (днем, ночью, в выходные и праздники)\n- Многократное ручное тестирование одной и той же функциональности скучно\n\nНедостатки автоматизированного тестирования:\n\n- Необходимость наличия высококвалифицированного персонала в силу того факта, что автоматизация — это «проект внутри проекта» (со своими требованиями, планами, ко- дом и т.д.).\n- Разработка и сопровождение как самих автоматизированных тест-кейсов, так и всей необ- ходимой инфраструктуры занимает очень много времени.\n- Автоматизация требует более тщательного планирования и управления рисками,т.к. в противном случае проекту может быть нанесён серьёзный ущерб&\n- Коммерческие средства автоматизации стоят ощутимо дорого, а имеющиеся бесплатные аналоги не всегда позволяют эффективно решать поставленные задачи. \n- Средств атоматизации крайне много, что усложняет проблему выбора того или иного средства, затрудняет планирование и определение стратегии тестирования, может повлечь за собой дополнительные временные и финансовые затраты, а также необходимость обучения персонала или найма соответствующих специалистов.\n\n## Что автоматизировать в первую очередь?\n\nДля максимальной эффективности, для определения сценариев, подходящих под автоматизацию, пользуйтесь следующими критериями:\n\n- Критически важная бизнес-функциональность\n- Тест кейсы, которые нужно выполнять много раз\n- Тест кейсы, которые сложно воспроизвести вручную\n- Тест кейсы, воспроизведение которых занимает много времени\n\nСледующие критерии не подходят для автоматизации:\n\n- Новые тест кейсы, которые еще не были выполнены вручную\n- Тест кейсы для функциональности, требования к которой часто меняются\n- Тест кейсы, которые выполняются редко\n\n## Процесс автоматизированного тестирования\n\nШаг 1: Выбор инструмента для автоматизации\nШаг 2: Определение функциональности, которую нужно автоматизировать\nШаг 3: Планирование, тест дизайн и разработка тестов\nШаг 4: Выполнение тестов\nШаг 5: Поддержка написанных тестов\n\n### Определение функциональности, которую нужно автоматизировать\n\nОбласть для автоматизации может быть определена по следующим критериям:\n\n- Функциональность, которая важна для бизнеса\n- Сценарии, для тестирования которых нужны большие объемы входных данных\n- Функциональность, использующаяся в нескольких частях приложения\n- Целесообразность с технической точки зрения\n- Сложность написания тест кейсов\n- Возможность использования одних и тех же тест кейсов для кроссбраузерного тестирования\n- Планирование, тест дизайн и разработка\n\nСценарии, обычно подходящие для автоматизации:\n\nТесты, которые повторяются во всех билдах\nТесты, в которых легко могут возникать ошибки тестировщиков\nТесты с большими объемами данных\nЧасто используемые функции с большими рисками\nТесты, забирающие много ручного времени\nТесты, задействующие много разных программных/аппаратных конфигураций\n\nДалее пять вещей, которые нужно оценить до того как приступать к автоматизации.\n\n1. Автоматизируй Smoke-тесты.\nТакие тесты позволяют удостовериться, что приложение в целом работоспособно, и их желательно делать при каждом изменении функциональности, и после каждого билда. Smoke-тесты должны интегрироваться в CI/CD-процессы — это позволяет выловить критические ошибки. Smoke-тестами проверяют основные части приложения/сайта, они должны оставаться работоспособными в любых условиях; гарантируется, что билд достаточно стабилен, значит можно продвигаться дальше в пайплайне.\n\nАвтоматизация Smoke-тестирования помогает:\n\nОперативно найти критические баги, и сделать это очень рано в пайплайне. Главная страница/экран не открывается; у клиент не получается залогиниться или сделать себе аккаунт; платежные системы не подключаются и т.п.\nБыстрее идет устранение новых или “регрессионных” дефектов. Smoke-тесты сами по себе “дают широкое покрытие, но малую глубину” этого покрытия. Получается много тестовых кейсов без необходимости “глубокого погружения” тестировщиков в проект. Убедились, что самые важные части работоспособны — и идем дальше, к менее важным компонентам.\nАвтоматизация Smoke-тестов позволяет экономить время за счет уменьшения большого количества ручной работы. Включение автотестов в CI/CD позволяет проводить smoke-тестирование еще на этапе сборки билда. \n2. Автоматизируй тесты, которые пишутся всегда, и которые пишутся в начале каждого этапа\nТогда получаются стабильные тест-сьюты. К примеру, тестирование создания аккаунта должно делаться до того как юзер может логиниться и видеть свое клиентское окно, проводить платежи и т.п.\n\nСоздание автоматического “регрессионного” тестового набора (сьюта) позволяет:\n\nДелать тесты, оперативно находящие баги, возникающие из правок в коде. Правки могут быть новыми функциями, или “фиксами” прошлых багов. \nТестовый набор, как уже было сказано, получается с повышенной стабильностью и надежностью. Регрессионное тестирование обычно касается существующей функциональности, то есть функции уже тестированы неоднократно. Это повышает стабильность сьютов, экономится время ручных тестировщиков, когда не знаешь, реально “падают” тесты или они нестабильные.\nЭкономится время: можно сосредоточиться на ручном тестировании (особенно граничных значений).\n3. Автоматизируй “большие тесты” — с большим массивом данных\n“Большие тесты” — это может быть ввод больших массивов данных, тестирование форм, или тесты предполагающие многократный ручной ввод самых разных данных. Их-то и надо автоматизировать. Если речь идет о формах, автоматизация позволяет быстро протестировать комбинации данных в форме, например ситуации когда пропущены поля, данные неполные, и т.п. Тут полезно DDT-тестирование, позволяющее модифицировать только данные, а не весь скрипт. Это то что называется “реюзабельный” и эффективный подход.\n\n4. Автоматизируй тесты с множественными конфигурациями\nЕсли в проекте множество ОС и целый “парк браузеров”, будет сложная конфигурация.\n\nРучная конфигурация всего этого “парка” — утомительная вещь, и для экономии времени такое тестирование стараются автоматизировать. Тесты запускают в разных окружениях, меняя лишь переменную среды достаточно удобным образом. \n\nЖелательно также почитать что-то о параллельном тестировании, которое также экономит время. Можно применять специальные “тулзы” типа CircleCI — прописывают ОС/браузер/окружение, в которых будут выполняться параллельные тесты. \n\n5. Автоматизируй тесты производительности\nТакие тесты проводятся для устранения отказов приложения, улучшения пресловутого User Experience, и, разумеется, контроля производительности приложения. Проверяется, как приложение ведет себя под серьезной нагрузкой; находят ее проблемные точки; контролируют то что называется “плавность” приложения, время реакции на действия, стабильность, степень задействования аппаратных ресурсов девайса, и способность безболезненно реагировать на резкий рост нагрузки. \n\nАвтоматизация тестирования производительности — это когда генерируются тысячи условных “пользователей”, и проверяют, как реагирует приложение. \n\nКак часто будут выполняться написанные тесты?\nСамый важный вопрос. Автоматизировать тест-кейс имеет смысл в том случае, если он будет выполняться постоянно. Обязательно учитывайте частоту использования при составлении плана по автоматизации.\n\nДля какой функциональности разрабатываются автотесты?\nНекоторые части приложения имеют большее значение/влияние, чем другие. Очень важно, чтобы критическая функциональность была покрыта тестами в первую очередь — баги в таких местах будут стоить очень дорого. Здесь автоматизация однозначно себя окупит.\n\nПланируется ли запускать тест с разными наборами данных?\nРучное выполнение тест-кейсов с разными наборами входных данных — тяжелая работа. С помощью автотестов можно освободить время ручных тестировщиков и минимизировать шансы багов на продакшене.\n\nТест будет выполняться в регрессионном или smoke-тестировании?\nРегрессионное и smoke-тестирование выполняются очень часто. Это тест-сьюты, которые тестируют приложение “вширь” — т.е. тестируют корректность работы всего базового функционала. Регрессионные тесты интегрируются в процесс сборки приложения и выполняются во время каждого билда. Их автоматизация поможет улучшить качество продукта.\n\nПросто ли написать автотест с помощью ваших инструментов?\nНужно проводить анализ возможности (сложности) разработки конкретного тест-сьюта с помощью используемого инструмента автоматизации. Например, попытка автоматизировать тестирование запросов к SAP — не лучшая трата вашего времени, если инструмент не поддерживает такое тестирование. Использование другого инструмента для одной конкретной задачи тоже не лучшее решение. Такие места дешевле всего тестировать вручную.\n\nКак часто будет меняться/дорабатываться функциональность, которую планируется покрывать?\nВажный вопрос. В случае, если часть приложения будет часто меняться, дорабатываться, переписываться с нуля и т.п. — писать автотетсы для нее рано. Каждый раз после изменения функционала тесты нужно будет обновлять/переписывать заново.\n\nПоэтому узнайте о планах разработчиков на ближайшее время — если функциональность планируют менять, отложите написание автотестов до лучших времен.\n\nЭто негативный тест?\nПисать негативные автотесты — не лучшее решение.\n\nСмогут ли написанные тесты выполняться параллельно?\nЕсли процесс автоматизации хорошо выстроен, можно сэкономить много времени, запуская тесты параллельно. Параллельное выполнение очень важно для получение максимальной отдачи от автоматизации. Поэтому тесты, которые в конечном итоге смогут быть выполнены только в определенном последовательном порядке — не лучшие кандидаты на автоматизацию. Это не значит, что их не нужно автоматизировать вообще. Просто на данном этапе лучше поискать что-то более подходящее.\n\nНе пишутся ли тесты только ради отчетов?\nСовременные инструменты для автоматизации дают возможность генерировать классные отчеты о результатах тестирования. Однако, отчеты не являются целью автоматизации. Для улучшения качества нужно разбирать каждый упавший тест — определять, почему он упал и что нужно исправить. Написанные тесты нужно постоянно поддерживать в актуальном состоянии. Все это нужно держать в уме, когда вы собираетесь писать автотест для какой-либо функциональности. Автоматизация гораздо больше, чем красивые отчеты.\n\nНа этом этапе создается тест стратегия и тест-план, которые содержат следующие детали:\n\n- Выбранный инструмент автоматизации\n- Фреймворк с описанием его особенностей\n- Описание функциональности, тестирование которой будет автоматизировано\n- Подготовка стендов для выполнения тестов\n- Расписание выполнения автотестов\n- Результаты автоматизированного тестирования\n\n### Выполнение тестов\n\nВо время этой стадии происходит выполнение автотестов. После выполнения генерируется подробный тест репорт.\n\nВыполнение тестов может быть запущено как из инструмента автоматизации напрямую, так и с помощью системы управления тестированием (Test Management Tool), который запустит инструмент автоматизации.\n\n### Поддержка написанных тестов\n\nНа стадии поддержки происходит изменение существующих тестов (в случае планируемого изменения функциональности) или добавление новых тестов.\n\n## Советы по использованию инструментов автоматизации\n\n- Функциональность, подходящая для автоматизации, должна быть определена до начала разработки проекта.\n- Инструмент для автоматизации должен быть выбран исходя из требований конкретного продукта, а не из популярности.\n- Придерживайтесь стандартов написания кода, когда разрабатываете автотесты. Вот некоторые из них:\n    - Придерживайтесь гайдлайнов при написании кода\n    - Оставлйте комментарии\n    - Обрабатывайте ошибки — при разработке думайте о том, как отработает ваша система в случае некорректного поведения приложения.\n- Собирайте метрики, чтобы определить эффективность автоматизированного тестирования. Вот некоторые из них:\n    - Процент найденных багов\n    - Время, затраченное на выполнение автотестов для каждого релиза\n\n## Типы автоматизированного тестирования\n\n|Случай/задача | В чём проблема автоматизации|\n|---|---|\n|Регрессионное тестирование|Необходимость выполнять вручную тесты, количество которых неуклонно растёт с каждым билдом, но вся суть которых сводится к проверке того факта, что ранее работавшая функциональность продолжает работать корректно.|\n|Инсталляционное тестирование и настройка тестового окружения.|Множество часто повторяющихся рутинных операций по проверке работы инсталлятора, размещения файлов в файловой системе, содержимого конфигурационных файлов, реестра и т. д. Подготовка прило- жения в заданной среде и с заданными настройками для проведения основного тестирования.|\n|Конфигурационное тестирование и тестирование совместимости.|Выполнение одних и тех же тест-кейсов на большом множестве входных данных, под разными платформами и в разных условиях. Классический пример: есть файл настроек, в нём сто параметров, каждый может принимать сто значений: существует 100100 вариантов конфигурационного файла — все их нужно проверить.|\n|Использование комбинаторных техник тестирования (в т.ч. доменного тестирования).|Генерация комбинаций значений и многократное выполнение тест-кейсов с использованием этих сгенерированных комбинаций в качестве входных данных.|\n|Модульное тестирование.|Проверка корректности работы атомарных участков кода и элементарных взаимодействий таких участков кода — практически невыполнимая для человека задача при условии, что нужно выполнить тысячи таких проверок и нигде не ошибиться.|\n|Интеграционное тестирование.|Глубокая проверка взаимодействия компонентов в ситуации, когда человеку почти нечего наблюдать, т. к. все представляющие интерес и подвергаемые тестированию процессы проходят на уровнях более глубоких, чем пользовательский интерфейс.|\n|Тестирование безопасности.|Необходимость проверки прав доступа, паролей по умолчанию, открытых портов, уязвимостей текущих версий ПО и т. д., т. е. быстрое выполнения очень большого количества проверок, в процессе которого нельзя что-то пропустить, забыть или «не так понять».|\n|Тестирование производительности.|Создание нагрузки с интенсивностью и точностью, недоступной человеку. Сбор с высокой скоростью большого набора параметров работы приложения. Анализ большого объёма данных из журналов работы системы автоматизации.\n|Дымовой тест для крупных систем.|Выполнение при получении каждого билда большого количества достаточно простых для автоматизации тест-кейсов.|\n|Приложения (или их части) без графического интерфейса.|Проверка консольных приложений на больших наборах значений параметров командной строки (и их комбинаций). Проверка приложений и их компонентов, вообще не предназначенных для взаимодействия с человеком (веб-сервисы, серверы, библиотеки и т. д.)|\n|Длительные, рутинные, утомительные для человека и/или требующие повышенного внимания операции.|Проверки, требующие сравнения больших объёмов данных, высокой точности вычислений, обработки большого количества размещённых по всему дереву каталогов файлов, ощутимо большого времени выполнения и т.д. Особенно, когда такие проверки повторяются очень часто.|\n|Проверка «внутренней функциональности» веб-приложений (ссылок, доступности страниц и т. д.)|Автоматизация предельно рутинных действий (например, проверить все 30’000+ ссылок на предмет того, что все они ведут на реально существующие страницы). Автоматизация здесь упрощается в силу стандартности задачи — существует много готовых решений.|\n|Стандартная, однотипная для многих проектов функциональность.|Даже высокая сложность при первичной автоматизации в таком слу- чае окупится за счёт простоты многократного использования полу- ченных решений в разных проектах.|\n|«Технические задачи».|Проверки корректности протоколирования, работы с базами данных, корректности поиска, файловых операций, корректности форматов и содержимого генерируемых документов и т. д.|\n ","date":"2022-05-28T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/ponyatie-avtomatizirovannogo-testirovaniya/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Что такое автоматизированное тестирование?","anchor":"#что-такое-автоматизированное-тестирование"},{"value":"Зачем нужно автоматизированное тестирование?","anchor":"#зачем-нужно-автоматизированное-тестирование"},{"value":"Что автоматизировать в первую очередь?","anchor":"#что-автоматизировать-в-первую-очередь"},{"value":"Процесс автоматизированного тестирования","anchor":"#процесс-автоматизированного-тестирования"},{"value":"Советы по использованию инструментов автоматизации","anchor":"#советы-по-использованию-инструментов-автоматизации"},{"value":"Типы автоматизированного тестирования","anchor":"#типы-автоматизированного-тестирования"}]}},{"node":{"id":"5b61610dde2e594b0b45d814b26e90e3","title":"Как установить OpenJDK на Mac OS","content":"\n\n## Скачиваем JDK \n\nЧтобы скачать пакет Open JDK нужно:\n\n1. Зайти на сайт [jdk.java.net](https://jdk.java.net/)\n2. Перейти по ссылке с нужной версией Java, последняя стабильная версия Java находится в пункте Ready for use\n3. В разделе Build выбираем ссылку на архив с пакетом. Для Mac OS - это macOS / x64\ttar.gz (sha256)\n\n## Извлекаем архив\n\n1. Переходим в папку в которую будем производить установку и создаем в ней папку для хранения jdk[^Here is the footnote]\n\n```bash{outputLines: 2}\ncd /Library/Java/JavaVirtualMachines/\n```\n\n2. Копируем в созданую папку скаченный архив\n\n```bash{outputLines: 2}\nuser@TestAutomation.Space:/usr$ sudo mv ~/Downloads/openjdk-..._bin.tar.gz /Library/Java/JavaVirtualMachines/\n[sudo] пароль для user: \n```\n\n3. И распаковываем tar-архив\n\n```bash{outputLines: 2}\nsudo tar zxvf /usr/java/openjdk-..._bin.tar.gz\n[sudo] пароль для user: \n```\n\n## Настраиваем переменные окружения PATH и JAVA_HOME\n\n1. Открыть на редактирование файл `.profile`\n\n```bash\nnano ~/.bash_profile\n```\n\n2. В конец добавляем строчки\n\n```bash\nJAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk.../Contents/Home\"\nexport JAVA_HOME\n\nPATH=${JAVA_HOME}/bin:${PATH}\nexport PATH\n```\n\n3. Нажимаем `Ctrl+X` и соглашаемся с сохранением изменений, нажав на `Y`\n4. Выполняем команду для инициализации изменени и проверяем что переменная среды выводится верно\n\n```bash\nsource ~/.bash_profile\nenv\necho $JAVA_HOME\necho $PATH\n```\n\n4. Теперь нужно перезапустить консоль и проверить версию Java\n\n```bash\njava -version\n```","date":"2020-04-26T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/kak-ustanovit-open-jdk-na-mac-os/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"setup","path":"/tag/setup/"},{"title":"macos","path":"/tag/macos/"}],"headings":[{"value":"Скачиваем JDK","anchor":"#скачиваем-jdk"},{"value":"Извлекаем архив","anchor":"#извлекаем-архив"},{"value":"Настраиваем переменные окружения PATH и JAVA_HOME","anchor":"#настраиваем-переменные-окружения-path-и-java_home"}]}}]}},"relatedCategory":{"id":"e9c3ea3dc1c81f4432b35adc5e174d7f","title":"automation","path":"/category/automation/","related":[{"id":"manual","path":"/category/manual/","title":"manual"},{"id":"api","path":"/category/api/","title":"api"}]}},"context":{}}