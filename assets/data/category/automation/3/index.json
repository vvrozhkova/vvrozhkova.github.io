{"hash":"74078440e78cf7eff9cd218b18924da13af0a419","data":{"category":{"title":"automation","path":"/category/automation/","belongsTo":{"totalCount":24,"pageInfo":{"totalPages":3,"currentPage":3},"edges":[{"node":{"id":"112370fc90d39fe48075453d187821e5","title":"Selenium API","content":"\n## Подключение зависимости\n\n```\n// https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java\nimplementation 'org.seleniumhq.selenium:selenium-java:4.2.2'\n```\n\n## Загрузка драйвера через WebDriverManager\n\n1. Нужно импортировать библиотеку\n\n```\nimplementation 'io.github.bonigarcia:webdrivermanager:5.2.0'\n```\n\n2. Перед запуском теста вызвать \n\n- для Chrome\n\n```\nWebDriverManager.chromedriver().setup();\n```\n\n## Открыть и закрыть браузер\n\n- Chrome\n```java\nChromeOptions options = new ChromeOptions();\ndriver = new ChromeDriver(options);\n\ndriver.quit();\n```\n\n- Microsoft Edge\n```java\nEdgeOptions options = new EdgeOptions();\ndriver = new EdgeDriver(options);\n\ndriver.quit();\n```\n\n- Firefox\n```java\nFirefoxOptions options = new FirefoxOptions();\ndriver = new FirefoxDriver(options);\n\ndriver.quit();\n```\n\n- Internet Explorer\n\nРекомендуется использовать 32-bit версию драйвера.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\ndriver = new InternetExplorerDriver(options);\n\ndriver.quit();\n```\n\nMicrosoft Edge можно использовать в режиме совместимости с IE с помощью драйвера IE.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.attachToEdgeChrome();\noptions.withEdgeExecutablePath(\"/path/to/edge/browser\");\n  \ndriver = new InternetExplorerDriver(options);\n  \ndriver.quit();\n```\n\n- Opera\n\nПоскольку драйвер Opera не поддерживает синтаксис w3c, а основан на Chromium, рекомендуется управлять браузером Opera с помощью chromedriver.\n\n```java\nChromeOptions options = new ChromeOptions();\noptions.setBinary(\"/path/to/opera/browser\");\n  \ndriver = new ChromeDriver(options);\n  \ndriver.quit();\n```\n\n- Safari\n\nЧтобы включить автоматизацию в Safari, выполните следующую команду из терминала:\n\n```\nsafaridriver --enable\n```\n\n```java\nSafariOptions options = new SafariOptions();\ndriver = new SafariDriver(options);\n  \ndriver.quit();\n```\n\n## Начало работы\n\n### Старт сессии\n```java\ndriver = new ChromeDriver();\n```\n\n### Переход на страницу\n```java\ndriver.get(\"https://google.com\");\n```\n\n### Получить заголовок страницы\n```java\nString title = driver.getTitle();\n```\n\n### Ожидания \n```java\ndriver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));\n```\n\n### Поиск элементов \n```java\nWebElement searchBox = driver.findElement(By.name(\"q\"));\nWebElement searchButton = driver.findElement(By.name(\"btnK\"));\n```\n\n### Действия на странице\n```java\nsearchBox.sendKeys(\"Selenium\");\nsearchButton.click();\n```\n\n### Запрос информации об элементе\n```java\nString value = searchBox.getAttribute(\"value\");\n```\n\n## Capabilities\n\n#### browserName\nЗадает имя браузера который нужно запустить\n#### browserVersion\nЗадает версию браузера. Можно не указывать.\n#### pageLoadStrategy\nПри переходе на новую страницу через URL, по умолчанию Selenium ждет пока страница будет загружена, выполняется проверка через js: `document.readyStatus` должен равняться `complete`. Однако для некоторых случаев, например для одностраничных сайтов, не имеет смысла ждать пока загрузится вся страница, так как элементы подгружаются динамически. В этом случае можно изменить этот параметр.\n\n> при изменении pageLoadStrategy обратите внимание, что стратегия ожидания (implicit/explicit wait) настроена, чтобы компенсировать нестабильность прогонов;\n\nМожет иметь одно из 3 значений: normal, eager, none;\n\n|Strategy|Ready State|Note|\n|---|---|---|\n|normal|complete|Используется по умолчанию; ждет пока все ресурсы страницы будут загружены|\n|eager|interactive|Доступ к DOM загрузился, но остальные ресурсы например картинки могут еще подгружаться|\n|none| Any| Не делает проверку загрузки ресурсов страницы|\n\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL);\nWebDriver driver = new ChromeDriver(chromeOptions);\n```\n\n#### platformName\nЗадает имя операционной системы необходимой для запуска\n\n#### acceptInsecureCerts\nВыполняется проверка сертификата безопасности сайта(TLS Certificate);\n\nесли выбрано `false` - то при наличии на сайте просроченного или невалидного сертификата будет выбрасываться исключение;  \nесли выбрано `true` - все сертификаты даже небезопасные будут считаться валидными\n\nПосле установки опции acceptInsecureCerts будет работать для все сессии.\n\n#### timeouts\nSelenium устанавливает определенные интервалы в течение которого пользователь может взаимодействовать с сайтом;\n\n- script timeout  \nТаймаут выполнения скриптов в текущем контексте. По умолчанию 30_000\n- Page Load Timeout  \nТаймаут загрузки страницы. По умолчанию 300_000. При превышении выбрасывает TimeoutException\n- Implicit Wait Timeout  \nвремя ожидания загрузки элемента страницы. По умолчанию 0.\n\n#### unhandledPromptBehavior\nЗадает поведение когда открывается диалоговое окно системы\nМожет иметь следущие значения:\n- dismiss\n- accept\n- dismiss and notify\n- accept and notify\n- ignore\n\nПо умолчанию dismiss and notify.\n\n#### strictFileInteractability\nЭта опция указывает должна ли применяться строгая проверка видимости поля input с атрибутом type=\"file\". Так как строгая проверка по умолчанию отключена, это может влиять на работу метода element.sendKeys при работе со скрытым элементом управления.\n\n#### proxy\nПрокси-сервер - это посредник для запросов между клиентом и сервером.\nТрафик проходит через прокси-сервер на пути к запрошенному адресу и обратно.\n\n```java\nProxy proxy = new Proxy();\nproxy.setHttpProxy(\"<HOST:PORT>\");\nChromeOptions options = new ChromeOptions();\noptions.setCapability(\"proxy\", proxy);\nWebDriver driver = new ChromeDriver(options);\n```\n\n### Firefox\n \nМожно установить кастомный профиль с нужными настройками\n\n```java\nFirefoxProfile profile = new FirefoxProfile();\nFirefoxOptions options = new FirefoxOptions();\noptions.setProfile(profile);\ndriver = new RemoteWebDriver(options);\n```\n\n### Internet Explorer\n\n#### fileUploadDialogTimeout\nВ некоторых окружениях Internet Explorer может с задержкой открывать окно Загрузка Файла. IEDriver по умолчанию устанавливает timeout ожидания этого окна в 1_000мс, но с помощью опции fileUploadDialogTimeout это время можно увеличить\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.waitForUploadDialogUpTo(Duration.ofSeconds(2));\nWebDriver driver = new RemoteWebDriver(options);\n```\n#### ensureCleanSession\nЕсли установлено в true - то кеш, история браузера и файлы cookie будут очищены для всех экземпляров Internet Explorer(в том числе запущенных вручную). По умолчанию false. При использовании этой опции при запуске браузера, дайвер будет ждать очистки кеша.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.destructivelyEnsureCleanSession();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreZoomSetting\nДрайвер InternetExplorer ожидает, что уровень масштабирования браузера будет равен 100%, иначе драйвер выдаст исключение. Это поведение по умолчанию можно отключить, установив для ignoreZoomSetting значение true.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.ignoreZoomSettings();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### ignoreProtectedModeSettings\nЕсли Protected Mode не включен и настройки защищенного режима не одинаковы для всех зон, драйвером будет выдано исключение. \n\nЕсли установлено значение true, драйвер будет игнорировать эту настройку, но тесты могут работать нестабильно, переставать отвечать или браузеры могут зависать. \n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.introduceFlakinessByIgnoringSecurityDomains();\nWebDriver driver = new RemoteWebDriver(options);\n```\n\n#### silent\nЕсли установлено значение true, эта опция игнорирует диагностические выходные данные IEDriverServer.\n\n```java\nInternetExplorerOptions options = new InternetExplorerOptions();\noptions.setCapability(\"silent\", true);\nWebDriver driver = new InternetExplorerDriver(options);\n```\n\n#### Command-Line Options\nInternet Explorer включает несколько параметров командной строки, которые позволяют устранять неполадки и настраивать браузер. \n\nНиже описаны несколько поддерживаемых параметров командной строки.\n- -private: используется для запуска IE в режиме приватного просмотра. Это работает для IE 8 и более поздних версий. \n- -k : запускает Internet Explorer в режиме киоска. Браузер открывается в развернутом окне, в котором нет адресной строки, кнопок навигации или строки состояния. \n- -extoff : Запускает IE в режиме без дополнений. Этот параметр специально используется для устранения неполадок с надстройками браузера. Работает в IE 7 и более поздних версиях. \n\n> ForceCreateProcessApi должен быть включен для того, чтобы аргументы командной строки работали.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        options.addCommandSwitches(\"-k\");\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n```\n\n#### forceCreateProcessApi\nПринудительно запускает Internet Explorer с помощью API CreateProcess. Значение по умолчанию false. Для IE 8 и более поздних версий этот параметр требует, чтобы для параметра реестра \"TabProcGrowth\" было установлено значение 0.\n\n```java\nimport org.openqa.selenium.Capabilities;\nimport org.openqa.selenium.ie.InternetExplorerDriver;\nimport org.openqa.selenium.ie.InternetExplorerOptions;\n\npublic class ieTest {\n    public static void main(String[] args) {\n        InternetExplorerOptions options = new InternetExplorerOptions();\n        options.useCreateProcessApiToLaunchIe();\n        InternetExplorerDriver driver = new InternetExplorerDriver(options);\n        try {\n            driver.get(\"https://google.com/ncr\");\n            Capabilities caps = driver.getCapabilities();\n            System.out.println(caps);\n        } finally {\n            driver.quit();\n        }\n    }\n}\n``` \n## Работа с браузером\n\n### Получение заголовка\n```java\ndriver.getTitle();\n```\n\n### Получение текущего URL\n\n```java\ndriver.getCurrentUrl();\n```\n\n### Навигация\n\n#### Переход на страницу\n```java\n//Convenient\ndriver.get(\"https://selenium.dev\");\n\n//Longer way\ndriver.navigate().to(\"https://selenium.dev\");\n```\n\n#### Возврат назад\n```java\ndriver.navigate().back();\n```\n\n#### Переход вперед\n```java\ndriver.navigate().forward();\n```\n\n#### Обновить страницу\n```java\ndriver.navigate().refresh();\n```\n\n### JavaScript окна\n#### Ожидание всплавающего окна браузера\n```java\nAlert alert = wait.until(ExpectedConditions.alertIsPresent());\n```\n\n#### Получить текст из всплывающего окна\n```java\nString text = alert.getText();\n```\n\n#### Нажать OK кнопку\n```java\nalert.accept();\n```\n\n#### Отклонить всплывающее окно\n```java\nalert.dismiss();\n```\n\n#### Ввести текст в всплывающем окне\n```java\nalert.sendKeys(\"Selenium\");\n```\n\n### Работа с Cookie\n\n#### Добавить Cookie\nПрежде чем выставлять куки нужно перейти на страницу сайта для которого нужно применить куки. Еслистраница долго грузится можно перейти на какую нибудь легковесную, например, страница с ошибкой 404.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class addCookie {\n    public static void main(String[] args) {\n        WebDriver driver = new ChromeDriver();\n        try {\n            driver.get(\"http://www.example.com\");\n\n            // Adds the cookie into current browser context\n            driver.manage().addCookie(new Cookie(\"key\", \"value\"));\n        } finally {\n            driver.quit();\n        }\n    }\n}\n  \n```\n#### Проверка что Cookie \n#### Получить имя Cookie\n\n#### Получить все Cookie\n\n#### Удалить Cookie\n\n#### Удалить все Cookie\n\n#### Проверка что Cookie отправляются с одного сайта\nПредназначенно для предотвращения подделки межсайтовых запросов (CSRF).\n\n- При установке значения Lax подразумевается, что куки должны отправляться при серфинге по одному сайту или через GET серфинг на ваш сайт с других сайтов. \n- Значение Strict ограничивало cookie запросами, исходящими только от одного сайта.\n\n> Работает только для Chrome(версия 80+) и Firefox(версия 79+) в Selenium 4 и более поздних.\n\n```java\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class cookieTest {\n  public static void main(String[] args) {\n    WebDriver driver = new ChromeDriver();\n    try {\n      driver.get(\"http://www.example.com\");\n      Cookie cookie = new Cookie.Builder(\"key\", \"value\").sameSite(\"Strict\").build();\n      Cookie cookie1 = new Cookie.Builder(\"key\", \"value\").sameSite(\"Lax\").build();\n      driver.manage().addCookie(cookie);\n      driver.manage().addCookie(cookie1);\n      System.out.println(cookie.getSameSite());\n      System.out.println(cookie1.getSameSite());\n    } finally {\n      driver.quit();\n    }\n  }\n}\n```\n\n### Работа с iFrame\n\nФреймы — это устаревшее средство создания макета сайта из нескольких документов в одном домене. Вы вряд ли будете работать с ними, если вы не работаете с веб-приложением до HTML5. \n\nФреймы iframe позволяют вставлять документ из совершенно другого домена и до сих пор широко используются. \n\n#### Переключение на фрейм через WebElement\n```java\nWebElement iframe = driver.findElement(By.cssSelector(\"#modal>iframe\"));\n//Switch to the frame\ndriver.switchTo().frame(iframe);\n```\n#### Переключение на фрейм через имя или id\n```java\n//Using the ID\ndriver.switchTo().frame(\"buttonframe\");\n\n//Or using the name instead\ndriver.switchTo().frame(\"myframe\");\n```\n\n#### Переключение на фрейм через index\n```java\n// Switches to the second frame\ndriver.switchTo().frame(1);\n```\n\n#### Возврат на основную страницу\n```java\n// Return to the top level\ndriver.switchTo().defaultContent();\n```\n\n### Работа с окнами и вкладками\n\n#### Получить обработчик текущего окна\n```java\ndriver.getWindowHandle();\n```\n\n#### Переключиться на новое окно или вкладку\n```java\nString originalWindow = driver.getWindowHandle();\n\n//Check we don't have other windows open already\nassert driver.getWindowHandles().size() == 1;\n\n//Click the link which opens in a new window\ndriver.findElement(By.linkText(\"new window\")).click();\n\n//Wait for the new window or tab\nwait.until(numberOfWindowsToBe(2));\n\n//Loop through until we find a new window handle\nfor (String windowHandle : driver.getWindowHandles()) {\n    if(!originalWindow.contentEquals(windowHandle)) {\n        driver.switchTo().window(windowHandle);\n        break;\n    }\n}\n\n//Wait for the new tab to finish loading content\nwait.until(titleIs(\"Selenium documentation\"));\n```\n\n#### Создать(открыть) новое окно или вкладку и переключиться на нее(Selenium 4)\n```java\n// Opens a new tab and switches to new tab\ndriver.switchTo().newWindow(WindowType.TAB);\n\n// Opens a new window and switches to new window\ndriver.switchTo().newWindow(WindowType.WINDOW);\n```\n\n#### Закрыть окно или вкладку\n```java\n//Close the tab or window\ndriver.close();\n\n//Switch back to the old tab or window\ndriver.switchTo().window(originalWindow);\n```\n\n#### Закрыть браузер и закончить сессию\n```java\ndriver.quit();\n```\n\n#### Управление окном\n\n##### Получить размер окна\nВыдает размер в пикселях\n\n```java\n//Access each dimension individually\nint width = driver.manage().window().getSize().getWidth();\nint height = driver.manage().window().getSize().getHeight();\n\n//Or store the dimensions and query them later\nDimension size = driver.manage().window().getSize();\nint width1 = size.getWidth();\nint height1 = size.getHeight();\n```\n\n##### Установить размер окна\n```java\ndriver.manage().window().setSize(new Dimension(1024, 768));\n```\n\n##### Получить положение окна\n```java\n// Access each dimension individually\nint x = driver.manage().window().getPosition().getX();\nint y = driver.manage().window().getPosition().getY();\n\n// Or store the dimensions and query them later\nPoint position = driver.manage().window().getPosition();\nint x1 = position.getX();\nint y1 = position.getY();\n```\n\n#### Переместить окно\n```java\n// Move the window to the top left of the primary monitor\ndriver.manage().window().setPosition(new Point(0, 0));\n```\n\n##### Увеличить окно на максимум\n```java\ndriver.manage().window().maximize();\n```\n\n##### Свернуть окно(Selenium 4)\n```java\ndriver.manage().window().minimize();\n```\n\n##### Развернуть окно на полный экран\n```java\ndriver.manage().window().fullscreen();\n```\n\n##### Сделать скриншот\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.*;\nimport org.openqa.selenium.*;\n\npublic class SeleniumTakeScreenshot {\n    public static void main(String args[]) throws IOException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(\"http://www.example.com\");\n        File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);\n        FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n        driver.quit();\n    }\n}\n```\n\n##### Сделать скриншот элемента\n```java\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class SeleniumelementTakeScreenshot {\n  public static void main(String args[]) throws IOException {\n    WebDriver driver = new ChromeDriver();\n    driver.get(\"https://www.example.com\");\n    WebElement element = driver.findElement(By.cssSelector(\"h1\"));\n    File scrFile = element.getScreenshotAs(OutputType.FILE);\n    FileUtils.copyFile(scrFile, new File(\"./image.png\"));\n    driver.quit();\n  }\n}\n```\n\n##### Выполнить скрипт\n```java\n    //Creating the JavascriptExecutor interface object by Type casting\n      JavascriptExecutor js = (JavascriptExecutor)driver;\n    //Button Element\n      WebElement button =driver.findElement(By.name(\"btnLogin\"));\n    //Executing JavaScript to click on element\n      js.executeScript(\"arguments[0].click();\", button);\n    //Get return value from script\n      String text = (String) js.executeScript(\"return arguments[0].innerText\", button);\n    //Executing JavaScript directly\n      js.executeScript(\"console.log('hello world')\");\n```\n\n##### Напечатать страницу\n> Необходимо чтобы Chromium браузер был в режиме headless\n```java\n    import org.openqa.selenium.print.PrintOptions;\n\n    driver.get(\"https://www.selenium.dev\");\n    printer = (PrintsPage) driver;\n\n    PrintOptions printOptions = new PrintOptions();\n    printOptions.setPageRanges(\"1-2\");\n\n    Pdf pdf = printer.print(printOptions);\n    String content = pdf.getContent();\n```\n\n## Элементы\n\n### Локаторы\n\n#### Относительные локаторы (Selenium 4)\n\n##### Above\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).above(By.id(\"password\"));\n```\n\n##### Below\n```java\nBy passwordLocator = RelativeLocator.with(By.tagName(\"input\")).below(By.id(\"email\"));\n```\n\n##### Left of\n```java\nBy cancelLocator = RelativeLocator.with(By.tagName(\"button\")).toLeftOf(By.id(\"submit\"));\n```\n\n##### Right of\n```java\nBy submitLocator = RelativeLocator.with(By.tagName(\"button\")).toRightOf(By.id(\"cancel\"));\n```\n\n##### Near\n```java\nBy emailLocator = RelativeLocator.with(By.tagName(\"input\")).near(By.id(\"lbl-email\"));\n```\n\n### Поиск элементов\n```java\nWebElement vegetable = driver.findElement(By.className(\"tomatoes\"));\n```\n\n#### Поиск дочернего элемента \n```java\n// не оптимальный способ\nWebElement fruits = driver.findElement(By.id(\"fruits\"));\nWebElement fruit = fruits.findElement(By.id(\"tomatoes\"));\n\n// так лучше\nWebElement fruit = driver.findElement(By.cssSelector(\"#fruits .tomatoes\"));\n```\n\n#### Поиск нескольких элементов\n```java\nList<WebElement> plants = driver.findElements(By.tagName(\"li\"));\n```\n\n#### Получить активный элемент\nАктивный элемент - на котором фокус.\n```java\ndriver.switchTo().activeElement()\n```\n\n### Взаимодействие с элеентами\n\n#### Клик - Click\n```java\ndriver.findElement(By.name(\"button\")).click();\n```\n\n#### Ввод символов - Send Keys\n```java\ndriver.findElement(By.name(\"q\")).sendKeys(\"q\" + Keys.ENTER);\n```\n\n#### Очистить поле - Clear\n```java\nWebElement searchInput = driver.findElement(By.name(\"q\"));\nsearchInput.sendKeys(\"selenium\");\n// Clears the entered text\nsearchInput.clear();\n```\n\n### Информация об элементе\n\n#### Видимость\n```java\nboolean isButtonVisible = driver.findElement(By.css(\"[name='login']\")).isDisplayed();\n```\n\n#### Доступность\n```java\nboolean value = driver.findElement(By.name(\"btnK\")).isEnabled();\n```\n\n#### Выбран ли\n```java\nboolean value = driver.findElement(By.cssSelector(\"input[type='checkbox']:first-of-type\")).isSelected();\n```\n\n#### Имя тега\n```java\nString value = driver.findElement(By.cssSelector(\"h1\")).getTagName();\n```\n\n#### Размер и положение\n```java\nRectangle res =  driver.findElement(By.cssSelector(\"h1\")).getRect();\n\n// Rectangle class provides getX,getY, getWidth, getHeight methods\nSystem.out.println(res.getX());\n```\n\n#### Получить CSS свойство\n```java\nString cssValue = driver.findElement(By.linkText(\"More information...\")).getCssValue(\"color\");\n```\n\n#### Получить текст элемента\n```java\nString text = driver.findElement(By.cssSelector(\"h1\")).getText();\n```\n\n### Работа с выпадающим списком\n\n#### Определить элемент выпадающего списка \n```java\nimport org.openqa.selenium.support.ui.Select;\n\nWebElement selectElement = driver.findElement(By.id(\"selectElementID\"));\nSelect selectObject = new Select(selectElement);\n```\n\n#### Выбрать опцию\n- по индексу\n```java\n// Select an <option> based upon the <select> element's internal index\nselectObject.selectByIndex(1);\n```\n\n- по значению\n```java\n// Select an <option> based upon its value attribute\nselectObject.selectByValue(\"value1\");\n```\n  \n- по видимому тексту\n```java\n// Select an <option> based upon its text\nselectObject.selectByVisibleText(\"Bread\");\n```\n\n#### Получить все выбранные опции\n```java\n// Return a List<WebElement> of options that have been selected\nList<WebElement> allSelectedOptions = selectObject.getAllSelectedOptions();\n```\n#### Получить первую выбранную опцию\n```java\n\n// Return a WebElement referencing the first selection option found by walking down the DOM\nWebElement firstSelectedOption = selectObject.getFirstSelectedOption();\n```\n\n#### Получить все опции\n```java\n// Return a List<WebElement> of options that the <select> element contains\nList<WebElement> allAvailableOptions = selectObject.getOptions();\n```\n\n#### Отменить выбор \n- по индексу\n```java\n// Deselect an <option> based upon the <select> element's internal index\nselectObject.deselectByIndex(1);\n```\n\n- по значению\n```java\n// Deselect an <option> based upon its value attribute\nselectObject.deselectByValue(\"value1\");\n```\n\n- по видимому тексту\n```java\n// Deselect an <option> based upon its text\nselectObject.deselectByVisibleText(\"Bread\");\n```\n\n- отменить все\n```java\n// Deselect all selected <option> elements\nselectObject.deselectAll();\n```\n\n#### Поддерживает ли список множественный выбор\n```java\nBoolean doesThisAllowMultipleSelections = selectObject.isMultiple();\n```\n\n## Удаленный браузер\n\n```java\nFirefoxOptions firefoxOptions = new FirefoxOptions();\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), firefoxOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Добавление опций\n```java\nChromeOptions chromeOptions = new ChromeOptions();\nchromeOptions.setCapability(\"browserVersion\", \"67\");\nchromeOptions.setCapability(\"platformName\", \"Windows XP\");\nWebDriver driver = new RemoteWebDriver(new URL(\"http://www.example.com\"), chromeOptions);\ndriver.get(\"http://www.google.com\");\ndriver.quit();\n```\n\n### Local file detector\nПозволяет загружать файл с клиентской машины на удаленную.\nНужно для загрузки файлов на сайт.\n\n```java\ndriver.setFileDetector(new LocalFileDetector());\n\ndriver.get(\"http://sso.dev.saucelabs.com/test/guinea-file-upload\");\nWebElement upload = driver.findElement(By.id(\"myfile\"));\nupload.sendKeys(\"/Users/sso/the/local/path/to/darkbulb.jpg\");\n  \n```\n\n### ","date":"2022-06-20T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/selenium-api/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Подключение зависимости","anchor":"#подключение-зависимости"},{"value":"Загрузка драйвера через WebDriverManager","anchor":"#загрузка-драйвера-через-webdrivermanager"},{"value":"Открыть и закрыть браузер","anchor":"#открыть-и-закрыть-браузер"},{"value":"Начало работы","anchor":"#начало-работы"},{"value":"Capabilities","anchor":"#capabilities"},{"value":"Работа с браузером","anchor":"#работа-с-браузером"},{"value":"Удаленный браузер","anchor":"#удаленный-браузер"}]}},{"node":{"id":"69e2a0e8f352a43863174d1d7360b43a","title":"Что такое Selenium?","content":"\n## Что такое Selenium?\n**Selenium** - это инструмент для автоматизированного управления браузерами _или_ драйвер для браузера, специальное ПО которое предназначено для управления браузерами и позволяет другим программам взаимодействовать с браузером.\n\nSelenium специальных средств для тестирования не имеет, он позволяет только управлять браузером.\n\n## Что умеет Selenium\nОбычно драйвер предоставляет некоторый набор команд, который соответствует некоторым функциям устройства, в нашем случае функциям браузера.\n\nДрайвер может:\n- запускать браузер \n- открывать URL адреса\n- находить ссылки или другие элементы\n- выполнять действия над элементами\n- остановить браузер\n\n## Реализации Selenium\nДля разных браузеров существуют разные драйверы, но они предоставляют одинаковый набор команд.\nТак же существуют разные реализации интерфейсов для разных языков программирования.\n\nВ рамках проекта Selenium разрабатываются интерфейсы для 5 языков:\n- Java\n- Python\n- Ruby\n- JavaScript\n- C#\n\n## Принцип работы\n\nКаждое веб приложение условно можно разделить на 2 части: \n- веб сервер, на котором реализуется логика и находится БД \n- браузер, который предоставляет графический пользовательский интерфейс к этому приложению. \n\nБраузер и веб сервер взаимодействуют по протоколу HTTP. Браузер отправляет запрос, сервер его обрабатывает и отправляет обратно ответ.\nЭтот ответ содержит информацию, которую браузер использует для визуализации. \n\nДля того, чтобы тестировать серверную часть, браузер не нужен, его можно заменить http клиентом(библиотека которая умеет отправлять запросы по протоколу http и получать ответы), такие клиенты сузествуют для разных языков они не имеют пользовательского интерфейс, только программный(API). \n\nОднако такой способ игнорирует всё, что происходит в браузере (в браузере может быть реализована часть логики плюс сам интерфес становится более динамичным и его тоже нужно тестировать).\n\nSelenium предоставляет клиентскую библиотеку для разных языков программирования, через которую можно связаться с самим Selenium интерфейсом, который уже взаимодействует с браузером.\n\nБольшинство браузеров сейчас  предоставляют интерфейс для управления или отладки, которым можно воспользоваться для внедрения JavaScript кода и выполнения этого кода в браузере.\n\nИзначально браузеры не предоставляли такие интерфейсы, кроме IExplorer и в нем работа была реализована изначально таким способом. Но потом появилась возможность взаимодействовать через интерфейсы и с другими браузерами.\n\n### Интерфесы которые предоставляют браузеры\nРазные браузеры предоставляют разные интерфейсы:\n- Chrome - Remote Debug\n- Firefox - Marionette\n- IE - COM API\n\n### Selenium интерфейсы для разных браузеров\nSelenium предоставляет единый интерфейс, а сам взаимодействует с браузерами по их интерфейсу:\n- Chrome - chromedriver\n- Firefox - geckodriver\n- IE - IEDriverServer","date":"2022-06-12T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/chto-takoe-selenium/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Что такое Selenium?","anchor":"#что-такое-selenium"},{"value":"Что умеет Selenium","anchor":"#что-умеет-selenium"},{"value":"Реализации Selenium","anchor":"#реализации-selenium"},{"value":"Принцип работы","anchor":"#принцип-работы"}]}},{"node":{"id":"703c641b88145adc725ea1a1585a102d","title":"Gradle","content":"\nGradle - это инструмент для автоматической сборки приложений. Он отвечает за структуру, зависимости, плагины вашего проекта, чтобы управлять этапами сборки проекта: компиляция, запуск тестов, публикация. \n\nGradle написан на Java и запускается на JVM, поэтому нужно чтобы был установлен JDK. При этом Gradle не заточен только под java приложения и может собирать любые другие. \n\nДля реализации и описания процесса сборки в Gradle реализовано 2 DSL языка на Groovy и на Kotlin.\nОба этих языка предоставляют примерно одинаковый API для работы со сборкой и имеют 2 интерфейса, которые эту сборку описывают.\n\n`project` - описывает как и из чего собрать проект;  \n`settings.gradle` - описывает дополнительные метаданные и список дочерних проектов, если это мультимодульный проект;\n\n## `project`\n\n### task\nПредставляет собой набор задач, который вам нужно выполнить для сборки приложения; эти задачи можно писать самим или добавлять через плагины.\n\n### plugin\nБольшинство функционала gradle реализуется с помощью плагинов, поэтому сам gradle изначально достаточно легкий и не содержит лишнего мусора.\n\nПлагин - это реализация методов интерфейса проекта(project), которые могут реализовывать работу с зависимостями, добавлять нужные таски и почти полностью менять, то как работает процесс сборки.\n\n### dependencies\nМожно указать необходимые зависимости для работы вашего приложения. Gradle реализует только логику управления зависимостями а сам репозиторий можно выбрать, настроив это в build скрипте. Это может быть например maven или ivy репозиторий.\n\nТип Task в Gradle это по сути класс. Он состоит из действий(actions), которые выполняет класс, входных данных(inputs), над которыми мы производим действия и выходных данных(outputs). \n\nКаждая из этих состовляющих кастомизируема и необязательна. Например, существуют LifeCycle таски, которые сами ничего не делают, но объединяют несколько других тасок.\n\nЗа счет такого разделения Gradle реализует **_инкрементальную_** сборку: перед выполнением таски Gradle проверяет есть ли изменения входных данных и повлияют ли эти изменеия на выходные данные. Если нет, то Gradle просто пропустит таск с надписью **UP TO DATE**, таким образом оптимизируется процесс сборки, чтобы каждый раз не собирать неизменяемые модули, а собирать только то, что изменилось, но эту логику также можно отключить.\n\nЧтобы обеспечить нужный порядок выполнения тасок и что каждая таска выполнится только один раз, в процессе билдинга Gradle строит из тасок так называемый ориентированный ациклический граф(**DAG, Directed Acyclic Graph**). \n\nГраф - это набор объектов(в нашем случае тасок), обладающих парными связями (каждая таска связана с одной или несколькими(двумя) другими тасками). \n\nТаски - вершины, связи между ними - ребра. \n\nТо что граф ориентированный или по другому орграф значит, что у ребер есть направление (порядок исполнения тасок), то что он ациклический означает, что в нем нет направленных циклов, нельзя из одной точки прийти в нее же, но это не мешает из разных точек прийти в одну. Такие графы много где использются, например для представления искусственных нейронных сетей без обратной связи. \n\n**Граф для сборки Java приложения**\n\n```mermaid\ngraph TD;\n      build-->check;\n      build-->assemble;\n      check-->test;\n      assemble-->jar;\n      jar-->classes;\n      classes-->compileJava;\n      classes-->processResources;\n```\n\n## Сборка Java приложения\nПроцесс сборки делится на 3 тапа: инициализация (initialization), конфигурация (configuration) и исполнение (execution). \n\n### Инициализация\nВ процессе инициализации Gradle ищет `settings.gradle` файл, из которого определяет это одиночный или мультимодульный проект. После этого он создает instance одного или нескольких проектов. \n\n```mermaid\ngraph TD;\n      Initialization-->settings.gradle-->project;\n```\n\n### Конфигурация\nДалее в процессе конфигурации, gradle для каждого проекта ищет build.gradle скрипт и выполняет все указанные там конфигурационные действия в контексте текущего проекта: подключает плагины, скачивает зависимости, выполняет код находящийся в конфигурационном блоке, создавая объекты сборки - строит граф из тасок.\n\n```mermaid\ngraph TD;\n      Configuration-->build.gradle-->build_objects;\n```\n\n\nВо время фазы конфигурации gradle исполняет конфигурационные скрипты всех проектов если это мультимодульный проект, даже если вы собираете только один из модулей. Так что если логика не относится ко всему мультимодульному проекту, лучше ее помещать в конкретные таски. \n\n### Исполнение\n\nПо сути в процессе конфигурации он строит тот самый граф из тасок и в процессе выполнения, исполняет те таски, которые мы указали.\n\n```mermaid\ngraph TD;\n      Execution-->execute_tasks;\n```\n\nИннициализация Gradle проекта выполняется командой gradle init.\n\n```\n$ gradle init\n```\n\nДалее нужно ответить на несколько вопросов и дождаться окончания инициализации.\nПосле этого в проекте будут созданы файлы: \n- gradlew(исполняющий файл для Linux подобных систем), gradlew.bat(исполняющий файл для Windows);\n- папка gradle, в которой папка wrapper;  \nКак раз этот wrapper и запускает скрипты. Gradle использует wrapper, чтобы можно было однозначно понять версию Gradle, которая будет использоваться для сборки.  \nWrapper сам скачает эту версию Graddle, если на машине он не установлен. Поменять версию и откуда его скачивать можно в файле gradle/gradle-wrapper.properties\n- build.gradle, settings.gradle\n\nВ **settings.gradle** указано только имя проекта, для мультимодульных проектов также здесь указывается список модулей. \n\nВ **build.gradle** имеются следущие секции:\n\n- секция plugins  \nЗдесь размещается обычно плагин id: 'java', который используется для сборки java проектов;  \nЕще существует плагин java-library, он используется если вы хотите поставлять ваше приложение как библиотеку.\n\n```groovy\nplugins {\n    id 'java'\n}\n```\n\n- секция repositories  \nЗдесь можно задать url репозитория из которого будут скачиваться зависимости. \n```groovy\nrepositories {\n    maven{\n        url = uri('https://repo.maven.apache.org/maven2/')\n    }\n}\n```\n\nДля стандартного Maven репозитория есть алиас mavenCentral().\n\n```groovy\nrepositories {\n    mavenCentral()\n}\n```\n\nТакже в build.gradle, как и в Maven содержатся group, version, description, java.sourceCompatibility, но в отличие от Maven их указывать не обязательно Gradle сможет сам сгенерировать эти данные.\nПосле компиляции нам доступны таски. В блоке verification есть таска test, которая будет запускать наши тесты. \n\n- секция dependencies  \n\nЕсть несколько типов зависимостей:\n- implementation - зависимость доступна и в main и в test директориях\n- testImplementation - зависимость доступна только в test директории\n- testAnnitationProcessor - зависимость, которая генерирует код в рантайме на основе аннотаций, требуется например для lombok\n- compileOnly - deprecated метод, вместо него нужно использовать implementation или testImplementation\n\nПосле названия метода указывается адрес зависимости, координаты адреса разделяются двоеточием - group:name:version.\n\n```groovy\ndependencies {\n    implementation 'com.codeborne:selenide:6.6.3'\n    testImplementation 'org.junit.jupiter:junit-jupiter:5.8.2'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'\n    testImplementation 'org.projectlombok:lombok:1.18.24'\n    testAnnotationProcessor 'org.projectlombok:lombok:1.18.24'\n}\n```\n\nЧтобы после билда запустились тесты, нужно указать каким движком нужно запустить тесты.\n\n```groovy\ntest {\n    useJUnitPlatform() //для запуска тестов с помощью JUnit5\n}\n```\n\nКогда зависимость требует какой то сложной конфигурацией она зачастую реализуется плагином. Тогда достаточно подключить плагин и не нужно добавлять несколько зависимостей.\n\nВместо testAnnotationProcessor которую мы прописывали для lombok можно добавить плагин.\n\n```groovy\nplugins {\n    id 'io.freefair.lombok' version'5.3.0'\n}\n```\n\n## Custom task\n\nДля добавления своей таски используется коллекция tasks и новые таски в нее добавляются с помощью методы register. В метод register нужно передать название таски(по этому названию мы в последствии сможем обращаться к этой таске)\nвторой параметр опционален, в него можно передать тип таски можно использовать стандартный тип Test который был добавлен Java плагином. \n\n### Таска для запуска тестов из определенной директории\nОтфильтровать тесты которые будут запускаться можно с помощью блока filter в нем есть метод includeTestsMatching.\nНа вход этому методу можно передать wildcard - часть пути до наших тестов со звездочкой. Путь - это имя модуля, пакета, класса в котором тесты находятся.\n\n```\nsrc\n├── main\n    ├── java\n        ├── simple\n            ├── automation\n├── test\n    ├── java\n        ├── rest\n        ├── utils\n        ├── web\n            ├── findby\n            ├── simple\n```\n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n```\n\n### Указываем платформу для запуска тестов из Custom Tasks \n\nЧтобы не прописывать в каждой таске, что она должна запускаться с помощью Junit можно выполнить одну настройку для всех тасок с типом test. \nДля этого на контейнере tasks используем метод withType, который выберет все таски с типом Test, и внутри конфигурационного блока используем useJUnitPlatform().\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n}\n```\n\n### Зауск тестов из Custom Task\nВыполняем запуск тестов webtests командой:\n\n```\n$ ./gradlew webtests\n```\n\n### Добавляем еще одну custom таску\nАналогично можно настроить запуск для rest тестов:\n\n```groovy\ntasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n```\n\n### Добавляем зависимость одной таски от другой\nБывает что rest тесты могут использоваться при выполнении web тестов и зачастую бывает удобно прогонять web тесты только если прошли rest тесты.\nДля этого в Gradle есть метод dependsOn с аргументом в виде названия таска, от которой зависит текущая таска. \n\n```groovy\ntasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n    dependsOn 'resttests'\n}\n```\n\nСоответсвенно, при запуске web тестов будут также запущены rest тесты и они выполнятся только если rest тесты пройдут. \n\n### Запуск независимых тасок в одном скоупе\nНо если у нас rest и web тесты работают независимо как разные модули или части системы, мы можем создать еще один таск regress, который будет запускать и те и другие тесты. Используем тот же метод dependsOn но уаазываем и web и rest тесты.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n}\n```\n\nНо в таком виде запуска мы не знаем в каком порядке запустятся эти таски. \n\n### Настраиваем порядок запуска тасок\nЕсли мы хотим определить порядок, например, чтобы web тесты запускались после rest тестов, мы можем использовать метод mustRunAfter или shouldRunAfter(является менее строгим и не запускает тесты если из-за зависимости образуется петля).\nЧтобы найти ранее созданный таск используем метод getByName и из него запускаем mustRunAfter с аргументом ввиде названия таски после которой нужно запускать.\n\n```groovy\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n    \n    tasks.getByName('webtests').mustRunAfter('resttests')\n}\n```\n\nЛибо при создании таска можно сохранить ее в переменную и тогда можно использовать эти переменные для вызова mustRunAfter.\n```groovy\ndef webtests = tasks.register('webtests', Test).configure() {\n    filter {\n        includeTestsMatching(\"web.simple*\")\n    }\n}\n\ndef resttests = tasks.register('resttests', Test).configure() {\n    filter {\n        includeTestsMatching(\"rest*\")\n    }\n}\n\ntasks.register('regress') {\n    dependsOn 'webtests'\n    dependsOn 'resttests'\n\n    webtests.mustRunAfter(resttests)\n}\n```\n\n### Запуск тестов из директории main\nЕсли по какой то причине тесты оказались не в папке test, а в папке main, то по умолчанию Gradle найти там тесты не может. Поэтому для того чтобы указать нестандартное место исходников можно использовать блок sourceSets.\n\n1. Добавляем новый sourceSet\n\nДля создания нового сета, просто пишем имя сета и скобку, внутри добавляем блок java чтобы указать свойства которые были добавлены java плагином, compileClasspath и runtimeClasspath, добавляем через += чтобы не затирать текущие значения. \nДобавляем туда путь к папке main(если тесты лежат в папке main) - main.output. Чтобы указать где взять исходники используем свойство srcDir. \n\n```groovy\nsourceSets {\n    maintests {\n        java {\n            compileClasspath += main.output\n            runtimeClasspath += main.output\n        }\n        srcDir = file(\"src/main/java/simple/automation\")\n    }\n}\n```\n\n2. Настраиваем зависимости для добавленного sourceSet\n\nТакже нам нужны зависимости из блока dependencies, по умолчанию они в блок sourceSet не попадают.\nДля этого используется блок configurations, в нем указываем имя нашего sourceSet и без пробела пишем Implementation или RuntimeOnly. \nДалее с помощью метода extendsFrom можем указать, что зависимости нужно брать стандартные из testImplementation и testRuntimeOnly.\n\n\n```groovy\nconfigurations{\n    maintestsImplementation.extendsFrom(testImplementation)\n    maintestsRuntimeOnly.extendsFrom(testRuntimeOnly)\n}\n```\n\n3. Добавляем таск для запуска тестов, используя sourceSet\n\nСоздаем таск для запуска псевдотестов и указываем, что нужно использовать наш кастомный sourceSet.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n}\n```\n\n4. Добавляем фильтрацию по тегам JUnit\n\nТеперь нужно отфильтровать псевдотесты чтобы запускались только они. Сделать как в предыдущих тасках мы не можем потому что по имени package simple.automation будут запущены также и web тесты.\nНо можно использовать фильтрацию по тегам Junit. Для этого вызываем метод useJUnitPlatform, но к нему добавляем конфигурационный блок includeTags и тег методов или классов которые хотите запустить.\n\n```groovy\ntasks.register('pseudotests', Test){\n    testClassesDirs = sourceSets.maintests.output.classesDirs\n    classPath = sourceSets.maintests.runtimeClasspath\n\n    useJUnitPlatform{\n        includeTags \"pseudo\"\n    }\n}\n```\n\n### Запуск тестов с логированием\nЧтобы добавить уровень логирования INFO при запуске gradlew нужно добавить ключ -i.\nТаком образом мы увидим сообщения которые выводятся в консоль из тестов.\n\n```\n$ ./gradlew -i pseudotests\n```\n\n### Отключаем инкрементальный билд при запуске\nНо сразу мы можем их не увидеть из-за инкрементального билда.\nТак как между запусками исходники тестов не поменялись Gradle просто не запустит их.\nЧтобы они запустились перед таской с тестами запустим также таску clean. Это актуально для запуска тестов из контекста main.\nЕсли запускаются тесты из директории test то нужно использовать таску cleanTest.\n\n```\n$ ./gradlew -i clean pseudotests\n```\n\n### Отключаем инкрементальный билд глобально при настройке таски\nЧтобы каждый раз не вызывать clean таску можно установить значение upToDateWhen в знасение false для всех тасок с типом Test.\n\n```groovy\ntasks.withType(Test) {\n    useJUnitPlatform()\n    outputs.upToDateWhen {false}\n}\n```\n\nЕсли запускаетя несколько независимых тасок с тестами, то Gradle по умолчанию останавливает выполнение на первом упавшем тесте. \nМожно настроить чтобы он все равно переходил к следущей задаче даже если упала предыдущая.\nДля этого можно при запуске добавить ключ --continue\n\n```\n$ ./gradlew --continue resttests webtests\n```\n\n### Отключаем стандартную таску test при билде\n\nДля этого нужно в блоке test присвоить свойству enabled значение false\n\n```groovy\ntest {\n    enabled = false\n}\n``` \n\n### Порядок выполнения build скрипта \n\n### Как добавить кастомные экшены к таскам\n\nСоздаем еще одну таску, но не указываем тип. В этом случае у таски будет тип DefaultTask и к ней не будет привязано никаких экшенов.\nВыводить текст в консоль можно стандартной командой println, но для реального логирования лучше использовать нормальные логгеры.\nДобавим вывод текста в блок конфигурирования таски, а также перед таской и после нее.\nЧтобы добавить кастомные экшены в таску можно использовать блок doFirst - это действие которое будет выполнено перед стандартными экшенами.\nВ нашем случае таких экшенов нет а для тасок с типом Test таким стандартным экшеном был запуск тестов.\nЕще мы можем использовать блок doLast - запускает кастомные экшены после стандартных. И doFirst и doLast можно использовать несколько раз, тогда они будут исполняться в указанном порядке. \n\nПосле запуска по тексту в консоли мы видим порядок выполнения.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\").configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\nРезультат выполнения:\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 637ms\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nСначала вполняется код конфигурации, затем код конфигурации самой таски (код внутри таски вне блоков doFirst и doLast), \nа уже дальше выполняются экшены сначала doFirst, потом doLast в порядке в котором они указаны в скрипте.\n\n> Стоит иметь ввиду если бы у нас был многомодульный проект, то сначала вполнился бы код конфигурации из всех build скриптов всех модулей.\n\nТип таски это прсто класс. Можно создать свой тип. \nДля этого используется метод с аннотацией @TaskAction, при этом класс должен наследоваться от DefaultTask.\n\n```groovy\nclass CustomTask extends DefaultTask{\n    @TaskAction\n    def customAction(){\n        println \"from custom action\"\n    }\n}\n```\n\nТеперь можно указать наш кастомный тип при регистрации таски. И теперь между doFirst и doLast экшенами выполнился наш кастомный экшен.\n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n```\n\n```console\n$ ./gradlew clean gradleTest\n\n> Configure project :\nfrom build script root\nfrom build script root 2\nfrom task root\n\n> Task :gradleTest\nfrom do first\nfrom custom action\nfrom do last\nfrom do last 2\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nТаск может состоять из input, actions, output. Добавим input в наш тип. Это можно сделать с помощью переменной с аннотацией @Input.\nПрисвоим ей дефолтное значение и будем использовать в нашем экшене. Теперь стандартный экшен использует значение из input'а \nи мы можем этот input переопределить в конфигурации самой таски. \n\n```groovy\nprintln \"from build script root\"\ntasks.register(\"gradleTest\", CustomTask).configure{\n    input = \"overrided\"\n    println \"from task root\"\n    doFirst {\n        println \"from do first\"\n    }\n    doLast {\n        println \"from do last\"\n    }\n    doLast {\n        println \"from do last 2\"\n    }\n}\nprintln \"from build script root 2\"\n\n\nclass CustomTask extends DefaultTask{\n    @Input\n    String input = \"default\"\n\n    @TaskAction\n    def customAction(){\n        println \"from custom action with $input\"\n    }\n}\n```\n\nПосле прогона тестов в build/test-results складывается xml отчет JUnit о прогоне тестов, а в папку reports сгенерированный из него html отчет.\nТакже есть тип таски zip позволяет что-нибудь заархивировать.\n\nИмя итогового архива задается через переменную archiveFileName, с помощью distinationDirectory указываем куда будет сложен этот архив и через\nметод from указываем какую именно папку заархивировать. Чтобы указать несколько папок используйте несколько строчек from. \n\nТаска чтобы заархивировать отчет:\n\n```groovy\ntasks.register(\"zipReport\", Zip).configure{\n    archiveFileName = 'report.zip'\n    distinationDirectory = file(\"$buildDir/reports\")\n    from \"$buildDir/reports/tests\"\n}\n```\n\nТакже потом его нужно куда нибудь скопировать. Для этого есть тип таски Copy. В ней указываем через from откуда взять файл(также можно указать несколько from),\nа в into указываем куда скопировать. \n\n```groovy\ntasks.register('copyReport', Copy).configure{\n    from file(\"$buildDir/reports/report.zip\")\n    into file(\"out\")\n}\n```\n\nЕще одна полезная таска это jar - позволяет заархивировать приложение в jar файл. \nУ него в блоке manifest в свойстве attributes можно задать атрибут Main-Class который указыывает класс в котром находится исполняемый метод main \nа в блоке from откуда взять скомпилированные классы \n\nJar собирается в папку build/libs и его можно запустить через команду java -jar \n\n```groovy\njar {\n    manifest {\n        attributes \"Main-Class\": \"simple.automation.Main\"\n    }\n    from {\n        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n}\n```\n\n## Источник информации \nhttps://www.youtube.com/watch?v=qYIz6URLxbU\n\n## TODO\n\nhttps://www.youtube.com/watch?v=WOBok2u-SL8\n\nhttps://www.youtube.com/watch?v=NZJTYPLb0iE","date":"2022-06-17T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/gradle/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"project","anchor":"#project"},{"value":"Сборка Java приложения","anchor":"#сборка-java-приложения"},{"value":"Custom task","anchor":"#custom-task"},{"value":"Источник информации","anchor":"#источник-информации"},{"value":"TODO","anchor":"#todo"}]}},{"node":{"id":"7f1278f719588578f4f4a80461d43b8a","title":"JUnit 5","content":"\nЗачастую для тестов нужно сделать какие то действия: до тестов, после тестов или перед каждым тестом.\nДля этих целей используются такие тест ранеры как JUnit или TestNG.\n\nJUnit5 разделен на 3 глобальных модулей: Platform, Jupiter, Vintage.\n\nPlatform - база которая позволяет строить свои собственные фреймворки для запуска тестов. На основе этого модуля сделали интеграцию с Intellij Idea, maven, gradle и сам Junit5. Сюда же входит лаунчер который позволяет запускать тесты из консоли. \n\nJupiter - прораммный код самого Junit5. Также этот модуль содержит новую концепцию extensions(расширений), которая заменила ранеры и правила из JUnit4. \n\nVintage - модуль для обратной совместимости. Позволяет запускать тесты написанных на JUnit3 и JUnit4. \n\n## Подключение зависимостей\n\nДля подключения JUnit5 добавляем в зависимости модуль Platform(junit-platform-launcher) и движок Jupiter(junit-jupiter-engine)\n\n### Maven\n\n```xml\n<!-- https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher -->\n<dependency>\n    <groupId>org.junit.platform</groupId>\n    <artifactId>junit-platform-launcher</artifactId>\n    <version>1.10.2</version>\n    <scope>test</scope>\n</dependency>\n\n<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine -->\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-engine</artifactId>\n    <version>5.10.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### Gradle\n\n```groovy\n// https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher\ntestImplementation 'org.junit.platform:junit-platform-launcher:1.10.2'\n\n// https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine\ntestImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'\n```\n\nПосле добавления к методу аннотации @Test в IDEA появляется кнопка play соответсвенно этот метод теперь можно запустить и его выполнит движок Junit. Если запустить класс то будут выполнены все тестовые методы из данного класса.\n\nМожно определять тестовые методы без модификатора (public, private, protected).\n\n```java\n@Test\nvoid someTest(){\n    assertTrue(true);\n}\n```\n\n## Аннотации JUnit 5\nJUnit 5 предлагает следующие аннотации для написания тестов.\n\n| Аннотации | Описание |\n| --- | --- |\n| @BeforeEach | Аннотированный метод будет запускаться перед каждым тестовым методом в тестовом классе. |\n| @AfterEach | Аннотированный метод будет запускаться после каждого тестового метода в тестовом классе. |\n| @BeforeAll | Аннотированный метод будет запущен перед всеми тестовыми методами в тестовом классе. Этот метод должен быть статическим. |\n| @AfterAll | Аннотированный метод будет запущен после всех тестовых методов в тестовом классе. Этот метод должен быть статическим. |\n| @Test | Он используется, чтобы пометить метод как тест junit. |\n| @DisplayName | Используется для предоставления любого настраиваемого отображаемого имени для тестового класса или тестового метода |\n| @Disable | Он используется для отключения или игнорирования тестового класса или тестового метода из набора тестов. |\n| @Nested | Используется для создания вложенных тестовых классов |\n| @Tag | Пометьте методы тестирования или классы тестов тегами для обнаружения и фильтрации тестов. |\n| @TestFactory | Отметить метод - это тестовая фабрика для динамических тестов. |\n\n\n### @BeforeAll\n\nАннотация @BoforeAll используются для указания о том, что аннотированный метод должен быть выполнен перед всеми @Test, @RepeatedTest, @ParameterizedTest и @TestFactory методами в текущем классе.\n\nПо умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeAll метод.\n\nАннотированный @BeforeAll метод ДОЛЖЕН быть статическим методом в тестовом классе.\n\n```java\n@BeforeAll\npublic static void init(){\n    System.out.println(\"BeforeAll init() method called\");\n}\n```\n\nИли мы можем применить эту аннотацию к default методам интерфейса, если тестовый интерфейс или тестовый класс аннотированы с помощью @TestInstance(Lifecycle.PER_CLASS).\n\n```java\n@TestInstance(Lifecycle.PER_CLASS)\ninterface TestLifecycleLogger {\n\n    @BeforeAll\n    default void beforeAllTests() {\n        //\n    }\n}\n```\n\nЕсли этого не сделать, JUnit выдаст ошибку времени выполнения типа JUnitException.\n\n```java\norg.junit.platform.commons.JUnitException: \n@BeforeAll method 'public void com.howtodoinjava.junit5.examples. \nJUnit5AnnotationsExample.init()' must be static.\nat org.junit.jupiter.engine.descriptor. \nLifecycleMethodUtils.assertStatic(LifecycleMethodUtils.java:66)\n```\n\n#### @BeforeAll в родительском и дочернем классах\n\n@BeforeAll методы наследуются от родительских классов (или интерфейсов), если они не скрыты или не переопределены. \n\nКроме того, @BeforeAll методы из родительских классов (или интерфейсов) будут выполняться перед @BeforeAll методами в дочерних классах.\n\n### @BeforeEach\n\nАннотация @BeforeEach используется для обозначения того, что аннотированный метод должен выполняться перед каждым методом @Test, @RepeatedTest, @ParameterizedTest, или @TestFactory в текущем классе.\n\nАннотация JUnit 5 @BeforeEach является одним из методов жизненного цикла и заменяет аннотацию @Before в JUnit 4.\n\nПо умолчанию тестовые методы будут выполняться в том же потоке, что и аннотированный @BeforeEach метод.\n\n```java\n@BeforeEach\npublic void initEach(){\n     //test setup code\n}\n\n@Test\nvoid succeedingTest() {\n    //test code and assertions\n}\n```\n\nАннотированный @BeforeEach метод НЕ ДОЛЖЕН быть статическим, иначе он вызовет ошибку времени выполнения.\n\n```java\n@BeforeEach\npublic static void initEach(){\n     //test setup code\n}\n\n//Error\n\n\norg.junit.platform.commons.JUnitException: @BeforeEach method 'public static void com.howtodoinjava.junit5.examples. JUnit5AnnotationsExample.initEach()' must not be static.\nat org.junit.jupiter.engine.descriptor. LifecycleMethodUtils.assertNonStatic(LifecycleMethodUtils.java:73)\n```\n\n#### @BeforeEach в родительском и дочернем классах\n\nМетод @BeforeEach наследуется от родительских классов (или интерфейсов) до тех пор, пока они не скрыты или не  переопределены. \n\nКроме того, каждый метод с аннотацией @Before из родительских классов (или интерфейсов) будет выполняться перед каждым методом с аннотацией @Before в дочерних классах.\n\n## @ParameterizedTest\n\nИспользуется, чтобы выполнить тест несколько раз, но с разными аргументами. \n\n1. Включите зависимость junit-jupiter-params, чтобы использовать параметризованные тесты.\n\nПоследнюю версию можно найти по этой ссылке https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params.\n\npom.xml\n\n```java\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-params</artifactId>\n    <version>${junit-version}</version>\n    <scope>test</scope>\n</dependency>\n```\n\n2. Нам не нужно использовать аннотацию @Test, вместо этого в таких тестах используется только аннотация @ParameterizedTest.\nМы должны объявить по крайней мере один источник аргументов, предоставляющий аргументы для каждого вызова, которые будут использоваться в тестовом методе.\n\nВ данном примере testPalindrome будет вызываться 2 раза для каждой строки, указанной в аннотации @ValueSource. Мы получаем доступ к аргументу, используя параметр word метода.\n\nИспользуйте аргумент name в аннотации @ParameterizedTest, чтобы настроить отображаемое сообщение.\n\n```java\npublic class ParameterizedTests \n{\n    public boolean isPalindrome(String s) {\n        return s == null ? false : StringUtils.reverse(s).equals(s);\n    }\n    \n    @ParameterizedTest(name = \"{index} - {0} is a palindrome\")\n    @ValueSource(strings = { \"12321\", \"pop\" })\n    void testPalindrome(String word) {\n        assertTrue(isPalindrome(word));\n    }\n}\n```\n\n### Источники тестовых аргументов\n\n#### Аннотация @ValueSource\nИспользуйте @ValueSource для простых буквальных значений, таких как примитивы и строки.\n\nОна определяет один массив значений и может использоваться только для предоставления одного аргумента для каждого параметризованного вызова теста.\n\nJava поддерживает автобоксирование, поэтому мы также можем использовать литералы в их классах-оболочках.\n\nМы не можем передавать null в качестве аргумента даже для типов String и Class.\n\n```java\n@ParameterizedTest\n@ValueSource(ints = { 1, 2, 3 })\nvoid testMethod(int argument) {\n    //test code\n}\n\n@ParameterizedTest\n@ValueSource(ints = { 1, 2, 3 })\nvoid testMethodWithAutoboxing(Integer argument) {\n    //test code\n}\n```\n\n#### Аннотация @NullSource\n\nОна предоставляет единственный null аргумент методу, аннотированному @ParameterizedTest.\n\n```java\n@ParameterizedTest\n@NullSource\nvoid testMethodNullSource(Integer argument) {\n    assertTrue(argument == null);\n}\n```\n\n#### Аннотация @EmptySource\nОна предоставляет метод, аннотированный @ParameterizedTest, с единственным пустым аргументом следующих типов:\n\njava.lang.String\n\njava.util.List\n\njava.util.Set\n\njava.util.Map\n\nпримитивные массивы (например, int [])\n\nмассивы объектов (например, String [])\n\n```java\n@ParameterizedTest\n@EmptySource\nvoid testMethodEmptySource(String argument) {\n    assertTrue(StringUtils.isEmpty(argument));\n}\n```\n\n#### Аннотация @NullAndEmptySource\nОна сочетает в себе функциональность @NullSource и @EmptySource. В данном примере тестовый метод будет вызываться два раза - сначала со значением null, а затем со значением empty.\n\n```java\n@ParameterizedTest\n@NullAndEmptySource\nvoid testMethodNullAndEmptySource(String argument) {\n    assertTrue(StringUtils.isEmpty(argument));\n}\n\n```\n\n##### Проверка null и non-null значений в одном тесте\n\nМы уже знаем, что аннотация @ValueSource не поддерживает значение null.\n\nТаким образом, используя @NullSource и @EmptySource в аннотации @ValueSource, мы можем тестировать null, non-null и пустые значения в одном и том же тесте.\n\n#### Аннотация @EnumSource\nЭто удобный способ использования Enum констант. Метод тестирования будет вызываться для каждой константы перечисления за раз.\n\nВ данном примере тестовый метод будет вызываться 4 раза, по одному разу для каждой Enum константы.\n\n```java\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n}\n\n@ParameterizedTest\n@EnumSource(Direction.class)\nvoid testWithEnumSource(Direction d) {\n    assertNotNull(d);\n}\n```\n\n#### Аннотация @MethodSource\nОна используется для ссылки на один или несколько фабричных методов тестового класса или внешних классов. Фабричный метод должен генерировать поток аргументов, где каждый аргумент в потоке будет использоваться методом, аннотированным @ParameterizedTest.\n\nФабричный метод должен быть static, если тестовый класс не аннотирован с помощью @TestInstance(Lifecycle.PER_CLASS).\n\nКроме того, фабричный метод не должен принимать аргументы.\n\n```java\n@ParameterizedTest\n@MethodSource(\"argsProviderFactory\")\nvoid testWithMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> argsProviderFactory() {\n    return Stream.of(\"alex\", \"brian\");\n}\n```\n\nЕсли мы явно не предоставим имя фабричного метода через @MethodSource, JUnit будет искать фабричный метод, имя которого по умолчанию совпадает с именем текущего метода с аннотацией @ParameterizedTest.\n\nПоэтому, в примере, если мы не предоставим имя метода argsProviderFactory в аннотации @MethodSource, Junit будет искать имя метода testWithMethodSource с возвращаемым типом `Stream<String>`.\n\n```java\n@ParameterizedTest\n@MethodSource\nvoid testWithMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> testWithMethodSource() {\n    return Stream.of(\"alex\", \"brian\");\n}\n```\n\nТакже поддерживаются потоки для примитивных типов (DoubleStream, IntStream и LongStream).\n\n```java\n@ParameterizedTest\n@MethodSource(\"argsProviderFactory\")\nvoid testWithMethodSource(int argument) {\n    assertNotEquals(9, argument);\n}\n\nstatic IntStream argsProviderFactory() {\n    return IntStream.range(0, 10);\n}\n```\n\n#### Аннотация @CsvSource\nЭта аннотация позволяет нам задавать списки аргументов как значения, разделенные запятыми. Каждый CSV токен представляет собой строку CSV и приводит к одному вызову параметризованного теста.\n\nЗадайте для свойства ignoreLeadingAndTrailingWhitespace значение true или false, указывающее на то, что Junit должен принимать или игнорировать пробелы в CSV токенах.\n\n```java\n@ParameterizedTest\n@CsvSource(value = {\n    \"alex, 30\",\n    \"brian, 35\",\n    \"charles, 40\"\n}, ignoreLeadingAndTrailingWhitespace = true)\nvoid testWithCsvSource(String name, int age) {\n    assertNotNull(name);\n    assertTrue(age > 0);\n}\n```\n\n#### Аннотация @CsvFileSource\nЭта аннотация очень похожа на @CsvSource за исключением того, что мы читаем токены CSV из файла вместо чтения токенов в исходном тексте. CSV файл можно прочитать по classpath или из локальной файловой системы.\n\nРазделителем по умолчанию является запятая (,), но мы можем использовать другой символ, установив атрибут разделителя.\n\nОбратите внимание, что любая строка, начинающаяся с символа #, будет интерпретироваться как комментарий и игнорироваться.\n\n```java\n@ParameterizedTest\n@CsvFileSource(resources = \"employeeData.csv\", numLinesToSkip = 0)\nvoid testWithCsvFileSource(String name, int age) {\n    assertNotNull(name);\n    assertTrue(age > 0);\n}\n```\n\n#### Аннотация @ArgumentsSource\nАннотацию @ArgumentsSource можно использовать для указания настраиваемого многоразового поставщика аргументов ArgumentsProvider.\n\n```java\n@ParameterizedTest(name = \"{index} - {0} is older than 40\")\n@ArgumentsSource(EmployeesArgumentsProvider.class)\nvoid isEmployeeAgeGreaterThan40(Employee e) {\n    assertTrue(Period.between(e.getDob(), LocalDate.now()).get(ChronoUnit.YEARS) > 40);\n}\n\nclass EmployeesArgumentsProvider implements ArgumentsProvider {\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n        return Stream.of(\n          Arguments.of(new Employee(1, \"Alex\", LocalDate.of(1980, 2, 3))),\n          Arguments.of(new Employee(2, \"Brian\", LocalDate.of(1979, 2, 3))),\n          Arguments.of(new Employee(3, \"Charles\", LocalDate.of(1978, 2, 3)))\n        );\n    }\n}\n```\n\n### Параметризованные тесты с несколькими аргументами\n\nЧтобы написать тесты, которые могут использовать несколько аргументов, мы можем использовать следующие аннотации:\n\n#### Аннотация @CsvSource\nКак показано в предыдущем разделе 3.7, с помощью аннотации @CsvSource мы можем предоставить множество литералов и простых типов аргументов.\n\nНам нужно предоставить все аргументы в одном токене CSV, а затем определить соответствующие аргументы метода.\n\n```java\n@ParameterizedTest\n@CsvSource({\n    \"alex, 30, HR, Active\",\n    \"brian, 35, Technology, Active\",\n    \"charles, 40, Finance, Purged\"\n})\nvoid testWithCsvSource(String name, int age, String department, String status) {\n    //test code\n}\n```\n\n#### Интерфейс ArgumentsProvider\nЧтобы предоставить несколько тестовых аргументов сложных или настраиваемых типов, мы должны использовать аннотацию @ArgumentsSource с аннотацией ArgumentsProvider.\n\nВ примере мы передаем три аргумента метода тестирования testArgumentsSource, типов Employee, LocalDateи enum константы типа Direction.\n\n```java\n@ParameterizedTest\n@ArgumentsSource(EmployeesArgumentsProvider.class)\nvoid testArgumentsSource(Employee e, LocalDate date, Direction d) {\n    assertTrue(Period.between(e.getDob(), LocalDate.now()).get(ChronoUnit.YEARS) > 40);\n    assertNotNull(date);\n    assertNotNull(d);\n}\n\nclass EmployeesArgumentsProvider implements ArgumentsProvider {\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n        return Stream.of(\n          Arguments.of(new Employee(1, \"Alex\", \n                  LocalDate.of(1980, 2, 3)), LocalDate.now(), Direction.EAST),\n          Arguments.of(new Employee(2, \"Brian\", \n                  LocalDate.of(1979, 2, 3)), LocalDate.now(), Direction.NORTH),\n          Arguments.of(new Employee(3, \"Charles\", \n                  LocalDate.of(1978, 2, 3)), LocalDate.now(), Direction.SOUTH)\n        );\n    }\n```\n\n## Build tool support\n\n```groovy\ntest {\n    useJUnitPlatform {\n        includeTags 'fast', 'smoke'\n        excludeTags 'slow', 'ci'\n\n        include 'org/foo/**'\n        exclude 'org/boo/**'\n    }\n}\n```\n\nhttps://www.youtube.com/watch?v=RAOAcq97KZM\n\nhttps://www.youtube.com/watch?v=w1ey2zjf3-s\n\nhttps://www.youtube.com/watch?v=DAszLeWMsqU\n\nhttps://www.youtube.com/watch?v=751gMXH-lEE\n\nhttps://www.youtube.com/watch?v=r-8EGXMFJaw\n\nhttps://www.youtube.com/watch?v=ZIkIUCyJBGU\n\nhttps://www.youtube.com/watch?v=3pOjh6O7-cg\n\nhttps://www.youtube.com/watch?v=W1INR0I3FCo&list=PLnh8EajVFTl5AqvBosxUefReW4nC35P0x","date":"2022-06-18T00:00:00.000Z","icon":"fas fa-robot","image":"null","path":"/j-unit-5/","order":null,"category":{"title":"automation","path":"/category/automation/"},"tags":[{"title":"Автоматизация тестирования","path":"/tag/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/"}],"headings":[{"value":"Подключение зависимостей","anchor":"#подключение-зависимостей"},{"value":"Аннотации JUnit 5","anchor":"#аннотации-junit-5"},{"value":"@ParameterizedTest","anchor":"#parameterizedtest"},{"value":"Build tool support","anchor":"#build-tool-support"}]}}]}},"relatedCategory":{"id":"e9c3ea3dc1c81f4432b35adc5e174d7f","title":"automation","path":"/category/automation/","related":[{"id":"manual","path":"/category/manual/","title":"manual"},{"id":"api","path":"/category/api/","title":"api"}]}},"context":{}}