{"hash":"7ce6058f470c3851afaa44882541a7f3d1089ffc","data":{"category":{"title":"java","path":"/category/java/","belongsTo":{"totalCount":6,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"8e8b9ac6c819939f0b5118e99f672242","title":"Конспект книги А. Бхаргава \"Грокаем алгоритмы\"","content":"\n## Что такое алгоритм?\n\nНабор инструкций для выполнения некоторой задачи.\n\n## $О$-большое\n\nСпециальная нотация которая описывает скорость выполнения алгоритма, а именно показывает с какой скоростью растет время выполнения алгоритма при увеличении входных данных.  \n\n$О$-большое не сообщает скорость в секундах а позволяет сравнить количество операций.  \n$О$-большое определяет время выполнения в худшем случае.\n\n#### Разновидности:\n- $O(1)$ - постоянное время\n- $O(log(n))$ - логарифмическое время. Пример: _бинарный поиск_\n- $O(n)$ - линейное время. Пример: _простой поиск_\n- $O(n * log(n))$ - Пример: _эффективные алгоритмы_\n- $O(n^2)$ - Пример: _медленные алгоритмы сортировки (сортировка выбором)_\n- $O(n!)$ - Пример: _очень медленные алгоритмы (задача о коммивояжере)_\n\n## Линейный поиск\n\nПроходим по массиву и при нахождении первого элемента с искомым значением возвращаем его индекс. \n\n\n```java\nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = lineSearch(arr, 12);\nSystem.out.println(index);\nSystem.out.println(arr[index]);\n```\n\n```java\nstatic int lineSearch(int[] arr, int key) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == key) {\n            return i;\n        }\n    }\n    \n    // return -1\n    throw new RuntimeException(\"Key '\" + key + \"' is not found!\");\n}\n```\n\n**Сложность алгоритма** - $O(n)$.  \nСкорость каждой итерации $O(1)$.  \nВ худшем случай $n$ итераций.  \n\n## Бинарный поиск\n\n- работает когда список отсортирован\n\nАналогично поиску слова в словаре.\n\n#### Реализация через цикл:\n\n```java\nstatic int binarySearch(int[] arr, int key) {\n    int low = 0;\n    int high = arr.length - 1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (key < arr[mid]) {\n            high = mid - 1;\n        } else if (key > arr[mid]) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n#### Реализация через рекурсию:\n\n```java \nint[] arr = {1, 3, 12, 4, 6, 10, 12, 12, 15, 20, 25};\nint index = binarySearch(arr, 12, 0, arr.length - 1);\n```\n\n```java\nstatic int binarySearch(int[] arr, int key, int low, int high) {\n    int mid = low + (high - low) / 2;\n    if (high < low) {\n        return -1;\n    }\n    if (arr[mid] == key) {\n        return mid;\n    } else if (key < arr[mid]) {\n        return binarySearch(arr, key, low, mid - 1);\n\n    } else {\n        return binarySearch(arr, key, mid + 1, high);\n    }\n}\n```\n\n**Сложность алгоритма** - $O({log_{2}(n)})$.  \n\n${log_{2}(n)} = k$   \n$k$ - в какую степень надо возвести 2, чтобы получить n   \n\n$n={2^k}$\n\n- если число n - не степень двойки, то выбирается такое наименьшее k, что $2^k > n$.\n\n- $O({log_{2}(n)})$ лучше чем O(n).\n\n## Сортировка выбором\n\n```java\npublic static void main(String args[]) throws Exception {\n    int[] arr = {64, 42, 73, 41, 32, 53, 16, 24, 57, 42, 74, 55, 36};\n    System.out.println(Arrays.toString(selectionSort(arr)));\n}\n```\n\n```java\nstatic int[] selectionSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n        int ind = smallest(arr, i);\n        int temp = arr[i];\n        arr[i] = arr[ind];\n        arr[ind] = temp;\n    }\n    return arr;\n}\n\nstatic int smallest(int[] arr, int start) {\n    int index = start;\n    int smallest = arr[start];\n    for (int i = start; i < arr.length; i++) {\n        if (arr[i] < smallest) {\n            smallest = arr[i];\n            index = i;\n        }\n    }\n    return index;\n}\n```\n\n**Сложность алгоритма** - $O(n^2)$.  \n\n\n## Рекурсия\n\n- Каждая рекурсивная функция состоит из двух частей:\n    - рекурсивного случая - функция вызывает сама себя\n    - базового случая - функция себя не вызывает, чтобы предотвратить зацикливание\n\n```java\n static int factorial(int n) {\n    if (n == 1) {\n        return n;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n```\n\n## Стратегия \"Разделяй и властвуй\"\n\nДанная стратегия состоит из двух шагов:\n\n1. Определяется базовый случай - простейший случай из всех возможных.\n2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.\n\nСтратегия \"Разделяй и властвуй\" - это не алгоритм, это подход к решению задачи.\n\n#### Пример:\nИмеется массив `{2, 4, 6}`. Нужно просуммировать все числа и вернуть сумму. \n\n\n```java\nstatic int sum(int[] arr) {\n    if (arr.length == 0) {\n        return 0;\n    } else if (arr.length == 1) {\n        return arr[0];\n    } else {\n        int[] newArr = Arrays.copyOfRange(arr, 1, arr.length);\n        return arr[0] + sum(newArr);\n    }\n}\n```\n\n> Если в рекурсивной функции используется массив, то базовым случаем чаще всего оказывается либо пустой массив, либо массив из одного элемента.\n\n\n## Быстрая сортировка\n\n- Работает быстрее сортировки выбором.\n- Основана на стратегии \"Разделяй и властвуй\"\n\n\nБазовый случай: массивы с одним элементом или пустой массив  \n\n#### Шаги рекурсивного случая:  \n1. Выбрать опорный элемент.\n2. Разделить массив на два подмассива:\n    - элементы, **меньшие** опрного \n    - элементы, **большие** опорного\n\n\n```java\npublic static void quickSort(int[] arr, int from, int to) {\n    if (from < to) {\n\n        int divideIndex = partition(arr, from, to);\n\n        quickSort(arr, from, divideIndex - 1);\n\n        quickSort(arr, divideIndex, to);\n    }\n}\n\nprivate static int partition(int[] arr, int from, int to) {\n    int rightIndex = to;\n    int leftIndex = from;\n\n    int pivot = arr[from + (to - from) / 2];\n    while (leftIndex <= rightIndex) {\n\n        while (arr[leftIndex] < pivot) {\n            leftIndex++;\n        }\n\n        while (arr[rightIndex] > pivot) {\n            rightIndex--;\n        }\n\n        if (leftIndex <= rightIndex) {\n            swap(arr, rightIndex, leftIndex);\n            leftIndex++;\n            rightIndex--;\n        }\n    }\n    return leftIndex;\n}\n\nprivate static void swap(int[] array, int index1, int index2) {\n    int tmp  = array[index1];\n    array[index1] = array[index2];\n    array[index2] = tmp;\n}\n```\n\n## Хеш-таблицы\n\n**Хеш-функция** представляет собой функцию которая получает строку[^Под \"строкой\" понимаются любые данные - последовательность байтов.] и возвращает число.\nХеш функция должна соответствовать требованиям:\n- Она должна быть последовательной. Всегда возвращать одинаковое число на одну и ту же строку.\n- Разным словам должны соотвествовать разные числа.\n\nМассив который хранит элементы при помощи хеш-функций называется **хеш-таблицей**. Их также называют \"ассоциативным массивом\", \"словарем\", \"отображением\", \"хеш картой\" или просто \"хеш\".\nХеш таблицы упрощают моделировние отношений между объектами.\n\n```java\nHashMap<String, Double> book = new HashMap();\nbook.put(\"apple\", 0.67);\nbook.put(\"milk\", 1.49);\nbook.put(\"avocado\", 1.49);\nSystem.out.println(book.get(\"avocado\"));\n```\n\nХеши подходят для решения следующих задач:\n- моделирование отношений между объектами;\n- устранение дубликатов;\n- кеширование/запоминание данных вместо выполнения работы на сервере.\n\n## Коллизии\n\nСитуация когда несколько элементов по хешу попадают в одну и туже ячейку[^Двум ключам назначается один элемент массива].\n\n#### Одна из стратегий обработки коллизий:\n> Если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.\nНо если все элементы попадают в одну ячейку и содержатся в одном связанном списке то работа с данными замедляется.\n\nОтсюда следует:\n- _Выбор хеш-функции действительно важен._ В идеале хеш функция должна распределять ключи равномерно по всему хешу.\n- Если связанные списки становятся слишком длинными, то работа с хеш-таблицей сильно замедлится. \nНо они не станут длинными _при использовании хорошей хеш-функции_!\n\nДля предотвращения коллизий необходимы:\n- низкий коэфициент заполнения;\n- хорошая хеш-функция;\n\n## Поиск в ширину\n\nАлгоритм для решения задачи поиска кратчайшего пути называется **_поиском в ширину_**.\n\n## Граф\n\nГраф моделирует набор связей. Каждый граф строится из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называют _соседями_.\n\n![Иллюстрация графа](/images/graph_illustration.png)\n\nАлгоритм поиска в ширину может ответить на 2 вопроса:\n\n1. существует ли путь от узла А к узлу В?\n2. как выглядит кратчайший путь от узла А к узлу В?\n\n> Связи первого уровня добавляются в список поиска раньше связей второго уровня и т.д.  \n\n> Проверять связи необходимо в порядке их добавления. Для операций такого рода есть специальная структура данных, называемая **_очередью_**.\n\n## Очередь\n\nДля этой структуры данных доступно только две операции:\n- постановка в очередь;\n- извлечение из очереди;\n\nЭлементы добавленные в очередь первыми, первыми же будут из нее извлечены.\n\n> <u>Очередь</u> относится к категории структур данных FIFO: _First In, First Out_ (\"первым вошел, первым вышел\").\n\n> А <u>стек</u> принадлежит к категории LIFO: _Last In, First Out_ (\"последним вошел, первым вышел\").\n\n## Реализация графа\n\nГраф можно реализовать с помощью хеш-таблицы. В хеш таблице ключ связан со значением, а в нашем случае узел должен быть связан с соседями.\n\n```java\nHashMap<String, String[]> book = new HashMap();\nString[] siblings = {\"alice\", \"bob\", \"claire\"};\nbook.put(\"you\", siblings);\n```\n\nРазличают _направленный_ и _ненаправленный_ граф.  \n**_Направленный граф (ориентированный, орграф)_** - это граф в котором отношения действуют только в одну сторону.  \n**_Ненаправленный граф (неориентированный, неорграф)_** - направления отношений нет и каждый из узлов является соседом друг к другу.\n\n![Виды графов](/images/graph_types.png)\n\nАлгоритм графа:\n1. Создать очередь\n2. Извлечь из очереди первый элемент\n3. Выполнить поисковую проверку \n4. Если элемент соотвествует поиску закончить проверку, если нет то добавить всех соседей данного элемента в очередь\n5. Повторить шаги пока не закончится очередь либо элемент удолетворяющий поиску не будет найден.\n\n> Однако, если элемент встречается в двух и более списках, то он будет проверяться дважды, либо может войти в цикл.  \nЧтобы избежать такого поведения необходимо добавить список, в который помещаются уже проверенные элементы.\n\n\n```java\npublic static void main(String[] args) {\n    HashMap<String, String[]> all = new HashMap();\n    String[] siblings = {\"alice\", \"bob\", \"claire\"};\n    String[] claireSiblings = {\"jack\", \"steve\", \"bob\"};\n    String[] bobSiblings = {\"claire\", \"damon\"};\n    all.put(\"you\", siblings);\n    all.put(\"claire\", claireSiblings);\n    all.put(\"bob\", bobSiblings);\n\n    ArrayDeque<String> searchDeque = new ArrayDeque();\n    searchDeque.addAll(Arrays.asList(all.get(\"you\")));\n    if (!searchMangoSeller(all, searchDeque)) {\n        throw new RuntimeException(\"Mango seller is not found!\");\n    }\n}\n\nstatic boolean searchMangoSeller(HashMap<String, String[]> all,\n                                    ArrayDeque<String> searchDeque) {\n    ArrayList<String> searched = new ArrayList();\n    while (!searchDeque.isEmpty()) {\n        String person = searchDeque.pop();\n        if (!searched.contains(person)) {\n            if (isSeller(person)) {\n                System.out.println(person + \" is a mango seller!\");\n                return true;\n            } else {\n                String[] siblings = all.get(person);\n                if (siblings != null) {\n                    searchDeque.addAll(Arrays.asList(siblings));\n                }\n                searched.add(person);\n            }\n        }\n    }\n    return false;\n}\n\nstatic boolean isSeller(String person) {\n    return person.charAt(person.length() - 1) == 'n';\n}\n```\n\n#### Время выполнения: \nЕсли поиск выполнен по всей сети то значит вы прошли по каждому ребру $O(количество\\:ребер)$.  \nТакже в программе должна храниться очередь поиска. Добавление каждого человека потребует $O(количество\\:людей)$.\nВ итоге поиск в ширину займет $O(количество\\:людей + количество\\:ребер)$, что обычно записывается как $O(V+E)$, _V - кол-во вершин, E - кол-во ребер_.\n\n## Алгоритм Дейкстры\n\nАлгоритм поиска в ширину находит путь, состоящий из меньшего количества сегментов. Но если нужно найти наименьший путь с учетом определеных характеристик, то эту задачу решает **Алгоритм Дейкстры**.\n\nАлгоритм Дейкстры состоит из следующих шагов:\n\n1. Каждому ребру нужно назначить свой вес, в зависимости от иследуемой характеристики.\n2. Найти узел с наименьшей стоимостью.\n3. Проверить существует ли более дешевый путь к соседям этого узла и если существует, обновить их стоимости.\n4. Повторять, пока это не будет сделано для всех узлов графа.\n5. Вычислить итоговый путь.\n\nГраф с весами называется **_взвешенным графом_**. Граф без весов называется **_невзвешенным графом_**.\n\nДля вычисления кратчайшего пути в <u>невзвешенном графе</u> используется _поиск в ширину_. Кратчайшие пути во <u>взвешенном графе</u> вычисляются по _алгоритму Дейкстры_.\n\nВ графах также могут присутствовать **_циклы_**. Это означает, что вы можете начать с некоторого узла перемещаться по графу, а потом снова оказаться в том же узле. \n\n> В ненаправленном графе, каждый из двух узлов ведет к другому узлу, а это _цикл_!  \n> Поэтому, алгоритм Дейкстры работает только с _направленными ациклическими графами, DAG (Directed Acyclic Graph)_.\n\n### Работа с отрицательным весом\n\nВ том случае если проходя по определенному ребру мы не тратим вес а наоборот получаем дополнительный бонус к нужной характеристике, то такому ребру назначется _отрицательный вес_. \n\nОднако Алгоритм Дейкстры не может использоваться при наличии ребер имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый _алгоритмом Беллмана-Форда_.\n","date":"2022-05-23T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/konspekt-knigi-a-bhargava-grokaem-algoritmy/","order":null,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"}],"headings":[{"value":"Что такое алгоритм?","anchor":"#что-такое-алгоритм"},{"value":"ООО-большое","anchor":"#о-большое"},{"value":"Линейный поиск","anchor":"#линейный-поиск"},{"value":"Бинарный поиск","anchor":"#бинарный-поиск"},{"value":"Сортировка выбором","anchor":"#сортировка-выбором"},{"value":"Рекурсия","anchor":"#рекурсия"},{"value":"Стратегия \"Разделяй и властвуй\"","anchor":"#стратегия-разделяй-и-властвуй"},{"value":"Быстрая сортировка","anchor":"#быстрая-сортировка"},{"value":"Хеш-таблицы","anchor":"#хеш-таблицы"},{"value":"Коллизии","anchor":"#коллизии"},{"value":"Поиск в ширину","anchor":"#поиск-в-ширину"},{"value":"Граф","anchor":"#граф"},{"value":"Очередь","anchor":"#очередь"},{"value":"Реализация графа","anchor":"#реализация-графа"},{"value":"Алгоритм Дейкстры","anchor":"#алгоритм-дейкстры"}]}},{"node":{"id":"5747b944f0af5ac4fbdcc63d1a76ed8f","title":"Алгоритмы (курс Тинькофф)","content":"\n## Асимптотический анализ\nИспользуется для оценки алгоритмов. Оценивается не то сколько алгоритм работает на конкретных данных, а то сколько алгоритм работает в зависимости от размера входа (объема данных). \n\nT(n) - сколько времени работает алгоритм на входе какого-то размера n.\n\n### В чем измерить сколько работает программа?\nНужно посчитать количество действий которые выполняет программа, колисество read/write операций. \n\n### RAM(Random Access Memory) - модель \nИмеет следующие правила:\n- К любой ячейке памяти можно за O(1) обратиться(read) и за O(1) записать что-то(write).\n\nБазовыми операциями, которыми можно вычислять скорость - это опреации read, write.\n\n$O(n)$ - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **ниже**, чем график функции, которая ее определяет - оценка сверху. (условно худшая скорость)\n\n$\\Omega(n)$ - оценка снизу - обозначает такую скорость которая при увеличении размера входных данных начиная с какого то момента будет **выше**, чем график функции, которая ее определяет - оценка снизу.\n\n$\\Theta(n)$ - если одновременно выполняются условия  $O(n)$ и $\\Omega(n)$\n\n\n\n\n\nhttps://www.youtube.com/watch?v=1cXq7F3ijxM&list=PLjCCarnDJNssC82zhyeg8BxfhPG3b8iZ2\n","date":"2022-07-24T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/algoritmy-kurs-tinkoff/","order":null,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"}],"headings":[{"value":"Асимптотический анализ","anchor":"#асимптотический-анализ"}]}},{"node":{"id":"8a6b33e55a7ca748d1b9e12020f95b24","title":"Алгоритмы (курс Яндекс)","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","date":"2022-07-24T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/algoritmy-kurs-yandeks/","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"c66f02339f21ce00fa32d069c52d071a","title":"Java Core","content":"\nJava Core\n\n## Что такое программа\n\nЛюбая программа это набор инструкций, которые выполняет процессор или его микропрограмма. Эти инструкции называются машинным кодом. \nОни показывают процессору откуда взять данные, что с ними сделать и куда поожить результат. Hello world на машинном языке выглядел бы как набор цифр и букв, набор инструкций зависит от реализации конкретного процессора и унифицируется на уровне операционных систем(созданием виртуального процесора с универсальным набором инструкций). \n\n\n## Появление и развитие языка программирования\n\n1. Чтобы было проще запоминать машинные коды для каждого кода придумали мнемоники. Так появился язык Asembler и код стал немного понятнее. \n\n2. Затем появились языки высокого уровня которые оперируют простыми словами, а специальные программы - компеляторы и интерпретаторы приводили их в машинный код. \n\n3. Следующим этапом развития стало компиляция языка программирования не напрямую в машинный код, а сначала в промежуточный байт-код, по этому пути пошли разработчики java и dotNet'a. \n\n- Разработчики Java создали концепцию JVM - java virtual machine - виртуальная машина, которая может исполнять bytecode скомпелированный из java кода. Создав реализацию такой виртуальной машины для разных платформ, мы получили возможность писать на джаве для любой платформы. \n\n- Разработчики из дотнета пошли другим путем и создали clr - common language runtime если разработчики джава были сосредоточены только на языке джава, то clr был создан для возможности писать на разных языках в пределах одного решения но при этом все ставки делались только на windows. \n\nВ настоящее время обе команды пересмотрели свою концепцию: в jvm появилась поддержка в том числе и других языков, а для дот нета почвилась платформа Mono которая позволяет запускать C# практически на любом устройстве. \n\n## Что такое JVM?\n\nJVM состоит из:\n- Class Loader, загружающего файлы с байт кодом в память;\n- виртуальная память, куда все это загружается;\n- движок, который исполняет и оптимизирует код;\n- дополнительные интерфейсы и библиотеки для работы с нативным кодом (кодом написанном на c/c++/assembler'e).\n\n### Class Loader\n\nРазличают 3 вида:\n- bootstrap - загружает все стандартные классы Java, т.е. все которые содержатся в пакетах java.lang, java.net и т.д.;\n- extension - загружает классы из дополнительных библиотек, которые стаятся вместе с jdk и jre;\n- application - загружает классы из  classpath папок, которые может настроить сам разработчик.\n\n### JVM Memory - виртуальная память\n\n- Method Area, metaspace - здесь хранятся все статичные структуры и сам код, эта область является частью Heap(кучи)\n- Heap - большая область памяти в которой хранятся все создаваемые объекты, она выделяется сразу при запуске и делится между всеми основными потоками. Здесь обычно происходят основные утечки память и здесь же работает garbage collector(уборщик мусора). GC - собирает информацию о данных которые больше не используются и пытается их удалить.\n- Stack - более емкая область памяти, которая создается при создании потока, у каждого потока свой стек. Стек устроен по принципу первый вошел последний вышел(FILO). Для каждого вызываемого метода в стеке создается frame, набор именнованных параметров которые хранит переменные созданные в этом методе, промежуточные результаты и итоговый результат который возвращается через return. После выполнения метода его фрейм извлекается из стека и происходит переход к фрейму метода который был положен в стек перед ним, те тот метод который вызывал данный метод. \n- PC Registers - содержат указатели на внутренние инструкции самой java.\n- Native Method Stack - стек для нативных методов.\n\n### Движок\n\n- JIT - just-in-time компилятор - оптимизирует уже скомпелированный байт код \n- Интерпретатор который исполняет скомпелированный байт код\n\n\n### JRE\n\nJVM + java библиотеки\n\n### JDK\n\nJRE + инструменты разработчика + компилятор\n\n","date":"2024-03-29T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/java-core/","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[{"value":"Что такое программа","anchor":"#что-такое-программа"},{"value":"Появление и развитие языка программирования","anchor":"#появление-и-развитие-языка-программирования"},{"value":"Что такое JVM?","anchor":"#что-такое-jvm"}]}},{"node":{"id":"c3df7d90d4bbd4a557fa97ed5ab680d2","title":"Создаем основу проекта","content":"\n- Какие тесты нужно автоматизировать в первую очередь?\nБерем тесты, которые чаще всего проверяются, чаще всего стреляют и которые больше всего затратны с точки зрения ручного тестирования.\n\n- эффективность автоматизации\nhttps://www.youtube.com/watch?v=GpvY3NF9mRc\n\nGradle\n\n1 создаем градл проект через идею.\n2 редактируем файл build.gradle \n\nПосле создания проекта дефолтный скрипт выглядит так:\n\n```groovy\nplugins {\n    id 'java' //плагин для сблорки java приложения\n}\n\n// группа и версия проекта\ngroup 'io.vvrozhkova'\nversion '1.0-SNAPSHOT'\n\n\n//репозиторий для скачивания зависимостей\nrepositories {\n    mavenCentral()\n}\n\n\n//список зависимостей\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'\n}\n\n\n//настройка запуска тестов через JUnit\ntest {\n    useJUnitPlatform()\n}\n```\n\n\n","date":"2024-03-29T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/sozdaem-osnovu-proekta/","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[]}},{"node":{"id":"b98339b91504be9db7d95591e1741b37","title":"План содания проекта для UI автотестов","content":"\n1. [Создаем основу проекта](/sozdaem-osnovu-proekta/)\n","date":"2024-03-29T00:00:00.000Z","icon":"fas fa-code","image":"null","path":"/plan-sodaniya-proekta-dlya-ui-avtotestov/","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"java","path":"/tag/java/"},{"title":"autotests","path":"/tag/autotests/"},{"title":"автотесты","path":"/tag/%D0%B0%D0%B2%D1%82%D0%BE%D1%82%D0%B5%D1%81%D1%82%D1%8B/"},{"title":"план проекта","path":"/tag/%D0%BF%D0%BB%D0%B0%D0%BD%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0/"}],"headings":[]}}]}},"relatedCategory":{"id":"c74157655cb78c682caa869aa9e93474","title":"java","path":"/category/java/","related":[{"id":"mobile","path":"/category/mobile/","title":"mobile"},{"id":"api","path":"/category/api/","title":"api"},{"id":"ui","path":"/category/ui/","title":"ui"}]}},"context":{}}