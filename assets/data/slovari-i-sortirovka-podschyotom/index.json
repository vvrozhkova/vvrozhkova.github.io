{"hash":"03f7058ba488a165454bf4fd228c446ef5a28a6f","data":{"post":{"title":"Словари и сортировка подсчётом","content":"\n## Сортировка подсчетом\n\nПусть необходимо отсортировать массив из N целых чисел, каждое от 0 до K. Все эти числа довольно маленькие. Например, школьные оценки от 1 до 5.\n\nОбычная сортировка(например, из классических быстрая, слиянием, пирамидальная) займет $O(N logN)$.\nНо мы не будем пользоваться классической сортировкой, если значения довольно не большие.\n\nБудем считать количество вхождений каждого числа, а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.\n\nИнтервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.\n\nРешение\n\nСоздаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. \nКогда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. \n\nЗатем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.\nДля языков, у которых нумерация массива начинается с нуля, рекомендуется не экономить эту ячейку памяти, а включить нулевую ячейку, чтобы не напутать с индексами.\n\nМы потратим $O(K)$ времени и $O(K)$ памяти, где К количество возможных значений.\n\n$O(K)$ памяти - тк нам нужно завести массив из К элементов.\n\n$O(K)$ времени - тк на создание массива тоже тратится время, пропорционально его длине. Если не на выделение памяти, то на заполнение нулями точно потратится.\n\n$O(N)$ времени - мы за один проход заполним этот массив, тк каждая операция это прибавление единицы и она занимает $O(1)$ времени. И поскольку чисел N, в сумме это займет $O(N)$.\n\nВ итоге на построение массива уходит $O(N+K)$ времени и $O(K)$ дополнительной памяти.\nТоже самое с выводом: мы пройдемся по всем возможным значениям - это цикл до К и в сумме мы совершим N действий на вывод. То есть на вывод мы тоже потратим $O(N+K)$ времени.\n\nЕсли бы мы не делали нулевой элемент в массиве этобы уменьшило количество занимаемой памяти но затруднило и усложнило вычисление, тк пришлось бы постоянно отнимать дополнительное число.\n\nНо если нужно отсортировать числа далекие от нуля, то этот интервал лучше перенести.\n\n```java\npublic static void countSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt(); // сложность O(N)\n    int min = Arrays.stream(arr).min().getAsInt(); // сложность O(N)\n\n    int k = max - min + 1;\n    int[] array = new int[k];\n    Arrays.fill(array, 0);\n\n    for (int i = 0; i < arr.length; i++) {\n        array[arr[i] - min] += 1;\n    }\n\n    int nowPos = 0;\n    for (int i = 0; i < array.length; i++) {\n        for (int j = 0; j < array[i]; j++) {\n            arr[nowPos] = i + min;\n            nowPos += 1;\n        }\n    }\n}\n```\n\n### Задача 1\n\nДано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.\n\nПосчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10. \nРазложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. \n\nЦиклом while проходим по каждой цифре пока после деления не останется 0. Такой способ возможен только если число без ведущих нулей. Это как раз наш случай.\nРаскладываем цифры в массив от 0 до 9, в соответсвии со значением индекса. Пришла цифра 9 увеличиваем на один значение в ячейке с индексом 9 и тд.\nДелаем это для обоих чисел и сравним эти массивы по элементно. Достаточно найти всего одно несовпадение.\n\nСортировка подсчетом уместна, когда разница между максимальным и минимальным значением небольшая и числа с одним и тем же значением встречаются достаточно часто, тогда N > K и сложность сортировки фактически стала $O(N)$.\nЕсли это не так, то точная оценка $O(N+K)$, но в случаях когда K большое, а N маленькое, сортировка подсчетом не лучший выбор.\nМожно вычислить конкретное значение K и сравнить с $N logN$.\n\n```java\npublic static boolean isDigitPerMutation(int x, int y) {\n    int[] digitsX = countDigits(x);\n    int[] digitsY = countDigits(y);\n    for (int i = 0; i < 10; i++) {\n        if (digitsX[i] != digitsY[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\npublic static int[] countDigits(int num) {\n    int[] digitCount = new int[10];\n    Arrays.fill(digitCount, 0);\n\n    while (num > 0) {\n        int lastDigit = num % 10;\n        digitCount[lastDigit] += 1;\n        num /= 10;\n    }\n    return digitCount;\n}\n```\n\n\n## Словари\n\nБолее универсальный алгоритм, но в некоторых случаях может работать хуже чем сортировка подсчетом.\n\nСловарь - он как множество, но к каждому ключу приписано значение.\nВ словаре есть пара ключ - значение (key, value). И все что происходит в множестве (подсчет хеша, раскладываение и тд), оно проходит только по ключу.\n\nКлюч должен быть неизменяемым объектом, чтобы у него эффективно хеш вычислялся, а значение может быть каким угодно, от него хеш ни в какой момент не считается, оно просто болтается рядом с ключом.\n \nИскать по значению в словаре нельзя.\n\nСложность поиска в словарях $O(1)$. НО константа большая. Тк может происходить расширение словаря, может считаться хеш функция и тд. Работает это медленее, чем доступ по индексу, как это происходит в сортировке подсчетом.\n\nКонстанта в сложности словарей заметно больше, чем у массивов, поэтому где можно - лучше использовать сортировку подсчетом (если начения лежат довольно плотно (разность между максимальным и минимальным не велика) и значения встречаются по несколько раз).\n\nСортировку подсчетом использовать неразумно, если данные разреженные(редкие вхождения, например числа до миллиарда).\n\n### Задача 1\n\nНа шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) \nОпределите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.\n\n$1<= N <= 10^9, 0<=M<=2*10^5$.\n\nРешение\n\nДля каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.\n\nЧтобы оценить время работы программы мы можем посмотреть на входные данные, значение N может достигать $10^9$ или $1 000 000 000$ - 1 миллиард операций. Даже на языке C, при наличии не примитивных операций, это может быть достаточно долго, для других языков тем более.\nПоэтому нужно ориентироваться на значение M, оно может достигать $2*10^5$ или $200 000$ - 200 тысяч оперций.\n\n> Ладья бьет другую ладью, если они стоят на одной вертикали или горизонтали.\n\n> Ферзь бьет другого ферзя, если они стоят на одной вертикали или горизонтали или на одной диагонмали(диагональ слева направо /, диагональ справа налево \\\\).\n\nОбратим внимание, что если на одной линии стоит 3 ладьи то они образуют 2 пары которые бьют друг друга.\nЕсли на одной линии 4 ладьи, то они образуют 3 пары и т.д.\nПолучается что пар ладей на 1 меньше, чем количество ладей на одной линии.\n\nОтталкиваясь от этого нужно завести 2 словаря для вертикали и горизонтали в которой будем подсчитывать количество ладей на соответсвующей линии.\n\n```java\npublic static int countBeatingRooks(int[][] rookcoords) {\n    Map rooksInRow = new HashMap<Integer, Integer>();\n    Map rooksInCol = new HashMap<Integer, Integer>();\n    for (int i = 0; i < rookcoords.length; i++) {\n        addRook(rooksInRow, rookcoords[i][0]);\n        addRook(rooksInCol, rookcoords[i][1]);\n    }\n    return countPairs(rooksInCol) + countPairs(rooksInRow);\n}\n\npublic static void addRook(Map<Integer, Integer> rowOrCol, int key) {\n    if (!rowOrCol.containsKey(key)) {\n        rowOrCol.put(key, 0);\n    }\n    rowOrCol.put(key, rowOrCol.get(key) + 1);\n}\n\npublic static int countPairs(Map<Integer, Integer> rowOrCol) {\n    int pairs = 0;\n    for (Integer key : rowOrCol.keySet()) {\n        pairs += rowOrCol.get(key) - 1;\n    }\n    return pairs;\n}\n```\n\nСложность данного решения составит $O(M)$. N - никак не участвует в оценке сложности.\nЕсли нужно будет посчитать ферзей, то нужно завести 2 словаря для диагоналей, в которых в качестве ключа для диагонали из нижнего левого угала в правй верхний (/) будет сумма между координатами (row + col или x+y),\nа для диагонали из левого верхнего угла в нижний правый угол (\\\\) будет разность между координатами (row - col или x-y).\n\n### Задача 2\n\nДана строка S.\nВыведите гистограмму как в примере (коды символов отсортированы)\n\nS = Hello, world!\n```\n      #\n      ##\n##########\n !,Hdelorw\n```\n\nПосчитать для каждой буквы сколько раз она встречается и вывести таким образом, как в примере.\n\nРешение\n\nДля каждого символа в словаре посчитаем, сколько раз он встречался. Найдем самый частый символ и переберем количество от этого числа до 1. Пройдем по всем отсортированным ключам и если количество больше счетчика - выведем #.\n\n1. Заводим словарь. Так как когда мы работаем с текстом, алфавит может быть очень большой, могут какие-нибудь иероглифы или эмоджи или еще какие либо символы использоваться. Если явно не сказано что только латинские буквы то лучше использовать словарь.\n2. Проходим по символам и добавляем в словарь по ключу со значением символа сколько раз он встречается.\n3. Отсортировать ключи и вывести нужным образом символы #.\n\nДля того чтобы вывести символы # по условию задачи, нужно найти максимальное значение(n), когда встречается один и тот же символ и для каждого символа в цикле пройтись от 1 до n и если значение меньше того что вышло в цикле то ставим пробел иначе ставим #. \n\n```java\npublic static void printChart(String s) {\n    Map<Character, Integer> symCount = new HashMap();\n    int maxSymCount = 0;\n    char[] charArray = s.toCharArray();\n    for (int i = 0; i < charArray.length; i++) {\n        char sym = charArray[i];\n        if (!symCount.containsKey(sym)) {\n            symCount.put(sym, 0);\n        }\n        symCount.put(sym, symCount.get(sym) + 1);\n        if (symCount.get(sym) > maxSymCount) {\n            maxSymCount = symCount.get(sym);\n        }\n    }\n    List<Character> sortedUniqSyms = symCount\n            .keySet()\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n    for (int i = maxSymCount; i > 0; i--) {\n        for (Character sym : sortedUniqSyms) {\n            if (symCount.get(sym) >= i) {\n                System.out.print('#');\n            } else {\n                System.out.print(' ');\n            }\n        }\n        System.out.println();\n    }\n\n    String str = sortedUniqSyms.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n    System.out.println(str);\n}\n```\n\nЭтот алгоритм не самый эффективный, во-первый вместо вызова функции print луше класть символы в массив и потом выводить строку через join, во-вторых в худшем случае этот алгоритм может работать за $O(N^2)$ или $O((N/2)^2)$\n\n\n## Задел под оптимизацию\n\nПреждевременная оптимизация страшный грех :). Так как иногда нужно сделать быстро  и нет времени на реализацию эффективных алгоритмов. В этом случае лучше сделать таким образом чтобы если вдруг придется решать проблему со скоростью было примерно понятно как это сделать при теущей реализации.\n\n### Всегда ли асмиптотически лучшее решение лучше?\n\n>  Например есть 2 алгоритма: \n- линейный - $1000 * N$ - $O(N)$ \n- алгоритм $2 * NlogN$ - $O(NlogN)$\n\nНа первый взгляд первый алгоритм лучше, но константа отличается в 500 раз.\nДля уточнения разделим обе части на N.\n\n> $2 * logN$ или $1000$\n\nТеперь делим на 2.\n\n> $logN$ или $500$\n\nТеперь то какой алгоримт лучше будет зависить от N.\n\nПри $N>2^{500}$ решение за $O(N)$ лучше, чем решение за $O(NlogN)$, но $2^{500}$ это $3*10^{150}$, что примерно в  $10^{70}$ раз больше количества атомов во вселенной. И вряд ли наш алгоритм будут запускать для таких чисел.\n\n> В реальности разница констант в 500 раз все же случается редко.\n\n### Некоторые другие критерии качества алгоритма\n\n- Потребление памяти - часто бывает, что есть 2 алгоритма с одной асимтотической сложностью, но разным потреблением памяти. Но чаще все равно выбирается время с хорошей асимтотикой.\n\n- Время на реализацию - если нужно писать какой то хороший алгорим но очень долго. То тут может не быть нужного оличества времени.\n\n- Сложность поддержки - как легко алгоритм будет поддерживать\n\n- Возможность распараллеливания - возможно ли будет алгортим разложить на несколько серверов если увеличится нагрузка.\n\n- Необходимая квалификация сотрудника - насколько легко найти человека который сможет поддерживать и разобраться в написанном вами алгоритме.\n\n- Стоимость оборудования - мы можем посидеть потратить время или купить более дорогое железо которое будет быстрее выполнять не самый эффективный алгоритм.\n\n### Задача 3\n\nСгруппировать слова по общим буквам.\n\n> ```Sample Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]```\n\n> ```Sample Output: [\"ate\", \"eat\", \"tea\"], [\"nat\", \"tan\"], [\"bat\"]```\n\n\nОтсортируем в каждом слове буквы и это будет выступать в роли ключа, а значением будет список слов.\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        char[] sortedWord = word.toCharArray();\n        Arrays.sort(sortedWord);\n        String srtWord = new String(sortedWord);\n        if (!groups.containsKey(srtWord)) {\n            groups.put(srtWord, new ArrayList<Character>());\n        }\n        groups.get(srtWord).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String sortedWord : groups.keySet()) {\n        ans.add(groups.get(sortedWord));\n    }\n\n    return ans;\n}\n```\n\nВдруг слово будет длинное (N)? Сортировка займет $O(NlogN)$. Количество различных букв в слове $K{\\leq}N$, можем посчитать количество каждой за $O(N)$ и отсортировать за $O(KlogK)$ с помощью сортировки подсчетом, теоретически \n\n#### Задел под оптимизацию\nНо так как в данный момент все успешно работает и нет времени на переделывание, то можно вынести шаги с сортировкой в отдельный метод.\n\n> Будет тормозить - посмотрим на профилировщике где, и если долго считается ключ - легко поправим на что-то более эффективное.\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Arrays.sort(sortedWord);\n    return new String(sortedWord);\n}\n```\n\n#### Оптимизация\n\n\n```java\npublic static List groupWords(String[] words) {\n    Map<String, List> groups = new HashMap();\n\n    for (String word : words) {\n        String groupKey = keyByWord(word);\n        if (!groups.containsKey(groupKey)) {\n            groups.put(groupKey, new ArrayList<Character>());\n        }\n        groups.get(groupKey).add(word);\n    }\n\n    List ans = new ArrayList();\n    for (String groupKey : groups.keySet()) {\n        ans.add(groups.get(groupKey));\n    }\n\n    return ans;\n}\n\npublic static String keyByWord(String word) {\n    char[] sortedWord = word.toCharArray();\n    Map<Character, Integer> symCnt = new HashMap();\n    for (char sym : sortedWord) {\n        if (!symCnt.containsKey(sym)) {\n            symCnt.put(sym, 0);\n        }\n        symCnt.put(sym, symCnt.get(sym) + 1);\n    }\n    ArrayList<String> lst = new ArrayList<>();\n\n    for (char sym : symCnt.keySet().stream().sorted().collect(Collectors.toList())) {\n        lst.add(Character.toString(sym));\n        lst.add(symCnt.get(sym).toString());\n    }\n    return lst.stream()\n            .map(String::valueOf)\n            .collect(Collectors.joining());\n}\n```\n\nВ худших случаях этот алгоритм будет работать быстрее, но в среднем будет тормозить.\nИ в некоторых случаях этот алгоритм можно сломать :)\n\n#### Сомнительная оптимизация (?)\n\nНо человек может не выделить часть под оптимизацию в отдельную функцию а вставить код прямо в основной алгоритм.\nКак минимум такой код будет тяжело читать. И вносить изменения, если придется.\n\n\n## Вопросы для проработки\n\n1. Как сджойнить массив символов в строку?\n```java\nlst.stream().map(String::valueOf).collect(Collectors.joining());\n```\n\n2. Как отсортировать массив?\n```java\nsymCnt.keySet().stream().sorted().collect(Collectors.toList())\n```\n\nhttps://www.youtube.com/embed/Nb5mW1yWVSs?si=IN4XvqnlTrMeJ7SK","description":"Словари и сортировка подсчётом","image":"null","category":null,"date":"25/07/2022","path":"/slovari-i-sortirovka-podschyotom/","links":[{"title":"","items":[{"title":"Алгоритмы (курс Яндекс)","link":"/algoritmy-kurs-yandeks/"},{"title":"Сложность, тестирование, особые случаи","link":"/slozhnost-testirovanie-osobye-sluchai/"},{"title":"Линейный поиск","link":"/linejnyj-poisk/"},{"title":"Множества","link":"/mnozhestva/"},{"title":"Словари и сортировка подсчётом","link":"/slovari-i-sortirovka-podschyotom/"},{"title":"Префиксные суммы и два указателя","link":"/prefiksnye-summy-i-dva-ukazatelya/"},{"title":"Бинарный поиск","link":"/binarnyj-poisk/"},{"title":"Сортировка событий","link":"/sortirovka-sobytij/"},{"title":"Деревья","link":"/derevya/"}]}],"headings":[{"value":"Сортировка подсчетом","anchor":"#сортировка-подсчетом"},{"value":"Словари","anchor":"#словари"},{"value":"Задел под оптимизацию","anchor":"#задел-под-оптимизацию"},{"value":"Вопросы для проработки","anchor":"#вопросы-для-проработки"}],"subtitles":[{"depth":2,"value":"Сортировка подсчетом","anchor":"#сортировка-подсчетом"},{"depth":3,"value":"Задача 1","anchor":"#задача-1"},{"depth":2,"value":"Словари","anchor":"#словари"},{"depth":3,"value":"Задача 1","anchor":"#задача-1-1"},{"depth":3,"value":"Задача 2","anchor":"#задача-2"},{"depth":2,"value":"Задел под оптимизацию","anchor":"#задел-под-оптимизацию"},{"depth":3,"value":"Всегда ли асмиптотически лучшее решение лучше?","anchor":"#всегда-ли-асмиптотически-лучшее-решение-лучше"},{"depth":3,"value":"Некоторые другие критерии качества алгоритма","anchor":"#некоторые-другие-критерии-качества-алгоритма"},{"depth":3,"value":"Задача 3","anchor":"#задача-3"},{"depth":4,"value":"Задел под оптимизацию","anchor":"#задел-под-оптимизацию-1"},{"depth":4,"value":"Оптимизация","anchor":"#оптимизация"},{"depth":4,"value":"Сомнительная оптимизация (?)","anchor":"#сомнительная-оптимизация-"},{"depth":2,"value":"Вопросы для проработки","anchor":"#вопросы-для-проработки"}],"tags":[{"id":"algorithms","title":"algorithms","path":"/tag/algorithms/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"алгоритмы","title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}]},"comments":{"edges":[]}},"context":{}}