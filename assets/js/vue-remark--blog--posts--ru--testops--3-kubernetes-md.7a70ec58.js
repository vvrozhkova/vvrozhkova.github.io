(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{UQSp:function(t,e,a){"use strict";e.a={name:"VueRemarkRoot",render(t){return t("div",null,this.$slots.default)}}},gcCc:function(t,e,a){"use strict";a.r(e);var s=a("KHd+"),i=a("UQSp"),n=a("oCYn");function l(t){return(l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}n.a.config.optionMergeStrategies;var r={VueRemarkRoot:i.a},o=function(t){var e=t.options.components=t.options.components||{},a=t.options.computed=t.options.computed||{};Object.keys(r).forEach((function(t){"object"===l(r[t])&&"function"==typeof r[t].render||"function"==typeof r[t]&&"function"==typeof r[t].options.render?e[t]=r[t]:a[t]=function(){return r[t]}}))},c=n.a.config.optionMergeStrategies,u="__vueRemarkFrontMatter",d={excerpt:null,title:"Kubernetes",category:"testops",description:"Kubernetes",tags:["Автоматизация тестирования"],icon:"fas fa-robot",image:"null",date:"2022-07-27T00:00:00.000Z",keywords:"qa, Автоматизация тестирования",order:3,links:[{items:[{title:"Микросервисная архитектура",link:"//mikroservisnaya-arhitektura//"},{title:"Docker",link:"/docker/"},{title:"Kubernetes",link:"/kubernetes/"},{title:"Linux",link:"/linux/"},{title:"Общие вопросы TestOps",link:"/obshhie-voprosy-test-ops/"}]}]};var p=function(t){t.options[u]&&(t.options[u]=d),n.a.util.defineReactive(t.options,u,d),t.options.computed=c.computed({$frontmatter:function(){return t.options[u]}},t.options.computed)},g=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("VueRemarkRoot",[e("h2",{attrs:{id:"kubernetes"}},[e("a",{attrs:{href:"#kubernetes","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Kubernetes")]),e("p",[t._v("Kubernetes - открытая платформа созданная для автомтаического деплоя, масштабирования и оперирования контейнерами приложений.")]),e("p",[t._v("Портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами которая облегчает как декларативную настройку так и автоматизацию.")]),e("p",[t._v("Kubernetes состоит из нод. Как правило рекомендуют использовать не менее 3х нод для Kubernetes. \nMaster Node и 2 Work Nodes. ")]),e("p",[e("strong",[t._v("Master Node")]),t._v(" - отвечает за поддержание желаемого состояния для вашего кластера.\nС Master Node взаимодействует kubectl - интерфейс командной строки, который позволяет через командную строку управлять Kubernetes кластером.")]),e("p",[t._v("С другой стороны у нас есть пользователь, который через интернет обращается к нашему приложению через Work Node и через kube-proxy ходит непосредственно на pod'ы.Основные фундаментальные концепции Kubernetes -  это pod и node, а также kublet, kube-proxy, etcd.")]),e("p",[e("strong",[t._v("Nodes(узлы)")]),t._v(" - это виртуальные либо физические машины в Kubernetes кластере на которых будут запускаться контейнеры.\nНода содержит kublet, Docker, kube-proxy. Также нода может содержать 1 или несколько под.")]),e("p",[e("strong",[t._v("Pod")]),t._v(" - минимальный юнит в Kubernetes с которым можно взаимодействовать, абстрактный объект Kubernetes представляющий группу из одного или нескольких контейнеров приложения (например Docker).")]),e("p",[t._v("Поды можно создавать, деплоить и удалять. Одна пода - один процесс в кластере. \nПод содержит: Docker container, storage resources, уникальный IP. ")]),e("p",[e("strong",[t._v("Cluster")]),t._v(" - совокупность мастер-сервисов и нод.")]),e("p",[e("strong",[t._v("Namespace")]),t._v(" - это способ разделения ресурсов кластера между несколькими пользователями.\nНапример, namespace команд, проектов и тд.")]),e("p",[t._v("Чтобы зайти в кластер и начать запускать команды нужно установить kubectl.")]),e("p",[t._v("kubectl - это инструмент командной строки kubernetes, который позволяет запускать команды для кластеров Kubernetes. Вы можете использовать kubectl для развертывания приложений проверки и управлени ресурсов кластера а также просмотра логов")]),e("h3",{attrs:{id:"жизненный-цикл-pod"}},[e("a",{attrs:{href:"#%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB-pod","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Жизненный цикл Pod")]),e("ul",[e("li",[t._v("Pending - ожидание, под ждет ресурсов. Под был принят кластером но один или несколько контейнеров еще не были запущены и нужно подождать.")]),e("li",[t._v("Running - запуск, созданы контейнеры необходимые для пода и запуска непосредственно на этой ноде. Под привязан к узлу и все контейнеры созданы.")]),e("li",[t._v("ContainerCreating - собираются контейнеры.")]),e("li",[t._v("Succeeded/Completed - успешный запуск, все контейнеры созданы, работают, нода запущена.")]),e("li",[t._v("CreateContainerConfigError - ошибка конфигурации.")]),e("li",[t._v("Failed - неуспешный запуск, запуск зафейлился приходит response != 1")]),e("li",[t._v("CrashLoopBackOff - под уходит в бесконечный цикл. Под был запущен крашнулся перезапустился и заново крашнулся (установлено значение restartPolicy: Always) нужно изучить логи.")]),e("li",[t._v("Terminating -  трафик не идет на под, под тушится после его удаления")])]),e("p",[t._v("Чтобы работало автодоплнение нужно выполнить команду:")]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("source <(kubectl completion bash)")])])]),e("p",[t._v("Далее нужно получить доступ к кластеру:")]),e("ul",[e("li",[t._v("Получить список всех неймспейсов")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get namespaces")])])]),e("ul",[e("li",[t._v("получить список всех подов во всех неймспейсах")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get pods --all-namespaces")])])]),e("ul",[e("li",[t._v("получить список всех подов во всех неймспейсах там где есть название ssr с подробным выводом логов")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get pods --all-namespaces -o wide |grep ssr")])])]),e("ul",[e("li",[t._v("получить список подов в определенном неймспейсе")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get pods -n core-team")])])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get pods -n core-team|grep besida-madmax")])])]),e("p",[t._v("После того как вышел список подов мы можем увидеть статусы в которых они находятся:")]),e("ul",[e("li",[t._v("Обзор запущенного пода")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl -n core-team describe pod besida-trunk-ua-685d5d4f-hpdw2")])])]),e("ul",[e("li",[t._v("Вывести логи пода ")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl -n core-team logs besida-trunk-ua-685d5d4f-hpdw2")])])]),e("p",[t._v("отображает логи на лету")]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl -n core-team logs -f besida-trunk-ua-685d5d4f-hpdw2")])])]),e("h3",{attrs:{id:"controllers"}},[e("a",{attrs:{href:"#controllers","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Controllers")]),e("p",[t._v("Управляется Controller Manager'ом. ")]),e("p",[t._v("Виды контроллеров:")]),e("ul",[e("li",[e("p",[t._v("ReplicaSets - проверяет что необходимое количество pod запущено все время. Если pods стало меньше (например одна изпод закрешилась), то replicaSet создаст новую. ReplicaSets существует не самостоятельно а в рамках Deployment.")])]),e("li",[e("p",[t._v("Deployments - предоставляет декларативное описание для апдейта ReplicaSet и Pod. В ранних версиях Kubernetes вместо ReplicaSet и Deployment использовался Replication Controller. Но это нарушало принцип single responsibilities и в дальнейшем он был разделен и облегчилась задача rollback'a - если во время деплоймента что то пошло не так то в текущих условиях легко откатиться назад и востановить работоспособность приложения.  ")])]),e("li",[e("p",[t._v("DeamonSets - проверяет что на каждой ноде запущен экземпляр конкретной поды. Если ноды добавляются в кластер или удаляются из кластера то DeamonSet добавить или удалить поды на этой ноде. Удаление DeamonSet означает удаление всех под из кластера.")])]),e("li",[e("p",[t._v("Jobs - это процесс верхнего уровня для пода. Используется когда нужно запустить pod для выполнения какой то задачи один раз или по расписанию. Типичный пример - cron job.")])]),e("li",[e("p",[t._v("Services - позволяет сетевое взаимодействие между деплойментами. Необходимы, когда нужно, чтобы поды из разных деплойментов взаимодействовали между собой. ")])])]),e("p",[t._v("Например: FrontEnd Pod взаимодействует с BackEnd Pods через Backend Service.")]),e("h3",{attrs:{id:"виды-сервисов"}},[e("a",{attrs:{href:"#%D0%B2%D0%B8%D0%B4%D1%8B-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Виды сервисов:")]),e("p",[t._v("Internal - ip-адрес доступен только внутри кластера. ")]),e("p",[t._v("External - эндпоинт доступен по ip адресу ноды(такой сервис называют NodePod). ")]),e("p",[t._v("Load Balancer - открывает приложение в интернет через лоад балансер (обычно используется когда кубернетис кластер развернут в облаке (GCP, AWS, Azure).")]),e("h3",{attrs:{id:"labels"}},[e("a",{attrs:{href:"#labels","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Labels")]),e("p",[t._v("Пара ключ/значение, может быть присоединена к таким объектам как поды, сервисы и доплойменты. Используются пользователями Кубернетис для идентификации аттрибутов для объектов. Уникальны в пределах объекта. ")]),e("p",[t._v('Пример: "environment": "dev", "environment": "qa", "environment": "prod"')]),e("p",[t._v("Labels как правило используются не одни а с selectors.")]),e("h3",{attrs:{id:"selectors"}},[e("a",{attrs:{href:"#selectors","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Selectors")]),e("ul",[e("li",[t._v("equality-based: '=' и '!='")]),e("li",[t._v("Set-based: 'IN', 'NOTIN' и 'EXISTS'")])]),e("p",[t._v("Labels и Selectors обычно используются в kubectl командах для получения списков объектов и их фильтрации. НапримерЖ получение списка под на QA env.")]),e("h3",{attrs:{id:"namespaces"}},[e("a",{attrs:{href:"#namespaces","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Namespaces")]),e("p",[t._v("Концепция неймспейсов позволяет реализовать множество виртуальных кластеров внутри одного физического кластера. Это полезно, когда есть необходимость разделять ресурсы физического кластера между командами и контролировать доступ к ресурсам.")]),e("h3",{attrs:{id:"kublet"}},[e("a",{attrs:{href:"#kublet","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Kublet")]),e("ul",[e("li",[t._v("Запущен на каждой work-ноде")]),e("li",[t._v("Коммуницирует с API сервером, который запущен на Master Node")]),e("li",[t._v("Запускает контейнеры для под через docker engine")]),e("li",[t._v("Подключает и запускает диски и сикреты для под")]),e("li",[t._v("Запускает хелсчеки для проверки статусов под/нод и сообщает статус API серверу")])]),e("h3",{attrs:{id:"kube-proxy"}},[e("a",{attrs:{href:"#kube-proxy","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Kube-proxy")]),e("ul",[e("li",[t._v("Запущен на каждой work-ноде")]),e("li",[t._v("Рефлицирует сетевой трафик для сервисов (NodePort и LoadBalancer)\nконфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.")])]),e("h3",{attrs:{id:"режимы-kube-proxy"}},[e("a",{attrs:{href:"#%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D1%8B-kube-proxy","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Режимы Kube-proxy")]),e("ul",[e("li",[t._v("User space mode (наиболее широко используемый)")]),e("li",[t._v("Iptables mode")]),e("li",[t._v("Ipvs mode (alpha version)")])]),e("h3",{attrs:{id:"etcd"}},[e("a",{attrs:{href:"#etcd","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("etcd")]),e("p",[t._v('Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.')]),e("h3",{attrs:{id:"kube-scheduler"}},[e("a",{attrs:{href:"#kube-scheduler","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("kube-scheduler")]),e("p",[t._v("Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.")]),e("h2",{attrs:{id:"команды-kubernetes"}},[e("a",{attrs:{href:"#%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-kubernetes","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Команды Kubernetes")]),e("ul",[e("li",[t._v("получить список подов")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get pods")])])]),e("ul",[e("li",[t._v("получить список сервисов")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get services")])])]),e("ul",[e("li",[t._v("получить список деплойментов")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl get deployments")])])]),e("ul",[e("li",[t._v("поднимаем selenium-hub")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl create -f selenium-hub-deployment.yaml")])])]),e("ul",[e("li",[t._v("поднимаем selenium-hub-svc")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl create -f selenium-hub-svc.yaml")])])]),e("ul",[e("li",[t._v("поднимаем selenium-node")])]),e("div",{staticClass:"gridsome-highlight",attrs:{"data-language":"text"}},[e("pre",{staticClass:"language-text"},[e("code",{staticClass:"language-text"},[t._v("kubectl create -f selenium-node-chrome-deployment.yaml")])])]),e("h2",{attrs:{id:"cicd-microservices"}},[e("a",{attrs:{href:"#cicd-microservices","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("CI/CD microservices")]),e("p",[t._v("CI - Continious Integration это когда разработчики интегрируют свои код в общий репозиторий на постоянной основе и постоянно проходят некий quality gate который показывает что их код синтегрировался корректно. ")]),e("p",[t._v("CD - Continious Delivery это когда артефакт который мы собрали в рамках Continious Integration и начинаем поставлять его на разные окружения.\nContinious De[loyment это когда мы в процессе Continious Delivery не ждем ручного апрува а автоматом через энвайронменты проводим и выкатываем на продакшен.")]),e("p",[t._v("Как этого достичь:\n1. Докеризация микросервисов\nнужно получить артефакт который будет неизменным - нужно быть уверенным что тот артефакт который мы собрали в таком же виде дойдет до продакшена\n2. Мы можем присваивать артефакту теги и тем самым продвигать его на следущую стадию\n3. Мы не завязываемся на технический стек\n4. Это прощает деплоймент, управление окружением, конфигурацию и т.д.\n5. Эфективное использование ресурсов")]),e("p",[t._v("У нас есть контейнер - запущенный процесс который представляет наш микросервис и image - immutable артефакт который мы собрали в рамках  CI и выложили его в registry - реестр images, где хранятся наши артефакты.")]),e("h2",{attrs:{id:"версионирование"}},[e("a",{attrs:{href:"#%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Версионирование")]),e("p",[t._v("Семантическое версионирование - \nглавная версия отвечает за то какие знаковые изменения были сделаны в микросервисе(то что мы не поломали API), если мы не имеем обратной совместимости то увеличиваем эту версию либо по большим релизом и с каждым релизом увеличиваем;\nминорная версия - либо начинаем каждый раз с нуля в рамках каждого нового большошо релиза либо если девелопим интерациями то используют номер интерации, тогда можно быстро востановить когда эта версия была выпущена.\nпатч версия - для хот фиксов \nкомит хештег как суффикс и дата как дополнительный суффикс")]),e("h2",{attrs:{id:"ci-pipeline"}},[e("a",{attrs:{href:"#ci-pipeline","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("CI pipeline")]),e("p",[t._v("Разработчик делает комит в гит репозиторий на CI делается: build code, run unit tests, build image, push image(пушится в реестр контейнеров). На выходе мы получаем кодовые артифакты, результаты тестов, image контейнер.")]),e("p",[t._v("Quality Gates:")]),e("ul",[e("li",[t._v("unit tests")]),e("li",[t._v("integration tests")]),e("li",[t._v("static code analysis")]),e("li",[t._v("api tests")]),e("li",[t._v("contract tests")]),e("li",[t._v("security checks")])]),e("p",[t._v("Чтобы поставить полностью всю систему нужно знать версии всех микросервисов.")]),e("p",[t._v("Здесь нужно учитывать совместимость - это когда мы взяли набор микросервисов подняли провели тесты и после этого мы говорим что этот набор сервисов совместим ")]),e("p",[t._v("Поэтому нужно сохранять нобор версий этих сервисов как отдельный артефакт \nЭтот артефакт можно положить в систему контроля версий(например гит)\nДальше в Continious Delivery будет участвовать этот набор. и дальше можно промоутить этот артефакт между разными окружениями. Если мы добавим зависимость на какую то версию postgress или elastic то мы получим полную совместимсоть")]),e("p",[t._v("Это делается с помощью property файла и прописываем версии.\nМожно использовать helm.")]),e("p",[e("strong",[t._v("Пример:")])]),e("p",[t._v("У нас есть 3 сервиса с соответсвущими версиями и мы их собрали в compatible set. ")]),e("p",[t._v("И тут появляется доработка в одном из сервисов и появляется его новая версия и это новый кандидат мы хотим его продвинуть. ")]),e("p",[t._v("Мы собираем новый set с этим кандидатом и пытаемся его запустить и билд падает(возможно оказалась проблема в несовместимости например с ui частью).")]),e("p",[t._v("И появилась необходимость сделать исправление в другом микросервисе, разработчики делают исправление, получают новую версию и хотят ее задеплоить. И тут вступает фактор, что нужно подхватывать всех новых кандидатов, потому что если бы подхватили только последний кандидат, он могбы упасть так как ожидает исправлений, которые появились в первом сервисе.")]),e("p",[t._v("Если билд проходит успешно, то мы делаем совместимый между собой set и сохраняем его в сисетму контроля версий.")]),e("p",[t._v("Если билд падает, то артифакт невидим и нет возможность такой билд куда-то задеплоить просто так, не пройдя тест на совместимость. ")]),e("p",[t._v("После того как артефакт появился в системе контроля версий, то либо jenkins джоба это проверяет, либо оператор в Kubernetes переодически мониторит что появляется и говорит что надо это деплоить - вручную или по расписанию. ")]),e("p",[t._v("Flux CD мониторит появление новых images в гите и говорит что можно их задеплоить.")]),e("h2",{attrs:{id:"выполняем-деплой-на-окружение"}},[e("a",{attrs:{href:"#%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D0%B5%D0%BC-%D0%B4%D0%B5%D0%BF%D0%BB%D0%BE%D0%B9-%D0%BD%D0%B0-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5","aria-hidden":"true"}},[e("span",{staticClass:"icon icon-link"})]),t._v("Выполняем деплой на окружение")]),e("p",[t._v("Для этого мы создаем Jenkins джобу или github actions которая показывает нам список окружений который нам доступен: dev, qa, stage, prod либо оставляем создаем новое окружение. Также показываются для выбора не отдельные микросервисы а показыватся сеты. Еще нужно указать TTL(Time To Live) окружение будет автоматически очищаться по истечению времени. ")]),e("p",[t._v("Но если будет много окружений - это займет все ресурс и для решения этой проблемы нужен Kubernetes.")]),e("p",[t._v("Как ускорить создание окружения в Kubernetes:")]),e("ul",[e("li",[t._v("каждое окружение уходит в отдельый namespace ")]),e("li",[t._v("конфигурируем минимальные лимиты и scale фактор ")]),e("li",[t._v("выносим основные внешние ресурсы (DB, Elastcsearch, Redis, Kafka)")]),e("li",[t._v("используем готовые images с данными")]),e("li",[t._v("сконфигурируем все тулы ")]),e("li",[t._v("асинхронное удаление окружение")]),e("li",[t._v("задаем TTL")])]),e("p",[t._v("zhuk.__")])])}),[],!1,null,null,null);"function"==typeof o&&o(g),"function"==typeof p&&p(g);e.default=g.exports}}]);