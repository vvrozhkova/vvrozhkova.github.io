(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{"P9+G":function(t,n,o){"use strict";o.r(n);var e=o("KHd+"),i=o("UQSp"),p=o("oCYn");function a(t){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}p.a.config.optionMergeStrategies;var r={VueRemarkRoot:i.a},s=function(t){var n=t.options.components=t.options.components||{},o=t.options.computed=t.options.computed||{};Object.keys(r).forEach((function(t){"object"===a(r[t])&&"function"==typeof r[t].render||"function"==typeof r[t]&&"function"==typeof r[t].options.render?n[t]=r[t]:o[t]=function(){return r[t]}}))},c=p.a.config.optionMergeStrategies,v="__vueRemarkFrontMatter",u={excerpt:null,title:"Глава 10. Внутренние классы",description:"Глава 10. Внутренние классы",tags:["java","ооп"],icon:"fas fa-code",image:"null",date:"2024-02-24T00:00:00.000Z",keywords:"java, ооп",order:10,links:[{items:[{title:"Глава 1. Введение в объекты",link:"/glava-1-vvedenie-v-obekty/"},{title:"Глава 5. Инициализация и завершение",link:"/glava-5-iniczializacziya-i-zavershenie/"},{title:"Глава 10. Внутренние классы",link:"/glava-10-vnutrennie-klassy/"}]}]};var l=function(t){t.options[v]&&(t.options[v]=u),p.a.util.defineReactive(t.options,v,u),t.options.computed=c.computed({$frontmatter:function(){return t.options[v]}},t.options.computed)},f=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("VueRemarkRoot",[n("h2",{attrs:{id:"внутренние-классы"}},[n("a",{attrs:{href:"#%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B","aria-hidden":"true"}},[n("span",{staticClass:"icon icon-link"})]),t._v("Внутренние классы")]),n("p",[t._v("Класс, размещенный в определении другого класса называется внутренним(inner class).")]),n("p",[t._v("Как правило внешний класс содержит ссылку на внутренний класс.")]),n("p",[t._v("Если нужно создать объект внутреннего класса где-нибудь за пределами внешнего класса или в статическом методе, нужно будет указать тип этого объекта следующим образом: ИмяВнешнегоКласса.ИмяВнутреннегоКласса.")]),n("p",[t._v("Внутренний класс может обращаться к членам внешнего класса и ему доступны все элементы внешнего класса.")]),n("p",[t._v("Внутренний класс хранит ссылку на внешний класс, поэтому существование внутреннего класса невозможно без внешнего если он не является статическим.")]),n("p",[t._v("Если нужно получить ссылку на внешний класс то указывается имя класс и .this.")]),n("p",[t._v("Если нужно создать объект внутреннего класса из внешнего, например в статическом методе или за пределом внешнего класса то используется объект внешнего класса и .new")]),n("p",[t._v("Закрытый внутренний класс позволяет разработчику класса полностью запретить использование определенных типов и скрыть детали реализации класса.")]),n("p",[t._v("Внутренние классы могут создаваться в методах и даже произвольных областях действия. Для этого есть 2 причины:\n1. Нужно создавать и возвращать ссылки на некоторый интерфейс\n2. Нужно решить сложную задачу и нужно создать класс, который будет задействован в его решении, но при этом сделать его недоступным для посторонних.")]),n("p",[t._v("Внутренний класс может быть:")]),n("ol",[n("li",[t._v("Класс, определенный в методе - локальный внутренний класс. К нему невозможно обратиться за пределами метода, в котором он определяется;")]),n("li",[t._v("Класс, определенный в области действия внутри метода - например вложен в область действия команды if. Внутренний класс не доступен за пределами действия в которой он определяется;")]),n("li",[t._v("Анонимный класс, реализованный в интерфейсе;\nЕсли вы определяете анонимный внутренний класс и хотите использовать внутри него объект передаваемый в аргументе, то необходимо чтобы аргумент был обозначен как final иначе компилятор выдаст ошибку.")]),n("li",[t._v("Анонимный класс, расширяющий класс с конструктором, который не является конструктором по умолчанию. В название класса передаются нужные аргументы и задается определение класса;")]),n("li",[t._v("Анонимный класс, выполняющий инициализацию поля;")]),n("li",[t._v("Анонимный класс, выполняющий конструирование с использованием инициализации экземпляра (анонимные внутренние классы не могут иметь конструкторов)")])]),n("p",[t._v("В отличие от обычного класса анонимные внутренние классы могут либо расширять класс, либо реализовать интерфейс но не оба действия сразу.")]),n("p",[t._v("Паттерн «Фабричный метод»")]),n("p",[t._v("Вложенные классы")]),n("p",[t._v("Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, внутренний класс можно сделать статическим (объявить его как static). Такой класс называют вложенным.")]),n("p",[t._v("Вложенный класс:\n1. Для создания его объекта не нужен объект внешнего класса\n2. Нельзя обращаться к членам не-статического объекта внешнего класса из объекта вложенного класса.")]),n("p",[t._v("Статические поля и методы внутреннего класса определяются только на уровне внешнего класса. Вложенные классы таких ограничений не имеют. Уточнить!!!")]),n("p",[t._v("Вложенный класс может быть частью интерфейса. Даже без специальных обозначений любой класс помещенный в интерфейс считается public и static. Это может быть удобно при здании общего кода, который должен использоваться со всеми реализациями интерфейса.")]),n("p",[t._v("Неважно насколько глубоко вложен класс он будет иметь доступ ко всем полям и методам всех внешних классов.")]),n("p",[t._v("Причина для использования внутренних классов:\nКаждый внутренний класс способен наследовать определенную реализацию. Таким образом внутренний класс не ограничен при наследовано в ситуациях, где внешний класс уже наследует реализацию.")]),n("p",[t._v("Таким образом, внутренний класс выступает как «довесок» множественного наследования.")]),n("p",[t._v("Для наследованная от внутреннего класса должна быть ссылка на внешний класс поэтому используется следующий синтаксис:\nextends ИмяВнешнегоКласса.ИмяВнутреннего класса\nи в конструктор нужно передать ссылку на внешний класс и определить его как \nСсылкаНаВнешнийКласс.super();")]),n("p",[t._v("Переопределение внутреннего класса не имеет никакого эффекта. Внутренние класс совершенно отдельные составляющие, с независимым пространством имен, но можно явно унаследовать от внутреннего класса.")]),n("p",[t._v("Локальный внутренний класс не имеет модификатора доступа, но имеет доступ к членам внешнего класса и final переменным.\nУ локального внутренний класса может быть свой конструктор.")]),n("p",[t._v("Анонимный внутренний класс не может содержать конструктора только инициализатор экземпляра.")]),n("p",[t._v("Единственный довод в пользу локального внутреннего класс перед анонимным внутренним классом есть необходимость в именованном конструкторе и/или перегруженных конструкторах и  возможность создавать более чем один объект такого класса.")]),n("p",[t._v("#философия_java")])])}),[],!1,null,null,null);"function"==typeof s&&s(f),"function"==typeof l&&l(f);n.default=f.exports},UQSp:function(t,n,o){"use strict";n.a={name:"VueRemarkRoot",render(t){return t("div",null,this.$slots.default)}}}}]);